{"ast":null,"code":"/* Mapbox GL JS is Copyright Â© 2020 Mapbox and subject to the Mapbox Terms of Service ((https://www.mapbox.com/legal/tos/). */\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() : typeof define === 'function' && define.amd ? define(factory) : (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.mapboxgl = factory());\n})(this, function () {\n  'use strict';\n\n  /* eslint-disable */\n  var shared, worker, mapboxgl;\n  // define gets called three times: one for each chunk. we rely on the order\n  // they're imported to know which is which\n  function define(_, chunk) {\n    if (!shared) {\n      shared = chunk;\n    } else if (!worker) {\n      worker = chunk;\n    } else {\n      var workerBundleString = \"self.onerror = function() { console.error('An error occurred while parsing the WebWorker bundle. This is most likely due to improper transpilation by Babel; please see https://docs.mapbox.com/mapbox-gl-js/guides/install/#transpiling'); }; var sharedChunk = {}; (\" + shared + \")(sharedChunk); (\" + worker + \")(sharedChunk); self.onerror = null;\";\n      var sharedChunk = {};\n      shared(sharedChunk);\n      mapboxgl = chunk(sharedChunk);\n      if (typeof window !== 'undefined' && window && window.URL && window.URL.createObjectURL) {\n        mapboxgl.workerUrl = window.URL.createObjectURL(new Blob([workerBundleString], {\n          type: 'text/javascript'\n        }));\n      }\n    }\n  }\n  define([\"exports\"], function (t) {\n    \"use strict\";\n\n    var e = \"undefined\" != typeof self ? self : {},\n      r = \"2.15.0\";\n    let n;\n    const i = {\n        API_URL: \"https://api.mapbox.com\",\n        get API_URL_REGEX() {\n          if (null == n) {\n            const t = /^((https?:)?\\/\\/)?([^\\/]+\\.)?mapbox\\.c(n|om)(\\/|\\?|$)/i;\n            try {\n              n = null != process.env.API_URL_REGEX ? new RegExp(process.env.API_URL_REGEX) : t;\n            } catch (e) {\n              n = t;\n            }\n          }\n          return n;\n        },\n        get API_TILEJSON_REGEX() {\n          return /^((https?:)?\\/\\/)?([^\\/]+\\.)?mapbox\\.c(n|om)(\\/v[0-9]*\\/.*\\.json.*$)/i;\n        },\n        get API_SPRITE_REGEX() {\n          return /^((https?:)?\\/\\/)?([^\\/]+\\.)?mapbox\\.c(n|om)(\\/styles\\/v[0-9]*\\/)(.*\\/sprite.*\\..*$)/i;\n        },\n        get API_FONTS_REGEX() {\n          return /^((https?:)?\\/\\/)?([^\\/]+\\.)?mapbox\\.c(n|om)(\\/fonts\\/v[0-9]*\\/)(.*\\.pbf.*$)/i;\n        },\n        get API_STYLE_REGEX() {\n          return /^((https?:)?\\/\\/)?([^\\/]+\\.)?mapbox\\.c(n|om)(\\/styles\\/v[0-9]*\\/)(.*$)/i;\n        },\n        get API_CDN_URL_REGEX() {\n          return /^((https?:)?\\/\\/)?api\\.mapbox\\.c(n|om)(\\/mapbox-gl-js\\/)(.*$)/i;\n        },\n        get EVENTS_URL() {\n          if (!i.API_URL) return null;\n          try {\n            const t = new URL(i.API_URL);\n            return \"api.mapbox.cn\" === t.hostname ? \"https://events.mapbox.cn/events/v2\" : \"api.mapbox.com\" === t.hostname ? \"https://events.mapbox.com/events/v2\" : null;\n          } catch (t) {\n            return null;\n          }\n        },\n        SESSION_PATH: \"/map-sessions/v1\",\n        FEEDBACK_URL: \"https://apps.mapbox.com/feedback\",\n        TILE_URL_VERSION: \"v4\",\n        RASTER_URL_PREFIX: \"raster/v1\",\n        REQUIRE_ACCESS_TOKEN: !0,\n        ACCESS_TOKEN: null,\n        MAX_PARALLEL_IMAGE_REQUESTS: 16\n      },\n      s = {\n        supported: !1,\n        testSupport: function (t) {\n          !l && o && (u ? c(t) : a = t);\n        }\n      };\n    let a,\n      o,\n      l = !1,\n      u = !1;\n    function c(t) {\n      const e = t.createTexture();\n      t.bindTexture(t.TEXTURE_2D, e);\n      try {\n        if (t.texImage2D(t.TEXTURE_2D, 0, t.RGBA, t.RGBA, t.UNSIGNED_BYTE, o), t.isContextLost()) return;\n        s.supported = !0;\n      } catch (t) {}\n      t.deleteTexture(e), l = !0;\n    }\n    e.document && (o = e.document.createElement(\"img\"), o.onload = function () {\n      a && c(a), a = null, u = !0;\n    }, o.onerror = function () {\n      l = !0, a = null;\n    }, o.src = \"data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAQAAAAfQ//73v/+BiOh/AAA=\");\n    const h = \"01\";\n    function p(t) {\n      return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, \"default\") ? t.default : t;\n    }\n    var d = f;\n    function f(t, e, r, n) {\n      this.cx = 3 * t, this.bx = 3 * (r - t) - this.cx, this.ax = 1 - this.cx - this.bx, this.cy = 3 * e, this.by = 3 * (n - e) - this.cy, this.ay = 1 - this.cy - this.by, this.p1x = t, this.p1y = e, this.p2x = r, this.p2y = n;\n    }\n    f.prototype = {\n      sampleCurveX: function (t) {\n        return ((this.ax * t + this.bx) * t + this.cx) * t;\n      },\n      sampleCurveY: function (t) {\n        return ((this.ay * t + this.by) * t + this.cy) * t;\n      },\n      sampleCurveDerivativeX: function (t) {\n        return (3 * this.ax * t + 2 * this.bx) * t + this.cx;\n      },\n      solveCurveX: function (t, e) {\n        if (void 0 === e && (e = 1e-6), t < 0) return 0;\n        if (t > 1) return 1;\n        for (var r = t, n = 0; n < 8; n++) {\n          var i = this.sampleCurveX(r) - t;\n          if (Math.abs(i) < e) return r;\n          var s = this.sampleCurveDerivativeX(r);\n          if (Math.abs(s) < 1e-6) break;\n          r -= i / s;\n        }\n        var a = 0,\n          o = 1;\n        for (r = t, n = 0; n < 20 && (i = this.sampleCurveX(r), !(Math.abs(i - t) < e)); n++) t > i ? a = r : o = r, r = .5 * (o - a) + a;\n        return r;\n      },\n      solve: function (t, e) {\n        return this.sampleCurveY(this.solveCurveX(t, e));\n      }\n    };\n    var y = p(d),\n      m = g;\n    function g(t, e) {\n      this.x = t, this.y = e;\n    }\n    g.prototype = {\n      clone: function () {\n        return new g(this.x, this.y);\n      },\n      add: function (t) {\n        return this.clone()._add(t);\n      },\n      sub: function (t) {\n        return this.clone()._sub(t);\n      },\n      multByPoint: function (t) {\n        return this.clone()._multByPoint(t);\n      },\n      divByPoint: function (t) {\n        return this.clone()._divByPoint(t);\n      },\n      mult: function (t) {\n        return this.clone()._mult(t);\n      },\n      div: function (t) {\n        return this.clone()._div(t);\n      },\n      rotate: function (t) {\n        return this.clone()._rotate(t);\n      },\n      rotateAround: function (t, e) {\n        return this.clone()._rotateAround(t, e);\n      },\n      matMult: function (t) {\n        return this.clone()._matMult(t);\n      },\n      unit: function () {\n        return this.clone()._unit();\n      },\n      perp: function () {\n        return this.clone()._perp();\n      },\n      round: function () {\n        return this.clone()._round();\n      },\n      mag: function () {\n        return Math.sqrt(this.x * this.x + this.y * this.y);\n      },\n      equals: function (t) {\n        return this.x === t.x && this.y === t.y;\n      },\n      dist: function (t) {\n        return Math.sqrt(this.distSqr(t));\n      },\n      distSqr: function (t) {\n        var e = t.x - this.x,\n          r = t.y - this.y;\n        return e * e + r * r;\n      },\n      angle: function () {\n        return Math.atan2(this.y, this.x);\n      },\n      angleTo: function (t) {\n        return Math.atan2(this.y - t.y, this.x - t.x);\n      },\n      angleWith: function (t) {\n        return this.angleWithSep(t.x, t.y);\n      },\n      angleWithSep: function (t, e) {\n        return Math.atan2(this.x * e - this.y * t, this.x * t + this.y * e);\n      },\n      _matMult: function (t) {\n        var e = t[2] * this.x + t[3] * this.y;\n        return this.x = t[0] * this.x + t[1] * this.y, this.y = e, this;\n      },\n      _add: function (t) {\n        return this.x += t.x, this.y += t.y, this;\n      },\n      _sub: function (t) {\n        return this.x -= t.x, this.y -= t.y, this;\n      },\n      _mult: function (t) {\n        return this.x *= t, this.y *= t, this;\n      },\n      _div: function (t) {\n        return this.x /= t, this.y /= t, this;\n      },\n      _multByPoint: function (t) {\n        return this.x *= t.x, this.y *= t.y, this;\n      },\n      _divByPoint: function (t) {\n        return this.x /= t.x, this.y /= t.y, this;\n      },\n      _unit: function () {\n        return this._div(this.mag()), this;\n      },\n      _perp: function () {\n        var t = this.y;\n        return this.y = this.x, this.x = -t, this;\n      },\n      _rotate: function (t) {\n        var e = Math.cos(t),\n          r = Math.sin(t),\n          n = r * this.x + e * this.y;\n        return this.x = e * this.x - r * this.y, this.y = n, this;\n      },\n      _rotateAround: function (t, e) {\n        var r = Math.cos(t),\n          n = Math.sin(t),\n          i = e.y + n * (this.x - e.x) + r * (this.y - e.y);\n        return this.x = e.x + r * (this.x - e.x) - n * (this.y - e.y), this.y = i, this;\n      },\n      _round: function () {\n        return this.x = Math.round(this.x), this.y = Math.round(this.y), this;\n      }\n    }, g.convert = function (t) {\n      return t instanceof g ? t : Array.isArray(t) ? new g(t[0], t[1]) : t;\n    };\n    var x = p(m);\n    const v = Math.PI / 180,\n      b = 180 / Math.PI;\n    function w(t) {\n      return t * v;\n    }\n    function _(t) {\n      return t * b;\n    }\n    const A = [[0, 0], [1, 0], [1, 1], [0, 1]];\n    function S(t) {\n      if (t <= 0) return 0;\n      if (t >= 1) return 1;\n      const e = t * t,\n        r = e * t;\n      return 4 * (t < .5 ? r : 3 * (t - e) + r - .75);\n    }\n    function k(t, e, r, n) {\n      const i = new y(t, e, r, n);\n      return function (t) {\n        return i.solve(t);\n      };\n    }\n    const I = k(.25, .1, .25, 1);\n    function M(t, e, r) {\n      return Math.min(r, Math.max(e, t));\n    }\n    function T(t, e, r) {\n      return (r = M((r - t) / (e - t), 0, 1)) * r * (3 - 2 * r);\n    }\n    function z(t, e, r) {\n      const n = r - e,\n        i = ((t - e) % n + n) % n + e;\n      return i === e ? r : i;\n    }\n    function B(t, e, r) {\n      if (!t.length) return r(null, []);\n      let n = t.length;\n      const i = new Array(t.length);\n      let s = null;\n      t.forEach((t, a) => {\n        e(t, (t, e) => {\n          t && (s = t), i[a] = e, 0 == --n && r(s, i);\n        });\n      });\n    }\n    function E(t) {\n      const e = [];\n      for (const r in t) e.push(t[r]);\n      return e;\n    }\n    function C(t, ...e) {\n      for (const r of e) for (const e in r) t[e] = r[e];\n      return t;\n    }\n    let P = 1;\n    function D() {\n      return P++;\n    }\n    function V() {\n      return function t(e) {\n        return e ? (e ^ Math.random() * (16 >> e / 4)).toString(16) : ([1e7] + -[1e3] + -4e3 + -8e3 + -1e11).replace(/[018]/g, t);\n      }();\n    }\n    function L(t) {\n      return t <= 1 ? 1 : Math.pow(2, Math.ceil(Math.log(t) / Math.LN2));\n    }\n    function F(t) {\n      return !!t && /^[0-9a-f]{8}-[0-9a-f]{4}-[4][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i.test(t);\n    }\n    function R(t, e) {\n      t.forEach(t => {\n        e[t] && (e[t] = e[t].bind(e));\n      });\n    }\n    function U(t, e) {\n      return -1 !== t.indexOf(e, t.length - e.length);\n    }\n    function $(t, e, r) {\n      const n = {};\n      for (const i in t) n[i] = e.call(r || this, t[i], i, t);\n      return n;\n    }\n    function j(t, e, r) {\n      const n = {};\n      for (const i in t) e.call(r || this, t[i], i, t) && (n[i] = t[i]);\n      return n;\n    }\n    function O(t) {\n      return Array.isArray(t) ? t.map(O) : \"object\" == typeof t && t ? $(t, O) : t;\n    }\n    const q = {};\n    function N(t) {\n      q[t] || (\"undefined\" != typeof console && console.warn(t), q[t] = !0);\n    }\n    function G(t, e, r) {\n      return (r.y - t.y) * (e.x - t.x) > (e.y - t.y) * (r.x - t.x);\n    }\n    function Z(t) {\n      let e = 0;\n      for (let r, n, i = 0, s = t.length, a = s - 1; i < s; a = i++) r = t[i], n = t[a], e += (n.x - r.x) * (r.y + n.y);\n      return e;\n    }\n    function K() {\n      return \"undefined\" != typeof WorkerGlobalScope && \"undefined\" != typeof self && self instanceof WorkerGlobalScope;\n    }\n    function X(t) {\n      const e = {};\n      if (t.replace(/(?:^|(?:\\s*\\,\\s*))([^\\x00-\\x20\\(\\)<>@\\,;\\:\\\\\"\\/\\[\\]\\?\\=\\{\\}\\x7F]+)(?:\\=(?:([^\\x00-\\x20\\(\\)<>@\\,;\\:\\\\\"\\/\\[\\]\\?\\=\\{\\}\\x7F]+)|(?:\\\"((?:[^\"\\\\]|\\\\.)*)\\\")))?/g, (t, r, n, i) => {\n        const s = n || i;\n        return e[r] = !s || s.toLowerCase(), \"\";\n      }), e[\"max-age\"]) {\n        const t = parseInt(e[\"max-age\"], 10);\n        isNaN(t) ? delete e[\"max-age\"] : e[\"max-age\"] = t;\n      }\n      return e;\n    }\n    let J = null;\n    function H(t) {\n      if (null == J) {\n        const e = t.navigator ? t.navigator.userAgent : null;\n        J = !!t.safari || !(!e || !(/\\b(iPad|iPhone|iPod)\\b/.test(e) || e.match(\"Safari\") && !e.match(\"Chrome\")));\n      }\n      return J;\n    }\n    function Y(t) {\n      try {\n        const r = e[t];\n        return r.setItem(\"_mapbox_test_\", 1), r.removeItem(\"_mapbox_test_\"), !0;\n      } catch (t) {\n        return !1;\n      }\n    }\n    function W(t, e) {\n      return [t[4 * e], t[4 * e + 1], t[4 * e + 2], t[4 * e + 3]];\n    }\n    const Q = \"mapbox-tiles\";\n    let tt = 500,\n      et = 50;\n    let rt, nt;\n    function it() {\n      try {\n        return e.caches;\n      } catch (t) {}\n    }\n    function st() {\n      it() && !rt && (rt = e.caches.open(Q));\n    }\n    function at(t) {\n      const e = t.indexOf(\"?\");\n      if (e < 0) return t;\n      const r = function (t) {\n          const e = t.indexOf(\"?\");\n          return e > 0 ? t.slice(e + 1).split(\"&\") : [];\n        }(t),\n        n = r.filter(t => {\n          const e = t.split(\"=\");\n          return \"language\" === e[0] || \"worldview\" === e[0];\n        });\n      return n.length ? `${t.slice(0, e)}?${n.join(\"&\")}` : t.slice(0, e);\n    }\n    let ot = 1 / 0;\n    const lt = {\n      Unknown: \"Unknown\",\n      Style: \"Style\",\n      Source: \"Source\",\n      Tile: \"Tile\",\n      Glyphs: \"Glyphs\",\n      SpriteImage: \"SpriteImage\",\n      SpriteJSON: \"SpriteJSON\",\n      Image: \"Image\"\n    };\n    \"function\" == typeof Object.freeze && Object.freeze(lt);\n    class ut extends Error {\n      constructor(t, e, r) {\n        401 === e && bt(r) && (t += \": you may have provided an invalid Mapbox access token. See https://docs.mapbox.com/api/overview/#access-tokens-and-token-scopes\"), super(t), this.status = e, this.url = r;\n      }\n      toString() {\n        return `${this.name}: ${this.message} (${this.status}): ${this.url}`;\n      }\n    }\n    const ct = K() ? () => self.worker && self.worker.referrer : () => (\"blob:\" === e.location.protocol ? e.parent : e).location.href;\n    const ht = function (t, r) {\n        if (!(/^file:/.test(n = t.url) || /^file:/.test(ct()) && !/^\\w+:/.test(n))) {\n          if (e.fetch && e.Request && e.AbortController && e.Request.prototype.hasOwnProperty(\"signal\")) return function (t, r) {\n            const n = new e.AbortController(),\n              i = new e.Request(t.url, {\n                method: t.method || \"GET\",\n                body: t.body,\n                credentials: t.credentials,\n                headers: t.headers,\n                referrer: ct(),\n                referrerPolicy: t.referrerPolicy,\n                signal: n.signal\n              });\n            let s = !1,\n              a = !1;\n            const o = (l = i.url).indexOf(\"sku=\") > 0 && bt(l);\n            var l;\n            \"json\" === t.type && i.headers.set(\"Accept\", \"application/json\");\n            const u = (n, s, l) => {\n                if (a) return;\n                if (n && \"SecurityError\" !== n.message && N(n.toString()), s && l) return c(s);\n                const u = Date.now();\n                e.fetch(i).then(e => {\n                  if (e.ok) {\n                    const t = o ? e.clone() : null;\n                    return c(e, t, u);\n                  }\n                  return r(new ut(e.statusText, e.status, t.url));\n                }).catch(e => {\n                  \"AbortError\" !== e.name && r(new Error(`${e.message} ${t.url}`));\n                });\n              },\n              c = (n, o, l) => {\n                (\"arrayBuffer\" === t.type ? n.arrayBuffer() : \"json\" === t.type ? n.json() : n.text()).then(t => {\n                  a || (o && l && function (t, r, n) {\n                    if (st(), !rt) return;\n                    const i = {\n                      status: r.status,\n                      statusText: r.statusText,\n                      headers: new e.Headers()\n                    };\n                    r.headers.forEach((t, e) => i.headers.set(e, t));\n                    const s = X(r.headers.get(\"Cache-Control\") || \"\");\n                    if (s[\"no-store\"]) return;\n                    s[\"max-age\"] && i.headers.set(\"Expires\", new Date(n + 1e3 * s[\"max-age\"]).toUTCString());\n                    const a = i.headers.get(\"Expires\");\n                    a && (new Date(a).getTime() - n < 42e4 || function (t, e) {\n                      if (void 0 === nt) try {\n                        new Response(new ReadableStream()), nt = !0;\n                      } catch (t) {\n                        nt = !1;\n                      }\n                      nt ? e(t.body) : t.blob().then(e);\n                    }(r, r => {\n                      const n = new e.Response(r, i);\n                      st(), rt && rt.then(e => e.put(at(t.url), n)).catch(t => N(t.message));\n                    }));\n                  }(i, o, l), s = !0, r(null, t, n.headers.get(\"Cache-Control\"), n.headers.get(\"Expires\")));\n                }).catch(t => {\n                  a || r(new Error(t.message));\n                });\n              };\n            return o ? function (t, e) {\n              if (st(), !rt) return e(null);\n              const r = at(t.url);\n              rt.then(t => {\n                t.match(r).then(n => {\n                  const i = function (t) {\n                    if (!t) return !1;\n                    const e = new Date(t.headers.get(\"Expires\") || 0),\n                      r = X(t.headers.get(\"Cache-Control\") || \"\");\n                    return e > Date.now() && !r[\"no-cache\"];\n                  }(n);\n                  t.delete(r), i && t.put(r, n.clone()), e(null, n, i);\n                }).catch(e);\n              }).catch(e);\n            }(i, u) : u(null, null), {\n              cancel: () => {\n                a = !0, s || n.abort();\n              }\n            };\n          }(t, r);\n          if (K() && self.worker && self.worker.actor) return self.worker.actor.send(\"getResource\", t, r, void 0, !0);\n        }\n        var n;\n        return function (t, r) {\n          const n = new e.XMLHttpRequest();\n          n.open(t.method || \"GET\", t.url, !0), \"arrayBuffer\" === t.type && (n.responseType = \"arraybuffer\");\n          for (const e in t.headers) n.setRequestHeader(e, t.headers[e]);\n          return \"json\" === t.type && (n.responseType = \"text\", n.setRequestHeader(\"Accept\", \"application/json\")), n.withCredentials = \"include\" === t.credentials, n.onerror = () => {\n            r(new Error(n.statusText));\n          }, n.onload = () => {\n            if ((n.status >= 200 && n.status < 300 || 0 === n.status) && null !== n.response) {\n              let e = n.response;\n              if (\"json\" === t.type) try {\n                e = JSON.parse(n.response);\n              } catch (t) {\n                return r(t);\n              }\n              r(null, e, n.getResponseHeader(\"Cache-Control\"), n.getResponseHeader(\"Expires\"));\n            } else r(new ut(n.statusText, n.status, t.url));\n          }, n.send(t.body), {\n            cancel: () => n.abort()\n          };\n        }(t, r);\n      },\n      pt = function (t, e) {\n        return ht(C(t, {\n          type: \"arrayBuffer\"\n        }), e);\n      };\n    function dt(t) {\n      const r = e.document.createElement(\"a\");\n      return r.href = t, r.protocol === e.document.location.protocol && r.host === e.document.location.host;\n    }\n    const ft = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAC0lEQVQYV2NgAAIAAAUAAarVyFEAAAAASUVORK5CYII=\";\n    let yt, mt;\n    yt = [], mt = 0;\n    const gt = function (t, r) {\n        if (s.supported && (t.headers || (t.headers = {}), t.headers.accept = \"image/webp,*/*\"), mt >= i.MAX_PARALLEL_IMAGE_REQUESTS) {\n          const e = {\n            requestParameters: t,\n            callback: r,\n            cancelled: !1,\n            cancel() {\n              this.cancelled = !0;\n            }\n          };\n          return yt.push(e), e;\n        }\n        mt++;\n        let n = !1;\n        const a = () => {\n            if (!n) for (n = !0, mt--; yt.length && mt < i.MAX_PARALLEL_IMAGE_REQUESTS;) {\n              const t = yt.shift(),\n                {\n                  requestParameters: e,\n                  callback: r,\n                  cancelled: n\n                } = t;\n              n || (t.cancel = gt(e, r).cancel);\n            }\n          },\n          o = pt(t, (t, n, i, s) => {\n            a(), t ? r(t) : n && (e.createImageBitmap ? function (t, r) {\n              const n = new e.Blob([new Uint8Array(t)], {\n                type: \"image/png\"\n              });\n              e.createImageBitmap(n).then(t => {\n                r(null, t);\n              }).catch(t => {\n                r(new Error(`Could not load image because of ${t.message}. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported.`));\n              });\n            }(n, (t, e) => r(t, e, i, s)) : function (t, r) {\n              const n = new e.Image(),\n                i = e.URL;\n              n.onload = () => {\n                r(null, n), i.revokeObjectURL(n.src), n.onload = null, e.requestAnimationFrame(() => {\n                  n.src = ft;\n                });\n              }, n.onerror = () => r(new Error(\"Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported.\"));\n              const s = new e.Blob([new Uint8Array(t)], {\n                type: \"image/png\"\n              });\n              n.src = t.byteLength ? i.createObjectURL(s) : ft;\n            }(n, (t, e) => r(t, e, i, s)));\n          });\n        return {\n          cancel: () => {\n            o.cancel(), a();\n          }\n        };\n      },\n      xt = \"NO_ACCESS_TOKEN\";\n    function vt(t) {\n      return 0 === t.indexOf(\"mapbox:\");\n    }\n    function bt(t) {\n      return i.API_URL_REGEX.test(t);\n    }\n    function wt(t) {\n      return i.API_CDN_URL_REGEX.test(t);\n    }\n    function _t(t) {\n      return i.API_STYLE_REGEX.test(t) && !At(t);\n    }\n    function At(t) {\n      return i.API_SPRITE_REGEX.test(t);\n    }\n    const St = /^(\\w+):\\/\\/([^/?]*)(\\/[^?]+)?\\??(.+)?/;\n    function kt(t) {\n      const e = t.match(St);\n      if (!e) throw new Error(\"Unable to parse URL object\");\n      return {\n        protocol: e[1],\n        authority: e[2],\n        path: e[3] || \"/\",\n        params: e[4] ? e[4].split(\"&\") : []\n      };\n    }\n    function It(t) {\n      const e = t.params.length ? `?${t.params.join(\"&\")}` : \"\";\n      return `${t.protocol}://${t.authority}${t.path}${e}`;\n    }\n    const Mt = \"mapbox.eventData\";\n    function Tt(t) {\n      if (!t) return null;\n      const r = t.split(\".\");\n      if (!r || 3 !== r.length) return null;\n      try {\n        return JSON.parse(decodeURIComponent(e.atob(r[1]).split(\"\").map(t => \"%\" + (\"00\" + t.charCodeAt(0).toString(16)).slice(-2)).join(\"\")));\n      } catch (t) {\n        return null;\n      }\n    }\n    class zt {\n      constructor(t) {\n        this.type = t, this.anonId = null, this.eventData = {}, this.queue = [], this.pendingRequest = null;\n      }\n      getStorageKey(t) {\n        const r = Tt(i.ACCESS_TOKEN);\n        let n = \"\";\n        return n = r && r.u ? e.btoa(encodeURIComponent(r.u).replace(/%([0-9A-F]{2})/g, (t, e) => String.fromCharCode(Number(\"0x\" + e)))) : i.ACCESS_TOKEN || \"\", t ? `${Mt}.${t}:${n}` : `${Mt}:${n}`;\n      }\n      fetchEventData() {\n        const t = Y(\"localStorage\"),\n          r = this.getStorageKey(),\n          n = this.getStorageKey(\"uuid\");\n        if (t) try {\n          const t = e.localStorage.getItem(r);\n          t && (this.eventData = JSON.parse(t));\n          const i = e.localStorage.getItem(n);\n          i && (this.anonId = i);\n        } catch (t) {\n          N(\"Unable to read from LocalStorage\");\n        }\n      }\n      saveEventData() {\n        const t = Y(\"localStorage\"),\n          r = this.getStorageKey(),\n          n = this.getStorageKey(\"uuid\");\n        if (t) try {\n          e.localStorage.setItem(n, this.anonId), Object.keys(this.eventData).length >= 1 && e.localStorage.setItem(r, JSON.stringify(this.eventData));\n        } catch (t) {\n          N(\"Unable to write to LocalStorage\");\n        }\n      }\n      processRequests(t) {}\n      postEvent(t, e, r, n) {\n        if (!i.EVENTS_URL) return;\n        const s = kt(i.EVENTS_URL);\n        s.params.push(`access_token=${n || i.ACCESS_TOKEN || \"\"}`);\n        const a = {\n            event: this.type,\n            created: new Date(t).toISOString()\n          },\n          o = e ? C(a, e) : a,\n          l = {\n            url: It(s),\n            headers: {\n              \"Content-Type\": \"text/plain\"\n            },\n            body: JSON.stringify([o])\n          };\n        this.pendingRequest = function (t, e) {\n          return ht(C(t, {\n            method: \"POST\"\n          }), e);\n        }(l, t => {\n          this.pendingRequest = null, r(t), this.saveEventData(), this.processRequests(n);\n        });\n      }\n      queueRequest(t, e) {\n        this.queue.push(t), this.processRequests(e);\n      }\n    }\n    const Bt = new class extends zt {\n        constructor(t) {\n          super(\"appUserTurnstile\"), this._customAccessToken = t;\n        }\n        postTurnstileEvent(t, e) {\n          i.EVENTS_URL && i.ACCESS_TOKEN && Array.isArray(t) && t.some(t => vt(t) || bt(t)) && this.queueRequest(Date.now(), e);\n        }\n        processRequests(t) {\n          if (this.pendingRequest || 0 === this.queue.length) return;\n          this.anonId && this.eventData.lastSuccess && this.eventData.tokenU || this.fetchEventData();\n          const e = Tt(i.ACCESS_TOKEN),\n            n = e ? e.u : i.ACCESS_TOKEN;\n          let s = n !== this.eventData.tokenU;\n          F(this.anonId) || (this.anonId = V(), s = !0);\n          const a = this.queue.shift();\n          if (this.eventData.lastSuccess) {\n            const t = new Date(this.eventData.lastSuccess),\n              e = new Date(a),\n              r = (a - this.eventData.lastSuccess) / 864e5;\n            s = s || r >= 1 || r < -1 || t.getDate() !== e.getDate();\n          } else s = !0;\n          s ? this.postEvent(a, {\n            sdkIdentifier: \"mapbox-gl-js\",\n            sdkVersion: r,\n            skuId: h,\n            \"enabled.telemetry\": !1,\n            userId: this.anonId\n          }, t => {\n            t || (this.eventData.lastSuccess = a, this.eventData.tokenU = n);\n          }, t) : this.processRequests();\n        }\n      }(),\n      Et = Bt.postTurnstileEvent.bind(Bt),\n      Ct = new class extends zt {\n        constructor() {\n          super(\"map.load\"), this.success = {}, this.skuToken = \"\";\n        }\n        postMapLoadEvent(t, e, r, n) {\n          this.skuToken = e, this.errorCb = n, i.EVENTS_URL && (r || i.ACCESS_TOKEN ? this.queueRequest({\n            id: t,\n            timestamp: Date.now()\n          }, r) : this.errorCb(new Error(xt)));\n        }\n        processRequests(t) {\n          if (this.pendingRequest || 0 === this.queue.length) return;\n          const {\n            id: e,\n            timestamp: n\n          } = this.queue.shift();\n          e && this.success[e] || (this.anonId || this.fetchEventData(), F(this.anonId) || (this.anonId = V()), this.postEvent(n, {\n            sdkIdentifier: \"mapbox-gl-js\",\n            sdkVersion: r,\n            skuId: h,\n            skuToken: this.skuToken,\n            userId: this.anonId\n          }, t => {\n            t ? this.errorCb(t) : e && (this.success[e] = !0);\n          }, t));\n        }\n      }(),\n      Pt = Ct.postMapLoadEvent.bind(Ct),\n      Dt = new class extends zt {\n        constructor() {\n          super(\"gljs.performance\");\n        }\n        postPerformanceEvent(t, e) {\n          i.EVENTS_URL && (t || i.ACCESS_TOKEN) && this.queueRequest({\n            timestamp: Date.now(),\n            performanceData: e\n          }, t);\n        }\n        processRequests(t) {\n          if (this.pendingRequest || 0 === this.queue.length) return;\n          const {\n              timestamp: n,\n              performanceData: i\n            } = this.queue.shift(),\n            s = function (t) {\n              const n = e.performance.getEntriesByType(\"resource\"),\n                i = e.performance.getEntriesByType(\"mark\"),\n                s = function (t) {\n                  const e = {};\n                  if (t) for (const r in t) if (\"other\" !== r) for (const n of t[r]) {\n                    const t = `${r}ResolveRangeMin`,\n                      i = `${r}ResolveRangeMax`,\n                      s = `${r}RequestCount`,\n                      a = `${r}RequestCachedCount`;\n                    e[t] = Math.min(e[t] || 1 / 0, n.startTime), e[i] = Math.max(e[i] || -1 / 0, n.responseEnd);\n                    const o = t => {\n                      void 0 === e[t] && (e[t] = 0), ++e[t];\n                    };\n                    void 0 !== n.transferSize && 0 === n.transferSize && o(a), o(s);\n                  }\n                  return e;\n                }(function (t, e) {\n                  const r = {};\n                  if (t) for (const n of t) {\n                    const t = e(n);\n                    void 0 === r[t] && (r[t] = []), r[t].push(n);\n                  }\n                  return r;\n                }(n, jt)),\n                a = e.devicePixelRatio,\n                o = e.navigator.connection || e.navigator.mozConnection || e.navigator.webkitConnection,\n                l = {\n                  counters: [],\n                  metadata: [],\n                  attributes: []\n                },\n                u = (t, e, r) => {\n                  null != r && t.push({\n                    name: e,\n                    value: r.toString()\n                  });\n                };\n              for (const t in s) u(l.counters, t, s[t]);\n              if (t.interactionRange[0] !== 1 / 0 && t.interactionRange[1] !== -1 / 0 && (u(l.counters, \"interactionRangeMin\", t.interactionRange[0]), u(l.counters, \"interactionRangeMax\", t.interactionRange[1])), i) for (const t of Object.keys(Ut)) {\n                const e = Ut[t],\n                  r = i.find(t => t.name === e);\n                r && u(l.counters, e, r.startTime);\n              }\n              return u(l.counters, \"visibilityHidden\", t.visibilityHidden), u(l.attributes, \"style\", function (t) {\n                if (t) for (const e of t) {\n                  const t = e.name.split(\"?\")[0];\n                  if (_t(t)) {\n                    const e = t.split(\"/\").slice(-2);\n                    if (2 === e.length) return `mapbox://styles/${e[0]}/${e[1]}`;\n                  }\n                }\n              }(n)), u(l.attributes, \"terrainEnabled\", t.terrainEnabled ? \"true\" : \"false\"), u(l.attributes, \"fogEnabled\", t.fogEnabled ? \"true\" : \"false\"), u(l.attributes, \"projection\", t.projection), u(l.attributes, \"zoom\", t.zoom), u(l.metadata, \"devicePixelRatio\", a), u(l.metadata, \"connectionEffectiveType\", o ? o.effectiveType : void 0), u(l.metadata, \"navigatorUserAgent\", e.navigator.userAgent), u(l.metadata, \"screenWidth\", e.screen.width), u(l.metadata, \"screenHeight\", e.screen.height), u(l.metadata, \"windowWidth\", e.innerWidth), u(l.metadata, \"windowHeight\", e.innerHeight), u(l.metadata, \"mapWidth\", t.width / a), u(l.metadata, \"mapHeight\", t.height / a), u(l.metadata, \"webglRenderer\", t.renderer), u(l.metadata, \"webglVendor\", t.vendor), u(l.metadata, \"sdkVersion\", r), u(l.metadata, \"sdkIdentifier\", \"mapbox-gl-js\"), l;\n            }(i);\n          for (const t of s.metadata);\n          for (const t of s.counters);\n          for (const t of s.attributes);\n          this.postEvent(n, s, () => {}, t);\n        }\n      }(),\n      Vt = Dt.postPerformanceEvent.bind(Dt),\n      Lt = new class extends zt {\n        constructor() {\n          super(\"map.auth\"), this.success = {}, this.skuToken = \"\";\n        }\n        getSession(t, e, r, n) {\n          if (!i.API_URL || !i.SESSION_PATH) return;\n          const s = kt(i.API_URL + i.SESSION_PATH);\n          s.params.push(`sku=${e || \"\"}`), s.params.push(`access_token=${n || i.ACCESS_TOKEN || \"\"}`);\n          const a = {\n            url: It(s),\n            headers: {\n              \"Content-Type\": \"text/plain\"\n            }\n          };\n          this.pendingRequest = function (t, e) {\n            return ht(C(t, {\n              method: \"GET\"\n            }), e);\n          }(a, t => {\n            this.pendingRequest = null, r(t), this.saveEventData(), this.processRequests(n);\n          });\n        }\n        getSessionAPI(t, e, r, n) {\n          this.skuToken = e, this.errorCb = n, i.SESSION_PATH && i.API_URL && (r || i.ACCESS_TOKEN ? this.queueRequest({\n            id: t,\n            timestamp: Date.now()\n          }, r) : this.errorCb(new Error(xt)));\n        }\n        processRequests(t) {\n          if (this.pendingRequest || 0 === this.queue.length) return;\n          const {\n            id: e,\n            timestamp: r\n          } = this.queue.shift();\n          e && this.success[e] || this.getSession(r, this.skuToken, t => {\n            t ? this.errorCb(t) : e && (this.success[e] = !0);\n          }, t);\n        }\n      }(),\n      Ft = Lt.getSessionAPI.bind(Lt),\n      Rt = new Set(),\n      Ut = {\n        create: \"create\",\n        load: \"load\",\n        fullLoad: \"fullLoad\"\n      },\n      $t = {\n        mark(t) {\n          e.performance.mark(t);\n        },\n        measure(t, r, n) {\n          e.performance.measure(t, r, n);\n        }\n      };\n    function jt(t) {\n      const e = t.name.split(\"?\")[0];\n      return wt(e) && e.includes(\"mapbox-gl.js\") ? \"javascript\" : wt(e) && e.includes(\"mapbox-gl.css\") ? \"css\" : function (t) {\n        return i.API_FONTS_REGEX.test(t);\n      }(e) ? \"fontRange\" : At(e) ? \"sprite\" : _t(e) ? \"style\" : function (t) {\n        return i.API_TILEJSON_REGEX.test(t);\n      }(e) ? \"tilejson\" : \"other\";\n    }\n    const Ot = e.performance;\n    function qt(t) {\n      const e = t ? t.url.toString() : void 0;\n      return Ot.getEntriesByName(e);\n    }\n    let Nt, Gt, Zt, Kt;\n    const Xt = {\n      now: () => void 0 !== Zt ? Zt : e.performance.now(),\n      setNow(t) {\n        Zt = t;\n      },\n      restoreNow() {\n        Zt = void 0;\n      },\n      frame(t) {\n        const r = e.requestAnimationFrame(t);\n        return {\n          cancel: () => e.cancelAnimationFrame(r)\n        };\n      },\n      getImageData(t, r = 0) {\n        const {\n          width: n,\n          height: i\n        } = t;\n        Kt || (Kt = e.document.createElement(\"canvas\"));\n        const s = Kt.getContext(\"2d\", {\n          willReadFrequently: !0\n        });\n        if (!s) throw new Error(\"failed to create canvas 2d context\");\n        return (n > Kt.width || i > Kt.height) && (Kt.width = n, Kt.height = i), s.clearRect(-r, -r, n + 2 * r, i + 2 * r), s.drawImage(t, 0, 0, n, i), s.getImageData(-r, -r, n + 2 * r, i + 2 * r);\n      },\n      resolveURL: t => (Nt || (Nt = e.document.createElement(\"a\")), Nt.href = t, Nt.href),\n      get devicePixelRatio() {\n        return e.devicePixelRatio;\n      },\n      get prefersReducedMotion() {\n        return !!e.matchMedia && (null == Gt && (Gt = e.matchMedia(\"(prefers-reduced-motion: reduce)\")), Gt.matches);\n      }\n    };\n    function Jt(t, e, r) {\n      r[t] && -1 !== r[t].indexOf(e) || (r[t] = r[t] || [], r[t].push(e));\n    }\n    function Ht(t, e, r) {\n      if (r && r[t]) {\n        const n = r[t].indexOf(e);\n        -1 !== n && r[t].splice(n, 1);\n      }\n    }\n    class Yt {\n      constructor(t, e = {}) {\n        C(this, e), this.type = t;\n      }\n    }\n    class Wt extends Yt {\n      constructor(t, e = {}) {\n        super(\"error\", C({\n          error: t\n        }, e));\n      }\n    }\n    class Qt {\n      on(t, e) {\n        return this._listeners = this._listeners || {}, Jt(t, e, this._listeners), this;\n      }\n      off(t, e) {\n        return Ht(t, e, this._listeners), Ht(t, e, this._oneTimeListeners), this;\n      }\n      once(t, e) {\n        return e ? (this._oneTimeListeners = this._oneTimeListeners || {}, Jt(t, e, this._oneTimeListeners), this) : new Promise(e => this.once(t, e));\n      }\n      fire(t, e) {\n        \"string\" == typeof t && (t = new Yt(t, e || {}));\n        const r = t.type;\n        if (this.listens(r)) {\n          t.target = this;\n          const e = this._listeners && this._listeners[r] ? this._listeners[r].slice() : [];\n          for (const r of e) r.call(this, t);\n          const n = this._oneTimeListeners && this._oneTimeListeners[r] ? this._oneTimeListeners[r].slice() : [];\n          for (const e of n) Ht(r, e, this._oneTimeListeners), e.call(this, t);\n          const i = this._eventedParent;\n          i && (C(t, \"function\" == typeof this._eventedParentData ? this._eventedParentData() : this._eventedParentData), i.fire(t));\n        } else t instanceof Wt && console.error(t.error);\n        return this;\n      }\n      listens(t) {\n        return !!(this._listeners && this._listeners[t] && this._listeners[t].length > 0 || this._oneTimeListeners && this._oneTimeListeners[t] && this._oneTimeListeners[t].length > 0 || this._eventedParent && this._eventedParent.listens(t));\n      }\n      setEventedParent(t, e) {\n        return this._eventedParent = t, this._eventedParentData = e, this;\n      }\n    }\n    var te = JSON.parse('{\"$version\":8,\"$root\":{\"version\":{\"required\":true,\"type\":\"enum\",\"values\":[8]},\"name\":{\"type\":\"string\"},\"metadata\":{\"type\":\"*\"},\"center\":{\"type\":\"array\",\"value\":\"number\"},\"zoom\":{\"type\":\"number\"},\"bearing\":{\"type\":\"number\",\"default\":0,\"period\":360,\"units\":\"degrees\"},\"pitch\":{\"type\":\"number\",\"default\":0,\"units\":\"degrees\"},\"light\":{\"type\":\"light\"},\"terrain\":{\"type\":\"terrain\"},\"fog\":{\"type\":\"fog\"},\"sources\":{\"required\":true,\"type\":\"sources\"},\"sprite\":{\"type\":\"string\"},\"glyphs\":{\"type\":\"string\"},\"transition\":{\"type\":\"transition\"},\"projection\":{\"type\":\"projection\"},\"layers\":{\"required\":true,\"type\":\"array\",\"value\":\"layer\"}},\"sources\":{\"*\":{\"type\":\"source\"}},\"source\":[\"source_vector\",\"source_raster\",\"source_raster_dem\",\"source_geojson\",\"source_video\",\"source_image\"],\"source_vector\":{\"type\":{\"required\":true,\"type\":\"enum\",\"values\":{\"vector\":{}}},\"url\":{\"type\":\"string\"},\"tiles\":{\"type\":\"array\",\"value\":\"string\"},\"bounds\":{\"type\":\"array\",\"value\":\"number\",\"length\":4,\"default\":[-180,-85.051129,180,85.051129]},\"scheme\":{\"type\":\"enum\",\"values\":{\"xyz\":{},\"tms\":{}},\"default\":\"xyz\"},\"minzoom\":{\"type\":\"number\",\"default\":0},\"maxzoom\":{\"type\":\"number\",\"default\":22},\"attribution\":{\"type\":\"string\"},\"promoteId\":{\"type\":\"promoteId\"},\"volatile\":{\"type\":\"boolean\",\"default\":false},\"*\":{\"type\":\"*\"}},\"source_raster\":{\"type\":{\"required\":true,\"type\":\"enum\",\"values\":{\"raster\":{}}},\"url\":{\"type\":\"string\"},\"tiles\":{\"type\":\"array\",\"value\":\"string\"},\"bounds\":{\"type\":\"array\",\"value\":\"number\",\"length\":4,\"default\":[-180,-85.051129,180,85.051129]},\"minzoom\":{\"type\":\"number\",\"default\":0},\"maxzoom\":{\"type\":\"number\",\"default\":22},\"tileSize\":{\"type\":\"number\",\"default\":512,\"units\":\"pixels\"},\"scheme\":{\"type\":\"enum\",\"values\":{\"xyz\":{},\"tms\":{}},\"default\":\"xyz\"},\"attribution\":{\"type\":\"string\"},\"volatile\":{\"type\":\"boolean\",\"default\":false},\"*\":{\"type\":\"*\"}},\"source_raster_dem\":{\"type\":{\"required\":true,\"type\":\"enum\",\"values\":{\"raster-dem\":{}}},\"url\":{\"type\":\"string\"},\"tiles\":{\"type\":\"array\",\"value\":\"string\"},\"bounds\":{\"type\":\"array\",\"value\":\"number\",\"length\":4,\"default\":[-180,-85.051129,180,85.051129]},\"minzoom\":{\"type\":\"number\",\"default\":0},\"maxzoom\":{\"type\":\"number\",\"default\":22},\"tileSize\":{\"type\":\"number\",\"default\":512,\"units\":\"pixels\"},\"attribution\":{\"type\":\"string\"},\"encoding\":{\"type\":\"enum\",\"values\":{\"terrarium\":{},\"mapbox\":{}},\"default\":\"mapbox\"},\"volatile\":{\"type\":\"boolean\",\"default\":false},\"*\":{\"type\":\"*\"}},\"source_geojson\":{\"type\":{\"required\":true,\"type\":\"enum\",\"values\":{\"geojson\":{}}},\"data\":{\"type\":\"*\"},\"maxzoom\":{\"type\":\"number\",\"default\":18},\"attribution\":{\"type\":\"string\"},\"buffer\":{\"type\":\"number\",\"default\":128,\"maximum\":512,\"minimum\":0},\"filter\":{\"type\":\"*\"},\"tolerance\":{\"type\":\"number\",\"default\":0.375},\"cluster\":{\"type\":\"boolean\",\"default\":false},\"clusterRadius\":{\"type\":\"number\",\"default\":50,\"minimum\":0},\"clusterMaxZoom\":{\"type\":\"number\"},\"clusterMinPoints\":{\"type\":\"number\"},\"clusterProperties\":{\"type\":\"*\"},\"lineMetrics\":{\"type\":\"boolean\",\"default\":false},\"generateId\":{\"type\":\"boolean\",\"default\":false},\"promoteId\":{\"type\":\"promoteId\"}},\"source_video\":{\"type\":{\"required\":true,\"type\":\"enum\",\"values\":{\"video\":{}}},\"urls\":{\"required\":true,\"type\":\"array\",\"value\":\"string\"},\"coordinates\":{\"required\":true,\"type\":\"array\",\"length\":4,\"value\":{\"type\":\"array\",\"length\":2,\"value\":\"number\"}}},\"source_image\":{\"type\":{\"required\":true,\"type\":\"enum\",\"values\":{\"image\":{}}},\"url\":{\"required\":true,\"type\":\"string\"},\"coordinates\":{\"required\":true,\"type\":\"array\",\"length\":4,\"value\":{\"type\":\"array\",\"length\":2,\"value\":\"number\"}}},\"layer\":{\"id\":{\"type\":\"string\",\"required\":true},\"type\":{\"type\":\"enum\",\"values\":{\"fill\":{},\"line\":{},\"symbol\":{},\"circle\":{},\"heatmap\":{},\"fill-extrusion\":{},\"raster\":{},\"hillshade\":{},\"background\":{},\"sky\":{}},\"required\":true},\"metadata\":{\"type\":\"*\"},\"source\":{\"type\":\"string\"},\"source-layer\":{\"type\":\"string\"},\"minzoom\":{\"type\":\"number\",\"minimum\":0,\"maximum\":24},\"maxzoom\":{\"type\":\"number\",\"minimum\":0,\"maximum\":24},\"filter\":{\"type\":\"filter\"},\"layout\":{\"type\":\"layout\"},\"paint\":{\"type\":\"paint\"}},\"layout\":[\"layout_fill\",\"layout_line\",\"layout_circle\",\"layout_heatmap\",\"layout_fill-extrusion\",\"layout_symbol\",\"layout_raster\",\"layout_hillshade\",\"layout_background\",\"layout_sky\"],\"layout_background\":{\"visibility\":{\"type\":\"enum\",\"values\":{\"visible\":{},\"none\":{}},\"default\":\"visible\",\"property-type\":\"constant\"}},\"layout_sky\":{\"visibility\":{\"type\":\"enum\",\"values\":{\"visible\":{},\"none\":{}},\"default\":\"visible\",\"property-type\":\"constant\"}},\"layout_fill\":{\"fill-sort-key\":{\"type\":\"number\",\"expression\":{\"interpolated\":false,\"parameters\":[\"zoom\",\"feature\"]},\"property-type\":\"data-driven\"},\"visibility\":{\"type\":\"enum\",\"values\":{\"visible\":{},\"none\":{}},\"default\":\"visible\",\"property-type\":\"constant\"}},\"layout_circle\":{\"circle-sort-key\":{\"type\":\"number\",\"expression\":{\"interpolated\":false,\"parameters\":[\"zoom\",\"feature\"]},\"property-type\":\"data-driven\"},\"visibility\":{\"type\":\"enum\",\"values\":{\"visible\":{},\"none\":{}},\"default\":\"visible\",\"property-type\":\"constant\"}},\"layout_heatmap\":{\"visibility\":{\"type\":\"enum\",\"values\":{\"visible\":{},\"none\":{}},\"default\":\"visible\",\"property-type\":\"constant\"}},\"layout_fill-extrusion\":{\"visibility\":{\"type\":\"enum\",\"values\":{\"visible\":{},\"none\":{}},\"default\":\"visible\",\"property-type\":\"constant\"},\"fill-extrusion-edge-radius\":{\"type\":\"number\",\"private\":true,\"default\":0,\"minimum\":0,\"maximum\":1,\"property-type\":\"constant\"}},\"layout_line\":{\"line-cap\":{\"type\":\"enum\",\"values\":{\"butt\":{},\"round\":{},\"square\":{}},\"default\":\"butt\",\"expression\":{\"interpolated\":false,\"parameters\":[\"zoom\",\"feature\"]},\"property-type\":\"data-driven\"},\"line-join\":{\"type\":\"enum\",\"values\":{\"bevel\":{},\"round\":{},\"miter\":{}},\"default\":\"miter\",\"expression\":{\"interpolated\":false,\"parameters\":[\"zoom\",\"feature\"]},\"property-type\":\"data-driven\"},\"line-miter-limit\":{\"type\":\"number\",\"default\":2,\"requires\":[{\"line-join\":\"miter\"}],\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"line-round-limit\":{\"type\":\"number\",\"default\":1.05,\"requires\":[{\"line-join\":\"round\"}],\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"line-sort-key\":{\"type\":\"number\",\"expression\":{\"interpolated\":false,\"parameters\":[\"zoom\",\"feature\"]},\"property-type\":\"data-driven\"},\"visibility\":{\"type\":\"enum\",\"values\":{\"visible\":{},\"none\":{}},\"default\":\"visible\",\"property-type\":\"constant\"}},\"layout_symbol\":{\"symbol-placement\":{\"type\":\"enum\",\"values\":{\"point\":{},\"line\":{},\"line-center\":{}},\"default\":\"point\",\"expression\":{\"interpolated\":false,\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"symbol-spacing\":{\"type\":\"number\",\"default\":250,\"minimum\":1,\"units\":\"pixels\",\"requires\":[{\"symbol-placement\":\"line\"}],\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"symbol-avoid-edges\":{\"type\":\"boolean\",\"default\":false,\"expression\":{\"interpolated\":false,\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"symbol-sort-key\":{\"type\":\"number\",\"expression\":{\"interpolated\":false,\"parameters\":[\"zoom\",\"feature\"]},\"property-type\":\"data-driven\"},\"symbol-z-order\":{\"type\":\"enum\",\"values\":{\"auto\":{},\"viewport-y\":{},\"source\":{}},\"default\":\"auto\",\"expression\":{\"interpolated\":false,\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"icon-allow-overlap\":{\"type\":\"boolean\",\"default\":false,\"requires\":[\"icon-image\"],\"expression\":{\"interpolated\":false,\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"icon-ignore-placement\":{\"type\":\"boolean\",\"default\":false,\"requires\":[\"icon-image\"],\"expression\":{\"interpolated\":false,\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"icon-optional\":{\"type\":\"boolean\",\"default\":false,\"requires\":[\"icon-image\",\"text-field\"],\"expression\":{\"interpolated\":false,\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"icon-rotation-alignment\":{\"type\":\"enum\",\"values\":{\"map\":{},\"viewport\":{},\"auto\":{}},\"default\":\"auto\",\"requires\":[\"icon-image\"],\"expression\":{\"interpolated\":false,\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"icon-size\":{\"type\":\"number\",\"default\":1,\"minimum\":0,\"units\":\"factor of the original icon size\",\"requires\":[\"icon-image\"],\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\"]},\"property-type\":\"data-driven\"},\"icon-text-fit\":{\"type\":\"enum\",\"values\":{\"none\":{},\"width\":{},\"height\":{},\"both\":{}},\"default\":\"none\",\"requires\":[\"icon-image\",\"text-field\"],\"expression\":{\"interpolated\":false,\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"icon-text-fit-padding\":{\"type\":\"array\",\"value\":\"number\",\"length\":4,\"default\":[0,0,0,0],\"units\":\"pixels\",\"requires\":[\"icon-image\",\"text-field\",{\"icon-text-fit\":[\"both\",\"width\",\"height\"]}],\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"icon-image\":{\"type\":\"resolvedImage\",\"tokens\":true,\"expression\":{\"interpolated\":false,\"parameters\":[\"zoom\",\"feature\"]},\"property-type\":\"data-driven\"},\"icon-rotate\":{\"type\":\"number\",\"default\":0,\"period\":360,\"units\":\"degrees\",\"requires\":[\"icon-image\"],\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\"]},\"property-type\":\"data-driven\"},\"icon-padding\":{\"type\":\"number\",\"default\":2,\"minimum\":0,\"units\":\"pixels\",\"requires\":[\"icon-image\"],\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"icon-keep-upright\":{\"type\":\"boolean\",\"default\":false,\"requires\":[\"icon-image\",{\"icon-rotation-alignment\":\"map\"},{\"symbol-placement\":[\"line\",\"line-center\"]}],\"expression\":{\"interpolated\":false,\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"icon-offset\":{\"type\":\"array\",\"value\":\"number\",\"length\":2,\"default\":[0,0],\"requires\":[\"icon-image\"],\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\"]},\"property-type\":\"data-driven\"},\"icon-anchor\":{\"type\":\"enum\",\"values\":{\"center\":{},\"left\":{},\"right\":{},\"top\":{},\"bottom\":{},\"top-left\":{},\"top-right\":{},\"bottom-left\":{},\"bottom-right\":{}},\"default\":\"center\",\"requires\":[\"icon-image\"],\"expression\":{\"interpolated\":false,\"parameters\":[\"zoom\",\"feature\"]},\"property-type\":\"data-driven\"},\"icon-pitch-alignment\":{\"type\":\"enum\",\"values\":{\"map\":{},\"viewport\":{},\"auto\":{}},\"default\":\"auto\",\"requires\":[\"icon-image\"],\"expression\":{\"interpolated\":false,\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"text-pitch-alignment\":{\"type\":\"enum\",\"values\":{\"map\":{},\"viewport\":{},\"auto\":{}},\"default\":\"auto\",\"requires\":[\"text-field\"],\"expression\":{\"interpolated\":false,\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"text-rotation-alignment\":{\"type\":\"enum\",\"values\":{\"map\":{},\"viewport\":{},\"auto\":{}},\"default\":\"auto\",\"requires\":[\"text-field\"],\"expression\":{\"interpolated\":false,\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"text-field\":{\"type\":\"formatted\",\"default\":\"\",\"tokens\":true,\"expression\":{\"interpolated\":false,\"parameters\":[\"zoom\",\"feature\"]},\"property-type\":\"data-driven\"},\"text-font\":{\"type\":\"array\",\"value\":\"string\",\"default\":[\"Open Sans Regular\",\"Arial Unicode MS Regular\"],\"requires\":[\"text-field\"],\"expression\":{\"interpolated\":false,\"parameters\":[\"zoom\",\"feature\"]},\"property-type\":\"data-driven\"},\"text-size\":{\"type\":\"number\",\"default\":16,\"minimum\":0,\"units\":\"pixels\",\"requires\":[\"text-field\"],\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\"]},\"property-type\":\"data-driven\"},\"text-max-width\":{\"type\":\"number\",\"default\":10,\"minimum\":0,\"units\":\"ems\",\"requires\":[\"text-field\",{\"symbol-placement\":[\"point\"]}],\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\"]},\"property-type\":\"data-driven\"},\"text-line-height\":{\"type\":\"number\",\"default\":1.2,\"units\":\"ems\",\"requires\":[\"text-field\"],\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\"]},\"property-type\":\"data-driven\"},\"text-letter-spacing\":{\"type\":\"number\",\"default\":0,\"units\":\"ems\",\"requires\":[\"text-field\"],\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\"]},\"property-type\":\"data-driven\"},\"text-justify\":{\"type\":\"enum\",\"values\":{\"auto\":{},\"left\":{},\"center\":{},\"right\":{}},\"default\":\"center\",\"requires\":[\"text-field\"],\"expression\":{\"interpolated\":false,\"parameters\":[\"zoom\",\"feature\"]},\"property-type\":\"data-driven\"},\"text-radial-offset\":{\"type\":\"number\",\"units\":\"ems\",\"default\":0,\"requires\":[\"text-field\"],\"property-type\":\"data-driven\",\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\"]}},\"text-variable-anchor\":{\"type\":\"array\",\"value\":\"enum\",\"values\":{\"center\":{},\"left\":{},\"right\":{},\"top\":{},\"bottom\":{},\"top-left\":{},\"top-right\":{},\"bottom-left\":{},\"bottom-right\":{}},\"requires\":[\"text-field\",{\"symbol-placement\":[\"point\"]}],\"expression\":{\"interpolated\":false,\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"text-anchor\":{\"type\":\"enum\",\"values\":{\"center\":{},\"left\":{},\"right\":{},\"top\":{},\"bottom\":{},\"top-left\":{},\"top-right\":{},\"bottom-left\":{},\"bottom-right\":{}},\"default\":\"center\",\"requires\":[\"text-field\",{\"!\":\"text-variable-anchor\"}],\"expression\":{\"interpolated\":false,\"parameters\":[\"zoom\",\"feature\"]},\"property-type\":\"data-driven\"},\"text-max-angle\":{\"type\":\"number\",\"default\":45,\"units\":\"degrees\",\"requires\":[\"text-field\",{\"symbol-placement\":[\"line\",\"line-center\"]}],\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"text-writing-mode\":{\"type\":\"array\",\"value\":\"enum\",\"values\":{\"horizontal\":{},\"vertical\":{}},\"requires\":[\"text-field\"],\"expression\":{\"interpolated\":false,\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"text-rotate\":{\"type\":\"number\",\"default\":0,\"period\":360,\"units\":\"degrees\",\"requires\":[\"text-field\"],\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\"]},\"property-type\":\"data-driven\"},\"text-padding\":{\"type\":\"number\",\"default\":2,\"minimum\":0,\"units\":\"pixels\",\"requires\":[\"text-field\"],\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"text-keep-upright\":{\"type\":\"boolean\",\"default\":true,\"requires\":[\"text-field\",{\"text-rotation-alignment\":\"map\"},{\"symbol-placement\":[\"line\",\"line-center\"]}],\"expression\":{\"interpolated\":false,\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"text-transform\":{\"type\":\"enum\",\"values\":{\"none\":{},\"uppercase\":{},\"lowercase\":{}},\"default\":\"none\",\"requires\":[\"text-field\"],\"expression\":{\"interpolated\":false,\"parameters\":[\"zoom\",\"feature\"]},\"property-type\":\"data-driven\"},\"text-offset\":{\"type\":\"array\",\"value\":\"number\",\"units\":\"ems\",\"length\":2,\"default\":[0,0],\"requires\":[\"text-field\",{\"!\":\"text-radial-offset\"}],\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\"]},\"property-type\":\"data-driven\"},\"text-allow-overlap\":{\"type\":\"boolean\",\"default\":false,\"requires\":[\"text-field\"],\"expression\":{\"interpolated\":false,\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"text-ignore-placement\":{\"type\":\"boolean\",\"default\":false,\"requires\":[\"text-field\"],\"expression\":{\"interpolated\":false,\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"text-optional\":{\"type\":\"boolean\",\"default\":false,\"requires\":[\"text-field\",\"icon-image\"],\"expression\":{\"interpolated\":false,\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"visibility\":{\"type\":\"enum\",\"values\":{\"visible\":{},\"none\":{}},\"default\":\"visible\",\"property-type\":\"constant\"}},\"layout_raster\":{\"visibility\":{\"type\":\"enum\",\"values\":{\"visible\":{},\"none\":{}},\"default\":\"visible\",\"property-type\":\"constant\"}},\"layout_hillshade\":{\"visibility\":{\"type\":\"enum\",\"values\":{\"visible\":{},\"none\":{}},\"default\":\"visible\",\"property-type\":\"constant\"}},\"filter\":{\"type\":\"array\",\"value\":\"*\"},\"filter_symbol\":{\"type\":\"boolean\",\"default\":false,\"transition\":false,\"property-type\":\"data-driven\",\"expression\":{\"interpolated\":false,\"parameters\":[\"zoom\",\"feature\",\"pitch\",\"distance-from-center\"]}},\"filter_fill\":{\"type\":\"boolean\",\"default\":false,\"transition\":false,\"property-type\":\"data-driven\",\"expression\":{\"interpolated\":false,\"parameters\":[\"zoom\",\"feature\"]}},\"filter_line\":{\"type\":\"boolean\",\"default\":false,\"transition\":false,\"property-type\":\"data-driven\",\"expression\":{\"interpolated\":false,\"parameters\":[\"zoom\",\"feature\"]}},\"filter_circle\":{\"type\":\"boolean\",\"default\":false,\"transition\":false,\"property-type\":\"data-driven\",\"expression\":{\"interpolated\":false,\"parameters\":[\"zoom\",\"feature\"]}},\"filter_fill-extrusion\":{\"type\":\"boolean\",\"default\":false,\"transition\":false,\"property-type\":\"data-driven\",\"expression\":{\"interpolated\":false,\"parameters\":[\"zoom\",\"feature\"]}},\"filter_heatmap\":{\"type\":\"boolean\",\"default\":false,\"transition\":false,\"property-type\":\"data-driven\",\"expression\":{\"interpolated\":false,\"parameters\":[\"zoom\",\"feature\"]}},\"filter_operator\":{\"type\":\"enum\",\"values\":{\"==\":{},\"!=\":{},\">\":{},\">=\":{},\"<\":{},\"<=\":{},\"in\":{},\"!in\":{},\"all\":{},\"any\":{},\"none\":{},\"has\":{},\"!has\":{},\"within\":{}}},\"geometry_type\":{\"type\":\"enum\",\"values\":{\"Point\":{},\"LineString\":{},\"Polygon\":{}}},\"function\":{\"expression\":{\"type\":\"expression\"},\"stops\":{\"type\":\"array\",\"value\":\"function_stop\"},\"base\":{\"type\":\"number\",\"default\":1,\"minimum\":0},\"property\":{\"type\":\"string\",\"default\":\"$zoom\"},\"type\":{\"type\":\"enum\",\"values\":{\"identity\":{},\"exponential\":{},\"interval\":{},\"categorical\":{}},\"default\":\"exponential\"},\"colorSpace\":{\"type\":\"enum\",\"values\":{\"rgb\":{},\"lab\":{},\"hcl\":{}},\"default\":\"rgb\"},\"default\":{\"type\":\"*\",\"required\":false}},\"function_stop\":{\"type\":\"array\",\"minimum\":0,\"maximum\":24,\"value\":[\"number\",\"color\"],\"length\":2},\"expression\":{\"type\":\"array\",\"value\":\"*\",\"minimum\":1},\"fog\":{\"range\":{\"type\":\"array\",\"default\":[0.5,10],\"minimum\":-20,\"maximum\":20,\"length\":2,\"value\":\"number\",\"property-type\":\"data-constant\",\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]}},\"color\":{\"type\":\"color\",\"property-type\":\"data-constant\",\"default\":\"#ffffff\",\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"transition\":true},\"high-color\":{\"type\":\"color\",\"property-type\":\"data-constant\",\"default\":\"#245cdf\",\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"transition\":true},\"space-color\":{\"type\":\"color\",\"property-type\":\"data-constant\",\"default\":[\"interpolate\",[\"linear\"],[\"zoom\"],4,\"#010b19\",7,\"#367ab9\"],\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"transition\":true},\"horizon-blend\":{\"type\":\"number\",\"property-type\":\"data-constant\",\"default\":[\"interpolate\",[\"linear\"],[\"zoom\"],4,0.2,7,0.1],\"minimum\":0,\"maximum\":1,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"transition\":true},\"star-intensity\":{\"type\":\"number\",\"property-type\":\"data-constant\",\"default\":[\"interpolate\",[\"linear\"],[\"zoom\"],5,0.35,6,0],\"minimum\":0,\"maximum\":1,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"transition\":true}},\"light\":{\"anchor\":{\"type\":\"enum\",\"default\":\"viewport\",\"values\":{\"map\":{},\"viewport\":{}},\"property-type\":\"data-constant\",\"transition\":false,\"expression\":{\"interpolated\":false,\"parameters\":[\"zoom\"]}},\"position\":{\"type\":\"array\",\"default\":[1.15,210,30],\"length\":3,\"value\":\"number\",\"property-type\":\"data-constant\",\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]}},\"color\":{\"type\":\"color\",\"property-type\":\"data-constant\",\"default\":\"#ffffff\",\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"transition\":true},\"intensity\":{\"type\":\"number\",\"property-type\":\"data-constant\",\"default\":0.5,\"minimum\":0,\"maximum\":1,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"transition\":true}},\"projection\":{\"name\":{\"type\":\"enum\",\"values\":{\"albers\":{},\"equalEarth\":{},\"equirectangular\":{},\"lambertConformalConic\":{},\"mercator\":{},\"naturalEarth\":{},\"winkelTripel\":{},\"globe\":{}},\"default\":\"mercator\",\"required\":true},\"center\":{\"type\":\"array\",\"length\":2,\"value\":\"number\",\"property-type\":\"data-constant\",\"minimum\":[-180,-90],\"maximum\":[180,90],\"transition\":false,\"requires\":[{\"name\":[\"albers\",\"lambertConformalConic\"]}]},\"parallels\":{\"type\":\"array\",\"length\":2,\"value\":\"number\",\"property-type\":\"data-constant\",\"minimum\":[-90,-90],\"maximum\":[90,90],\"transition\":false,\"requires\":[{\"name\":[\"albers\",\"lambertConformalConic\"]}]}},\"terrain\":{\"source\":{\"type\":\"string\",\"required\":true},\"exaggeration\":{\"type\":\"number\",\"property-type\":\"data-constant\",\"default\":1,\"minimum\":0,\"maximum\":1000,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"transition\":true,\"requires\":[\"source\"]}},\"paint\":[\"paint_fill\",\"paint_line\",\"paint_circle\",\"paint_heatmap\",\"paint_fill-extrusion\",\"paint_symbol\",\"paint_raster\",\"paint_hillshade\",\"paint_background\",\"paint_sky\"],\"paint_fill\":{\"fill-antialias\":{\"type\":\"boolean\",\"default\":true,\"expression\":{\"interpolated\":false,\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"fill-opacity\":{\"type\":\"number\",\"default\":1,\"minimum\":0,\"maximum\":1,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\"]},\"property-type\":\"data-driven\"},\"fill-color\":{\"type\":\"color\",\"default\":\"#000000\",\"transition\":true,\"requires\":[{\"!\":\"fill-pattern\"}],\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\"]},\"property-type\":\"data-driven\"},\"fill-outline-color\":{\"type\":\"color\",\"transition\":true,\"requires\":[{\"!\":\"fill-pattern\"},{\"fill-antialias\":true}],\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\"]},\"property-type\":\"data-driven\"},\"fill-translate\":{\"type\":\"array\",\"value\":\"number\",\"length\":2,\"default\":[0,0],\"transition\":true,\"units\":\"pixels\",\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"fill-translate-anchor\":{\"type\":\"enum\",\"values\":{\"map\":{},\"viewport\":{}},\"default\":\"map\",\"requires\":[\"fill-translate\"],\"expression\":{\"interpolated\":false,\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"fill-pattern\":{\"type\":\"resolvedImage\",\"transition\":false,\"expression\":{\"interpolated\":false,\"parameters\":[\"zoom\",\"feature\"]},\"property-type\":\"data-driven\"}},\"paint_fill-extrusion\":{\"fill-extrusion-opacity\":{\"type\":\"number\",\"default\":1,\"minimum\":0,\"maximum\":1,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"fill-extrusion-color\":{\"type\":\"color\",\"default\":\"#000000\",\"transition\":true,\"requires\":[{\"!\":\"fill-extrusion-pattern\"}],\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\"]},\"property-type\":\"data-driven\"},\"fill-extrusion-translate\":{\"type\":\"array\",\"value\":\"number\",\"length\":2,\"default\":[0,0],\"transition\":true,\"units\":\"pixels\",\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"fill-extrusion-translate-anchor\":{\"type\":\"enum\",\"values\":{\"map\":{},\"viewport\":{}},\"default\":\"map\",\"requires\":[\"fill-extrusion-translate\"],\"expression\":{\"interpolated\":false,\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"fill-extrusion-pattern\":{\"type\":\"resolvedImage\",\"transition\":false,\"expression\":{\"interpolated\":false,\"parameters\":[\"zoom\",\"feature\"]},\"property-type\":\"data-driven\"},\"fill-extrusion-height\":{\"type\":\"number\",\"default\":0,\"minimum\":0,\"units\":\"meters\",\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\"]},\"property-type\":\"data-driven\"},\"fill-extrusion-base\":{\"type\":\"number\",\"default\":0,\"minimum\":0,\"units\":\"meters\",\"transition\":true,\"requires\":[\"fill-extrusion-height\"],\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\"]},\"property-type\":\"data-driven\"},\"fill-extrusion-vertical-gradient\":{\"type\":\"boolean\",\"default\":true,\"transition\":false,\"expression\":{\"interpolated\":false,\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"fill-extrusion-ambient-occlusion-intensity\":{\"property-type\":\"data-constant\",\"type\":\"number\",\"private\":true,\"default\":0,\"minimum\":0,\"maximum\":1,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"transition\":true},\"fill-extrusion-ambient-occlusion-radius\":{\"property-type\":\"data-constant\",\"type\":\"number\",\"private\":true,\"default\":3,\"minimum\":0,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"transition\":true,\"requires\":[\"fill-extrusion-edge-radius\"]},\"fill-extrusion-rounded-roof\":{\"type\":\"boolean\",\"default\":true,\"requires\":[\"fill-extrusion-edge-radius\"],\"transition\":false,\"expression\":{\"interpolated\":false,\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"}},\"paint_line\":{\"line-opacity\":{\"type\":\"number\",\"default\":1,\"minimum\":0,\"maximum\":1,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\"]},\"property-type\":\"data-driven\"},\"line-color\":{\"type\":\"color\",\"default\":\"#000000\",\"transition\":true,\"requires\":[{\"!\":\"line-pattern\"}],\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\"]},\"property-type\":\"data-driven\"},\"line-translate\":{\"type\":\"array\",\"value\":\"number\",\"length\":2,\"default\":[0,0],\"transition\":true,\"units\":\"pixels\",\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"line-translate-anchor\":{\"type\":\"enum\",\"values\":{\"map\":{},\"viewport\":{}},\"default\":\"map\",\"requires\":[\"line-translate\"],\"expression\":{\"interpolated\":false,\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"line-width\":{\"type\":\"number\",\"default\":1,\"minimum\":0,\"transition\":true,\"units\":\"pixels\",\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\"]},\"property-type\":\"data-driven\"},\"line-gap-width\":{\"type\":\"number\",\"default\":0,\"minimum\":0,\"transition\":true,\"units\":\"pixels\",\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\"]},\"property-type\":\"data-driven\"},\"line-offset\":{\"type\":\"number\",\"default\":0,\"transition\":true,\"units\":\"pixels\",\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\"]},\"property-type\":\"data-driven\"},\"line-blur\":{\"type\":\"number\",\"default\":0,\"minimum\":0,\"transition\":true,\"units\":\"pixels\",\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\"]},\"property-type\":\"data-driven\"},\"line-dasharray\":{\"type\":\"array\",\"value\":\"number\",\"minimum\":0,\"transition\":false,\"units\":\"line widths\",\"requires\":[{\"!\":\"line-pattern\"}],\"expression\":{\"interpolated\":false,\"parameters\":[\"zoom\",\"feature\"]},\"property-type\":\"data-driven\"},\"line-pattern\":{\"type\":\"resolvedImage\",\"transition\":false,\"expression\":{\"interpolated\":false,\"parameters\":[\"zoom\",\"feature\"]},\"property-type\":\"data-driven\"},\"line-gradient\":{\"type\":\"color\",\"transition\":false,\"requires\":[{\"!\":\"line-pattern\"},{\"source\":\"geojson\",\"has\":{\"lineMetrics\":true}}],\"expression\":{\"interpolated\":true,\"parameters\":[\"line-progress\"]},\"property-type\":\"color-ramp\"},\"line-trim-offset\":{\"type\":\"array\",\"value\":\"number\",\"length\":2,\"default\":[0,0],\"minimum\":[0,0],\"maximum\":[1,1],\"transition\":false,\"requires\":[{\"source\":\"geojson\",\"has\":{\"lineMetrics\":true}}],\"property-type\":\"constant\"}},\"paint_circle\":{\"circle-radius\":{\"type\":\"number\",\"default\":5,\"minimum\":0,\"transition\":true,\"units\":\"pixels\",\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\"]},\"property-type\":\"data-driven\"},\"circle-color\":{\"type\":\"color\",\"default\":\"#000000\",\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\"]},\"property-type\":\"data-driven\"},\"circle-blur\":{\"type\":\"number\",\"default\":0,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\"]},\"property-type\":\"data-driven\"},\"circle-opacity\":{\"type\":\"number\",\"default\":1,\"minimum\":0,\"maximum\":1,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\"]},\"property-type\":\"data-driven\"},\"circle-translate\":{\"type\":\"array\",\"value\":\"number\",\"length\":2,\"default\":[0,0],\"transition\":true,\"units\":\"pixels\",\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"circle-translate-anchor\":{\"type\":\"enum\",\"values\":{\"map\":{},\"viewport\":{}},\"default\":\"map\",\"requires\":[\"circle-translate\"],\"expression\":{\"interpolated\":false,\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"circle-pitch-scale\":{\"type\":\"enum\",\"values\":{\"map\":{},\"viewport\":{}},\"default\":\"map\",\"expression\":{\"interpolated\":false,\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"circle-pitch-alignment\":{\"type\":\"enum\",\"values\":{\"map\":{},\"viewport\":{}},\"default\":\"viewport\",\"expression\":{\"interpolated\":false,\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"circle-stroke-width\":{\"type\":\"number\",\"default\":0,\"minimum\":0,\"transition\":true,\"units\":\"pixels\",\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\"]},\"property-type\":\"data-driven\"},\"circle-stroke-color\":{\"type\":\"color\",\"default\":\"#000000\",\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\"]},\"property-type\":\"data-driven\"},\"circle-stroke-opacity\":{\"type\":\"number\",\"default\":1,\"minimum\":0,\"maximum\":1,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\"]},\"property-type\":\"data-driven\"}},\"paint_heatmap\":{\"heatmap-radius\":{\"type\":\"number\",\"default\":30,\"minimum\":1,\"transition\":true,\"units\":\"pixels\",\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\"]},\"property-type\":\"data-driven\"},\"heatmap-weight\":{\"type\":\"number\",\"default\":1,\"minimum\":0,\"transition\":false,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\"]},\"property-type\":\"data-driven\"},\"heatmap-intensity\":{\"type\":\"number\",\"default\":1,\"minimum\":0,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"heatmap-color\":{\"type\":\"color\",\"default\":[\"interpolate\",[\"linear\"],[\"heatmap-density\"],0,\"rgba(0, 0, 255, 0)\",0.1,\"royalblue\",0.3,\"cyan\",0.5,\"lime\",0.7,\"yellow\",1,\"red\"],\"transition\":false,\"expression\":{\"interpolated\":true,\"parameters\":[\"heatmap-density\"]},\"property-type\":\"color-ramp\"},\"heatmap-opacity\":{\"type\":\"number\",\"default\":1,\"minimum\":0,\"maximum\":1,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"}},\"paint_symbol\":{\"icon-opacity\":{\"type\":\"number\",\"default\":1,\"minimum\":0,\"maximum\":1,\"transition\":true,\"requires\":[\"icon-image\"],\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\"]},\"property-type\":\"data-driven\"},\"icon-color\":{\"type\":\"color\",\"default\":\"#000000\",\"transition\":true,\"requires\":[\"icon-image\"],\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\"]},\"property-type\":\"data-driven\"},\"icon-halo-color\":{\"type\":\"color\",\"default\":\"rgba(0, 0, 0, 0)\",\"transition\":true,\"requires\":[\"icon-image\"],\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\"]},\"property-type\":\"data-driven\"},\"icon-halo-width\":{\"type\":\"number\",\"default\":0,\"minimum\":0,\"transition\":true,\"units\":\"pixels\",\"requires\":[\"icon-image\"],\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\"]},\"property-type\":\"data-driven\"},\"icon-halo-blur\":{\"type\":\"number\",\"default\":0,\"minimum\":0,\"transition\":true,\"units\":\"pixels\",\"requires\":[\"icon-image\"],\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\"]},\"property-type\":\"data-driven\"},\"icon-translate\":{\"type\":\"array\",\"value\":\"number\",\"length\":2,\"default\":[0,0],\"transition\":true,\"units\":\"pixels\",\"requires\":[\"icon-image\"],\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"icon-translate-anchor\":{\"type\":\"enum\",\"values\":{\"map\":{},\"viewport\":{}},\"default\":\"map\",\"requires\":[\"icon-image\",\"icon-translate\"],\"expression\":{\"interpolated\":false,\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"text-opacity\":{\"type\":\"number\",\"default\":1,\"minimum\":0,\"maximum\":1,\"transition\":true,\"requires\":[\"text-field\"],\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\"]},\"property-type\":\"data-driven\"},\"text-color\":{\"type\":\"color\",\"default\":\"#000000\",\"transition\":true,\"overridable\":true,\"requires\":[\"text-field\"],\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\"]},\"property-type\":\"data-driven\"},\"text-halo-color\":{\"type\":\"color\",\"default\":\"rgba(0, 0, 0, 0)\",\"transition\":true,\"requires\":[\"text-field\"],\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\"]},\"property-type\":\"data-driven\"},\"text-halo-width\":{\"type\":\"number\",\"default\":0,\"minimum\":0,\"transition\":true,\"units\":\"pixels\",\"requires\":[\"text-field\"],\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\"]},\"property-type\":\"data-driven\"},\"text-halo-blur\":{\"type\":\"number\",\"default\":0,\"minimum\":0,\"transition\":true,\"units\":\"pixels\",\"requires\":[\"text-field\"],\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\"]},\"property-type\":\"data-driven\"},\"text-translate\":{\"type\":\"array\",\"value\":\"number\",\"length\":2,\"default\":[0,0],\"transition\":true,\"units\":\"pixels\",\"requires\":[\"text-field\"],\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"text-translate-anchor\":{\"type\":\"enum\",\"values\":{\"map\":{},\"viewport\":{}},\"default\":\"map\",\"requires\":[\"text-field\",\"text-translate\"],\"expression\":{\"interpolated\":false,\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"}},\"paint_raster\":{\"raster-opacity\":{\"type\":\"number\",\"default\":1,\"minimum\":0,\"maximum\":1,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"raster-hue-rotate\":{\"type\":\"number\",\"default\":0,\"period\":360,\"transition\":true,\"units\":\"degrees\",\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"raster-brightness-min\":{\"type\":\"number\",\"default\":0,\"minimum\":0,\"maximum\":1,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"raster-brightness-max\":{\"type\":\"number\",\"default\":1,\"minimum\":0,\"maximum\":1,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"raster-saturation\":{\"type\":\"number\",\"default\":0,\"minimum\":-1,\"maximum\":1,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"raster-contrast\":{\"type\":\"number\",\"default\":0,\"minimum\":-1,\"maximum\":1,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"raster-resampling\":{\"type\":\"enum\",\"values\":{\"linear\":{},\"nearest\":{}},\"default\":\"linear\",\"expression\":{\"interpolated\":false,\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"raster-fade-duration\":{\"type\":\"number\",\"default\":300,\"minimum\":0,\"transition\":false,\"units\":\"milliseconds\",\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"}},\"paint_hillshade\":{\"hillshade-illumination-direction\":{\"type\":\"number\",\"default\":335,\"minimum\":0,\"maximum\":359,\"transition\":false,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"hillshade-illumination-anchor\":{\"type\":\"enum\",\"values\":{\"map\":{},\"viewport\":{}},\"default\":\"viewport\",\"expression\":{\"interpolated\":false,\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"hillshade-exaggeration\":{\"type\":\"number\",\"default\":0.5,\"minimum\":0,\"maximum\":1,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"hillshade-shadow-color\":{\"type\":\"color\",\"default\":\"#000000\",\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"hillshade-highlight-color\":{\"type\":\"color\",\"default\":\"#FFFFFF\",\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"hillshade-accent-color\":{\"type\":\"color\",\"default\":\"#000000\",\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"}},\"paint_background\":{\"background-color\":{\"type\":\"color\",\"default\":\"#000000\",\"transition\":true,\"requires\":[{\"!\":\"background-pattern\"}],\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"background-pattern\":{\"type\":\"resolvedImage\",\"transition\":false,\"expression\":{\"interpolated\":false,\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"background-opacity\":{\"type\":\"number\",\"default\":1,\"minimum\":0,\"maximum\":1,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"}},\"paint_sky\":{\"sky-type\":{\"type\":\"enum\",\"values\":{\"gradient\":{},\"atmosphere\":{}},\"default\":\"atmosphere\",\"expression\":{\"interpolated\":false,\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"sky-atmosphere-sun\":{\"type\":\"array\",\"value\":\"number\",\"length\":2,\"units\":\"degrees\",\"minimum\":[0,0],\"maximum\":[360,180],\"transition\":false,\"requires\":[{\"sky-type\":\"atmosphere\"}],\"expression\":{\"interpolated\":false,\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"sky-atmosphere-sun-intensity\":{\"type\":\"number\",\"requires\":[{\"sky-type\":\"atmosphere\"}],\"default\":10,\"minimum\":0,\"maximum\":100,\"transition\":false,\"property-type\":\"data-constant\"},\"sky-gradient-center\":{\"type\":\"array\",\"requires\":[{\"sky-type\":\"gradient\"}],\"value\":\"number\",\"default\":[0,0],\"length\":2,\"units\":\"degrees\",\"minimum\":[0,0],\"maximum\":[360,180],\"transition\":false,\"expression\":{\"interpolated\":false,\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"sky-gradient-radius\":{\"type\":\"number\",\"requires\":[{\"sky-type\":\"gradient\"}],\"default\":90,\"minimum\":0,\"maximum\":180,\"transition\":false,\"expression\":{\"interpolated\":false,\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"sky-gradient\":{\"type\":\"color\",\"default\":[\"interpolate\",[\"linear\"],[\"sky-radial-progress\"],0.8,\"#87ceeb\",1,\"white\"],\"transition\":false,\"requires\":[{\"sky-type\":\"gradient\"}],\"expression\":{\"interpolated\":true,\"parameters\":[\"sky-radial-progress\"]},\"property-type\":\"color-ramp\"},\"sky-atmosphere-halo-color\":{\"type\":\"color\",\"default\":\"white\",\"transition\":false,\"requires\":[{\"sky-type\":\"atmosphere\"}],\"property-type\":\"data-constant\"},\"sky-atmosphere-color\":{\"type\":\"color\",\"default\":\"white\",\"transition\":false,\"requires\":[{\"sky-type\":\"atmosphere\"}],\"property-type\":\"data-constant\"},\"sky-opacity\":{\"type\":\"number\",\"default\":1,\"minimum\":0,\"maximum\":1,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"}},\"transition\":{\"duration\":{\"type\":\"number\",\"default\":300,\"minimum\":0,\"units\":\"milliseconds\"},\"delay\":{\"type\":\"number\",\"default\":0,\"minimum\":0,\"units\":\"milliseconds\"}},\"property-type\":{\"data-driven\":{\"type\":\"property-type\"},\"color-ramp\":{\"type\":\"property-type\"},\"data-constant\":{\"type\":\"property-type\"},\"constant\":{\"type\":\"property-type\"}},\"promoteId\":{\"*\":{\"type\":\"string\"}}}');\n    function ee(t, ...e) {\n      for (const r of e) for (const e in r) t[e] = r[e];\n      return t;\n    }\n    function re(t) {\n      return t instanceof Number || t instanceof String || t instanceof Boolean ? t.valueOf() : t;\n    }\n    function ne(t) {\n      if (Array.isArray(t)) return t.map(ne);\n      if (t instanceof Object && !(t instanceof Number || t instanceof String || t instanceof Boolean)) {\n        const e = {};\n        for (const r in t) e[r] = ne(t[r]);\n        return e;\n      }\n      return re(t);\n    }\n    class ie extends Error {\n      constructor(t, e) {\n        super(e), this.message = e, this.key = t;\n      }\n    }\n    var se = ie;\n    class ae {\n      constructor(t, e = []) {\n        this.parent = t, this.bindings = {};\n        for (const [t, r] of e) this.bindings[t] = r;\n      }\n      concat(t) {\n        return new ae(this, t);\n      }\n      get(t) {\n        if (this.bindings[t]) return this.bindings[t];\n        if (this.parent) return this.parent.get(t);\n        throw new Error(`${t} not found in scope.`);\n      }\n      has(t) {\n        return !!this.bindings[t] || !!this.parent && this.parent.has(t);\n      }\n    }\n    var oe = ae;\n    const le = {\n        kind: \"null\"\n      },\n      ue = {\n        kind: \"number\"\n      },\n      ce = {\n        kind: \"string\"\n      },\n      he = {\n        kind: \"boolean\"\n      },\n      pe = {\n        kind: \"color\"\n      },\n      de = {\n        kind: \"object\"\n      },\n      fe = {\n        kind: \"value\"\n      },\n      ye = {\n        kind: \"collator\"\n      },\n      me = {\n        kind: \"formatted\"\n      },\n      ge = {\n        kind: \"resolvedImage\"\n      };\n    function xe(t, e) {\n      return {\n        kind: \"array\",\n        itemType: t,\n        N: e\n      };\n    }\n    function ve(t) {\n      if (\"array\" === t.kind) {\n        const e = ve(t.itemType);\n        return \"number\" == typeof t.N ? `array<${e}, ${t.N}>` : \"value\" === t.itemType.kind ? \"array\" : `array<${e}>`;\n      }\n      return t.kind;\n    }\n    const be = [le, ue, ce, he, pe, me, de, xe(fe), ge];\n    function we(t, e) {\n      if (\"error\" === e.kind) return null;\n      if (\"array\" === t.kind) {\n        if (\"array\" === e.kind && (0 === e.N && \"value\" === e.itemType.kind || !we(t.itemType, e.itemType)) && (\"number\" != typeof t.N || t.N === e.N)) return null;\n      } else {\n        if (t.kind === e.kind) return null;\n        if (\"value\" === t.kind) for (const t of be) if (!we(t, e)) return null;\n      }\n      return `Expected ${ve(t)} but found ${ve(e)} instead.`;\n    }\n    function _e(t, e) {\n      return e.some(e => e.kind === t.kind);\n    }\n    function Ae(t, e) {\n      return e.some(e => \"null\" === e ? null === t : \"array\" === e ? Array.isArray(t) : \"object\" === e ? t && !Array.isArray(t) && \"object\" == typeof t : e === typeof t);\n    }\n    var Se,\n      ke = {\n        transparent: [0, 0, 0, 0],\n        aliceblue: [240, 248, 255, 1],\n        antiquewhite: [250, 235, 215, 1],\n        aqua: [0, 255, 255, 1],\n        aquamarine: [127, 255, 212, 1],\n        azure: [240, 255, 255, 1],\n        beige: [245, 245, 220, 1],\n        bisque: [255, 228, 196, 1],\n        black: [0, 0, 0, 1],\n        blanchedalmond: [255, 235, 205, 1],\n        blue: [0, 0, 255, 1],\n        blueviolet: [138, 43, 226, 1],\n        brown: [165, 42, 42, 1],\n        burlywood: [222, 184, 135, 1],\n        cadetblue: [95, 158, 160, 1],\n        chartreuse: [127, 255, 0, 1],\n        chocolate: [210, 105, 30, 1],\n        coral: [255, 127, 80, 1],\n        cornflowerblue: [100, 149, 237, 1],\n        cornsilk: [255, 248, 220, 1],\n        crimson: [220, 20, 60, 1],\n        cyan: [0, 255, 255, 1],\n        darkblue: [0, 0, 139, 1],\n        darkcyan: [0, 139, 139, 1],\n        darkgoldenrod: [184, 134, 11, 1],\n        darkgray: [169, 169, 169, 1],\n        darkgreen: [0, 100, 0, 1],\n        darkgrey: [169, 169, 169, 1],\n        darkkhaki: [189, 183, 107, 1],\n        darkmagenta: [139, 0, 139, 1],\n        darkolivegreen: [85, 107, 47, 1],\n        darkorange: [255, 140, 0, 1],\n        darkorchid: [153, 50, 204, 1],\n        darkred: [139, 0, 0, 1],\n        darksalmon: [233, 150, 122, 1],\n        darkseagreen: [143, 188, 143, 1],\n        darkslateblue: [72, 61, 139, 1],\n        darkslategray: [47, 79, 79, 1],\n        darkslategrey: [47, 79, 79, 1],\n        darkturquoise: [0, 206, 209, 1],\n        darkviolet: [148, 0, 211, 1],\n        deeppink: [255, 20, 147, 1],\n        deepskyblue: [0, 191, 255, 1],\n        dimgray: [105, 105, 105, 1],\n        dimgrey: [105, 105, 105, 1],\n        dodgerblue: [30, 144, 255, 1],\n        firebrick: [178, 34, 34, 1],\n        floralwhite: [255, 250, 240, 1],\n        forestgreen: [34, 139, 34, 1],\n        fuchsia: [255, 0, 255, 1],\n        gainsboro: [220, 220, 220, 1],\n        ghostwhite: [248, 248, 255, 1],\n        gold: [255, 215, 0, 1],\n        goldenrod: [218, 165, 32, 1],\n        gray: [128, 128, 128, 1],\n        green: [0, 128, 0, 1],\n        greenyellow: [173, 255, 47, 1],\n        grey: [128, 128, 128, 1],\n        honeydew: [240, 255, 240, 1],\n        hotpink: [255, 105, 180, 1],\n        indianred: [205, 92, 92, 1],\n        indigo: [75, 0, 130, 1],\n        ivory: [255, 255, 240, 1],\n        khaki: [240, 230, 140, 1],\n        lavender: [230, 230, 250, 1],\n        lavenderblush: [255, 240, 245, 1],\n        lawngreen: [124, 252, 0, 1],\n        lemonchiffon: [255, 250, 205, 1],\n        lightblue: [173, 216, 230, 1],\n        lightcoral: [240, 128, 128, 1],\n        lightcyan: [224, 255, 255, 1],\n        lightgoldenrodyellow: [250, 250, 210, 1],\n        lightgray: [211, 211, 211, 1],\n        lightgreen: [144, 238, 144, 1],\n        lightgrey: [211, 211, 211, 1],\n        lightpink: [255, 182, 193, 1],\n        lightsalmon: [255, 160, 122, 1],\n        lightseagreen: [32, 178, 170, 1],\n        lightskyblue: [135, 206, 250, 1],\n        lightslategray: [119, 136, 153, 1],\n        lightslategrey: [119, 136, 153, 1],\n        lightsteelblue: [176, 196, 222, 1],\n        lightyellow: [255, 255, 224, 1],\n        lime: [0, 255, 0, 1],\n        limegreen: [50, 205, 50, 1],\n        linen: [250, 240, 230, 1],\n        magenta: [255, 0, 255, 1],\n        maroon: [128, 0, 0, 1],\n        mediumaquamarine: [102, 205, 170, 1],\n        mediumblue: [0, 0, 205, 1],\n        mediumorchid: [186, 85, 211, 1],\n        mediumpurple: [147, 112, 219, 1],\n        mediumseagreen: [60, 179, 113, 1],\n        mediumslateblue: [123, 104, 238, 1],\n        mediumspringgreen: [0, 250, 154, 1],\n        mediumturquoise: [72, 209, 204, 1],\n        mediumvioletred: [199, 21, 133, 1],\n        midnightblue: [25, 25, 112, 1],\n        mintcream: [245, 255, 250, 1],\n        mistyrose: [255, 228, 225, 1],\n        moccasin: [255, 228, 181, 1],\n        navajowhite: [255, 222, 173, 1],\n        navy: [0, 0, 128, 1],\n        oldlace: [253, 245, 230, 1],\n        olive: [128, 128, 0, 1],\n        olivedrab: [107, 142, 35, 1],\n        orange: [255, 165, 0, 1],\n        orangered: [255, 69, 0, 1],\n        orchid: [218, 112, 214, 1],\n        palegoldenrod: [238, 232, 170, 1],\n        palegreen: [152, 251, 152, 1],\n        paleturquoise: [175, 238, 238, 1],\n        palevioletred: [219, 112, 147, 1],\n        papayawhip: [255, 239, 213, 1],\n        peachpuff: [255, 218, 185, 1],\n        peru: [205, 133, 63, 1],\n        pink: [255, 192, 203, 1],\n        plum: [221, 160, 221, 1],\n        powderblue: [176, 224, 230, 1],\n        purple: [128, 0, 128, 1],\n        rebeccapurple: [102, 51, 153, 1],\n        red: [255, 0, 0, 1],\n        rosybrown: [188, 143, 143, 1],\n        royalblue: [65, 105, 225, 1],\n        saddlebrown: [139, 69, 19, 1],\n        salmon: [250, 128, 114, 1],\n        sandybrown: [244, 164, 96, 1],\n        seagreen: [46, 139, 87, 1],\n        seashell: [255, 245, 238, 1],\n        sienna: [160, 82, 45, 1],\n        silver: [192, 192, 192, 1],\n        skyblue: [135, 206, 235, 1],\n        slateblue: [106, 90, 205, 1],\n        slategray: [112, 128, 144, 1],\n        slategrey: [112, 128, 144, 1],\n        snow: [255, 250, 250, 1],\n        springgreen: [0, 255, 127, 1],\n        steelblue: [70, 130, 180, 1],\n        tan: [210, 180, 140, 1],\n        teal: [0, 128, 128, 1],\n        thistle: [216, 191, 216, 1],\n        tomato: [255, 99, 71, 1],\n        turquoise: [64, 224, 208, 1],\n        violet: [238, 130, 238, 1],\n        wheat: [245, 222, 179, 1],\n        white: [255, 255, 255, 1],\n        whitesmoke: [245, 245, 245, 1],\n        yellow: [255, 255, 0, 1],\n        yellowgreen: [154, 205, 50, 1]\n      };\n    function Ie(t) {\n      return (t = Math.round(t)) < 0 ? 0 : t > 255 ? 255 : t;\n    }\n    function Me(t) {\n      return Ie(\"%\" === t[t.length - 1] ? parseFloat(t) / 100 * 255 : parseInt(t));\n    }\n    function Te(t) {\n      return (e = \"%\" === t[t.length - 1] ? parseFloat(t) / 100 : parseFloat(t)) < 0 ? 0 : e > 1 ? 1 : e;\n      var e;\n    }\n    function ze(t, e, r) {\n      return r < 0 ? r += 1 : r > 1 && (r -= 1), 6 * r < 1 ? t + (e - t) * r * 6 : 2 * r < 1 ? e : 3 * r < 2 ? t + (e - t) * (2 / 3 - r) * 6 : t;\n    }\n    try {\n      Se = {}.parseCSSColor = function (t) {\n        var e,\n          r = t.replace(/ /g, \"\").toLowerCase();\n        if (r in ke) return ke[r].slice();\n        if (\"#\" === r[0]) return 4 === r.length ? (e = parseInt(r.substr(1), 16)) >= 0 && e <= 4095 ? [(3840 & e) >> 4 | (3840 & e) >> 8, 240 & e | (240 & e) >> 4, 15 & e | (15 & e) << 4, 1] : null : 7 === r.length && (e = parseInt(r.substr(1), 16)) >= 0 && e <= 16777215 ? [(16711680 & e) >> 16, (65280 & e) >> 8, 255 & e, 1] : null;\n        var n = r.indexOf(\"(\"),\n          i = r.indexOf(\")\");\n        if (-1 !== n && i + 1 === r.length) {\n          var s = r.substr(0, n),\n            a = r.substr(n + 1, i - (n + 1)).split(\",\"),\n            o = 1;\n          switch (s) {\n            case \"rgba\":\n              if (4 !== a.length) return null;\n              o = Te(a.pop());\n            case \"rgb\":\n              return 3 !== a.length ? null : [Me(a[0]), Me(a[1]), Me(a[2]), o];\n            case \"hsla\":\n              if (4 !== a.length) return null;\n              o = Te(a.pop());\n            case \"hsl\":\n              if (3 !== a.length) return null;\n              var l = (parseFloat(a[0]) % 360 + 360) % 360 / 360,\n                u = Te(a[1]),\n                c = Te(a[2]),\n                h = c <= .5 ? c * (u + 1) : c + u - c * u,\n                p = 2 * c - h;\n              return [Ie(255 * ze(p, h, l + 1 / 3)), Ie(255 * ze(p, h, l)), Ie(255 * ze(p, h, l - 1 / 3)), o];\n            default:\n              return null;\n          }\n        }\n        return null;\n      };\n    } catch (t) {}\n    class Be {\n      constructor(t, e, r, n = 1) {\n        this.r = t, this.g = e, this.b = r, this.a = n;\n      }\n      static parse(t) {\n        if (!t) return;\n        if (t instanceof Be) return t;\n        if (\"string\" != typeof t) return;\n        const e = Se(t);\n        return e ? new Be(e[0] / 255 * e[3], e[1] / 255 * e[3], e[2] / 255 * e[3], e[3]) : void 0;\n      }\n      toString() {\n        const [t, e, r, n] = this.toArray();\n        return `rgba(${Math.round(t)},${Math.round(e)},${Math.round(r)},${n})`;\n      }\n      toArray() {\n        const {\n          r: t,\n          g: e,\n          b: r,\n          a: n\n        } = this;\n        return 0 === n ? [0, 0, 0, 0] : [255 * t / n, 255 * e / n, 255 * r / n, n];\n      }\n      toArray01() {\n        const {\n          r: t,\n          g: e,\n          b: r,\n          a: n\n        } = this;\n        return 0 === n ? [0, 0, 0, 0] : [t / n, e / n, r / n, n];\n      }\n      toArray01PremultipliedAlpha() {\n        const {\n          r: t,\n          g: e,\n          b: r,\n          a: n\n        } = this;\n        return [t, e, r, n];\n      }\n    }\n    Be.black = new Be(0, 0, 0, 1), Be.white = new Be(1, 1, 1, 1), Be.transparent = new Be(0, 0, 0, 0), Be.red = new Be(1, 0, 0, 1), Be.blue = new Be(0, 0, 1, 1);\n    var Ee = Be;\n    class Ce {\n      constructor(t, e, r) {\n        this.sensitivity = t ? e ? \"variant\" : \"case\" : e ? \"accent\" : \"base\", this.locale = r, this.collator = new Intl.Collator(this.locale ? this.locale : [], {\n          sensitivity: this.sensitivity,\n          usage: \"search\"\n        });\n      }\n      compare(t, e) {\n        return this.collator.compare(t, e);\n      }\n      resolvedLocale() {\n        return new Intl.Collator(this.locale ? this.locale : []).resolvedOptions().locale;\n      }\n    }\n    class Pe {\n      constructor(t, e, r, n, i) {\n        this.text = t.normalize ? t.normalize() : t, this.image = e, this.scale = r, this.fontStack = n, this.textColor = i;\n      }\n    }\n    class De {\n      constructor(t) {\n        this.sections = t;\n      }\n      static fromString(t) {\n        return new De([new Pe(t, null, null, null, null)]);\n      }\n      isEmpty() {\n        return 0 === this.sections.length || !this.sections.some(t => 0 !== t.text.length || t.image && 0 !== t.image.name.length);\n      }\n      static factory(t) {\n        return t instanceof De ? t : De.fromString(t);\n      }\n      toString() {\n        return 0 === this.sections.length ? \"\" : this.sections.map(t => t.text).join(\"\");\n      }\n      serialize() {\n        const t = [\"format\"];\n        for (const e of this.sections) {\n          if (e.image) {\n            t.push([\"image\", e.image.name]);\n            continue;\n          }\n          t.push(e.text);\n          const r = {};\n          e.fontStack && (r[\"text-font\"] = [\"literal\", e.fontStack.split(\",\")]), e.scale && (r[\"font-scale\"] = e.scale), e.textColor && (r[\"text-color\"] = [\"rgba\"].concat(e.textColor.toArray())), t.push(r);\n        }\n        return t;\n      }\n    }\n    class Ve {\n      constructor(t) {\n        this.name = t.name, this.available = t.available;\n      }\n      toString() {\n        return this.name;\n      }\n      static fromString(t) {\n        return t ? new Ve({\n          name: t,\n          available: !1\n        }) : null;\n      }\n      serialize() {\n        return [\"image\", this.name];\n      }\n    }\n    function Le(t, e, r, n) {\n      return \"number\" == typeof t && t >= 0 && t <= 255 && \"number\" == typeof e && e >= 0 && e <= 255 && \"number\" == typeof r && r >= 0 && r <= 255 ? void 0 === n || \"number\" == typeof n && n >= 0 && n <= 1 ? null : `Invalid rgba value [${[t, e, r, n].join(\", \")}]: 'a' must be between 0 and 1.` : `Invalid rgba value [${(\"number\" == typeof n ? [t, e, r, n] : [t, e, r]).join(\", \")}]: 'r', 'g', and 'b' must be between 0 and 255.`;\n    }\n    function Fe(t) {\n      if (null === t) return !0;\n      if (\"string\" == typeof t) return !0;\n      if (\"boolean\" == typeof t) return !0;\n      if (\"number\" == typeof t) return !0;\n      if (t instanceof Ee) return !0;\n      if (t instanceof Ce) return !0;\n      if (t instanceof De) return !0;\n      if (t instanceof Ve) return !0;\n      if (Array.isArray(t)) {\n        for (const e of t) if (!Fe(e)) return !1;\n        return !0;\n      }\n      if (\"object\" == typeof t) {\n        for (const e in t) if (!Fe(t[e])) return !1;\n        return !0;\n      }\n      return !1;\n    }\n    function Re(t) {\n      if (null === t) return le;\n      if (\"string\" == typeof t) return ce;\n      if (\"boolean\" == typeof t) return he;\n      if (\"number\" == typeof t) return ue;\n      if (t instanceof Ee) return pe;\n      if (t instanceof Ce) return ye;\n      if (t instanceof De) return me;\n      if (t instanceof Ve) return ge;\n      if (Array.isArray(t)) {\n        const e = t.length;\n        let r;\n        for (const e of t) {\n          const t = Re(e);\n          if (r) {\n            if (r === t) continue;\n            r = fe;\n            break;\n          }\n          r = t;\n        }\n        return xe(r || fe, e);\n      }\n      return de;\n    }\n    function Ue(t) {\n      const e = typeof t;\n      return null === t ? \"\" : \"string\" === e || \"number\" === e || \"boolean\" === e ? String(t) : t instanceof Ee || t instanceof De || t instanceof Ve ? t.toString() : JSON.stringify(t);\n    }\n    class $e {\n      constructor(t, e) {\n        this.type = t, this.value = e;\n      }\n      static parse(t, e) {\n        if (2 !== t.length) return e.error(`'literal' expression requires exactly one argument, but found ${t.length - 1} instead.`);\n        if (!Fe(t[1])) return e.error(\"invalid value\");\n        const r = t[1];\n        let n = Re(r);\n        const i = e.expectedType;\n        return \"array\" !== n.kind || 0 !== n.N || !i || \"array\" !== i.kind || \"number\" == typeof i.N && 0 !== i.N || (n = i), new $e(n, r);\n      }\n      evaluate() {\n        return this.value;\n      }\n      eachChild() {}\n      outputDefined() {\n        return !0;\n      }\n      serialize() {\n        return \"array\" === this.type.kind || \"object\" === this.type.kind ? [\"literal\", this.value] : this.value instanceof Ee ? [\"rgba\"].concat(this.value.toArray()) : this.value instanceof De ? this.value.serialize() : this.value;\n      }\n    }\n    var je = $e,\n      Oe = class {\n        constructor(t) {\n          this.name = \"ExpressionEvaluationError\", this.message = t;\n        }\n        toJSON() {\n          return this.message;\n        }\n      };\n    const qe = {\n      string: ce,\n      number: ue,\n      boolean: he,\n      object: de\n    };\n    class Ne {\n      constructor(t, e) {\n        this.type = t, this.args = e;\n      }\n      static parse(t, e) {\n        if (t.length < 2) return e.error(\"Expected at least one argument.\");\n        let r,\n          n = 1;\n        const i = t[0];\n        if (\"array\" === i) {\n          let i, s;\n          if (t.length > 2) {\n            const r = t[1];\n            if (\"string\" != typeof r || !(r in qe) || \"object\" === r) return e.error('The item type argument of \"array\" must be one of string, number, boolean', 1);\n            i = qe[r], n++;\n          } else i = fe;\n          if (t.length > 3) {\n            if (null !== t[2] && (\"number\" != typeof t[2] || t[2] < 0 || t[2] !== Math.floor(t[2]))) return e.error('The length argument to \"array\" must be a positive integer literal', 2);\n            s = t[2], n++;\n          }\n          r = xe(i, s);\n        } else r = qe[i];\n        const s = [];\n        for (; n < t.length; n++) {\n          const r = e.parse(t[n], n, fe);\n          if (!r) return null;\n          s.push(r);\n        }\n        return new Ne(r, s);\n      }\n      evaluate(t) {\n        for (let e = 0; e < this.args.length; e++) {\n          const r = this.args[e].evaluate(t);\n          if (!we(this.type, Re(r))) return r;\n          if (e === this.args.length - 1) throw new Oe(`Expected value to be of type ${ve(this.type)}, but found ${ve(Re(r))} instead.`);\n        }\n        return null;\n      }\n      eachChild(t) {\n        this.args.forEach(t);\n      }\n      outputDefined() {\n        return this.args.every(t => t.outputDefined());\n      }\n      serialize() {\n        const t = this.type,\n          e = [t.kind];\n        if (\"array\" === t.kind) {\n          const r = t.itemType;\n          if (\"string\" === r.kind || \"number\" === r.kind || \"boolean\" === r.kind) {\n            e.push(r.kind);\n            const n = t.N;\n            (\"number\" == typeof n || this.args.length > 1) && e.push(n);\n          }\n        }\n        return e.concat(this.args.map(t => t.serialize()));\n      }\n    }\n    var Ge = Ne;\n    class Ze {\n      constructor(t) {\n        this.type = me, this.sections = t;\n      }\n      static parse(t, e) {\n        if (t.length < 2) return e.error(\"Expected at least one argument.\");\n        const r = t[1];\n        if (!Array.isArray(r) && \"object\" == typeof r) return e.error(\"First argument must be an image or text section.\");\n        const n = [];\n        let i = !1;\n        for (let r = 1; r <= t.length - 1; ++r) {\n          const s = t[r];\n          if (i && \"object\" == typeof s && !Array.isArray(s)) {\n            i = !1;\n            let t = null;\n            if (s[\"font-scale\"] && (t = e.parse(s[\"font-scale\"], 1, ue), !t)) return null;\n            let r = null;\n            if (s[\"text-font\"] && (r = e.parse(s[\"text-font\"], 1, xe(ce)), !r)) return null;\n            let a = null;\n            if (s[\"text-color\"] && (a = e.parse(s[\"text-color\"], 1, pe), !a)) return null;\n            const o = n[n.length - 1];\n            o.scale = t, o.font = r, o.textColor = a;\n          } else {\n            const s = e.parse(t[r], 1, fe);\n            if (!s) return null;\n            const a = s.type.kind;\n            if (\"string\" !== a && \"value\" !== a && \"null\" !== a && \"resolvedImage\" !== a) return e.error(\"Formatted text type must be 'string', 'value', 'image' or 'null'.\");\n            i = !0, n.push({\n              content: s,\n              scale: null,\n              font: null,\n              textColor: null\n            });\n          }\n        }\n        return new Ze(n);\n      }\n      evaluate(t) {\n        return new De(this.sections.map(e => {\n          const r = e.content.evaluate(t);\n          return Re(r) === ge ? new Pe(\"\", r, null, null, null) : new Pe(Ue(r), null, e.scale ? e.scale.evaluate(t) : null, e.font ? e.font.evaluate(t).join(\",\") : null, e.textColor ? e.textColor.evaluate(t) : null);\n        }));\n      }\n      eachChild(t) {\n        for (const e of this.sections) t(e.content), e.scale && t(e.scale), e.font && t(e.font), e.textColor && t(e.textColor);\n      }\n      outputDefined() {\n        return !1;\n      }\n      serialize() {\n        const t = [\"format\"];\n        for (const e of this.sections) {\n          t.push(e.content.serialize());\n          const r = {};\n          e.scale && (r[\"font-scale\"] = e.scale.serialize()), e.font && (r[\"text-font\"] = e.font.serialize()), e.textColor && (r[\"text-color\"] = e.textColor.serialize()), t.push(r);\n        }\n        return t;\n      }\n    }\n    class Ke {\n      constructor(t) {\n        this.type = ge, this.input = t;\n      }\n      static parse(t, e) {\n        if (2 !== t.length) return e.error(\"Expected two arguments.\");\n        const r = e.parse(t[1], 1, ce);\n        return r ? new Ke(r) : e.error(\"No image name provided.\");\n      }\n      evaluate(t) {\n        const e = this.input.evaluate(t),\n          r = Ve.fromString(e);\n        return r && t.availableImages && (r.available = t.availableImages.indexOf(e) > -1), r;\n      }\n      eachChild(t) {\n        t(this.input);\n      }\n      outputDefined() {\n        return !1;\n      }\n      serialize() {\n        return [\"image\", this.input.serialize()];\n      }\n    }\n    const Xe = {\n      \"to-boolean\": he,\n      \"to-color\": pe,\n      \"to-number\": ue,\n      \"to-string\": ce\n    };\n    class Je {\n      constructor(t, e) {\n        this.type = t, this.args = e;\n      }\n      static parse(t, e) {\n        if (t.length < 2) return e.error(\"Expected at least one argument.\");\n        const r = t[0];\n        if ((\"to-boolean\" === r || \"to-string\" === r) && 2 !== t.length) return e.error(\"Expected one argument.\");\n        const n = Xe[r],\n          i = [];\n        for (let r = 1; r < t.length; r++) {\n          const n = e.parse(t[r], r, fe);\n          if (!n) return null;\n          i.push(n);\n        }\n        return new Je(n, i);\n      }\n      evaluate(t) {\n        if (\"boolean\" === this.type.kind) return Boolean(this.args[0].evaluate(t));\n        if (\"color\" === this.type.kind) {\n          let e, r;\n          for (const n of this.args) {\n            if (e = n.evaluate(t), r = null, e instanceof Ee) return e;\n            if (\"string\" == typeof e) {\n              const r = t.parseColor(e);\n              if (r) return r;\n            } else if (Array.isArray(e) && (r = e.length < 3 || e.length > 4 ? `Invalid rbga value ${JSON.stringify(e)}: expected an array containing either three or four numeric values.` : Le(e[0], e[1], e[2], e[3]), !r)) return new Ee(e[0] / 255, e[1] / 255, e[2] / 255, e[3]);\n          }\n          throw new Oe(r || `Could not parse color from value '${\"string\" == typeof e ? e : String(JSON.stringify(e))}'`);\n        }\n        if (\"number\" === this.type.kind) {\n          let e = null;\n          for (const r of this.args) {\n            if (e = r.evaluate(t), null === e) return 0;\n            const n = Number(e);\n            if (!isNaN(n)) return n;\n          }\n          throw new Oe(`Could not convert ${JSON.stringify(e)} to number.`);\n        }\n        return \"formatted\" === this.type.kind ? De.fromString(Ue(this.args[0].evaluate(t))) : \"resolvedImage\" === this.type.kind ? Ve.fromString(Ue(this.args[0].evaluate(t))) : Ue(this.args[0].evaluate(t));\n      }\n      eachChild(t) {\n        this.args.forEach(t);\n      }\n      outputDefined() {\n        return this.args.every(t => t.outputDefined());\n      }\n      serialize() {\n        if (\"formatted\" === this.type.kind) return new Ze([{\n          content: this.args[0],\n          scale: null,\n          font: null,\n          textColor: null\n        }]).serialize();\n        if (\"resolvedImage\" === this.type.kind) return new Ke(this.args[0]).serialize();\n        const t = [`to-${this.type.kind}`];\n        return this.eachChild(e => {\n          t.push(e.serialize());\n        }), t;\n      }\n    }\n    var He = Je;\n    const Ye = [\"Unknown\", \"Point\", \"LineString\", \"Polygon\"];\n    var We = class {\n      constructor() {\n        this.globals = null, this.feature = null, this.featureState = null, this.formattedSection = null, this._parseColorCache = {}, this.availableImages = null, this.canonical = null, this.featureTileCoord = null, this.featureDistanceData = null;\n      }\n      id() {\n        return this.feature && void 0 !== this.feature.id ? this.feature.id : null;\n      }\n      geometryType() {\n        return this.feature ? \"number\" == typeof this.feature.type ? Ye[this.feature.type] : this.feature.type : null;\n      }\n      geometry() {\n        return this.feature && \"geometry\" in this.feature ? this.feature.geometry : null;\n      }\n      canonicalID() {\n        return this.canonical;\n      }\n      properties() {\n        return this.feature && this.feature.properties || {};\n      }\n      distanceFromCenter() {\n        if (this.featureTileCoord && this.featureDistanceData) {\n          const t = this.featureDistanceData.center,\n            e = this.featureDistanceData.scale,\n            {\n              x: r,\n              y: n\n            } = this.featureTileCoord;\n          return this.featureDistanceData.bearing[0] * (r * e - t[0]) + this.featureDistanceData.bearing[1] * (n * e - t[1]);\n        }\n        return 0;\n      }\n      parseColor(t) {\n        let e = this._parseColorCache[t];\n        return e || (e = this._parseColorCache[t] = Ee.parse(t)), e;\n      }\n    };\n    class Qe {\n      constructor(t, e, r, n) {\n        this.name = t, this.type = e, this._evaluate = r, this.args = n;\n      }\n      evaluate(t) {\n        return this._evaluate(t, this.args);\n      }\n      eachChild(t) {\n        this.args.forEach(t);\n      }\n      outputDefined() {\n        return !1;\n      }\n      serialize() {\n        return [this.name].concat(this.args.map(t => t.serialize()));\n      }\n      static parse(t, e) {\n        const r = t[0],\n          n = Qe.definitions[r];\n        if (!n) return e.error(`Unknown expression \"${r}\". If you wanted a literal array, use [\"literal\", [...]].`, 0);\n        const i = Array.isArray(n) ? n[0] : n.type,\n          s = Array.isArray(n) ? [[n[1], n[2]]] : n.overloads,\n          a = s.filter(([e]) => !Array.isArray(e) || e.length === t.length - 1);\n        let o = null;\n        for (const [n, s] of a) {\n          o = new Ir(e.registry, e.path, null, e.scope);\n          const a = [];\n          let l = !1;\n          for (let e = 1; e < t.length; e++) {\n            const r = t[e],\n              i = Array.isArray(n) ? n[e - 1] : n.type,\n              s = o.parse(r, 1 + a.length, i);\n            if (!s) {\n              l = !0;\n              break;\n            }\n            a.push(s);\n          }\n          if (!l) if (Array.isArray(n) && n.length !== a.length) o.error(`Expected ${n.length} arguments, but found ${a.length} instead.`);else {\n            for (let t = 0; t < a.length; t++) {\n              const e = Array.isArray(n) ? n[t] : n.type,\n                r = a[t];\n              o.concat(t + 1).checkSubtype(e, r.type);\n            }\n            if (0 === o.errors.length) return new Qe(r, i, s, a);\n          }\n        }\n        if (1 === a.length) e.errors.push(...o.errors);else {\n          const r = (a.length ? a : s).map(([t]) => {\n              return e = t, Array.isArray(e) ? `(${e.map(ve).join(\", \")})` : `(${ve(e.type)}...)`;\n              var e;\n            }).join(\" | \"),\n            n = [];\n          for (let r = 1; r < t.length; r++) {\n            const i = e.parse(t[r], 1 + n.length);\n            if (!i) return null;\n            n.push(ve(i.type));\n          }\n          e.error(`Expected arguments of type ${r}, but found (${n.join(\", \")}) instead.`);\n        }\n        return null;\n      }\n      static register(t, e) {\n        Qe.definitions = e;\n        for (const r in e) t[r] = Qe;\n      }\n    }\n    var tr = Qe;\n    class er {\n      constructor(t, e, r) {\n        this.type = ye, this.locale = r, this.caseSensitive = t, this.diacriticSensitive = e;\n      }\n      static parse(t, e) {\n        if (2 !== t.length) return e.error(\"Expected one argument.\");\n        const r = t[1];\n        if (\"object\" != typeof r || Array.isArray(r)) return e.error(\"Collator options argument must be an object.\");\n        const n = e.parse(void 0 !== r[\"case-sensitive\"] && r[\"case-sensitive\"], 1, he);\n        if (!n) return null;\n        const i = e.parse(void 0 !== r[\"diacritic-sensitive\"] && r[\"diacritic-sensitive\"], 1, he);\n        if (!i) return null;\n        let s = null;\n        return r.locale && (s = e.parse(r.locale, 1, ce), !s) ? null : new er(n, i, s);\n      }\n      evaluate(t) {\n        return new Ce(this.caseSensitive.evaluate(t), this.diacriticSensitive.evaluate(t), this.locale ? this.locale.evaluate(t) : null);\n      }\n      eachChild(t) {\n        t(this.caseSensitive), t(this.diacriticSensitive), this.locale && t(this.locale);\n      }\n      outputDefined() {\n        return !1;\n      }\n      serialize() {\n        const t = {};\n        return t[\"case-sensitive\"] = this.caseSensitive.serialize(), t[\"diacritic-sensitive\"] = this.diacriticSensitive.serialize(), this.locale && (t.locale = this.locale.serialize()), [\"collator\", t];\n      }\n    }\n    const rr = 8192;\n    function nr(t, e) {\n      t[0] = Math.min(t[0], e[0]), t[1] = Math.min(t[1], e[1]), t[2] = Math.max(t[2], e[0]), t[3] = Math.max(t[3], e[1]);\n    }\n    function ir(t, e) {\n      return !(t[0] <= e[0] || t[2] >= e[2] || t[1] <= e[1] || t[3] >= e[3]);\n    }\n    function sr(t, e) {\n      const r = (180 + t[0]) / 360,\n        n = (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + t[1] * Math.PI / 360))) / 360,\n        i = Math.pow(2, e.z);\n      return [Math.round(r * i * rr), Math.round(n * i * rr)];\n    }\n    function ar(t, e, r) {\n      const n = t[0] - e[0],\n        i = t[1] - e[1],\n        s = t[0] - r[0],\n        a = t[1] - r[1];\n      return n * a - s * i == 0 && n * s <= 0 && i * a <= 0;\n    }\n    function or(t, e) {\n      let r = !1;\n      for (let a = 0, o = e.length; a < o; a++) {\n        const o = e[a];\n        for (let e = 0, a = o.length; e < a - 1; e++) {\n          if (ar(t, o[e], o[e + 1])) return !1;\n          (i = o[e])[1] > (n = t)[1] != (s = o[e + 1])[1] > n[1] && n[0] < (s[0] - i[0]) * (n[1] - i[1]) / (s[1] - i[1]) + i[0] && (r = !r);\n        }\n      }\n      var n, i, s;\n      return r;\n    }\n    function lr(t, e) {\n      for (let r = 0; r < e.length; r++) if (or(t, e[r])) return !0;\n      return !1;\n    }\n    function ur(t, e, r, n) {\n      const i = n[0] - r[0],\n        s = n[1] - r[1],\n        a = (t[0] - r[0]) * s - i * (t[1] - r[1]),\n        o = (e[0] - r[0]) * s - i * (e[1] - r[1]);\n      return a > 0 && o < 0 || a < 0 && o > 0;\n    }\n    function cr(t, e, r) {\n      for (const u of r) for (let r = 0; r < u.length - 1; ++r) if (0 != (o = [(a = u[r + 1])[0] - (s = u[r])[0], a[1] - s[1]])[0] * (l = [(i = e)[0] - (n = t)[0], i[1] - n[1]])[1] - o[1] * l[0] && ur(n, i, s, a) && ur(s, a, n, i)) return !0;\n      var n, i, s, a, o, l;\n      return !1;\n    }\n    function hr(t, e) {\n      for (let r = 0; r < t.length; ++r) if (!or(t[r], e)) return !1;\n      for (let r = 0; r < t.length - 1; ++r) if (cr(t[r], t[r + 1], e)) return !1;\n      return !0;\n    }\n    function pr(t, e) {\n      for (let r = 0; r < e.length; r++) if (hr(t, e[r])) return !0;\n      return !1;\n    }\n    function dr(t, e, r) {\n      const n = [];\n      for (let i = 0; i < t.length; i++) {\n        const s = [];\n        for (let n = 0; n < t[i].length; n++) {\n          const a = sr(t[i][n], r);\n          nr(e, a), s.push(a);\n        }\n        n.push(s);\n      }\n      return n;\n    }\n    function fr(t, e, r) {\n      const n = [];\n      for (let i = 0; i < t.length; i++) {\n        const s = dr(t[i], e, r);\n        n.push(s);\n      }\n      return n;\n    }\n    function yr(t, e, r, n) {\n      if (t[0] < r[0] || t[0] > r[2]) {\n        const e = .5 * n;\n        let i = t[0] - r[0] > e ? -n : r[0] - t[0] > e ? n : 0;\n        0 === i && (i = t[0] - r[2] > e ? -n : r[2] - t[0] > e ? n : 0), t[0] += i;\n      }\n      nr(e, t);\n    }\n    function mr(t, e, r, n) {\n      const i = Math.pow(2, n.z) * rr,\n        s = [n.x * rr, n.y * rr],\n        a = [];\n      if (!t) return a;\n      for (const n of t) for (const t of n) {\n        const n = [t.x + s[0], t.y + s[1]];\n        yr(n, e, r, i), a.push(n);\n      }\n      return a;\n    }\n    function gr(t, e, r, n) {\n      const i = Math.pow(2, n.z) * rr,\n        s = [n.x * rr, n.y * rr],\n        a = [];\n      if (!t) return a;\n      for (const r of t) {\n        const t = [];\n        for (const n of r) {\n          const r = [n.x + s[0], n.y + s[1]];\n          nr(e, r), t.push(r);\n        }\n        a.push(t);\n      }\n      if (e[2] - e[0] <= i / 2) {\n        (o = e)[0] = o[1] = 1 / 0, o[2] = o[3] = -1 / 0;\n        for (const t of a) for (const n of t) yr(n, e, r, i);\n      }\n      var o;\n      return a;\n    }\n    class xr {\n      constructor(t, e) {\n        this.type = he, this.geojson = t, this.geometries = e;\n      }\n      static parse(t, e) {\n        if (2 !== t.length) return e.error(`'within' expression requires exactly one argument, but found ${t.length - 1} instead.`);\n        if (Fe(t[1])) {\n          const e = t[1];\n          if (\"FeatureCollection\" === e.type) for (let t = 0; t < e.features.length; ++t) {\n            const r = e.features[t].geometry.type;\n            if (\"Polygon\" === r || \"MultiPolygon\" === r) return new xr(e, e.features[t].geometry);\n          } else if (\"Feature\" === e.type) {\n            const t = e.geometry.type;\n            if (\"Polygon\" === t || \"MultiPolygon\" === t) return new xr(e, e.geometry);\n          } else if (\"Polygon\" === e.type || \"MultiPolygon\" === e.type) return new xr(e, e);\n        }\n        return e.error(\"'within' expression requires valid geojson object that contains polygon geometry type.\");\n      }\n      evaluate(t) {\n        if (null != t.geometry() && null != t.canonicalID()) {\n          if (\"Point\" === t.geometryType()) return function (t, e) {\n            const r = [1 / 0, 1 / 0, -1 / 0, -1 / 0],\n              n = [1 / 0, 1 / 0, -1 / 0, -1 / 0],\n              i = t.canonicalID();\n            if (!i) return !1;\n            if (\"Polygon\" === e.type) {\n              const s = dr(e.coordinates, n, i),\n                a = mr(t.geometry(), r, n, i);\n              if (!ir(r, n)) return !1;\n              for (const t of a) if (!or(t, s)) return !1;\n            }\n            if (\"MultiPolygon\" === e.type) {\n              const s = fr(e.coordinates, n, i),\n                a = mr(t.geometry(), r, n, i);\n              if (!ir(r, n)) return !1;\n              for (const t of a) if (!lr(t, s)) return !1;\n            }\n            return !0;\n          }(t, this.geometries);\n          if (\"LineString\" === t.geometryType()) return function (t, e) {\n            const r = [1 / 0, 1 / 0, -1 / 0, -1 / 0],\n              n = [1 / 0, 1 / 0, -1 / 0, -1 / 0],\n              i = t.canonicalID();\n            if (!i) return !1;\n            if (\"Polygon\" === e.type) {\n              const s = dr(e.coordinates, n, i),\n                a = gr(t.geometry(), r, n, i);\n              if (!ir(r, n)) return !1;\n              for (const t of a) if (!hr(t, s)) return !1;\n            }\n            if (\"MultiPolygon\" === e.type) {\n              const s = fr(e.coordinates, n, i),\n                a = gr(t.geometry(), r, n, i);\n              if (!ir(r, n)) return !1;\n              for (const t of a) if (!pr(t, s)) return !1;\n            }\n            return !0;\n          }(t, this.geometries);\n        }\n        return !1;\n      }\n      eachChild() {}\n      outputDefined() {\n        return !0;\n      }\n      serialize() {\n        return [\"within\", this.geojson];\n      }\n    }\n    var vr = xr;\n    function br(t) {\n      if (t instanceof tr) {\n        if (\"get\" === t.name && 1 === t.args.length) return !1;\n        if (\"feature-state\" === t.name) return !1;\n        if (\"has\" === t.name && 1 === t.args.length) return !1;\n        if (\"properties\" === t.name || \"geometry-type\" === t.name || \"id\" === t.name) return !1;\n        if (/^filter-/.test(t.name)) return !1;\n      }\n      if (t instanceof vr) return !1;\n      let e = !0;\n      return t.eachChild(t => {\n        e && !br(t) && (e = !1);\n      }), e;\n    }\n    function wr(t) {\n      if (t instanceof tr && \"feature-state\" === t.name) return !1;\n      let e = !0;\n      return t.eachChild(t => {\n        e && !wr(t) && (e = !1);\n      }), e;\n    }\n    function _r(t, e) {\n      if (t instanceof tr && e.indexOf(t.name) >= 0) return !1;\n      let r = !0;\n      return t.eachChild(t => {\n        r && !_r(t, e) && (r = !1);\n      }), r;\n    }\n    class Ar {\n      constructor(t, e) {\n        this.type = e.type, this.name = t, this.boundExpression = e;\n      }\n      static parse(t, e) {\n        if (2 !== t.length || \"string\" != typeof t[1]) return e.error(\"'var' expression requires exactly one string literal argument.\");\n        const r = t[1];\n        return e.scope.has(r) ? new Ar(r, e.scope.get(r)) : e.error(`Unknown variable \"${r}\". Make sure \"${r}\" has been bound in an enclosing \"let\" expression before using it.`, 1);\n      }\n      evaluate(t) {\n        return this.boundExpression.evaluate(t);\n      }\n      eachChild() {}\n      outputDefined() {\n        return !1;\n      }\n      serialize() {\n        return [\"var\", this.name];\n      }\n    }\n    var Sr = Ar;\n    class kr {\n      constructor(t, e = [], r, n = new oe(), i = []) {\n        this.registry = t, this.path = e, this.key = e.map(t => `[${t}]`).join(\"\"), this.scope = n, this.errors = i, this.expectedType = r;\n      }\n      parse(t, e, r, n, i = {}) {\n        return e ? this.concat(e, r, n)._parse(t, i) : this._parse(t, i);\n      }\n      _parse(t, e) {\n        function r(t, e, r) {\n          return \"assert\" === r ? new Ge(e, [t]) : \"coerce\" === r ? new He(e, [t]) : t;\n        }\n        if (null !== t && \"string\" != typeof t && \"boolean\" != typeof t && \"number\" != typeof t || (t = [\"literal\", t]), Array.isArray(t)) {\n          if (0 === t.length) return this.error('Expected an array with at least one element. If you wanted a literal array, use [\"literal\", []].');\n          const n = t[0];\n          if (\"string\" != typeof n) return this.error(`Expression name must be a string, but found ${typeof n} instead. If you wanted a literal array, use [\"literal\", [...]].`, 0), null;\n          const i = this.registry[n];\n          if (i) {\n            let n = i.parse(t, this);\n            if (!n) return null;\n            if (this.expectedType) {\n              const t = this.expectedType,\n                i = n.type;\n              if (\"string\" !== t.kind && \"number\" !== t.kind && \"boolean\" !== t.kind && \"object\" !== t.kind && \"array\" !== t.kind || \"value\" !== i.kind) {\n                if (\"color\" !== t.kind && \"formatted\" !== t.kind && \"resolvedImage\" !== t.kind || \"value\" !== i.kind && \"string\" !== i.kind) {\n                  if (this.checkSubtype(t, i)) return null;\n                } else n = r(n, t, e.typeAnnotation || \"coerce\");\n              } else n = r(n, t, e.typeAnnotation || \"assert\");\n            }\n            if (!(n instanceof je) && \"resolvedImage\" !== n.type.kind && Mr(n)) {\n              const t = new We();\n              try {\n                n = new je(n.type, n.evaluate(t));\n              } catch (t) {\n                return this.error(t.message), null;\n              }\n            }\n            return n;\n          }\n          return this.error(`Unknown expression \"${n}\". If you wanted a literal array, use [\"literal\", [...]].`, 0);\n        }\n        return this.error(void 0 === t ? \"'undefined' value invalid. Use null instead.\" : \"object\" == typeof t ? 'Bare objects invalid. Use [\"literal\", {...}] instead.' : `Expected an array, but found ${typeof t} instead.`);\n      }\n      concat(t, e, r) {\n        const n = \"number\" == typeof t ? this.path.concat(t) : this.path,\n          i = r ? this.scope.concat(r) : this.scope;\n        return new kr(this.registry, n, e || null, i, this.errors);\n      }\n      error(t, ...e) {\n        const r = `${this.key}${e.map(t => `[${t}]`).join(\"\")}`;\n        this.errors.push(new se(r, t));\n      }\n      checkSubtype(t, e) {\n        const r = we(t, e);\n        return r && this.error(r), r;\n      }\n    }\n    var Ir = kr;\n    function Mr(t) {\n      if (t instanceof Sr) return Mr(t.boundExpression);\n      if (t instanceof tr && \"error\" === t.name) return !1;\n      if (t instanceof er) return !1;\n      if (t instanceof vr) return !1;\n      const e = t instanceof He || t instanceof Ge;\n      let r = !0;\n      return t.eachChild(t => {\n        r = e ? r && Mr(t) : r && t instanceof je;\n      }), !!r && br(t) && _r(t, [\"zoom\", \"heatmap-density\", \"line-progress\", \"sky-radial-progress\", \"accumulated\", \"is-supported-script\", \"pitch\", \"distance-from-center\"]);\n    }\n    function Tr(t, e) {\n      const r = t.length - 1;\n      let n,\n        i,\n        s = 0,\n        a = r,\n        o = 0;\n      for (; s <= a;) if (o = Math.floor((s + a) / 2), n = t[o], i = t[o + 1], n <= e) {\n        if (o === r || e < i) return o;\n        s = o + 1;\n      } else {\n        if (!(n > e)) throw new Oe(\"Input is not a number.\");\n        a = o - 1;\n      }\n      return 0;\n    }\n    class zr {\n      constructor(t, e, r) {\n        this.type = t, this.input = e, this.labels = [], this.outputs = [];\n        for (const [t, e] of r) this.labels.push(t), this.outputs.push(e);\n      }\n      static parse(t, e) {\n        if (t.length - 1 < 4) return e.error(`Expected at least 4 arguments, but found only ${t.length - 1}.`);\n        if ((t.length - 1) % 2 != 0) return e.error(\"Expected an even number of arguments.\");\n        const r = e.parse(t[1], 1, ue);\n        if (!r) return null;\n        const n = [];\n        let i = null;\n        e.expectedType && \"value\" !== e.expectedType.kind && (i = e.expectedType);\n        for (let r = 1; r < t.length; r += 2) {\n          const s = 1 === r ? -1 / 0 : t[r],\n            a = t[r + 1],\n            o = r,\n            l = r + 1;\n          if (\"number\" != typeof s) return e.error('Input/output pairs for \"step\" expressions must be defined using literal numeric values (not computed expressions) for the input values.', o);\n          if (n.length && n[n.length - 1][0] >= s) return e.error('Input/output pairs for \"step\" expressions must be arranged with input values in strictly ascending order.', o);\n          const u = e.parse(a, l, i);\n          if (!u) return null;\n          i = i || u.type, n.push([s, u]);\n        }\n        return new zr(i, r, n);\n      }\n      evaluate(t) {\n        const e = this.labels,\n          r = this.outputs;\n        if (1 === e.length) return r[0].evaluate(t);\n        const n = this.input.evaluate(t);\n        if (n <= e[0]) return r[0].evaluate(t);\n        const i = e.length;\n        return n >= e[i - 1] ? r[i - 1].evaluate(t) : r[Tr(e, n)].evaluate(t);\n      }\n      eachChild(t) {\n        t(this.input);\n        for (const e of this.outputs) t(e);\n      }\n      outputDefined() {\n        return this.outputs.every(t => t.outputDefined());\n      }\n      serialize() {\n        const t = [\"step\", this.input.serialize()];\n        for (let e = 0; e < this.labels.length; e++) e > 0 && t.push(this.labels[e]), t.push(this.outputs[e].serialize());\n        return t;\n      }\n    }\n    var Br = zr;\n    function Er(t, e, r) {\n      return t * (1 - r) + e * r;\n    }\n    var Cr = Object.freeze({\n      __proto__: null,\n      array: function (t, e, r) {\n        return t.map((t, n) => Er(t, e[n], r));\n      },\n      color: function (t, e, r) {\n        return new Ee(Er(t.r, e.r, r), Er(t.g, e.g, r), Er(t.b, e.b, r), Er(t.a, e.a, r));\n      },\n      number: Er\n    });\n    const Pr = .95047,\n      Dr = 1.08883,\n      Vr = 4 / 29,\n      Lr = 6 / 29,\n      Fr = 3 * Lr * Lr,\n      Rr = Lr * Lr * Lr,\n      Ur = Math.PI / 180,\n      $r = 180 / Math.PI;\n    function jr(t) {\n      return t > Rr ? Math.pow(t, 1 / 3) : t / Fr + Vr;\n    }\n    function Or(t) {\n      return t > Lr ? t * t * t : Fr * (t - Vr);\n    }\n    function qr(t) {\n      return 255 * (t <= .0031308 ? 12.92 * t : 1.055 * Math.pow(t, 1 / 2.4) - .055);\n    }\n    function Nr(t) {\n      return (t /= 255) <= .04045 ? t / 12.92 : Math.pow((t + .055) / 1.055, 2.4);\n    }\n    function Gr(t) {\n      const e = Nr(t.r),\n        r = Nr(t.g),\n        n = Nr(t.b),\n        i = jr((.4124564 * e + .3575761 * r + .1804375 * n) / Pr),\n        s = jr((.2126729 * e + .7151522 * r + .072175 * n) / 1);\n      return {\n        l: 116 * s - 16,\n        a: 500 * (i - s),\n        b: 200 * (s - jr((.0193339 * e + .119192 * r + .9503041 * n) / Dr)),\n        alpha: t.a\n      };\n    }\n    function Zr(t) {\n      let e = (t.l + 16) / 116,\n        r = isNaN(t.a) ? e : e + t.a / 500,\n        n = isNaN(t.b) ? e : e - t.b / 200;\n      return e = 1 * Or(e), r = Pr * Or(r), n = Dr * Or(n), new Ee(qr(3.2404542 * r - 1.5371385 * e - .4985314 * n), qr(-.969266 * r + 1.8760108 * e + .041556 * n), qr(.0556434 * r - .2040259 * e + 1.0572252 * n), t.alpha);\n    }\n    function Kr(t, e, r) {\n      const n = e - t;\n      return t + r * (n > 180 || n < -180 ? n - 360 * Math.round(n / 360) : n);\n    }\n    const Xr = {\n        forward: Gr,\n        reverse: Zr,\n        interpolate: function (t, e, r) {\n          return {\n            l: Er(t.l, e.l, r),\n            a: Er(t.a, e.a, r),\n            b: Er(t.b, e.b, r),\n            alpha: Er(t.alpha, e.alpha, r)\n          };\n        }\n      },\n      Jr = {\n        forward: function (t) {\n          const {\n              l: e,\n              a: r,\n              b: n\n            } = Gr(t),\n            i = Math.atan2(n, r) * $r;\n          return {\n            h: i < 0 ? i + 360 : i,\n            c: Math.sqrt(r * r + n * n),\n            l: e,\n            alpha: t.a\n          };\n        },\n        reverse: function (t) {\n          const e = t.h * Ur,\n            r = t.c;\n          return Zr({\n            l: t.l,\n            a: Math.cos(e) * r,\n            b: Math.sin(e) * r,\n            alpha: t.alpha\n          });\n        },\n        interpolate: function (t, e, r) {\n          return {\n            h: Kr(t.h, e.h, r),\n            c: Er(t.c, e.c, r),\n            l: Er(t.l, e.l, r),\n            alpha: Er(t.alpha, e.alpha, r)\n          };\n        }\n      };\n    var Hr = Object.freeze({\n      __proto__: null,\n      hcl: Jr,\n      lab: Xr\n    });\n    class Yr {\n      constructor(t, e, r, n, i) {\n        this.type = t, this.operator = e, this.interpolation = r, this.input = n, this.labels = [], this.outputs = [];\n        for (const [t, e] of i) this.labels.push(t), this.outputs.push(e);\n      }\n      static interpolationFactor(t, e, r, n) {\n        let i = 0;\n        if (\"exponential\" === t.name) i = Wr(e, t.base, r, n);else if (\"linear\" === t.name) i = Wr(e, 1, r, n);else if (\"cubic-bezier\" === t.name) {\n          const s = t.controlPoints;\n          i = new y(s[0], s[1], s[2], s[3]).solve(Wr(e, 1, r, n));\n        }\n        return i;\n      }\n      static parse(t, e) {\n        let [r, n, i, ...s] = t;\n        if (!Array.isArray(n) || 0 === n.length) return e.error(\"Expected an interpolation type expression.\", 1);\n        if (\"linear\" === n[0]) n = {\n          name: \"linear\"\n        };else if (\"exponential\" === n[0]) {\n          const t = n[1];\n          if (\"number\" != typeof t) return e.error(\"Exponential interpolation requires a numeric base.\", 1, 1);\n          n = {\n            name: \"exponential\",\n            base: t\n          };\n        } else {\n          if (\"cubic-bezier\" !== n[0]) return e.error(`Unknown interpolation type ${String(n[0])}`, 1, 0);\n          {\n            const t = n.slice(1);\n            if (4 !== t.length || t.some(t => \"number\" != typeof t || t < 0 || t > 1)) return e.error(\"Cubic bezier interpolation requires four numeric arguments with values between 0 and 1.\", 1);\n            n = {\n              name: \"cubic-bezier\",\n              controlPoints: t\n            };\n          }\n        }\n        if (t.length - 1 < 4) return e.error(`Expected at least 4 arguments, but found only ${t.length - 1}.`);\n        if ((t.length - 1) % 2 != 0) return e.error(\"Expected an even number of arguments.\");\n        if (i = e.parse(i, 2, ue), !i) return null;\n        const a = [];\n        let o = null;\n        \"interpolate-hcl\" === r || \"interpolate-lab\" === r ? o = pe : e.expectedType && \"value\" !== e.expectedType.kind && (o = e.expectedType);\n        for (let t = 0; t < s.length; t += 2) {\n          const r = s[t],\n            n = s[t + 1],\n            i = t + 3,\n            l = t + 4;\n          if (\"number\" != typeof r) return e.error('Input/output pairs for \"interpolate\" expressions must be defined using literal numeric values (not computed expressions) for the input values.', i);\n          if (a.length && a[a.length - 1][0] >= r) return e.error('Input/output pairs for \"interpolate\" expressions must be arranged with input values in strictly ascending order.', i);\n          const u = e.parse(n, l, o);\n          if (!u) return null;\n          o = o || u.type, a.push([r, u]);\n        }\n        return \"number\" === o.kind || \"color\" === o.kind || \"array\" === o.kind && \"number\" === o.itemType.kind && \"number\" == typeof o.N ? new Yr(o, r, n, i, a) : e.error(`Type ${ve(o)} is not interpolatable.`);\n      }\n      evaluate(t) {\n        const e = this.labels,\n          r = this.outputs;\n        if (1 === e.length) return r[0].evaluate(t);\n        const n = this.input.evaluate(t);\n        if (n <= e[0]) return r[0].evaluate(t);\n        const i = e.length;\n        if (n >= e[i - 1]) return r[i - 1].evaluate(t);\n        const s = Tr(e, n),\n          a = Yr.interpolationFactor(this.interpolation, n, e[s], e[s + 1]),\n          o = r[s].evaluate(t),\n          l = r[s + 1].evaluate(t);\n        return \"interpolate\" === this.operator ? Cr[this.type.kind.toLowerCase()](o, l, a) : \"interpolate-hcl\" === this.operator ? Jr.reverse(Jr.interpolate(Jr.forward(o), Jr.forward(l), a)) : Xr.reverse(Xr.interpolate(Xr.forward(o), Xr.forward(l), a));\n      }\n      eachChild(t) {\n        t(this.input);\n        for (const e of this.outputs) t(e);\n      }\n      outputDefined() {\n        return this.outputs.every(t => t.outputDefined());\n      }\n      serialize() {\n        let t;\n        t = \"linear\" === this.interpolation.name ? [\"linear\"] : \"exponential\" === this.interpolation.name ? 1 === this.interpolation.base ? [\"linear\"] : [\"exponential\", this.interpolation.base] : [\"cubic-bezier\"].concat(this.interpolation.controlPoints);\n        const e = [this.operator, t, this.input.serialize()];\n        for (let t = 0; t < this.labels.length; t++) e.push(this.labels[t], this.outputs[t].serialize());\n        return e;\n      }\n    }\n    function Wr(t, e, r, n) {\n      const i = n - r,\n        s = t - r;\n      return 0 === i ? 0 : 1 === e ? s / i : (Math.pow(e, s) - 1) / (Math.pow(e, i) - 1);\n    }\n    var Qr = Yr;\n    class tn {\n      constructor(t, e) {\n        this.type = t, this.args = e;\n      }\n      static parse(t, e) {\n        if (t.length < 2) return e.error(\"Expectected at least one argument.\");\n        let r = null;\n        const n = e.expectedType;\n        n && \"value\" !== n.kind && (r = n);\n        const i = [];\n        for (const n of t.slice(1)) {\n          const t = e.parse(n, 1 + i.length, r, void 0, {\n            typeAnnotation: \"omit\"\n          });\n          if (!t) return null;\n          r = r || t.type, i.push(t);\n        }\n        const s = n && i.some(t => we(n, t.type));\n        return new tn(s ? fe : r, i);\n      }\n      evaluate(t) {\n        let e,\n          r = null,\n          n = 0;\n        for (const i of this.args) {\n          if (n++, r = i.evaluate(t), r && r instanceof Ve && !r.available && (e || (e = r), r = null, n === this.args.length)) return e;\n          if (null !== r) break;\n        }\n        return r;\n      }\n      eachChild(t) {\n        this.args.forEach(t);\n      }\n      outputDefined() {\n        return this.args.every(t => t.outputDefined());\n      }\n      serialize() {\n        const t = [\"coalesce\"];\n        return this.eachChild(e => {\n          t.push(e.serialize());\n        }), t;\n      }\n    }\n    var en = tn;\n    class rn {\n      constructor(t, e) {\n        this.type = e.type, this.bindings = [].concat(t), this.result = e;\n      }\n      evaluate(t) {\n        return this.result.evaluate(t);\n      }\n      eachChild(t) {\n        for (const e of this.bindings) t(e[1]);\n        t(this.result);\n      }\n      static parse(t, e) {\n        if (t.length < 4) return e.error(`Expected at least 3 arguments, but found ${t.length - 1} instead.`);\n        const r = [];\n        for (let n = 1; n < t.length - 1; n += 2) {\n          const i = t[n];\n          if (\"string\" != typeof i) return e.error(`Expected string, but found ${typeof i} instead.`, n);\n          if (/[^a-zA-Z0-9_]/.test(i)) return e.error(\"Variable names must contain only alphanumeric characters or '_'.\", n);\n          const s = e.parse(t[n + 1], n + 1);\n          if (!s) return null;\n          r.push([i, s]);\n        }\n        const n = e.parse(t[t.length - 1], t.length - 1, e.expectedType, r);\n        return n ? new rn(r, n) : null;\n      }\n      outputDefined() {\n        return this.result.outputDefined();\n      }\n      serialize() {\n        const t = [\"let\"];\n        for (const [e, r] of this.bindings) t.push(e, r.serialize());\n        return t.push(this.result.serialize()), t;\n      }\n    }\n    var nn = rn;\n    class sn {\n      constructor(t, e, r) {\n        this.type = t, this.index = e, this.input = r;\n      }\n      static parse(t, e) {\n        if (3 !== t.length) return e.error(`Expected 2 arguments, but found ${t.length - 1} instead.`);\n        const r = e.parse(t[1], 1, ue),\n          n = e.parse(t[2], 2, xe(e.expectedType || fe));\n        return r && n ? new sn(n.type.itemType, r, n) : null;\n      }\n      evaluate(t) {\n        const e = this.index.evaluate(t),\n          r = this.input.evaluate(t);\n        if (e < 0) throw new Oe(`Array index out of bounds: ${e} < 0.`);\n        if (e >= r.length) throw new Oe(`Array index out of bounds: ${e} > ${r.length - 1}.`);\n        if (e !== Math.floor(e)) throw new Oe(`Array index must be an integer, but found ${e} instead.`);\n        return r[e];\n      }\n      eachChild(t) {\n        t(this.index), t(this.input);\n      }\n      outputDefined() {\n        return !1;\n      }\n      serialize() {\n        return [\"at\", this.index.serialize(), this.input.serialize()];\n      }\n    }\n    var an = sn;\n    class on {\n      constructor(t, e) {\n        this.type = he, this.needle = t, this.haystack = e;\n      }\n      static parse(t, e) {\n        if (3 !== t.length) return e.error(`Expected 2 arguments, but found ${t.length - 1} instead.`);\n        const r = e.parse(t[1], 1, fe),\n          n = e.parse(t[2], 2, fe);\n        return r && n ? _e(r.type, [he, ce, ue, le, fe]) ? new on(r, n) : e.error(`Expected first argument to be of type boolean, string, number or null, but found ${ve(r.type)} instead`) : null;\n      }\n      evaluate(t) {\n        const e = this.needle.evaluate(t),\n          r = this.haystack.evaluate(t);\n        if (null == r) return !1;\n        if (!Ae(e, [\"boolean\", \"string\", \"number\", \"null\"])) throw new Oe(`Expected first argument to be of type boolean, string, number or null, but found ${ve(Re(e))} instead.`);\n        if (!Ae(r, [\"string\", \"array\"])) throw new Oe(`Expected second argument to be of type array or string, but found ${ve(Re(r))} instead.`);\n        return r.indexOf(e) >= 0;\n      }\n      eachChild(t) {\n        t(this.needle), t(this.haystack);\n      }\n      outputDefined() {\n        return !0;\n      }\n      serialize() {\n        return [\"in\", this.needle.serialize(), this.haystack.serialize()];\n      }\n    }\n    var ln = on;\n    class un {\n      constructor(t, e, r) {\n        this.type = ue, this.needle = t, this.haystack = e, this.fromIndex = r;\n      }\n      static parse(t, e) {\n        if (t.length <= 2 || t.length >= 5) return e.error(`Expected 3 or 4 arguments, but found ${t.length - 1} instead.`);\n        const r = e.parse(t[1], 1, fe),\n          n = e.parse(t[2], 2, fe);\n        if (!r || !n) return null;\n        if (!_e(r.type, [he, ce, ue, le, fe])) return e.error(`Expected first argument to be of type boolean, string, number or null, but found ${ve(r.type)} instead`);\n        if (4 === t.length) {\n          const i = e.parse(t[3], 3, ue);\n          return i ? new un(r, n, i) : null;\n        }\n        return new un(r, n);\n      }\n      evaluate(t) {\n        const e = this.needle.evaluate(t),\n          r = this.haystack.evaluate(t);\n        if (!Ae(e, [\"boolean\", \"string\", \"number\", \"null\"])) throw new Oe(`Expected first argument to be of type boolean, string, number or null, but found ${ve(Re(e))} instead.`);\n        if (!Ae(r, [\"string\", \"array\"])) throw new Oe(`Expected second argument to be of type array or string, but found ${ve(Re(r))} instead.`);\n        if (this.fromIndex) {\n          const n = this.fromIndex.evaluate(t);\n          return r.indexOf(e, n);\n        }\n        return r.indexOf(e);\n      }\n      eachChild(t) {\n        t(this.needle), t(this.haystack), this.fromIndex && t(this.fromIndex);\n      }\n      outputDefined() {\n        return !1;\n      }\n      serialize() {\n        if (null != this.fromIndex && void 0 !== this.fromIndex) {\n          const t = this.fromIndex.serialize();\n          return [\"index-of\", this.needle.serialize(), this.haystack.serialize(), t];\n        }\n        return [\"index-of\", this.needle.serialize(), this.haystack.serialize()];\n      }\n    }\n    var cn = un;\n    class hn {\n      constructor(t, e, r, n, i, s) {\n        this.inputType = t, this.type = e, this.input = r, this.cases = n, this.outputs = i, this.otherwise = s;\n      }\n      static parse(t, e) {\n        if (t.length < 5) return e.error(`Expected at least 4 arguments, but found only ${t.length - 1}.`);\n        if (t.length % 2 != 1) return e.error(\"Expected an even number of arguments.\");\n        let r, n;\n        e.expectedType && \"value\" !== e.expectedType.kind && (n = e.expectedType);\n        const i = {},\n          s = [];\n        for (let a = 2; a < t.length - 1; a += 2) {\n          let o = t[a];\n          const l = t[a + 1];\n          Array.isArray(o) || (o = [o]);\n          const u = e.concat(a);\n          if (0 === o.length) return u.error(\"Expected at least one branch label.\");\n          for (const t of o) {\n            if (\"number\" != typeof t && \"string\" != typeof t) return u.error(\"Branch labels must be numbers or strings.\");\n            if (\"number\" == typeof t && Math.abs(t) > Number.MAX_SAFE_INTEGER) return u.error(`Branch labels must be integers no larger than ${Number.MAX_SAFE_INTEGER}.`);\n            if (\"number\" == typeof t && Math.floor(t) !== t) return u.error(\"Numeric branch labels must be integer values.\");\n            if (r) {\n              if (u.checkSubtype(r, Re(t))) return null;\n            } else r = Re(t);\n            if (void 0 !== i[String(t)]) return u.error(\"Branch labels must be unique.\");\n            i[String(t)] = s.length;\n          }\n          const c = e.parse(l, a, n);\n          if (!c) return null;\n          n = n || c.type, s.push(c);\n        }\n        const a = e.parse(t[1], 1, fe);\n        if (!a) return null;\n        const o = e.parse(t[t.length - 1], t.length - 1, n);\n        return o ? \"value\" !== a.type.kind && e.concat(1).checkSubtype(r, a.type) ? null : new hn(r, n, a, i, s, o) : null;\n      }\n      evaluate(t) {\n        const e = this.input.evaluate(t);\n        return (Re(e) === this.inputType && this.outputs[this.cases[e]] || this.otherwise).evaluate(t);\n      }\n      eachChild(t) {\n        t(this.input), this.outputs.forEach(t), t(this.otherwise);\n      }\n      outputDefined() {\n        return this.outputs.every(t => t.outputDefined()) && this.otherwise.outputDefined();\n      }\n      serialize() {\n        const t = [\"match\", this.input.serialize()],\n          e = Object.keys(this.cases).sort(),\n          r = [],\n          n = {};\n        for (const t of e) {\n          const e = n[this.cases[t]];\n          void 0 === e ? (n[this.cases[t]] = r.length, r.push([this.cases[t], [t]])) : r[e][1].push(t);\n        }\n        const i = t => \"number\" === this.inputType.kind ? Number(t) : t;\n        for (const [e, n] of r) t.push(1 === n.length ? i(n[0]) : n.map(i)), t.push(this.outputs[e].serialize());\n        return t.push(this.otherwise.serialize()), t;\n      }\n    }\n    var pn = hn;\n    class dn {\n      constructor(t, e, r) {\n        this.type = t, this.branches = e, this.otherwise = r;\n      }\n      static parse(t, e) {\n        if (t.length < 4) return e.error(`Expected at least 3 arguments, but found only ${t.length - 1}.`);\n        if (t.length % 2 != 0) return e.error(\"Expected an odd number of arguments.\");\n        let r;\n        e.expectedType && \"value\" !== e.expectedType.kind && (r = e.expectedType);\n        const n = [];\n        for (let i = 1; i < t.length - 1; i += 2) {\n          const s = e.parse(t[i], i, he);\n          if (!s) return null;\n          const a = e.parse(t[i + 1], i + 1, r);\n          if (!a) return null;\n          n.push([s, a]), r = r || a.type;\n        }\n        const i = e.parse(t[t.length - 1], t.length - 1, r);\n        return i ? new dn(r, n, i) : null;\n      }\n      evaluate(t) {\n        for (const [e, r] of this.branches) if (e.evaluate(t)) return r.evaluate(t);\n        return this.otherwise.evaluate(t);\n      }\n      eachChild(t) {\n        for (const [e, r] of this.branches) t(e), t(r);\n        t(this.otherwise);\n      }\n      outputDefined() {\n        return this.branches.every(([t, e]) => e.outputDefined()) && this.otherwise.outputDefined();\n      }\n      serialize() {\n        const t = [\"case\"];\n        return this.eachChild(e => {\n          t.push(e.serialize());\n        }), t;\n      }\n    }\n    var fn = dn;\n    class yn {\n      constructor(t, e, r, n) {\n        this.type = t, this.input = e, this.beginIndex = r, this.endIndex = n;\n      }\n      static parse(t, e) {\n        if (t.length <= 2 || t.length >= 5) return e.error(`Expected 3 or 4 arguments, but found ${t.length - 1} instead.`);\n        const r = e.parse(t[1], 1, fe),\n          n = e.parse(t[2], 2, ue);\n        if (!r || !n) return null;\n        if (!_e(r.type, [xe(fe), ce, fe])) return e.error(`Expected first argument to be of type array or string, but found ${ve(r.type)} instead`);\n        if (4 === t.length) {\n          const i = e.parse(t[3], 3, ue);\n          return i ? new yn(r.type, r, n, i) : null;\n        }\n        return new yn(r.type, r, n);\n      }\n      evaluate(t) {\n        const e = this.input.evaluate(t),\n          r = this.beginIndex.evaluate(t);\n        if (!Ae(e, [\"string\", \"array\"])) throw new Oe(`Expected first argument to be of type array or string, but found ${ve(Re(e))} instead.`);\n        if (this.endIndex) {\n          const n = this.endIndex.evaluate(t);\n          return e.slice(r, n);\n        }\n        return e.slice(r);\n      }\n      eachChild(t) {\n        t(this.input), t(this.beginIndex), this.endIndex && t(this.endIndex);\n      }\n      outputDefined() {\n        return !1;\n      }\n      serialize() {\n        if (null != this.endIndex && void 0 !== this.endIndex) {\n          const t = this.endIndex.serialize();\n          return [\"slice\", this.input.serialize(), this.beginIndex.serialize(), t];\n        }\n        return [\"slice\", this.input.serialize(), this.beginIndex.serialize()];\n      }\n    }\n    var mn = yn;\n    function gn(t, e) {\n      return \"==\" === t || \"!=\" === t ? \"boolean\" === e.kind || \"string\" === e.kind || \"number\" === e.kind || \"null\" === e.kind || \"value\" === e.kind : \"string\" === e.kind || \"number\" === e.kind || \"value\" === e.kind;\n    }\n    function xn(t, e, r, n) {\n      return 0 === n.compare(e, r);\n    }\n    function vn(t, e, r) {\n      const n = \"==\" !== t && \"!=\" !== t;\n      return class i {\n        constructor(t, e, r) {\n          this.type = he, this.lhs = t, this.rhs = e, this.collator = r, this.hasUntypedArgument = \"value\" === t.type.kind || \"value\" === e.type.kind;\n        }\n        static parse(t, e) {\n          if (3 !== t.length && 4 !== t.length) return e.error(\"Expected two or three arguments.\");\n          const r = t[0];\n          let s = e.parse(t[1], 1, fe);\n          if (!s) return null;\n          if (!gn(r, s.type)) return e.concat(1).error(`\"${r}\" comparisons are not supported for type '${ve(s.type)}'.`);\n          let a = e.parse(t[2], 2, fe);\n          if (!a) return null;\n          if (!gn(r, a.type)) return e.concat(2).error(`\"${r}\" comparisons are not supported for type '${ve(a.type)}'.`);\n          if (s.type.kind !== a.type.kind && \"value\" !== s.type.kind && \"value\" !== a.type.kind) return e.error(`Cannot compare types '${ve(s.type)}' and '${ve(a.type)}'.`);\n          n && (\"value\" === s.type.kind && \"value\" !== a.type.kind ? s = new Ge(a.type, [s]) : \"value\" !== s.type.kind && \"value\" === a.type.kind && (a = new Ge(s.type, [a])));\n          let o = null;\n          if (4 === t.length) {\n            if (\"string\" !== s.type.kind && \"string\" !== a.type.kind && \"value\" !== s.type.kind && \"value\" !== a.type.kind) return e.error(\"Cannot use collator to compare non-string types.\");\n            if (o = e.parse(t[3], 3, ye), !o) return null;\n          }\n          return new i(s, a, o);\n        }\n        evaluate(i) {\n          const s = this.lhs.evaluate(i),\n            a = this.rhs.evaluate(i);\n          if (n && this.hasUntypedArgument) {\n            const e = Re(s),\n              r = Re(a);\n            if (e.kind !== r.kind || \"string\" !== e.kind && \"number\" !== e.kind) throw new Oe(`Expected arguments for \"${t}\" to be (string, string) or (number, number), but found (${e.kind}, ${r.kind}) instead.`);\n          }\n          if (this.collator && !n && this.hasUntypedArgument) {\n            const t = Re(s),\n              r = Re(a);\n            if (\"string\" !== t.kind || \"string\" !== r.kind) return e(i, s, a);\n          }\n          return this.collator ? r(i, s, a, this.collator.evaluate(i)) : e(i, s, a);\n        }\n        eachChild(t) {\n          t(this.lhs), t(this.rhs), this.collator && t(this.collator);\n        }\n        outputDefined() {\n          return !0;\n        }\n        serialize() {\n          const e = [t];\n          return this.eachChild(t => {\n            e.push(t.serialize());\n          }), e;\n        }\n      };\n    }\n    const bn = vn(\"==\", function (t, e, r) {\n        return e === r;\n      }, xn),\n      wn = vn(\"!=\", function (t, e, r) {\n        return e !== r;\n      }, function (t, e, r, n) {\n        return !xn(0, e, r, n);\n      }),\n      _n = vn(\"<\", function (t, e, r) {\n        return e < r;\n      }, function (t, e, r, n) {\n        return n.compare(e, r) < 0;\n      }),\n      An = vn(\">\", function (t, e, r) {\n        return e > r;\n      }, function (t, e, r, n) {\n        return n.compare(e, r) > 0;\n      }),\n      Sn = vn(\"<=\", function (t, e, r) {\n        return e <= r;\n      }, function (t, e, r, n) {\n        return n.compare(e, r) <= 0;\n      }),\n      kn = vn(\">=\", function (t, e, r) {\n        return e >= r;\n      }, function (t, e, r, n) {\n        return n.compare(e, r) >= 0;\n      });\n    class In {\n      constructor(t, e, r, n, i, s) {\n        this.type = ce, this.number = t, this.locale = e, this.currency = r, this.unit = n, this.minFractionDigits = i, this.maxFractionDigits = s;\n      }\n      static parse(t, e) {\n        if (3 !== t.length) return e.error(\"Expected two arguments.\");\n        const r = e.parse(t[1], 1, ue);\n        if (!r) return null;\n        const n = t[2];\n        if (\"object\" != typeof n || Array.isArray(n)) return e.error(\"NumberFormat options argument must be an object.\");\n        let i = null;\n        if (n.locale && (i = e.parse(n.locale, 1, ce), !i)) return null;\n        let s = null;\n        if (n.currency && (s = e.parse(n.currency, 1, ce), !s)) return null;\n        let a = null;\n        if (n.unit && (a = e.parse(n.unit, 1, ce), !a)) return null;\n        let o = null;\n        if (n[\"min-fraction-digits\"] && (o = e.parse(n[\"min-fraction-digits\"], 1, ue), !o)) return null;\n        let l = null;\n        return n[\"max-fraction-digits\"] && (l = e.parse(n[\"max-fraction-digits\"], 1, ue), !l) ? null : new In(r, i, s, a, o, l);\n      }\n      evaluate(t) {\n        return new Intl.NumberFormat(this.locale ? this.locale.evaluate(t) : [], {\n          style: (this.currency ? \"currency\" : this.unit && \"unit\") || \"decimal\",\n          currency: this.currency ? this.currency.evaluate(t) : void 0,\n          unit: this.unit ? this.unit.evaluate(t) : void 0,\n          minimumFractionDigits: this.minFractionDigits ? this.minFractionDigits.evaluate(t) : void 0,\n          maximumFractionDigits: this.maxFractionDigits ? this.maxFractionDigits.evaluate(t) : void 0\n        }).format(this.number.evaluate(t));\n      }\n      eachChild(t) {\n        t(this.number), this.locale && t(this.locale), this.currency && t(this.currency), this.unit && t(this.unit), this.minFractionDigits && t(this.minFractionDigits), this.maxFractionDigits && t(this.maxFractionDigits);\n      }\n      outputDefined() {\n        return !1;\n      }\n      serialize() {\n        const t = {};\n        return this.locale && (t.locale = this.locale.serialize()), this.currency && (t.currency = this.currency.serialize()), this.unit && (t.unit = this.unit.serialize()), this.minFractionDigits && (t[\"min-fraction-digits\"] = this.minFractionDigits.serialize()), this.maxFractionDigits && (t[\"max-fraction-digits\"] = this.maxFractionDigits.serialize()), [\"number-format\", this.number.serialize(), t];\n      }\n    }\n    class Mn {\n      constructor(t) {\n        this.type = ue, this.input = t;\n      }\n      static parse(t, e) {\n        if (2 !== t.length) return e.error(`Expected 1 argument, but found ${t.length - 1} instead.`);\n        const r = e.parse(t[1], 1);\n        return r ? \"array\" !== r.type.kind && \"string\" !== r.type.kind && \"value\" !== r.type.kind ? e.error(`Expected argument of type string or array, but found ${ve(r.type)} instead.`) : new Mn(r) : null;\n      }\n      evaluate(t) {\n        const e = this.input.evaluate(t);\n        if (\"string\" == typeof e) return e.length;\n        if (Array.isArray(e)) return e.length;\n        throw new Oe(`Expected value to be of type string or array, but found ${ve(Re(e))} instead.`);\n      }\n      eachChild(t) {\n        t(this.input);\n      }\n      outputDefined() {\n        return !1;\n      }\n      serialize() {\n        const t = [\"length\"];\n        return this.eachChild(e => {\n          t.push(e.serialize());\n        }), t;\n      }\n    }\n    const Tn = {\n      \"==\": bn,\n      \"!=\": wn,\n      \">\": An,\n      \"<\": _n,\n      \">=\": kn,\n      \"<=\": Sn,\n      array: Ge,\n      at: an,\n      boolean: Ge,\n      case: fn,\n      coalesce: en,\n      collator: er,\n      format: Ze,\n      image: Ke,\n      in: ln,\n      \"index-of\": cn,\n      interpolate: Qr,\n      \"interpolate-hcl\": Qr,\n      \"interpolate-lab\": Qr,\n      length: Mn,\n      let: nn,\n      literal: je,\n      match: pn,\n      number: Ge,\n      \"number-format\": In,\n      object: Ge,\n      slice: mn,\n      step: Br,\n      string: Ge,\n      \"to-boolean\": He,\n      \"to-color\": He,\n      \"to-number\": He,\n      \"to-string\": He,\n      var: Sr,\n      within: vr\n    };\n    function zn(t, [e, r, n, i]) {\n      e = e.evaluate(t), r = r.evaluate(t), n = n.evaluate(t);\n      const s = i ? i.evaluate(t) : 1,\n        a = Le(e, r, n, s);\n      if (a) throw new Oe(a);\n      return new Ee(e / 255 * s, r / 255 * s, n / 255 * s, s);\n    }\n    function Bn(t, e) {\n      return t in e;\n    }\n    function En(t, e) {\n      const r = e[t];\n      return void 0 === r ? null : r;\n    }\n    function Cn(t) {\n      return {\n        type: t\n      };\n    }\n    tr.register(Tn, {\n      error: [{\n        kind: \"error\"\n      }, [ce], (t, [e]) => {\n        throw new Oe(e.evaluate(t));\n      }],\n      typeof: [ce, [fe], (t, [e]) => ve(Re(e.evaluate(t)))],\n      \"to-rgba\": [xe(ue, 4), [pe], (t, [e]) => e.evaluate(t).toArray()],\n      rgb: [pe, [ue, ue, ue], zn],\n      rgba: [pe, [ue, ue, ue, ue], zn],\n      has: {\n        type: he,\n        overloads: [[[ce], (t, [e]) => Bn(e.evaluate(t), t.properties())], [[ce, de], (t, [e, r]) => Bn(e.evaluate(t), r.evaluate(t))]]\n      },\n      get: {\n        type: fe,\n        overloads: [[[ce], (t, [e]) => En(e.evaluate(t), t.properties())], [[ce, de], (t, [e, r]) => En(e.evaluate(t), r.evaluate(t))]]\n      },\n      \"feature-state\": [fe, [ce], (t, [e]) => En(e.evaluate(t), t.featureState || {})],\n      properties: [de, [], t => t.properties()],\n      \"geometry-type\": [ce, [], t => t.geometryType()],\n      id: [fe, [], t => t.id()],\n      zoom: [ue, [], t => t.globals.zoom],\n      pitch: [ue, [], t => t.globals.pitch || 0],\n      \"distance-from-center\": [ue, [], t => t.distanceFromCenter()],\n      \"heatmap-density\": [ue, [], t => t.globals.heatmapDensity || 0],\n      \"line-progress\": [ue, [], t => t.globals.lineProgress || 0],\n      \"sky-radial-progress\": [ue, [], t => t.globals.skyRadialProgress || 0],\n      accumulated: [fe, [], t => void 0 === t.globals.accumulated ? null : t.globals.accumulated],\n      \"+\": [ue, Cn(ue), (t, e) => {\n        let r = 0;\n        for (const n of e) r += n.evaluate(t);\n        return r;\n      }],\n      \"*\": [ue, Cn(ue), (t, e) => {\n        let r = 1;\n        for (const n of e) r *= n.evaluate(t);\n        return r;\n      }],\n      \"-\": {\n        type: ue,\n        overloads: [[[ue, ue], (t, [e, r]) => e.evaluate(t) - r.evaluate(t)], [[ue], (t, [e]) => -e.evaluate(t)]]\n      },\n      \"/\": [ue, [ue, ue], (t, [e, r]) => e.evaluate(t) / r.evaluate(t)],\n      \"%\": [ue, [ue, ue], (t, [e, r]) => e.evaluate(t) % r.evaluate(t)],\n      ln2: [ue, [], () => Math.LN2],\n      pi: [ue, [], () => Math.PI],\n      e: [ue, [], () => Math.E],\n      \"^\": [ue, [ue, ue], (t, [e, r]) => Math.pow(e.evaluate(t), r.evaluate(t))],\n      sqrt: [ue, [ue], (t, [e]) => Math.sqrt(e.evaluate(t))],\n      log10: [ue, [ue], (t, [e]) => Math.log(e.evaluate(t)) / Math.LN10],\n      ln: [ue, [ue], (t, [e]) => Math.log(e.evaluate(t))],\n      log2: [ue, [ue], (t, [e]) => Math.log(e.evaluate(t)) / Math.LN2],\n      sin: [ue, [ue], (t, [e]) => Math.sin(e.evaluate(t))],\n      cos: [ue, [ue], (t, [e]) => Math.cos(e.evaluate(t))],\n      tan: [ue, [ue], (t, [e]) => Math.tan(e.evaluate(t))],\n      asin: [ue, [ue], (t, [e]) => Math.asin(e.evaluate(t))],\n      acos: [ue, [ue], (t, [e]) => Math.acos(e.evaluate(t))],\n      atan: [ue, [ue], (t, [e]) => Math.atan(e.evaluate(t))],\n      min: [ue, Cn(ue), (t, e) => Math.min(...e.map(e => e.evaluate(t)))],\n      max: [ue, Cn(ue), (t, e) => Math.max(...e.map(e => e.evaluate(t)))],\n      abs: [ue, [ue], (t, [e]) => Math.abs(e.evaluate(t))],\n      round: [ue, [ue], (t, [e]) => {\n        const r = e.evaluate(t);\n        return r < 0 ? -Math.round(-r) : Math.round(r);\n      }],\n      floor: [ue, [ue], (t, [e]) => Math.floor(e.evaluate(t))],\n      ceil: [ue, [ue], (t, [e]) => Math.ceil(e.evaluate(t))],\n      \"filter-==\": [he, [ce, fe], (t, [e, r]) => t.properties()[e.value] === r.value],\n      \"filter-id-==\": [he, [fe], (t, [e]) => t.id() === e.value],\n      \"filter-type-==\": [he, [ce], (t, [e]) => t.geometryType() === e.value],\n      \"filter-<\": [he, [ce, fe], (t, [e, r]) => {\n        const n = t.properties()[e.value],\n          i = r.value;\n        return typeof n == typeof i && n < i;\n      }],\n      \"filter-id-<\": [he, [fe], (t, [e]) => {\n        const r = t.id(),\n          n = e.value;\n        return typeof r == typeof n && r < n;\n      }],\n      \"filter->\": [he, [ce, fe], (t, [e, r]) => {\n        const n = t.properties()[e.value],\n          i = r.value;\n        return typeof n == typeof i && n > i;\n      }],\n      \"filter-id->\": [he, [fe], (t, [e]) => {\n        const r = t.id(),\n          n = e.value;\n        return typeof r == typeof n && r > n;\n      }],\n      \"filter-<=\": [he, [ce, fe], (t, [e, r]) => {\n        const n = t.properties()[e.value],\n          i = r.value;\n        return typeof n == typeof i && n <= i;\n      }],\n      \"filter-id-<=\": [he, [fe], (t, [e]) => {\n        const r = t.id(),\n          n = e.value;\n        return typeof r == typeof n && r <= n;\n      }],\n      \"filter->=\": [he, [ce, fe], (t, [e, r]) => {\n        const n = t.properties()[e.value],\n          i = r.value;\n        return typeof n == typeof i && n >= i;\n      }],\n      \"filter-id->=\": [he, [fe], (t, [e]) => {\n        const r = t.id(),\n          n = e.value;\n        return typeof r == typeof n && r >= n;\n      }],\n      \"filter-has\": [he, [fe], (t, [e]) => e.value in t.properties()],\n      \"filter-has-id\": [he, [], t => null !== t.id() && void 0 !== t.id()],\n      \"filter-type-in\": [he, [xe(ce)], (t, [e]) => e.value.indexOf(t.geometryType()) >= 0],\n      \"filter-id-in\": [he, [xe(fe)], (t, [e]) => e.value.indexOf(t.id()) >= 0],\n      \"filter-in-small\": [he, [ce, xe(fe)], (t, [e, r]) => r.value.indexOf(t.properties()[e.value]) >= 0],\n      \"filter-in-large\": [he, [ce, xe(fe)], (t, [e, r]) => function (t, e, r, n) {\n        for (; r <= n;) {\n          const i = r + n >> 1;\n          if (e[i] === t) return !0;\n          e[i] > t ? n = i - 1 : r = i + 1;\n        }\n        return !1;\n      }(t.properties()[e.value], r.value, 0, r.value.length - 1)],\n      all: {\n        type: he,\n        overloads: [[[he, he], (t, [e, r]) => e.evaluate(t) && r.evaluate(t)], [Cn(he), (t, e) => {\n          for (const r of e) if (!r.evaluate(t)) return !1;\n          return !0;\n        }]]\n      },\n      any: {\n        type: he,\n        overloads: [[[he, he], (t, [e, r]) => e.evaluate(t) || r.evaluate(t)], [Cn(he), (t, e) => {\n          for (const r of e) if (r.evaluate(t)) return !0;\n          return !1;\n        }]]\n      },\n      \"!\": [he, [he], (t, [e]) => !e.evaluate(t)],\n      \"is-supported-script\": [he, [ce], (t, [e]) => {\n        const r = t.globals && t.globals.isSupportedScript;\n        return !r || r(e.evaluate(t));\n      }],\n      upcase: [ce, [ce], (t, [e]) => e.evaluate(t).toUpperCase()],\n      downcase: [ce, [ce], (t, [e]) => e.evaluate(t).toLowerCase()],\n      concat: [ce, Cn(fe), (t, e) => e.map(e => Ue(e.evaluate(t))).join(\"\")],\n      \"resolved-locale\": [ce, [ye], (t, [e]) => e.evaluate(t).resolvedLocale()]\n    });\n    var Pn = Tn;\n    function Dn(t) {\n      return {\n        result: \"success\",\n        value: t\n      };\n    }\n    function Vn(t) {\n      return {\n        result: \"error\",\n        value: t\n      };\n    }\n    function Ln(t) {\n      return \"data-driven\" === t[\"property-type\"];\n    }\n    function Fn(t) {\n      return !!t.expression && t.expression.parameters.indexOf(\"zoom\") > -1;\n    }\n    function Rn(t) {\n      return !!t.expression && t.expression.interpolated;\n    }\n    function Un(t) {\n      return t instanceof Number ? \"number\" : t instanceof String ? \"string\" : t instanceof Boolean ? \"boolean\" : Array.isArray(t) ? \"array\" : null === t ? \"null\" : typeof t;\n    }\n    function $n(t) {\n      return \"object\" == typeof t && null !== t && !Array.isArray(t);\n    }\n    function jn(t) {\n      return t;\n    }\n    function On(t, e) {\n      const r = \"color\" === e.type,\n        n = t.stops && \"object\" == typeof t.stops[0][0],\n        i = n || !(n || void 0 !== t.property),\n        s = t.type || (Rn(e) ? \"exponential\" : \"interval\");\n      if (r && ((t = ee({}, t)).stops && (t.stops = t.stops.map(t => [t[0], Ee.parse(t[1])])), t.default = Ee.parse(t.default ? t.default : e.default)), t.colorSpace && \"rgb\" !== t.colorSpace && !Hr[t.colorSpace]) throw new Error(`Unknown color space: ${t.colorSpace}`);\n      let a, o, l;\n      if (\"exponential\" === s) a = Zn;else if (\"interval\" === s) a = Gn;else if (\"categorical\" === s) {\n        a = Nn, o = Object.create(null);\n        for (const e of t.stops) o[e[0]] = e[1];\n        l = typeof t.stops[0][0];\n      } else {\n        if (\"identity\" !== s) throw new Error(`Unknown function type \"${s}\"`);\n        a = Kn;\n      }\n      if (n) {\n        const r = {},\n          n = [];\n        for (let e = 0; e < t.stops.length; e++) {\n          const i = t.stops[e],\n            s = i[0].zoom;\n          void 0 === r[s] && (r[s] = {\n            zoom: s,\n            type: t.type,\n            property: t.property,\n            default: t.default,\n            stops: []\n          }, n.push(s)), r[s].stops.push([i[0].value, i[1]]);\n        }\n        const i = [];\n        for (const t of n) i.push([r[t].zoom, On(r[t], e)]);\n        const s = {\n          name: \"linear\"\n        };\n        return {\n          kind: \"composite\",\n          interpolationType: s,\n          interpolationFactor: Qr.interpolationFactor.bind(void 0, s),\n          zoomStops: i.map(t => t[0]),\n          evaluate: ({\n            zoom: r\n          }, n) => Zn({\n            stops: i,\n            base: t.base\n          }, e, r).evaluate(r, n)\n        };\n      }\n      if (i) {\n        const r = \"exponential\" === s ? {\n          name: \"exponential\",\n          base: void 0 !== t.base ? t.base : 1\n        } : null;\n        return {\n          kind: \"camera\",\n          interpolationType: r,\n          interpolationFactor: Qr.interpolationFactor.bind(void 0, r),\n          zoomStops: t.stops.map(t => t[0]),\n          evaluate: ({\n            zoom: r\n          }) => a(t, e, r, o, l)\n        };\n      }\n      return {\n        kind: \"source\",\n        evaluate(r, n) {\n          const i = n && n.properties ? n.properties[t.property] : void 0;\n          return void 0 === i ? qn(t.default, e.default) : a(t, e, i, o, l);\n        }\n      };\n    }\n    function qn(t, e, r) {\n      return void 0 !== t ? t : void 0 !== e ? e : void 0 !== r ? r : void 0;\n    }\n    function Nn(t, e, r, n, i) {\n      return qn(typeof r === i ? n[r] : void 0, t.default, e.default);\n    }\n    function Gn(t, e, r) {\n      if (\"number\" !== Un(r)) return qn(t.default, e.default);\n      const n = t.stops.length;\n      if (1 === n) return t.stops[0][1];\n      if (r <= t.stops[0][0]) return t.stops[0][1];\n      if (r >= t.stops[n - 1][0]) return t.stops[n - 1][1];\n      const i = Tr(t.stops.map(t => t[0]), r);\n      return t.stops[i][1];\n    }\n    function Zn(t, e, r) {\n      const n = void 0 !== t.base ? t.base : 1;\n      if (\"number\" !== Un(r)) return qn(t.default, e.default);\n      const i = t.stops.length;\n      if (1 === i) return t.stops[0][1];\n      if (r <= t.stops[0][0]) return t.stops[0][1];\n      if (r >= t.stops[i - 1][0]) return t.stops[i - 1][1];\n      const s = Tr(t.stops.map(t => t[0]), r),\n        a = function (t, e, r, n) {\n          const i = n - r,\n            s = t - r;\n          return 0 === i ? 0 : 1 === e ? s / i : (Math.pow(e, s) - 1) / (Math.pow(e, i) - 1);\n        }(r, n, t.stops[s][0], t.stops[s + 1][0]),\n        o = t.stops[s][1],\n        l = t.stops[s + 1][1];\n      let u = Cr[e.type] || jn;\n      if (t.colorSpace && \"rgb\" !== t.colorSpace) {\n        const e = Hr[t.colorSpace];\n        u = (t, r) => e.reverse(e.interpolate(e.forward(t), e.forward(r), a));\n      }\n      return \"function\" == typeof o.evaluate ? {\n        evaluate(...t) {\n          const e = o.evaluate.apply(void 0, t),\n            r = l.evaluate.apply(void 0, t);\n          if (void 0 !== e && void 0 !== r) return u(e, r, a);\n        }\n      } : u(o, l, a);\n    }\n    function Kn(t, e, r) {\n      return \"color\" === e.type ? r = Ee.parse(r) : \"formatted\" === e.type ? r = De.fromString(r.toString()) : \"resolvedImage\" === e.type ? r = Ve.fromString(r.toString()) : Un(r) === e.type || \"enum\" === e.type && e.values[r] || (r = void 0), qn(r, t.default, e.default);\n    }\n    class Xn {\n      constructor(t, e) {\n        this.expression = t, this._warningHistory = {}, this._evaluator = new We(), this._defaultValue = e ? function (t) {\n          return \"color\" === t.type && ($n(t.default) || Array.isArray(t.default)) ? new Ee(0, 0, 0, 0) : \"color\" === t.type ? Ee.parse(t.default) || null : void 0 === t.default ? null : t.default;\n        }(e) : null, this._enumValues = e && \"enum\" === e.type ? e.values : null;\n      }\n      evaluateWithoutErrorHandling(t, e, r, n, i, s, a, o) {\n        return this._evaluator.globals = t, this._evaluator.feature = e, this._evaluator.featureState = r, this._evaluator.canonical = n || null, this._evaluator.availableImages = i || null, this._evaluator.formattedSection = s, this._evaluator.featureTileCoord = a || null, this._evaluator.featureDistanceData = o || null, this.expression.evaluate(this._evaluator);\n      }\n      evaluate(t, e, r, n, i, s, a, o) {\n        this._evaluator.globals = t, this._evaluator.feature = e || null, this._evaluator.featureState = r || null, this._evaluator.canonical = n || null, this._evaluator.availableImages = i || null, this._evaluator.formattedSection = s || null, this._evaluator.featureTileCoord = a || null, this._evaluator.featureDistanceData = o || null;\n        try {\n          const t = this.expression.evaluate(this._evaluator);\n          if (null == t || \"number\" == typeof t && t != t) return this._defaultValue;\n          if (this._enumValues && !(t in this._enumValues)) throw new Oe(`Expected value to be one of ${Object.keys(this._enumValues).map(t => JSON.stringify(t)).join(\", \")}, but found ${JSON.stringify(t)} instead.`);\n          return t;\n        } catch (t) {\n          return this._warningHistory[t.message] || (this._warningHistory[t.message] = !0, \"undefined\" != typeof console && console.warn(t.message)), this._defaultValue;\n        }\n      }\n    }\n    function Jn(t) {\n      return Array.isArray(t) && t.length > 0 && \"string\" == typeof t[0] && t[0] in Pn;\n    }\n    function Hn(t, e) {\n      const r = new Ir(Pn, [], e ? function (t) {\n          const e = {\n            color: pe,\n            string: ce,\n            number: ue,\n            enum: ce,\n            boolean: he,\n            formatted: me,\n            resolvedImage: ge\n          };\n          return \"array\" === t.type ? xe(e[t.value] || fe, t.length) : e[t.type];\n        }(e) : void 0),\n        n = r.parse(t, void 0, void 0, void 0, e && \"string\" === e.type ? {\n          typeAnnotation: \"coerce\"\n        } : void 0);\n      return n ? Dn(new Xn(n, e)) : Vn(r.errors);\n    }\n    class Yn {\n      constructor(t, e) {\n        this.kind = t, this._styleExpression = e, this.isStateDependent = \"constant\" !== t && !wr(e.expression);\n      }\n      evaluateWithoutErrorHandling(t, e, r, n, i, s) {\n        return this._styleExpression.evaluateWithoutErrorHandling(t, e, r, n, i, s);\n      }\n      evaluate(t, e, r, n, i, s) {\n        return this._styleExpression.evaluate(t, e, r, n, i, s);\n      }\n    }\n    class Wn {\n      constructor(t, e, r, n) {\n        this.kind = t, this.zoomStops = r, this._styleExpression = e, this.isStateDependent = \"camera\" !== t && !wr(e.expression), this.interpolationType = n;\n      }\n      evaluateWithoutErrorHandling(t, e, r, n, i, s) {\n        return this._styleExpression.evaluateWithoutErrorHandling(t, e, r, n, i, s);\n      }\n      evaluate(t, e, r, n, i, s) {\n        return this._styleExpression.evaluate(t, e, r, n, i, s);\n      }\n      interpolationFactor(t, e, r) {\n        return this.interpolationType ? Qr.interpolationFactor(this.interpolationType, t, e, r) : 0;\n      }\n    }\n    function Qn(t, e) {\n      if (\"error\" === (t = Hn(t, e)).result) return t;\n      const r = t.value.expression,\n        n = br(r);\n      if (!n && !Ln(e)) return Vn([new se(\"\", \"data expressions not supported\")]);\n      const i = _r(r, [\"zoom\", \"pitch\", \"distance-from-center\"]);\n      if (!i && !Fn(e)) return Vn([new se(\"\", \"zoom expressions not supported\")]);\n      const s = ei(r);\n      return s || i ? s instanceof se ? Vn([s]) : s instanceof Qr && !Rn(e) ? Vn([new se(\"\", '\"interpolate\" expressions cannot be used with this property')]) : Dn(s ? new Wn(n ? \"camera\" : \"composite\", t.value, s.labels, s instanceof Qr ? s.interpolation : void 0) : new Yn(n ? \"constant\" : \"source\", t.value)) : Vn([new se(\"\", '\"zoom\" expression may only be used as input to a top-level \"step\" or \"interpolate\" expression.')]);\n    }\n    class ti {\n      constructor(t, e) {\n        this._parameters = t, this._specification = e, ee(this, On(this._parameters, this._specification));\n      }\n      static deserialize(t) {\n        return new ti(t._parameters, t._specification);\n      }\n      static serialize(t) {\n        return {\n          _parameters: t._parameters,\n          _specification: t._specification\n        };\n      }\n    }\n    function ei(t) {\n      let e = null;\n      if (t instanceof nn) e = ei(t.result);else if (t instanceof en) {\n        for (const r of t.args) if (e = ei(r), e) break;\n      } else (t instanceof Br || t instanceof Qr) && t.input instanceof tr && \"zoom\" === t.input.name && (e = t);\n      return e instanceof se || t.eachChild(t => {\n        const r = ei(t);\n        r instanceof se ? e = r : !e && r ? e = new se(\"\", '\"zoom\" expression may only be used as input to a top-level \"step\" or \"interpolate\" expression.') : e && r && e !== r && (e = new se(\"\", 'Only one zoom-based \"step\" or \"interpolate\" subexpression may be used in an expression.'));\n      }), e;\n    }\n    class ri {\n      constructor(t, e, r, n) {\n        this.message = (t ? `${t}: ` : \"\") + r, n && (this.identifier = n), null != e && e.__line__ && (this.line = e.__line__);\n      }\n    }\n    function ni(t) {\n      const e = t.key,\n        r = t.value,\n        n = t.valueSpec || {},\n        i = t.objectElementValidators || {},\n        s = t.style,\n        a = t.styleSpec;\n      let o = [];\n      const l = Un(r);\n      if (\"object\" !== l) return [new ri(e, r, `object expected, ${l} found`)];\n      for (const t in r) {\n        const l = t.split(\".\")[0];\n        let u;\n        i[l] ? u = i[l] : n[l] ? u = Fi : i[\"*\"] ? u = i[\"*\"] : n[\"*\"] && (u = Fi), u ? o = o.concat(u({\n          key: (e ? `${e}.` : e) + t,\n          value: r[t],\n          valueSpec: n[l] || n[\"*\"],\n          style: s,\n          styleSpec: a,\n          object: r,\n          objectKey: t\n        }, r)) : o.push(new ri(e, r[t], `unknown property \"${t}\"`));\n      }\n      for (const t in n) i[t] || n[t].required && void 0 === n[t].default && void 0 === r[t] && o.push(new ri(e, r, `missing required property \"${t}\"`));\n      return o;\n    }\n    function ii(t) {\n      const e = t.value,\n        r = t.valueSpec,\n        n = t.style,\n        i = t.styleSpec,\n        s = t.key,\n        a = t.arrayElementValidator || Fi;\n      if (\"array\" !== Un(e)) return [new ri(s, e, `array expected, ${Un(e)} found`)];\n      if (r.length && e.length !== r.length) return [new ri(s, e, `array length ${r.length} expected, length ${e.length} found`)];\n      if (r[\"min-length\"] && e.length < r[\"min-length\"]) return [new ri(s, e, `array length at least ${r[\"min-length\"]} expected, length ${e.length} found`)];\n      let o = {\n        type: r.value,\n        values: r.values,\n        minimum: r.minimum,\n        maximum: r.maximum,\n        function: void 0\n      };\n      i.$version < 7 && (o.function = r.function), \"object\" === Un(r.value) && (o = r.value);\n      let l = [];\n      for (let t = 0; t < e.length; t++) l = l.concat(a({\n        array: e,\n        arrayIndex: t,\n        value: e[t],\n        valueSpec: o,\n        style: n,\n        styleSpec: i,\n        key: `${s}[${t}]`\n      }));\n      return l;\n    }\n    function si(t) {\n      const e = t.key,\n        r = t.value,\n        n = t.valueSpec;\n      let i = Un(r);\n      if (\"number\" === i && r != r && (i = \"NaN\"), \"number\" !== i) return [new ri(e, r, `number expected, ${i} found`)];\n      if (\"minimum\" in n) {\n        let i = n.minimum;\n        if (\"array\" === Un(n.minimum) && (i = n.minimum[t.arrayIndex]), r < i) return [new ri(e, r, `${r} is less than the minimum value ${i}`)];\n      }\n      if (\"maximum\" in n) {\n        let i = n.maximum;\n        if (\"array\" === Un(n.maximum) && (i = n.maximum[t.arrayIndex]), r > i) return [new ri(e, r, `${r} is greater than the maximum value ${i}`)];\n      }\n      return [];\n    }\n    function ai(t) {\n      const e = t.valueSpec,\n        r = re(t.value.type);\n      let n,\n        i,\n        s,\n        a = {};\n      const o = \"categorical\" !== r && void 0 === t.value.property,\n        l = !o,\n        u = \"array\" === Un(t.value.stops) && \"array\" === Un(t.value.stops[0]) && \"object\" === Un(t.value.stops[0][0]),\n        c = ni({\n          key: t.key,\n          value: t.value,\n          valueSpec: t.styleSpec.function,\n          style: t.style,\n          styleSpec: t.styleSpec,\n          objectElementValidators: {\n            stops: function (t) {\n              if (\"identity\" === r) return [new ri(t.key, t.value, 'identity function may not have a \"stops\" property')];\n              let e = [];\n              const n = t.value;\n              return e = e.concat(ii({\n                key: t.key,\n                value: n,\n                valueSpec: t.valueSpec,\n                style: t.style,\n                styleSpec: t.styleSpec,\n                arrayElementValidator: h\n              })), \"array\" === Un(n) && 0 === n.length && e.push(new ri(t.key, n, \"array must have at least one stop\")), e;\n            },\n            default: function (t) {\n              return Fi({\n                key: t.key,\n                value: t.value,\n                valueSpec: e,\n                style: t.style,\n                styleSpec: t.styleSpec\n              });\n            }\n          }\n        });\n      return \"identity\" === r && o && c.push(new ri(t.key, t.value, 'missing required property \"property\"')), \"identity\" === r || t.value.stops || c.push(new ri(t.key, t.value, 'missing required property \"stops\"')), \"exponential\" === r && t.valueSpec.expression && !Rn(t.valueSpec) && c.push(new ri(t.key, t.value, \"exponential functions not supported\")), t.styleSpec.$version >= 8 && (l && !Ln(t.valueSpec) ? c.push(new ri(t.key, t.value, \"property functions not supported\")) : o && !Fn(t.valueSpec) && c.push(new ri(t.key, t.value, \"zoom functions not supported\"))), \"categorical\" !== r && !u || void 0 !== t.value.property || c.push(new ri(t.key, t.value, '\"property\" property is required')), c;\n      function h(t) {\n        let r = [];\n        const n = t.value,\n          o = t.key;\n        if (\"array\" !== Un(n)) return [new ri(o, n, `array expected, ${Un(n)} found`)];\n        if (2 !== n.length) return [new ri(o, n, `array length 2 expected, length ${n.length} found`)];\n        if (u) {\n          if (\"object\" !== Un(n[0])) return [new ri(o, n, `object expected, ${Un(n[0])} found`)];\n          if (void 0 === n[0].zoom) return [new ri(o, n, \"object stop key must have zoom\")];\n          if (void 0 === n[0].value) return [new ri(o, n, \"object stop key must have value\")];\n          const e = re(n[0].zoom);\n          if (\"number\" != typeof e) return [new ri(o, n[0].zoom, \"stop zoom values must be numbers\")];\n          if (s && s > e) return [new ri(o, n[0].zoom, \"stop zoom values must appear in ascending order\")];\n          e !== s && (s = e, i = void 0, a = {}), r = r.concat(ni({\n            key: `${o}[0]`,\n            value: n[0],\n            valueSpec: {\n              zoom: {}\n            },\n            style: t.style,\n            styleSpec: t.styleSpec,\n            objectElementValidators: {\n              zoom: si,\n              value: p\n            }\n          }));\n        } else r = r.concat(p({\n          key: `${o}[0]`,\n          value: n[0],\n          valueSpec: {},\n          style: t.style,\n          styleSpec: t.styleSpec\n        }, n));\n        return Jn(ne(n[1])) ? r.concat([new ri(`${o}[1]`, n[1], \"expressions are not allowed in function stops.\")]) : r.concat(Fi({\n          key: `${o}[1]`,\n          value: n[1],\n          valueSpec: e,\n          style: t.style,\n          styleSpec: t.styleSpec\n        }));\n      }\n      function p(t, s) {\n        const o = Un(t.value),\n          l = re(t.value),\n          u = null !== t.value ? t.value : s;\n        if (n) {\n          if (o !== n) return [new ri(t.key, u, `${o} stop domain type must match previous stop domain type ${n}`)];\n        } else n = o;\n        if (\"number\" !== o && \"string\" !== o && \"boolean\" !== o && \"number\" != typeof l && \"string\" != typeof l && \"boolean\" != typeof l) return [new ri(t.key, u, \"stop domain value must be a number, string, or boolean\")];\n        if (\"number\" !== o && \"categorical\" !== r) {\n          let n = `number expected, ${o} found`;\n          return Ln(e) && void 0 === r && (n += '\\nIf you intended to use a categorical function, specify `\"type\": \"categorical\"`.'), [new ri(t.key, u, n)];\n        }\n        return \"categorical\" !== r || \"number\" !== o || \"number\" == typeof l && isFinite(l) && Math.floor(l) === l ? \"categorical\" !== r && \"number\" === o && \"number\" == typeof l && \"number\" == typeof i && void 0 !== i && l < i ? [new ri(t.key, u, \"stop domain values must appear in ascending order\")] : (i = l, \"categorical\" === r && l in a ? [new ri(t.key, u, \"stop domain values must be unique\")] : (a[l] = !0, [])) : [new ri(t.key, u, `integer expected, found ${String(l)}`)];\n      }\n    }\n    function oi(t) {\n      const e = (\"property\" === t.expressionContext ? Qn : Hn)(ne(t.value), t.valueSpec);\n      if (\"error\" === e.result) return e.value.map(e => new ri(`${t.key}${e.key}`, t.value, e.message));\n      const r = e.value.expression || e.value._styleExpression.expression;\n      if (\"property\" === t.expressionContext && \"text-font\" === t.propertyKey && !r.outputDefined()) return [new ri(t.key, t.value, `Invalid data expression for \"${t.propertyKey}\". Output values must be contained as literals within the expression.`)];\n      if (\"property\" === t.expressionContext && \"layout\" === t.propertyType && !wr(r)) return [new ri(t.key, t.value, '\"feature-state\" data expressions are not supported with layout properties.')];\n      if (\"filter\" === t.expressionContext) return li(r, t);\n      if (t.expressionContext && 0 === t.expressionContext.indexOf(\"cluster\")) {\n        if (!_r(r, [\"zoom\", \"feature-state\"])) return [new ri(t.key, t.value, '\"zoom\" and \"feature-state\" expressions are not supported with cluster properties.')];\n        if (\"cluster-initial\" === t.expressionContext && !br(r)) return [new ri(t.key, t.value, \"Feature data expressions are not supported with initial expression part of cluster properties.\")];\n      }\n      return [];\n    }\n    function li(t, e) {\n      const r = new Set([\"zoom\", \"feature-state\", \"pitch\", \"distance-from-center\"]);\n      if (e.valueSpec && e.valueSpec.expression) for (const t of e.valueSpec.expression.parameters) r.delete(t);\n      if (0 === r.size) return [];\n      const n = [];\n      return t instanceof tr && r.has(t.name) ? [new ri(e.key, e.value, `[\"${t.name}\"] expression is not supported in a filter for a ${e.object.type} layer with id: ${e.object.id}`)] : (t.eachChild(t => {\n        n.push(...li(t, e));\n      }), n);\n    }\n    function ui(t) {\n      const e = t.key,\n        r = t.value,\n        n = t.valueSpec,\n        i = [];\n      return Array.isArray(n.values) ? -1 === n.values.indexOf(re(r)) && i.push(new ri(e, r, `expected one of [${n.values.join(\", \")}], ${JSON.stringify(r)} found`)) : -1 === Object.keys(n.values).indexOf(re(r)) && i.push(new ri(e, r, `expected one of [${Object.keys(n.values).join(\", \")}], ${JSON.stringify(r)} found`)), i;\n    }\n    function ci(t) {\n      if (!0 === t || !1 === t) return !0;\n      if (!Array.isArray(t) || 0 === t.length) return !1;\n      switch (t[0]) {\n        case \"has\":\n          return t.length >= 2 && \"$id\" !== t[1] && \"$type\" !== t[1];\n        case \"in\":\n          return t.length >= 3 && (\"string\" != typeof t[1] || Array.isArray(t[2]));\n        case \"!in\":\n        case \"!has\":\n        case \"none\":\n          return !1;\n        case \"==\":\n        case \"!=\":\n        case \">\":\n        case \">=\":\n        case \"<\":\n        case \"<=\":\n          return 3 !== t.length || Array.isArray(t[1]) || Array.isArray(t[2]);\n        case \"any\":\n        case \"all\":\n          for (const e of t.slice(1)) if (!ci(e) && \"boolean\" != typeof e) return !1;\n          return !0;\n        default:\n          return !0;\n      }\n    }\n    function hi(t, e = \"fill\") {\n      if (null == t) return {\n        filter: () => !0,\n        needGeometry: !1,\n        needFeature: !1\n      };\n      ci(t) || (t = xi(t));\n      const r = t;\n      let n = !0;\n      try {\n        n = function (t) {\n          if (!fi(t)) return t;\n          let e = ne(t);\n          return di(e), e = pi(e), e;\n        }(r);\n      } catch (t) {\n        console.warn(`Failed to extract static filter. Filter will continue working, but at higher memory usage and slower framerate.\\nThis is most likely a bug, please report this via https://github.com/mapbox/mapbox-gl-js/issues/new?assignees=&labels=&template=Bug_report.md\\nand paste the contents of this message in the report.\\nThank you!\\nFilter Expression:\\n${JSON.stringify(r, null, 2)}\\n        `);\n      }\n      const i = te[`filter_${e}`],\n        s = Hn(n, i);\n      let a = null;\n      if (\"error\" === s.result) throw new Error(s.value.map(t => `${t.key}: ${t.message}`).join(\", \"));\n      a = (t, e, r) => s.value.evaluate(t, e, {}, r);\n      let o = null,\n        l = null;\n      if (n !== r) {\n        const t = Hn(r, i);\n        if (\"error\" === t.result) throw new Error(t.value.map(t => `${t.key}: ${t.message}`).join(\", \"));\n        o = (e, r, n, i, s) => t.value.evaluate(e, r, {}, n, void 0, void 0, i, s), l = !br(t.value.expression);\n      }\n      return {\n        filter: a,\n        dynamicFilter: o || void 0,\n        needGeometry: gi(n),\n        needFeature: !!l\n      };\n    }\n    function pi(t) {\n      if (!Array.isArray(t)) return t;\n      const e = function (t) {\n        if (yi.has(t[0])) for (let e = 1; e < t.length; e++) if (fi(t[e])) return !0;\n        return t;\n      }(t);\n      return !0 === e ? e : e.map(t => pi(t));\n    }\n    function di(t) {\n      let e = !1;\n      const r = [];\n      if (\"case\" === t[0]) {\n        for (let n = 1; n < t.length - 1; n += 2) e = e || fi(t[n]), r.push(t[n + 1]);\n        r.push(t[t.length - 1]);\n      } else if (\"match\" === t[0]) {\n        e = e || fi(t[1]);\n        for (let e = 2; e < t.length - 1; e += 2) r.push(t[e + 1]);\n        r.push(t[t.length - 1]);\n      } else if (\"step\" === t[0]) {\n        e = e || fi(t[1]);\n        for (let e = 1; e < t.length - 1; e += 2) r.push(t[e + 1]);\n      }\n      e && (t.length = 0, t.push(\"any\", ...r));\n      for (let e = 1; e < t.length; e++) di(t[e]);\n    }\n    function fi(t) {\n      if (!Array.isArray(t)) return !1;\n      if (\"pitch\" === (e = t[0]) || \"distance-from-center\" === e) return !0;\n      var e;\n      for (let e = 1; e < t.length; e++) if (fi(t[e])) return !0;\n      return !1;\n    }\n    const yi = new Set([\"in\", \"==\", \"!=\", \">\", \">=\", \"<\", \"<=\", \"to-boolean\"]);\n    function mi(t, e) {\n      return t < e ? -1 : t > e ? 1 : 0;\n    }\n    function gi(t) {\n      if (!Array.isArray(t)) return !1;\n      if (\"within\" === t[0]) return !0;\n      for (let e = 1; e < t.length; e++) if (gi(t[e])) return !0;\n      return !1;\n    }\n    function xi(t) {\n      if (!t) return !0;\n      const e = t[0];\n      return t.length <= 1 ? \"any\" !== e : \"==\" === e ? vi(t[1], t[2], \"==\") : \"!=\" === e ? _i(vi(t[1], t[2], \"==\")) : \"<\" === e || \">\" === e || \"<=\" === e || \">=\" === e ? vi(t[1], t[2], e) : \"any\" === e ? (r = t.slice(1), [\"any\"].concat(r.map(xi))) : \"all\" === e ? [\"all\"].concat(t.slice(1).map(xi)) : \"none\" === e ? [\"all\"].concat(t.slice(1).map(xi).map(_i)) : \"in\" === e ? bi(t[1], t.slice(2)) : \"!in\" === e ? _i(bi(t[1], t.slice(2))) : \"has\" === e ? wi(t[1]) : \"!has\" === e ? _i(wi(t[1])) : \"within\" !== e || t;\n      var r;\n    }\n    function vi(t, e, r) {\n      switch (t) {\n        case \"$type\":\n          return [`filter-type-${r}`, e];\n        case \"$id\":\n          return [`filter-id-${r}`, e];\n        default:\n          return [`filter-${r}`, t, e];\n      }\n    }\n    function bi(t, e) {\n      if (0 === e.length) return !1;\n      switch (t) {\n        case \"$type\":\n          return [\"filter-type-in\", [\"literal\", e]];\n        case \"$id\":\n          return [\"filter-id-in\", [\"literal\", e]];\n        default:\n          return e.length > 200 && !e.some(t => typeof t != typeof e[0]) ? [\"filter-in-large\", t, [\"literal\", e.sort(mi)]] : [\"filter-in-small\", t, [\"literal\", e]];\n      }\n    }\n    function wi(t) {\n      switch (t) {\n        case \"$type\":\n          return !0;\n        case \"$id\":\n          return [\"filter-has-id\"];\n        default:\n          return [\"filter-has\", t];\n      }\n    }\n    function _i(t) {\n      return [\"!\", t];\n    }\n    function Ai(t) {\n      return ci(ne(t.value)) ? oi(ee({}, t, {\n        expressionContext: \"filter\",\n        valueSpec: t.styleSpec[`filter_${t.layerType || \"fill\"}`]\n      })) : Si(t);\n    }\n    function Si(t) {\n      const e = t.value,\n        r = t.key;\n      if (\"array\" !== Un(e)) return [new ri(r, e, `array expected, ${Un(e)} found`)];\n      const n = t.styleSpec;\n      let i,\n        s = [];\n      if (e.length < 1) return [new ri(r, e, \"filter array must have at least 1 element\")];\n      switch (s = s.concat(ui({\n        key: `${r}[0]`,\n        value: e[0],\n        valueSpec: n.filter_operator,\n        style: t.style,\n        styleSpec: t.styleSpec\n      })), re(e[0])) {\n        case \"<\":\n        case \"<=\":\n        case \">\":\n        case \">=\":\n          e.length >= 2 && \"$type\" === re(e[1]) && s.push(new ri(r, e, `\"$type\" cannot be use with operator \"${e[0]}\"`));\n        case \"==\":\n        case \"!=\":\n          3 !== e.length && s.push(new ri(r, e, `filter array for operator \"${e[0]}\" must have 3 elements`));\n        case \"in\":\n        case \"!in\":\n          e.length >= 2 && (i = Un(e[1]), \"string\" !== i && s.push(new ri(`${r}[1]`, e[1], `string expected, ${i} found`)));\n          for (let a = 2; a < e.length; a++) i = Un(e[a]), \"$type\" === re(e[1]) ? s = s.concat(ui({\n            key: `${r}[${a}]`,\n            value: e[a],\n            valueSpec: n.geometry_type,\n            style: t.style,\n            styleSpec: t.styleSpec\n          })) : \"string\" !== i && \"number\" !== i && \"boolean\" !== i && s.push(new ri(`${r}[${a}]`, e[a], `string, number, or boolean expected, ${i} found`));\n          break;\n        case \"any\":\n        case \"all\":\n        case \"none\":\n          for (let n = 1; n < e.length; n++) s = s.concat(Si({\n            key: `${r}[${n}]`,\n            value: e[n],\n            style: t.style,\n            styleSpec: t.styleSpec\n          }));\n          break;\n        case \"has\":\n        case \"!has\":\n          i = Un(e[1]), 2 !== e.length ? s.push(new ri(r, e, `filter array for \"${e[0]}\" operator must have 2 elements`)) : \"string\" !== i && s.push(new ri(`${r}[1]`, e[1], `string expected, ${i} found`));\n          break;\n        case \"within\":\n          i = Un(e[1]), 2 !== e.length ? s.push(new ri(r, e, `filter array for \"${e[0]}\" operator must have 2 elements`)) : \"object\" !== i && s.push(new ri(`${r}[1]`, e[1], `object expected, ${i} found`));\n      }\n      return s;\n    }\n    function ki(t, e) {\n      const r = t.key,\n        n = t.style,\n        i = t.styleSpec,\n        s = t.value,\n        a = t.objectKey,\n        o = i[`${e}_${t.layerType}`];\n      if (!o) return [];\n      const l = a.match(/^(.*)-transition$/);\n      if (\"paint\" === e && l && o[l[1]] && o[l[1]].transition) return Fi({\n        key: r,\n        value: s,\n        valueSpec: i.transition,\n        style: n,\n        styleSpec: i\n      });\n      const u = t.valueSpec || o[a];\n      if (!u) return [new ri(r, s, `unknown property \"${a}\"`)];\n      let c;\n      if (\"string\" === Un(s) && Ln(u) && !u.tokens && (c = /^{([^}]+)}$/.exec(s))) {\n        const t = `\\`{ \"type\": \"identity\", \"property\": ${c ? JSON.stringify(c[1]) : '\"_\"'} }\\``;\n        return [new ri(r, s, `\"${a}\" does not support interpolation syntax\\nUse an identity property function instead: ${t}.`)];\n      }\n      const h = [];\n      return \"symbol\" === t.layerType && (\"text-field\" === a && n && !n.glyphs && h.push(new ri(r, s, 'use of \"text-field\" requires a style \"glyphs\" property')), \"text-font\" === a && $n(ne(s)) && \"identity\" === re(s.type) && h.push(new ri(r, s, '\"text-font\" does not support identity functions'))), h.concat(Fi({\n        key: t.key,\n        value: s,\n        valueSpec: u,\n        style: n,\n        styleSpec: i,\n        expressionContext: \"property\",\n        propertyType: e,\n        propertyKey: a\n      }));\n    }\n    function Ii(t) {\n      return ki(t, \"paint\");\n    }\n    function Mi(t) {\n      return ki(t, \"layout\");\n    }\n    function Ti(t) {\n      let e = [];\n      const r = t.value,\n        n = t.key,\n        i = t.style,\n        s = t.styleSpec;\n      r.type || r.ref || e.push(new ri(n, r, 'either \"type\" or \"ref\" is required'));\n      let a = re(r.type);\n      const o = re(r.ref);\n      if (r.id) {\n        const s = re(r.id);\n        for (let a = 0; a < t.arrayIndex; a++) {\n          const t = i.layers[a];\n          re(t.id) === s && e.push(new ri(n, r.id, `duplicate layer id \"${r.id}\", previously used at line ${t.id.__line__}`));\n        }\n      }\n      if (\"ref\" in r) {\n        let t;\n        [\"type\", \"source\", \"source-layer\", \"filter\", \"layout\"].forEach(t => {\n          t in r && e.push(new ri(n, r[t], `\"${t}\" is prohibited for ref layers`));\n        }), i.layers.forEach(e => {\n          re(e.id) === o && (t = e);\n        }), t ? t.ref ? e.push(new ri(n, r.ref, \"ref cannot reference another ref layer\")) : a = re(t.type) : \"string\" == typeof o && e.push(new ri(n, r.ref, `ref layer \"${o}\" not found`));\n      } else if (\"background\" !== a && \"sky\" !== a) if (r.source) {\n        const t = i.sources && i.sources[r.source],\n          s = t && re(t.type);\n        t ? \"vector\" === s && \"raster\" === a ? e.push(new ri(n, r.source, `layer \"${r.id}\" requires a raster source`)) : \"raster\" === s && \"raster\" !== a ? e.push(new ri(n, r.source, `layer \"${r.id}\" requires a vector source`)) : \"vector\" !== s || r[\"source-layer\"] ? \"raster-dem\" === s && \"hillshade\" !== a ? e.push(new ri(n, r.source, \"raster-dem source can only be used with layer type 'hillshade'.\")) : \"line\" !== a || !r.paint || !r.paint[\"line-gradient\"] && !r.paint[\"line-trim-offset\"] || \"geojson\" === s && t.lineMetrics || e.push(new ri(n, r, `layer \"${r.id}\" specifies a line-gradient, which requires a GeoJSON source with \\`lineMetrics\\` enabled.`)) : e.push(new ri(n, r, `layer \"${r.id}\" must specify a \"source-layer\"`)) : e.push(new ri(n, r.source, `source \"${r.source}\" not found`));\n      } else e.push(new ri(n, r, 'missing required property \"source\"'));\n      return e = e.concat(ni({\n        key: n,\n        value: r,\n        valueSpec: s.layer,\n        style: t.style,\n        styleSpec: t.styleSpec,\n        objectElementValidators: {\n          \"*\": () => [],\n          type: () => Fi({\n            key: `${n}.type`,\n            value: r.type,\n            valueSpec: s.layer.type,\n            style: t.style,\n            styleSpec: t.styleSpec,\n            object: r,\n            objectKey: \"type\"\n          }),\n          filter: t => Ai(ee({\n            layerType: a\n          }, t)),\n          layout: t => ni({\n            layer: r,\n            key: t.key,\n            value: t.value,\n            valueSpec: {},\n            style: t.style,\n            styleSpec: t.styleSpec,\n            objectElementValidators: {\n              \"*\": t => Mi(ee({\n                layerType: a\n              }, t))\n            }\n          }),\n          paint: t => ni({\n            layer: r,\n            key: t.key,\n            value: t.value,\n            valueSpec: {},\n            style: t.style,\n            styleSpec: t.styleSpec,\n            objectElementValidators: {\n              \"*\": t => Ii(ee({\n                layerType: a\n              }, t))\n            }\n          })\n        }\n      })), e;\n    }\n    function zi(t) {\n      const e = t.value,\n        r = t.key,\n        n = Un(e);\n      return \"string\" !== n ? [new ri(r, e, `string expected, ${n} found`)] : [];\n    }\n    const Bi = {\n      promoteId: function ({\n        key: t,\n        value: e\n      }) {\n        if (\"string\" === Un(e)) return zi({\n          key: t,\n          value: e\n        });\n        {\n          const r = [];\n          for (const n in e) r.push(...zi({\n            key: `${t}.${n}`,\n            value: e[n]\n          }));\n          return r;\n        }\n      }\n    };\n    function Ei(t) {\n      const e = t.value,\n        r = t.key,\n        n = t.styleSpec,\n        i = t.style;\n      if (!e.type) return [new ri(r, e, '\"type\" is required')];\n      const s = re(e.type);\n      let a;\n      switch (s) {\n        case \"vector\":\n        case \"raster\":\n        case \"raster-dem\":\n          return a = ni({\n            key: r,\n            value: e,\n            valueSpec: n[`source_${s.replace(\"-\", \"_\")}`],\n            style: t.style,\n            styleSpec: n,\n            objectElementValidators: Bi\n          }), a;\n        case \"geojson\":\n          if (a = ni({\n            key: r,\n            value: e,\n            valueSpec: n.source_geojson,\n            style: i,\n            styleSpec: n,\n            objectElementValidators: Bi\n          }), e.cluster) for (const t in e.clusterProperties) {\n            const [n, i] = e.clusterProperties[t],\n              s = \"string\" == typeof n ? [n, [\"accumulated\"], [\"get\", t]] : n;\n            a.push(...oi({\n              key: `${r}.${t}.map`,\n              value: i,\n              expressionContext: \"cluster-map\"\n            })), a.push(...oi({\n              key: `${r}.${t}.reduce`,\n              value: s,\n              expressionContext: \"cluster-reduce\"\n            }));\n          }\n          return a;\n        case \"video\":\n          return ni({\n            key: r,\n            value: e,\n            valueSpec: n.source_video,\n            style: i,\n            styleSpec: n\n          });\n        case \"image\":\n          return ni({\n            key: r,\n            value: e,\n            valueSpec: n.source_image,\n            style: i,\n            styleSpec: n\n          });\n        case \"canvas\":\n          return [new ri(r, null, \"Please use runtime APIs to add canvas sources, rather than including them in stylesheets.\", \"source.canvas\")];\n        default:\n          return ui({\n            key: `${r}.type`,\n            value: e.type,\n            valueSpec: {\n              values: Ci(n)\n            },\n            style: i,\n            styleSpec: n\n          });\n      }\n    }\n    function Ci(t) {\n      return t.source.reduce((e, r) => {\n        const n = t[r];\n        return \"enum\" === n.type.type && (e = e.concat(Object.keys(n.type.values))), e;\n      }, []);\n    }\n    function Pi(t) {\n      const e = t.value,\n        r = t.styleSpec,\n        n = r.light,\n        i = t.style;\n      let s = [];\n      const a = Un(e);\n      if (void 0 === e) return s;\n      if (\"object\" !== a) return s = s.concat([new ri(\"light\", e, `object expected, ${a} found`)]), s;\n      for (const t in e) {\n        const a = t.match(/^(.*)-transition$/);\n        s = s.concat(a && n[a[1]] && n[a[1]].transition ? Fi({\n          key: t,\n          value: e[t],\n          valueSpec: r.transition,\n          style: i,\n          styleSpec: r\n        }) : n[t] ? Fi({\n          key: t,\n          value: e[t],\n          valueSpec: n[t],\n          style: i,\n          styleSpec: r\n        }) : [new ri(t, e[t], `unknown property \"${t}\"`)]);\n      }\n      return s;\n    }\n    function Di(t) {\n      const e = t.value,\n        r = t.key,\n        n = t.style,\n        i = t.styleSpec,\n        s = i.terrain;\n      let a = [];\n      const o = Un(e);\n      if (void 0 === e) return a;\n      if (\"object\" !== o) return a = a.concat([new ri(\"terrain\", e, `object expected, ${o} found`)]), a;\n      for (const t in e) {\n        const r = t.match(/^(.*)-transition$/);\n        a = a.concat(r && s[r[1]] && s[r[1]].transition ? Fi({\n          key: t,\n          value: e[t],\n          valueSpec: i.transition,\n          style: n,\n          styleSpec: i\n        }) : s[t] ? Fi({\n          key: t,\n          value: e[t],\n          valueSpec: s[t],\n          style: n,\n          styleSpec: i\n        }) : [new ri(t, e[t], `unknown property \"${t}\"`)]);\n      }\n      if (e.source) {\n        const t = n.sources && n.sources[e.source],\n          i = t && re(t.type);\n        t ? \"raster-dem\" !== i && a.push(new ri(r, e.source, `terrain cannot be used with a source of type ${String(i)}, it only be used with a \"raster-dem\" source type`)) : a.push(new ri(r, e.source, `source \"${e.source}\" not found`));\n      } else a.push(new ri(r, e, 'terrain is missing required property \"source\"'));\n      return a;\n    }\n    function Vi(t) {\n      const e = t.value,\n        r = t.style,\n        n = t.styleSpec,\n        i = n.fog;\n      let s = [];\n      const a = Un(e);\n      if (void 0 === e) return s;\n      if (\"object\" !== a) return s = s.concat([new ri(\"fog\", e, `object expected, ${a} found`)]), s;\n      for (const t in e) {\n        const a = t.match(/^(.*)-transition$/);\n        s = s.concat(a && i[a[1]] && i[a[1]].transition ? Fi({\n          key: t,\n          value: e[t],\n          valueSpec: n.transition,\n          style: r,\n          styleSpec: n\n        }) : i[t] ? Fi({\n          key: t,\n          value: e[t],\n          valueSpec: i[t],\n          style: r,\n          styleSpec: n\n        }) : [new ri(t, e[t], `unknown property \"${t}\"`)]);\n      }\n      return s;\n    }\n    const Li = {\n      \"*\": () => [],\n      array: ii,\n      boolean: function (t) {\n        const e = t.value,\n          r = t.key,\n          n = Un(e);\n        return \"boolean\" !== n ? [new ri(r, e, `boolean expected, ${n} found`)] : [];\n      },\n      number: si,\n      color: function (t) {\n        const e = t.key,\n          r = t.value,\n          n = Un(r);\n        return \"string\" !== n ? [new ri(e, r, `color expected, ${n} found`)] : null === Se(r) ? [new ri(e, r, `color expected, \"${r}\" found`)] : [];\n      },\n      enum: ui,\n      filter: Ai,\n      function: ai,\n      layer: Ti,\n      object: ni,\n      source: Ei,\n      light: Pi,\n      terrain: Di,\n      fog: Vi,\n      string: zi,\n      formatted: function (t) {\n        return 0 === zi(t).length ? [] : oi(t);\n      },\n      resolvedImage: function (t) {\n        return 0 === zi(t).length ? [] : oi(t);\n      },\n      projection: function (t) {\n        const e = t.value,\n          r = t.styleSpec,\n          n = r.projection,\n          i = t.style;\n        let s = [];\n        const a = Un(e);\n        if (\"object\" === a) for (const t in e) s = s.concat(Fi({\n          key: t,\n          value: e[t],\n          valueSpec: n[t],\n          style: i,\n          styleSpec: r\n        }));else \"string\" !== a && (s = s.concat([new ri(\"projection\", e, `object or string expected, ${a} found`)]));\n        return s;\n      }\n    };\n    function Fi(t) {\n      const e = t.value,\n        r = t.valueSpec,\n        n = t.styleSpec;\n      return r.expression && $n(re(e)) ? ai(t) : r.expression && Jn(ne(e)) ? oi(t) : r.type && Li[r.type] ? Li[r.type](t) : ni(ee({}, t, {\n        valueSpec: r.type ? n[r.type] : r\n      }));\n    }\n    function Ri(t) {\n      const e = t.value,\n        r = t.key,\n        n = zi(t);\n      return n.length || (-1 === e.indexOf(\"{fontstack}\") && n.push(new ri(r, e, '\"glyphs\" url must include a \"{fontstack}\" token')), -1 === e.indexOf(\"{range}\") && n.push(new ri(r, e, '\"glyphs\" url must include a \"{range}\" token'))), n;\n    }\n    function Ui(t, e = te) {\n      return Oi(Fi({\n        key: \"\",\n        value: t,\n        valueSpec: e.$root,\n        styleSpec: e,\n        style: t,\n        objectElementValidators: {\n          glyphs: Ri,\n          \"*\": () => []\n        }\n      }));\n    }\n    const $i = t => Oi(Ii(t)),\n      ji = t => Oi(Mi(t));\n    function Oi(t) {\n      return t.slice().sort((t, e) => t.line && e.line ? t.line - e.line : 0);\n    }\n    function qi(t, e) {\n      let r = !1;\n      if (e && e.length) for (const n of e) t.fire(new Wt(new Error(n.message))), r = !0;\n      return r;\n    }\n    var Ni = Zi,\n      Gi = 3;\n    function Zi(t, e, r) {\n      var n = this.cells = [];\n      if (t instanceof ArrayBuffer) {\n        this.arrayBuffer = t;\n        var i = new Int32Array(this.arrayBuffer);\n        t = i[0], this.d = (e = i[1]) + 2 * (r = i[2]);\n        for (var s = 0; s < this.d * this.d; s++) {\n          var a = i[Gi + s],\n            o = i[Gi + s + 1];\n          n.push(a === o ? null : i.subarray(a, o));\n        }\n        var l = i[Gi + n.length + 1];\n        this.keys = i.subarray(i[Gi + n.length], l), this.bboxes = i.subarray(l), this.insert = this._insertReadonly;\n      } else {\n        this.d = e + 2 * r;\n        for (var u = 0; u < this.d * this.d; u++) n.push([]);\n        this.keys = [], this.bboxes = [];\n      }\n      this.n = e, this.extent = t, this.padding = r, this.scale = e / t, this.uid = 0;\n      var c = r / e * t;\n      this.min = -c, this.max = t + c;\n    }\n    Zi.prototype.insert = function (t, e, r, n, i) {\n      this._forEachCell(e, r, n, i, this._insertCell, this.uid++), this.keys.push(t), this.bboxes.push(e), this.bboxes.push(r), this.bboxes.push(n), this.bboxes.push(i);\n    }, Zi.prototype._insertReadonly = function () {\n      throw \"Cannot insert into a GridIndex created from an ArrayBuffer.\";\n    }, Zi.prototype._insertCell = function (t, e, r, n, i, s) {\n      this.cells[i].push(s);\n    }, Zi.prototype.query = function (t, e, r, n, i) {\n      var s = this.min,\n        a = this.max;\n      if (t <= s && e <= s && a <= r && a <= n && !i) return Array.prototype.slice.call(this.keys);\n      var o = [];\n      return this._forEachCell(t, e, r, n, this._queryCell, o, {}, i), o;\n    }, Zi.prototype._queryCell = function (t, e, r, n, i, s, a, o) {\n      var l = this.cells[i];\n      if (null !== l) for (var u = this.keys, c = this.bboxes, h = 0; h < l.length; h++) {\n        var p = l[h];\n        if (void 0 === a[p]) {\n          var d = 4 * p;\n          (o ? o(c[d + 0], c[d + 1], c[d + 2], c[d + 3]) : t <= c[d + 2] && e <= c[d + 3] && r >= c[d + 0] && n >= c[d + 1]) ? (a[p] = !0, s.push(u[p])) : a[p] = !1;\n        }\n      }\n    }, Zi.prototype._forEachCell = function (t, e, r, n, i, s, a, o) {\n      for (var l = this._convertToCellCoord(t), u = this._convertToCellCoord(e), c = this._convertToCellCoord(r), h = this._convertToCellCoord(n), p = l; p <= c; p++) for (var d = u; d <= h; d++) {\n        var f = this.d * d + p;\n        if ((!o || o(this._convertFromCellCoord(p), this._convertFromCellCoord(d), this._convertFromCellCoord(p + 1), this._convertFromCellCoord(d + 1))) && i.call(this, t, e, r, n, f, s, a, o)) return;\n      }\n    }, Zi.prototype._convertFromCellCoord = function (t) {\n      return (t - this.padding) / this.scale;\n    }, Zi.prototype._convertToCellCoord = function (t) {\n      return Math.max(0, Math.min(this.d - 1, Math.floor(t * this.scale) + this.padding));\n    }, Zi.prototype.toArrayBuffer = function () {\n      if (this.arrayBuffer) return this.arrayBuffer;\n      for (var t = this.cells, e = Gi + this.cells.length + 1 + 1, r = 0, n = 0; n < this.cells.length; n++) r += this.cells[n].length;\n      var i = new Int32Array(e + r + this.keys.length + this.bboxes.length);\n      i[0] = this.extent, i[1] = this.n, i[2] = this.padding;\n      for (var s = e, a = 0; a < t.length; a++) {\n        var o = t[a];\n        i[Gi + a] = s, i.set(o, s), s += o.length;\n      }\n      return i[Gi + t.length] = s, i.set(this.keys, s), i[Gi + t.length + 1] = s += this.keys.length, i.set(this.bboxes, s), s += this.bboxes.length, i.buffer;\n    };\n    var Ki = p(Ni);\n    const Xi = {};\n    function Ji(t, e, r = {}) {\n      Object.defineProperty(t, \"_classRegistryKey\", {\n        value: e,\n        writeable: !1\n      }), Xi[e] = {\n        klass: t,\n        omit: r.omit || []\n      };\n    }\n    Ji(Object, \"Object\"), Ki.serialize = function (t, e) {\n      const r = t.toArrayBuffer();\n      return e && e.push(r), {\n        buffer: r\n      };\n    }, Ki.deserialize = function (t) {\n      return new Ki(t.buffer);\n    }, Object.defineProperty(Ki, \"name\", {\n      value: \"Grid\"\n    }), Ji(Ki, \"Grid\"), Ji(Ee, \"Color\"), Ji(Error, \"Error\"), Ji(ut, \"AJAXError\"), Ji(Ve, \"ResolvedImage\"), Ji(ti, \"StylePropertyFunction\"), Ji(Xn, \"StyleExpression\", {\n      omit: [\"_evaluator\"]\n    }), Ji(Wn, \"ZoomDependentExpression\"), Ji(Yn, \"ZoomConstantExpression\"), Ji(tr, \"CompoundExpression\", {\n      omit: [\"_evaluate\"]\n    });\n    for (const t in Pn) Xi[Pn[t]._classRegistryKey] || Ji(Pn[t], `Expression${t}`);\n    function Hi(t) {\n      return t && \"undefined\" != typeof ArrayBuffer && (t instanceof ArrayBuffer || t.constructor && \"ArrayBuffer\" === t.constructor.name);\n    }\n    function Yi(t) {\n      return e.ImageBitmap && t instanceof e.ImageBitmap;\n    }\n    function Wi(t, r) {\n      if (null == t || \"boolean\" == typeof t || \"number\" == typeof t || \"string\" == typeof t || t instanceof Boolean || t instanceof Number || t instanceof String || t instanceof Date || t instanceof RegExp) return t;\n      if (Hi(t) || Yi(t)) return r && r.push(t), t;\n      if (ArrayBuffer.isView(t)) {\n        const e = t;\n        return r && r.push(e.buffer), e;\n      }\n      if (t instanceof e.ImageData) return r && r.push(t.data.buffer), t;\n      if (Array.isArray(t)) {\n        const e = [];\n        for (const n of t) e.push(Wi(n, r));\n        return e;\n      }\n      if (\"object\" == typeof t) {\n        const e = t.constructor,\n          n = e._classRegistryKey;\n        if (!n) throw new Error(`can't serialize object of unregistered class ${n}`);\n        const i = e.serialize ? e.serialize(t, r) : {};\n        if (!e.serialize) {\n          for (const e in t) t.hasOwnProperty(e) && (Xi[n].omit.indexOf(e) >= 0 || (i[e] = Wi(t[e], r)));\n          t instanceof Error && (i.message = t.message);\n        }\n        if (i.$name) throw new Error(\"$name property is reserved for worker serialization logic.\");\n        return \"Object\" !== n && (i.$name = n), i;\n      }\n      throw new Error(\"can't serialize object of type \" + typeof t);\n    }\n    function Qi(t) {\n      if (null == t || \"boolean\" == typeof t || \"number\" == typeof t || \"string\" == typeof t || t instanceof Boolean || t instanceof Number || t instanceof String || t instanceof Date || t instanceof RegExp || Hi(t) || Yi(t) || ArrayBuffer.isView(t) || t instanceof e.ImageData) return t;\n      if (Array.isArray(t)) return t.map(Qi);\n      if (\"object\" == typeof t) {\n        const e = t.$name || \"Object\",\n          {\n            klass: r\n          } = Xi[e];\n        if (!r) throw new Error(`can't deserialize unregistered class ${e}`);\n        if (r.deserialize) return r.deserialize(t);\n        const n = Object.create(r.prototype);\n        for (const e of Object.keys(t)) \"$name\" !== e && (n[e] = Qi(t[e]));\n        return n;\n      }\n      throw new Error(\"can't deserialize object of type \" + typeof t);\n    }\n    const ts = {\n      \"Latin-1 Supplement\": t => t >= 128 && t <= 255,\n      Arabic: t => t >= 1536 && t <= 1791,\n      \"Arabic Supplement\": t => t >= 1872 && t <= 1919,\n      \"Arabic Extended-A\": t => t >= 2208 && t <= 2303,\n      \"Hangul Jamo\": t => t >= 4352 && t <= 4607,\n      \"Unified Canadian Aboriginal Syllabics\": t => t >= 5120 && t <= 5759,\n      Khmer: t => t >= 6016 && t <= 6143,\n      \"Unified Canadian Aboriginal Syllabics Extended\": t => t >= 6320 && t <= 6399,\n      \"General Punctuation\": t => t >= 8192 && t <= 8303,\n      \"Letterlike Symbols\": t => t >= 8448 && t <= 8527,\n      \"Number Forms\": t => t >= 8528 && t <= 8591,\n      \"Miscellaneous Technical\": t => t >= 8960 && t <= 9215,\n      \"Control Pictures\": t => t >= 9216 && t <= 9279,\n      \"Optical Character Recognition\": t => t >= 9280 && t <= 9311,\n      \"Enclosed Alphanumerics\": t => t >= 9312 && t <= 9471,\n      \"Geometric Shapes\": t => t >= 9632 && t <= 9727,\n      \"Miscellaneous Symbols\": t => t >= 9728 && t <= 9983,\n      \"Miscellaneous Symbols and Arrows\": t => t >= 11008 && t <= 11263,\n      \"CJK Radicals Supplement\": t => t >= 11904 && t <= 12031,\n      \"Kangxi Radicals\": t => t >= 12032 && t <= 12255,\n      \"Ideographic Description Characters\": t => t >= 12272 && t <= 12287,\n      \"CJK Symbols and Punctuation\": t => t >= 12288 && t <= 12351,\n      Hiragana: t => t >= 12352 && t <= 12447,\n      Katakana: t => t >= 12448 && t <= 12543,\n      Bopomofo: t => t >= 12544 && t <= 12591,\n      \"Hangul Compatibility Jamo\": t => t >= 12592 && t <= 12687,\n      Kanbun: t => t >= 12688 && t <= 12703,\n      \"Bopomofo Extended\": t => t >= 12704 && t <= 12735,\n      \"CJK Strokes\": t => t >= 12736 && t <= 12783,\n      \"Katakana Phonetic Extensions\": t => t >= 12784 && t <= 12799,\n      \"Enclosed CJK Letters and Months\": t => t >= 12800 && t <= 13055,\n      \"CJK Compatibility\": t => t >= 13056 && t <= 13311,\n      \"CJK Unified Ideographs Extension A\": t => t >= 13312 && t <= 19903,\n      \"Yijing Hexagram Symbols\": t => t >= 19904 && t <= 19967,\n      \"CJK Unified Ideographs\": t => t >= 19968 && t <= 40959,\n      \"Yi Syllables\": t => t >= 40960 && t <= 42127,\n      \"Yi Radicals\": t => t >= 42128 && t <= 42191,\n      \"Hangul Jamo Extended-A\": t => t >= 43360 && t <= 43391,\n      \"Hangul Syllables\": t => t >= 44032 && t <= 55215,\n      \"Hangul Jamo Extended-B\": t => t >= 55216 && t <= 55295,\n      \"Private Use Area\": t => t >= 57344 && t <= 63743,\n      \"CJK Compatibility Ideographs\": t => t >= 63744 && t <= 64255,\n      \"Arabic Presentation Forms-A\": t => t >= 64336 && t <= 65023,\n      \"Vertical Forms\": t => t >= 65040 && t <= 65055,\n      \"CJK Compatibility Forms\": t => t >= 65072 && t <= 65103,\n      \"Small Form Variants\": t => t >= 65104 && t <= 65135,\n      \"Arabic Presentation Forms-B\": t => t >= 65136 && t <= 65279,\n      \"Halfwidth and Fullwidth Forms\": t => t >= 65280 && t <= 65519\n    };\n    function es(t) {\n      for (const e of t) if (is(e.charCodeAt(0))) return !0;\n      return !1;\n    }\n    function rs(t) {\n      for (const e of t) if (!ns(e.charCodeAt(0))) return !1;\n      return !0;\n    }\n    function ns(t) {\n      return !(ts.Arabic(t) || ts[\"Arabic Supplement\"](t) || ts[\"Arabic Extended-A\"](t) || ts[\"Arabic Presentation Forms-A\"](t) || ts[\"Arabic Presentation Forms-B\"](t));\n    }\n    function is(t) {\n      return !(746 !== t && 747 !== t && (t < 4352 || !(ts[\"Bopomofo Extended\"](t) || ts.Bopomofo(t) || ts[\"CJK Compatibility Forms\"](t) && !(t >= 65097 && t <= 65103) || ts[\"CJK Compatibility Ideographs\"](t) || ts[\"CJK Compatibility\"](t) || ts[\"CJK Radicals Supplement\"](t) || ts[\"CJK Strokes\"](t) || !(!ts[\"CJK Symbols and Punctuation\"](t) || t >= 12296 && t <= 12305 || t >= 12308 && t <= 12319 || 12336 === t) || ts[\"CJK Unified Ideographs Extension A\"](t) || ts[\"CJK Unified Ideographs\"](t) || ts[\"Enclosed CJK Letters and Months\"](t) || ts[\"Hangul Compatibility Jamo\"](t) || ts[\"Hangul Jamo Extended-A\"](t) || ts[\"Hangul Jamo Extended-B\"](t) || ts[\"Hangul Jamo\"](t) || ts[\"Hangul Syllables\"](t) || ts.Hiragana(t) || ts[\"Ideographic Description Characters\"](t) || ts.Kanbun(t) || ts[\"Kangxi Radicals\"](t) || ts[\"Katakana Phonetic Extensions\"](t) || ts.Katakana(t) && 12540 !== t || !(!ts[\"Halfwidth and Fullwidth Forms\"](t) || 65288 === t || 65289 === t || 65293 === t || t >= 65306 && t <= 65310 || 65339 === t || 65341 === t || 65343 === t || t >= 65371 && t <= 65503 || 65507 === t || t >= 65512 && t <= 65519) || !(!ts[\"Small Form Variants\"](t) || t >= 65112 && t <= 65118 || t >= 65123 && t <= 65126) || ts[\"Unified Canadian Aboriginal Syllabics\"](t) || ts[\"Unified Canadian Aboriginal Syllabics Extended\"](t) || ts[\"Vertical Forms\"](t) || ts[\"Yijing Hexagram Symbols\"](t) || ts[\"Yi Syllables\"](t) || ts[\"Yi Radicals\"](t))));\n    }\n    function ss(t) {\n      return !(is(t) || function (t) {\n        return !!(ts[\"Latin-1 Supplement\"](t) && (167 === t || 169 === t || 174 === t || 177 === t || 188 === t || 189 === t || 190 === t || 215 === t || 247 === t) || ts[\"General Punctuation\"](t) && (8214 === t || 8224 === t || 8225 === t || 8240 === t || 8241 === t || 8251 === t || 8252 === t || 8258 === t || 8263 === t || 8264 === t || 8265 === t || 8273 === t) || ts[\"Letterlike Symbols\"](t) || ts[\"Number Forms\"](t) || ts[\"Miscellaneous Technical\"](t) && (t >= 8960 && t <= 8967 || t >= 8972 && t <= 8991 || t >= 8996 && t <= 9e3 || 9003 === t || t >= 9085 && t <= 9114 || t >= 9150 && t <= 9165 || 9167 === t || t >= 9169 && t <= 9179 || t >= 9186 && t <= 9215) || ts[\"Control Pictures\"](t) && 9251 !== t || ts[\"Optical Character Recognition\"](t) || ts[\"Enclosed Alphanumerics\"](t) || ts[\"Geometric Shapes\"](t) || ts[\"Miscellaneous Symbols\"](t) && !(t >= 9754 && t <= 9759) || ts[\"Miscellaneous Symbols and Arrows\"](t) && (t >= 11026 && t <= 11055 || t >= 11088 && t <= 11097 || t >= 11192 && t <= 11243) || ts[\"CJK Symbols and Punctuation\"](t) || ts.Katakana(t) || ts[\"Private Use Area\"](t) || ts[\"CJK Compatibility Forms\"](t) || ts[\"Small Form Variants\"](t) || ts[\"Halfwidth and Fullwidth Forms\"](t) || 8734 === t || 8756 === t || 8757 === t || t >= 9984 && t <= 10087 || t >= 10102 && t <= 10131 || 65532 === t || 65533 === t);\n      }(t));\n    }\n    function as(t) {\n      return t >= 1424 && t <= 2303 || ts[\"Arabic Presentation Forms-A\"](t) || ts[\"Arabic Presentation Forms-B\"](t);\n    }\n    function os(t, e) {\n      return !(!e && as(t) || t >= 2304 && t <= 3583 || t >= 3840 && t <= 4255 || ts.Khmer(t));\n    }\n    function ls(t) {\n      for (const e of t) if (as(e.charCodeAt(0))) return !0;\n      return !1;\n    }\n    const us = \"deferred\",\n      cs = \"loading\",\n      hs = \"loaded\";\n    let ps = null,\n      ds = \"unavailable\",\n      fs = null;\n    const ys = function (t) {\n      t && \"string\" == typeof t && t.indexOf(\"NetworkError\") > -1 && (ds = \"error\"), ps && ps(t);\n    };\n    function ms() {\n      gs.fire(new Yt(\"pluginStateChange\", {\n        pluginStatus: ds,\n        pluginURL: fs\n      }));\n    }\n    const gs = new Qt(),\n      xs = function () {\n        return ds;\n      },\n      vs = function () {\n        if (ds !== us || !fs) throw new Error(\"rtl-text-plugin cannot be downloaded unless a pluginURL is specified\");\n        ds = cs, ms(), fs && pt({\n          url: fs\n        }, t => {\n          t ? ys(t) : (ds = hs, ms());\n        });\n      },\n      bs = {\n        applyArabicShaping: null,\n        processBidirectionalText: null,\n        processStyledBidirectionalText: null,\n        isLoaded: () => ds === hs || null != bs.applyArabicShaping,\n        isLoading: () => ds === cs,\n        setState(t) {\n          ds = t.pluginStatus, fs = t.pluginURL;\n        },\n        isParsed: () => null != bs.applyArabicShaping && null != bs.processBidirectionalText && null != bs.processStyledBidirectionalText,\n        getPluginURL: () => fs\n      };\n    class ws {\n      constructor(t, e) {\n        this.zoom = t, e ? (this.now = e.now, this.fadeDuration = e.fadeDuration, this.transition = e.transition, this.pitch = e.pitch) : (this.now = 0, this.fadeDuration = 0, this.transition = {}, this.pitch = 0);\n      }\n      isSupportedScript(t) {\n        return function (t, e) {\n          for (const r of t) if (!os(r.charCodeAt(0), e)) return !1;\n          return !0;\n        }(t, bs.isLoaded());\n      }\n    }\n    class _s {\n      constructor(t, e) {\n        this.property = t, this.value = e, this.expression = function (t, e) {\n          if ($n(t)) return new ti(t, e);\n          if (Jn(t)) {\n            const r = Qn(t, e);\n            if (\"error\" === r.result) throw new Error(r.value.map(t => `${t.key}: ${t.message}`).join(\", \"));\n            return r.value;\n          }\n          {\n            let r = t;\n            return \"string\" == typeof t && \"color\" === e.type && (r = Ee.parse(t)), {\n              kind: \"constant\",\n              evaluate: () => r\n            };\n          }\n        }(void 0 === e ? t.specification.default : e, t.specification);\n      }\n      isDataDriven() {\n        return \"source\" === this.expression.kind || \"composite\" === this.expression.kind;\n      }\n      possiblyEvaluate(t, e, r) {\n        return this.property.possiblyEvaluate(this, t, e, r);\n      }\n    }\n    class As {\n      constructor(t) {\n        this.property = t, this.value = new _s(t, void 0);\n      }\n      transitioned(t, e) {\n        return new ks(this.property, this.value, e, C({}, t.transition, this.transition), t.now);\n      }\n      untransitioned() {\n        return new ks(this.property, this.value, null, {}, 0);\n      }\n    }\n    class Ss {\n      constructor(t) {\n        this._properties = t, this._values = Object.create(t.defaultTransitionablePropertyValues);\n      }\n      getValue(t) {\n        return O(this._values[t].value.value);\n      }\n      setValue(t, e) {\n        this._values.hasOwnProperty(t) || (this._values[t] = new As(this._values[t].property)), this._values[t].value = new _s(this._values[t].property, null === e ? void 0 : O(e));\n      }\n      getTransition(t) {\n        return O(this._values[t].transition);\n      }\n      setTransition(t, e) {\n        this._values.hasOwnProperty(t) || (this._values[t] = new As(this._values[t].property)), this._values[t].transition = O(e) || void 0;\n      }\n      serialize() {\n        const t = {};\n        for (const e of Object.keys(this._values)) {\n          const r = this.getValue(e);\n          void 0 !== r && (t[e] = r);\n          const n = this.getTransition(e);\n          void 0 !== n && (t[`${e}-transition`] = n);\n        }\n        return t;\n      }\n      transitioned(t, e) {\n        const r = new Is(this._properties);\n        for (const n of Object.keys(this._values)) r._values[n] = this._values[n].transitioned(t, e._values[n]);\n        return r;\n      }\n      untransitioned() {\n        const t = new Is(this._properties);\n        for (const e of Object.keys(this._values)) t._values[e] = this._values[e].untransitioned();\n        return t;\n      }\n    }\n    class ks {\n      constructor(t, e, r, n, i) {\n        const s = n.delay || 0,\n          a = n.duration || 0;\n        i = i || 0, this.property = t, this.value = e, this.begin = i + s, this.end = this.begin + a, t.specification.transition && (n.delay || n.duration) && (this.prior = r);\n      }\n      possiblyEvaluate(t, e, r) {\n        const n = t.now || 0,\n          i = this.value.possiblyEvaluate(t, e, r),\n          s = this.prior;\n        if (s) {\n          if (n > this.end) return this.prior = null, i;\n          if (this.value.isDataDriven()) return this.prior = null, i;\n          if (n < this.begin) return s.possiblyEvaluate(t, e, r);\n          {\n            const a = (n - this.begin) / (this.end - this.begin);\n            return this.property.interpolate(s.possiblyEvaluate(t, e, r), i, S(a));\n          }\n        }\n        return i;\n      }\n    }\n    class Is {\n      constructor(t) {\n        this._properties = t, this._values = Object.create(t.defaultTransitioningPropertyValues);\n      }\n      possiblyEvaluate(t, e, r) {\n        const n = new zs(this._properties);\n        for (const i of Object.keys(this._values)) n._values[i] = this._values[i].possiblyEvaluate(t, e, r);\n        return n;\n      }\n      hasTransition() {\n        for (const t of Object.keys(this._values)) if (this._values[t].prior) return !0;\n        return !1;\n      }\n    }\n    class Ms {\n      constructor(t) {\n        this._properties = t, this._values = Object.create(t.defaultPropertyValues);\n      }\n      getValue(t) {\n        return O(this._values[t].value);\n      }\n      setValue(t, e) {\n        this._values[t] = new _s(this._values[t].property, null === e ? void 0 : O(e));\n      }\n      serialize() {\n        const t = {};\n        for (const e of Object.keys(this._values)) {\n          const r = this.getValue(e);\n          void 0 !== r && (t[e] = r);\n        }\n        return t;\n      }\n      possiblyEvaluate(t, e, r) {\n        const n = new zs(this._properties);\n        for (const i of Object.keys(this._values)) n._values[i] = this._values[i].possiblyEvaluate(t, e, r);\n        return n;\n      }\n    }\n    class Ts {\n      constructor(t, e, r) {\n        this.property = t, this.value = e, this.parameters = r;\n      }\n      isConstant() {\n        return \"constant\" === this.value.kind;\n      }\n      constantOr(t) {\n        return \"constant\" === this.value.kind ? this.value.value : t;\n      }\n      evaluate(t, e, r, n) {\n        return this.property.evaluate(this.value, this.parameters, t, e, r, n);\n      }\n    }\n    class zs {\n      constructor(t) {\n        this._properties = t, this._values = Object.create(t.defaultPossiblyEvaluatedValues);\n      }\n      get(t) {\n        return this._values[t];\n      }\n    }\n    class Bs {\n      constructor(t) {\n        this.specification = t;\n      }\n      possiblyEvaluate(t, e) {\n        return t.expression.evaluate(e);\n      }\n      interpolate(t, e, r) {\n        const n = Cr[this.specification.type];\n        return n ? n(t, e, r) : t;\n      }\n    }\n    class Es {\n      constructor(t, e) {\n        this.specification = t, this.overrides = e;\n      }\n      possiblyEvaluate(t, e, r, n) {\n        return new Ts(this, \"constant\" === t.expression.kind || \"camera\" === t.expression.kind ? {\n          kind: \"constant\",\n          value: t.expression.evaluate(e, null, {}, r, n)\n        } : t.expression, e);\n      }\n      interpolate(t, e, r) {\n        if (\"constant\" !== t.value.kind || \"constant\" !== e.value.kind) return t;\n        if (void 0 === t.value.value || void 0 === e.value.value) return new Ts(this, {\n          kind: \"constant\",\n          value: void 0\n        }, t.parameters);\n        const n = Cr[this.specification.type];\n        return n ? new Ts(this, {\n          kind: \"constant\",\n          value: n(t.value.value, e.value.value, r)\n        }, t.parameters) : t;\n      }\n      evaluate(t, e, r, n, i, s) {\n        return \"constant\" === t.kind ? t.value : t.evaluate(e, r, n, i, s);\n      }\n    }\n    class Cs {\n      constructor(t) {\n        this.specification = t;\n      }\n      possiblyEvaluate(t, e, r, n) {\n        return !!t.expression.evaluate(e, null, {}, r, n);\n      }\n      interpolate() {\n        return !1;\n      }\n    }\n    class Ps {\n      constructor(t) {\n        this.properties = t, this.defaultPropertyValues = {}, this.defaultTransitionablePropertyValues = {}, this.defaultTransitioningPropertyValues = {}, this.defaultPossiblyEvaluatedValues = {}, this.overridableProperties = [];\n        const e = new ws(0, {});\n        for (const r in t) {\n          const n = t[r];\n          n.specification.overridable && this.overridableProperties.push(r);\n          const i = this.defaultPropertyValues[r] = new _s(n, void 0),\n            s = this.defaultTransitionablePropertyValues[r] = new As(n);\n          this.defaultTransitioningPropertyValues[r] = s.untransitioned(), this.defaultPossiblyEvaluatedValues[r] = i.possiblyEvaluate(e);\n        }\n      }\n    }\n    function Ds(t, e) {\n      return 256 * (t = M(Math.floor(t), 0, 255)) + M(Math.floor(e), 0, 255);\n    }\n    Ji(Es, \"DataDrivenProperty\"), Ji(Bs, \"DataConstantProperty\"), Ji(Cs, \"ColorRampProperty\");\n    const Vs = {\n      Int8: Int8Array,\n      Uint8: Uint8Array,\n      Int16: Int16Array,\n      Uint16: Uint16Array,\n      Int32: Int32Array,\n      Uint32: Uint32Array,\n      Float32: Float32Array\n    };\n    class Ls {\n      constructor(t, e) {\n        this._structArray = t, this._pos1 = e * this.size, this._pos2 = this._pos1 / 2, this._pos4 = this._pos1 / 4, this._pos8 = this._pos1 / 8;\n      }\n    }\n    class Fs {\n      constructor() {\n        this.isTransferred = !1, this.capacity = -1, this.resize(0);\n      }\n      static serialize(t, e) {\n        return t._trim(), e && (t.isTransferred = !0, e.push(t.arrayBuffer)), {\n          length: t.length,\n          arrayBuffer: t.arrayBuffer\n        };\n      }\n      static deserialize(t) {\n        const e = Object.create(this.prototype);\n        return e.arrayBuffer = t.arrayBuffer, e.length = t.length, e.capacity = t.arrayBuffer.byteLength / e.bytesPerElement, e._refreshViews(), e;\n      }\n      _trim() {\n        this.length !== this.capacity && (this.capacity = this.length, this.arrayBuffer = this.arrayBuffer.slice(0, this.length * this.bytesPerElement), this._refreshViews());\n      }\n      clear() {\n        this.length = 0;\n      }\n      resize(t) {\n        this.reserve(t), this.length = t;\n      }\n      reserve(t) {\n        if (t > this.capacity) {\n          this.capacity = Math.max(t, Math.floor(5 * this.capacity), 128), this.arrayBuffer = new ArrayBuffer(this.capacity * this.bytesPerElement);\n          const e = this.uint8;\n          this._refreshViews(), e && this.uint8.set(e);\n        }\n      }\n      _refreshViews() {\n        throw new Error(\"_refreshViews() must be implemented by each concrete StructArray layout\");\n      }\n      destroy() {\n        this.int8 = this.uint8 = this.int16 = this.uint16 = this.int32 = this.uint32 = this.float32 = null, this.arrayBuffer = null;\n      }\n    }\n    function Rs(t, e = 1) {\n      let r = 0,\n        n = 0;\n      return {\n        members: t.map(t => {\n          const i = Vs[t.type].BYTES_PER_ELEMENT,\n            s = r = Us(r, Math.max(e, i)),\n            a = t.components || 1;\n          return n = Math.max(n, i), r += i * a, {\n            name: t.name,\n            type: t.type,\n            components: a,\n            offset: s\n          };\n        }),\n        size: Us(r, Math.max(n, e)),\n        alignment: e\n      };\n    }\n    function Us(t, e) {\n      return Math.ceil(t / e) * e;\n    }\n    class $s extends Fs {\n      _refreshViews() {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);\n      }\n      emplaceBack(t, e) {\n        const r = this.length;\n        return this.resize(r + 1), this.emplace(r, t, e);\n      }\n      emplace(t, e, r) {\n        const n = 2 * t;\n        return this.int16[n + 0] = e, this.int16[n + 1] = r, t;\n      }\n    }\n    $s.prototype.bytesPerElement = 4, Ji($s, \"StructArrayLayout2i4\");\n    class js extends Fs {\n      _refreshViews() {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);\n      }\n      emplaceBack(t, e, r) {\n        const n = this.length;\n        return this.resize(n + 1), this.emplace(n, t, e, r);\n      }\n      emplace(t, e, r, n) {\n        const i = 3 * t;\n        return this.int16[i + 0] = e, this.int16[i + 1] = r, this.int16[i + 2] = n, t;\n      }\n    }\n    js.prototype.bytesPerElement = 6, Ji(js, \"StructArrayLayout3i6\");\n    class Os extends Fs {\n      _refreshViews() {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);\n      }\n      emplaceBack(t, e, r, n) {\n        const i = this.length;\n        return this.resize(i + 1), this.emplace(i, t, e, r, n);\n      }\n      emplace(t, e, r, n, i) {\n        const s = 4 * t;\n        return this.int16[s + 0] = e, this.int16[s + 1] = r, this.int16[s + 2] = n, this.int16[s + 3] = i, t;\n      }\n    }\n    Os.prototype.bytesPerElement = 8, Ji(Os, \"StructArrayLayout4i8\");\n    class qs extends Fs {\n      _refreshViews() {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);\n      }\n      emplaceBack(t, e, r, n, i, s, a) {\n        const o = this.length;\n        return this.resize(o + 1), this.emplace(o, t, e, r, n, i, s, a);\n      }\n      emplace(t, e, r, n, i, s, a, o) {\n        const l = 6 * t,\n          u = 12 * t,\n          c = 3 * t;\n        return this.int16[l + 0] = e, this.int16[l + 1] = r, this.uint8[u + 4] = n, this.uint8[u + 5] = i, this.uint8[u + 6] = s, this.uint8[u + 7] = a, this.float32[c + 2] = o, t;\n      }\n    }\n    qs.prototype.bytesPerElement = 12, Ji(qs, \"StructArrayLayout2i4ub1f12\");\n    class Ns extends Fs {\n      _refreshViews() {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);\n      }\n      emplaceBack(t, e, r, n) {\n        const i = this.length;\n        return this.resize(i + 1), this.emplace(i, t, e, r, n);\n      }\n      emplace(t, e, r, n, i) {\n        const s = 4 * t;\n        return this.float32[s + 0] = e, this.float32[s + 1] = r, this.float32[s + 2] = n, this.float32[s + 3] = i, t;\n      }\n    }\n    Ns.prototype.bytesPerElement = 16, Ji(Ns, \"StructArrayLayout4f16\");\n    class Gs extends Fs {\n      _refreshViews() {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);\n      }\n      emplaceBack(t, e, r, n, i) {\n        const s = this.length;\n        return this.resize(s + 1), this.emplace(s, t, e, r, n, i);\n      }\n      emplace(t, e, r, n, i, s) {\n        const a = 6 * t,\n          o = 3 * t;\n        return this.uint16[a + 0] = e, this.uint16[a + 1] = r, this.uint16[a + 2] = n, this.uint16[a + 3] = i, this.float32[o + 2] = s, t;\n      }\n    }\n    Gs.prototype.bytesPerElement = 12, Ji(Gs, \"StructArrayLayout4ui1f12\");\n    class Zs extends Fs {\n      _refreshViews() {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);\n      }\n      emplaceBack(t, e, r, n) {\n        const i = this.length;\n        return this.resize(i + 1), this.emplace(i, t, e, r, n);\n      }\n      emplace(t, e, r, n, i) {\n        const s = 4 * t;\n        return this.uint16[s + 0] = e, this.uint16[s + 1] = r, this.uint16[s + 2] = n, this.uint16[s + 3] = i, t;\n      }\n    }\n    Zs.prototype.bytesPerElement = 8, Ji(Zs, \"StructArrayLayout4ui8\");\n    class Ks extends Fs {\n      _refreshViews() {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);\n      }\n      emplaceBack(t, e, r, n, i, s) {\n        const a = this.length;\n        return this.resize(a + 1), this.emplace(a, t, e, r, n, i, s);\n      }\n      emplace(t, e, r, n, i, s, a) {\n        const o = 6 * t;\n        return this.int16[o + 0] = e, this.int16[o + 1] = r, this.int16[o + 2] = n, this.int16[o + 3] = i, this.int16[o + 4] = s, this.int16[o + 5] = a, t;\n      }\n    }\n    Ks.prototype.bytesPerElement = 12, Ji(Ks, \"StructArrayLayout6i12\");\n    class Xs extends Fs {\n      _refreshViews() {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);\n      }\n      emplaceBack(t, e, r, n, i, s, a, o, l, u, c, h) {\n        const p = this.length;\n        return this.resize(p + 1), this.emplace(p, t, e, r, n, i, s, a, o, l, u, c, h);\n      }\n      emplace(t, e, r, n, i, s, a, o, l, u, c, h, p) {\n        const d = 12 * t;\n        return this.int16[d + 0] = e, this.int16[d + 1] = r, this.int16[d + 2] = n, this.int16[d + 3] = i, this.uint16[d + 4] = s, this.uint16[d + 5] = a, this.uint16[d + 6] = o, this.uint16[d + 7] = l, this.int16[d + 8] = u, this.int16[d + 9] = c, this.int16[d + 10] = h, this.int16[d + 11] = p, t;\n      }\n    }\n    Xs.prototype.bytesPerElement = 24, Ji(Xs, \"StructArrayLayout4i4ui4i24\");\n    class Js extends Fs {\n      _refreshViews() {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);\n      }\n      emplaceBack(t, e, r, n, i, s) {\n        const a = this.length;\n        return this.resize(a + 1), this.emplace(a, t, e, r, n, i, s);\n      }\n      emplace(t, e, r, n, i, s, a) {\n        const o = 10 * t,\n          l = 5 * t;\n        return this.int16[o + 0] = e, this.int16[o + 1] = r, this.int16[o + 2] = n, this.float32[l + 2] = i, this.float32[l + 3] = s, this.float32[l + 4] = a, t;\n      }\n    }\n    Js.prototype.bytesPerElement = 20, Ji(Js, \"StructArrayLayout3i3f20\");\n    class Hs extends Fs {\n      _refreshViews() {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer);\n      }\n      emplaceBack(t) {\n        const e = this.length;\n        return this.resize(e + 1), this.emplace(e, t);\n      }\n      emplace(t, e) {\n        return this.uint32[1 * t + 0] = e, t;\n      }\n    }\n    Hs.prototype.bytesPerElement = 4, Ji(Hs, \"StructArrayLayout1ul4\");\n    class Ys extends Fs {\n      _refreshViews() {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);\n      }\n      emplaceBack(t, e, r, n, i, s, a, o, l, u, c, h, p) {\n        const d = this.length;\n        return this.resize(d + 1), this.emplace(d, t, e, r, n, i, s, a, o, l, u, c, h, p);\n      }\n      emplace(t, e, r, n, i, s, a, o, l, u, c, h, p, d) {\n        const f = 20 * t,\n          y = 10 * t;\n        return this.int16[f + 0] = e, this.int16[f + 1] = r, this.int16[f + 2] = n, this.int16[f + 3] = i, this.int16[f + 4] = s, this.float32[y + 3] = a, this.float32[y + 4] = o, this.float32[y + 5] = l, this.float32[y + 6] = u, this.int16[f + 14] = c, this.uint32[y + 8] = h, this.uint16[f + 18] = p, this.uint16[f + 19] = d, t;\n      }\n    }\n    Ys.prototype.bytesPerElement = 40, Ji(Ys, \"StructArrayLayout5i4f1i1ul2ui40\");\n    class Ws extends Fs {\n      _refreshViews() {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);\n      }\n      emplaceBack(t, e, r, n, i, s, a) {\n        const o = this.length;\n        return this.resize(o + 1), this.emplace(o, t, e, r, n, i, s, a);\n      }\n      emplace(t, e, r, n, i, s, a, o) {\n        const l = 8 * t;\n        return this.int16[l + 0] = e, this.int16[l + 1] = r, this.int16[l + 2] = n, this.int16[l + 4] = i, this.int16[l + 5] = s, this.int16[l + 6] = a, this.int16[l + 7] = o, t;\n      }\n    }\n    Ws.prototype.bytesPerElement = 16, Ji(Ws, \"StructArrayLayout3i2i2i16\");\n    class Qs extends Fs {\n      _refreshViews() {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);\n      }\n      emplaceBack(t, e, r, n, i) {\n        const s = this.length;\n        return this.resize(s + 1), this.emplace(s, t, e, r, n, i);\n      }\n      emplace(t, e, r, n, i, s) {\n        const a = 4 * t,\n          o = 8 * t;\n        return this.float32[a + 0] = e, this.float32[a + 1] = r, this.float32[a + 2] = n, this.int16[o + 6] = i, this.int16[o + 7] = s, t;\n      }\n    }\n    Qs.prototype.bytesPerElement = 16, Ji(Qs, \"StructArrayLayout2f1f2i16\");\n    class ta extends Fs {\n      _refreshViews() {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);\n      }\n      emplaceBack(t, e, r, n) {\n        const i = this.length;\n        return this.resize(i + 1), this.emplace(i, t, e, r, n);\n      }\n      emplace(t, e, r, n, i) {\n        const s = 12 * t,\n          a = 3 * t;\n        return this.uint8[s + 0] = e, this.uint8[s + 1] = r, this.float32[a + 1] = n, this.float32[a + 2] = i, t;\n      }\n    }\n    ta.prototype.bytesPerElement = 12, Ji(ta, \"StructArrayLayout2ub2f12\");\n    class ea extends Fs {\n      _refreshViews() {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);\n      }\n      emplaceBack(t, e, r) {\n        const n = this.length;\n        return this.resize(n + 1), this.emplace(n, t, e, r);\n      }\n      emplace(t, e, r, n) {\n        const i = 3 * t;\n        return this.float32[i + 0] = e, this.float32[i + 1] = r, this.float32[i + 2] = n, t;\n      }\n    }\n    ea.prototype.bytesPerElement = 12, Ji(ea, \"StructArrayLayout3f12\");\n    class ra extends Fs {\n      _refreshViews() {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);\n      }\n      emplaceBack(t, e, r) {\n        const n = this.length;\n        return this.resize(n + 1), this.emplace(n, t, e, r);\n      }\n      emplace(t, e, r, n) {\n        const i = 3 * t;\n        return this.uint16[i + 0] = e, this.uint16[i + 1] = r, this.uint16[i + 2] = n, t;\n      }\n    }\n    ra.prototype.bytesPerElement = 6, Ji(ra, \"StructArrayLayout3ui6\");\n    class na extends Fs {\n      _refreshViews() {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer);\n      }\n      emplaceBack(t, e, r, n, i, s, a, o, l, u, c, h, p, d, f, y, m, g, x, v, b) {\n        const w = this.length;\n        return this.resize(w + 1), this.emplace(w, t, e, r, n, i, s, a, o, l, u, c, h, p, d, f, y, m, g, x, v, b);\n      }\n      emplace(t, e, r, n, i, s, a, o, l, u, c, h, p, d, f, y, m, g, x, v, b, w) {\n        const _ = 30 * t,\n          A = 15 * t,\n          S = 60 * t;\n        return this.int16[_ + 0] = e, this.int16[_ + 1] = r, this.int16[_ + 2] = n, this.float32[A + 2] = i, this.float32[A + 3] = s, this.uint16[_ + 8] = a, this.uint16[_ + 9] = o, this.uint32[A + 5] = l, this.uint32[A + 6] = u, this.uint32[A + 7] = c, this.uint16[_ + 16] = h, this.uint16[_ + 17] = p, this.uint16[_ + 18] = d, this.float32[A + 10] = f, this.float32[A + 11] = y, this.uint8[S + 48] = m, this.uint8[S + 49] = g, this.uint8[S + 50] = x, this.uint32[A + 13] = v, this.int16[_ + 28] = b, this.uint8[S + 58] = w, t;\n      }\n    }\n    na.prototype.bytesPerElement = 60, Ji(na, \"StructArrayLayout3i2f2ui3ul3ui2f3ub1ul1i1ub60\");\n    class ia extends Fs {\n      _refreshViews() {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer);\n      }\n      emplaceBack(t, e, r, n, i, s, a, o, l, u, c, h, p, d, f, y, m, g, x, v, b, w, _, A, S, k, I, M, T, z) {\n        const B = this.length;\n        return this.resize(B + 1), this.emplace(B, t, e, r, n, i, s, a, o, l, u, c, h, p, d, f, y, m, g, x, v, b, w, _, A, S, k, I, M, T, z);\n      }\n      emplace(t, e, r, n, i, s, a, o, l, u, c, h, p, d, f, y, m, g, x, v, b, w, _, A, S, k, I, M, T, z, B) {\n        const E = 38 * t,\n          C = 19 * t;\n        return this.int16[E + 0] = e, this.int16[E + 1] = r, this.int16[E + 2] = n, this.float32[C + 2] = i, this.float32[C + 3] = s, this.int16[E + 8] = a, this.int16[E + 9] = o, this.int16[E + 10] = l, this.int16[E + 11] = u, this.int16[E + 12] = c, this.int16[E + 13] = h, this.uint16[E + 14] = p, this.uint16[E + 15] = d, this.uint16[E + 16] = f, this.uint16[E + 17] = y, this.uint16[E + 18] = m, this.uint16[E + 19] = g, this.uint16[E + 20] = x, this.uint16[E + 21] = v, this.uint16[E + 22] = b, this.uint16[E + 23] = w, this.uint16[E + 24] = _, this.uint16[E + 25] = A, this.uint16[E + 26] = S, this.uint16[E + 27] = k, this.uint16[E + 28] = I, this.uint32[C + 15] = M, this.float32[C + 16] = T, this.float32[C + 17] = z, this.float32[C + 18] = B, t;\n      }\n    }\n    ia.prototype.bytesPerElement = 76, Ji(ia, \"StructArrayLayout3i2f6i15ui1ul3f76\");\n    class sa extends Fs {\n      _refreshViews() {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);\n      }\n      emplaceBack(t) {\n        const e = this.length;\n        return this.resize(e + 1), this.emplace(e, t);\n      }\n      emplace(t, e) {\n        return this.float32[1 * t + 0] = e, t;\n      }\n    }\n    sa.prototype.bytesPerElement = 4, Ji(sa, \"StructArrayLayout1f4\");\n    class aa extends Fs {\n      _refreshViews() {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);\n      }\n      emplaceBack(t, e, r, n, i) {\n        const s = this.length;\n        return this.resize(s + 1), this.emplace(s, t, e, r, n, i);\n      }\n      emplace(t, e, r, n, i, s) {\n        const a = 5 * t;\n        return this.float32[a + 0] = e, this.float32[a + 1] = r, this.float32[a + 2] = n, this.float32[a + 3] = i, this.float32[a + 4] = s, t;\n      }\n    }\n    aa.prototype.bytesPerElement = 20, Ji(aa, \"StructArrayLayout5f20\");\n    class oa extends Fs {\n      _refreshViews() {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);\n      }\n      emplaceBack(t, e, r, n) {\n        const i = this.length;\n        return this.resize(i + 1), this.emplace(i, t, e, r, n);\n      }\n      emplace(t, e, r, n, i) {\n        const s = 6 * t;\n        return this.uint32[3 * t + 0] = e, this.uint16[s + 2] = r, this.uint16[s + 3] = n, this.uint16[s + 4] = i, t;\n      }\n    }\n    oa.prototype.bytesPerElement = 12, Ji(oa, \"StructArrayLayout1ul3ui12\");\n    class la extends Fs {\n      _refreshViews() {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);\n      }\n      emplaceBack(t, e) {\n        const r = this.length;\n        return this.resize(r + 1), this.emplace(r, t, e);\n      }\n      emplace(t, e, r) {\n        const n = 2 * t;\n        return this.uint16[n + 0] = e, this.uint16[n + 1] = r, t;\n      }\n    }\n    la.prototype.bytesPerElement = 4, Ji(la, \"StructArrayLayout2ui4\");\n    class ua extends Fs {\n      _refreshViews() {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);\n      }\n      emplaceBack(t) {\n        const e = this.length;\n        return this.resize(e + 1), this.emplace(e, t);\n      }\n      emplace(t, e) {\n        return this.uint16[1 * t + 0] = e, t;\n      }\n    }\n    ua.prototype.bytesPerElement = 2, Ji(ua, \"StructArrayLayout1ui2\");\n    class ca extends Fs {\n      _refreshViews() {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);\n      }\n      emplaceBack(t, e) {\n        const r = this.length;\n        return this.resize(r + 1), this.emplace(r, t, e);\n      }\n      emplace(t, e, r) {\n        const n = 2 * t;\n        return this.float32[n + 0] = e, this.float32[n + 1] = r, t;\n      }\n    }\n    ca.prototype.bytesPerElement = 8, Ji(ca, \"StructArrayLayout2f8\");\n    class ha extends Ls {\n      get projectedAnchorX() {\n        return this._structArray.int16[this._pos2 + 0];\n      }\n      get projectedAnchorY() {\n        return this._structArray.int16[this._pos2 + 1];\n      }\n      get projectedAnchorZ() {\n        return this._structArray.int16[this._pos2 + 2];\n      }\n      get tileAnchorX() {\n        return this._structArray.int16[this._pos2 + 3];\n      }\n      get tileAnchorY() {\n        return this._structArray.int16[this._pos2 + 4];\n      }\n      get x1() {\n        return this._structArray.float32[this._pos4 + 3];\n      }\n      get y1() {\n        return this._structArray.float32[this._pos4 + 4];\n      }\n      get x2() {\n        return this._structArray.float32[this._pos4 + 5];\n      }\n      get y2() {\n        return this._structArray.float32[this._pos4 + 6];\n      }\n      get padding() {\n        return this._structArray.int16[this._pos2 + 14];\n      }\n      get featureIndex() {\n        return this._structArray.uint32[this._pos4 + 8];\n      }\n      get sourceLayerIndex() {\n        return this._structArray.uint16[this._pos2 + 18];\n      }\n      get bucketIndex() {\n        return this._structArray.uint16[this._pos2 + 19];\n      }\n    }\n    ha.prototype.size = 40;\n    class pa extends Ys {\n      get(t) {\n        return new ha(this, t);\n      }\n    }\n    Ji(pa, \"CollisionBoxArray\");\n    class da extends Ls {\n      get projectedAnchorX() {\n        return this._structArray.int16[this._pos2 + 0];\n      }\n      get projectedAnchorY() {\n        return this._structArray.int16[this._pos2 + 1];\n      }\n      get projectedAnchorZ() {\n        return this._structArray.int16[this._pos2 + 2];\n      }\n      get tileAnchorX() {\n        return this._structArray.float32[this._pos4 + 2];\n      }\n      get tileAnchorY() {\n        return this._structArray.float32[this._pos4 + 3];\n      }\n      get glyphStartIndex() {\n        return this._structArray.uint16[this._pos2 + 8];\n      }\n      get numGlyphs() {\n        return this._structArray.uint16[this._pos2 + 9];\n      }\n      get vertexStartIndex() {\n        return this._structArray.uint32[this._pos4 + 5];\n      }\n      get lineStartIndex() {\n        return this._structArray.uint32[this._pos4 + 6];\n      }\n      get lineLength() {\n        return this._structArray.uint32[this._pos4 + 7];\n      }\n      get segment() {\n        return this._structArray.uint16[this._pos2 + 16];\n      }\n      get lowerSize() {\n        return this._structArray.uint16[this._pos2 + 17];\n      }\n      get upperSize() {\n        return this._structArray.uint16[this._pos2 + 18];\n      }\n      get lineOffsetX() {\n        return this._structArray.float32[this._pos4 + 10];\n      }\n      get lineOffsetY() {\n        return this._structArray.float32[this._pos4 + 11];\n      }\n      get writingMode() {\n        return this._structArray.uint8[this._pos1 + 48];\n      }\n      get placedOrientation() {\n        return this._structArray.uint8[this._pos1 + 49];\n      }\n      set placedOrientation(t) {\n        this._structArray.uint8[this._pos1 + 49] = t;\n      }\n      get hidden() {\n        return this._structArray.uint8[this._pos1 + 50];\n      }\n      set hidden(t) {\n        this._structArray.uint8[this._pos1 + 50] = t;\n      }\n      get crossTileID() {\n        return this._structArray.uint32[this._pos4 + 13];\n      }\n      set crossTileID(t) {\n        this._structArray.uint32[this._pos4 + 13] = t;\n      }\n      get associatedIconIndex() {\n        return this._structArray.int16[this._pos2 + 28];\n      }\n      get flipState() {\n        return this._structArray.uint8[this._pos1 + 58];\n      }\n      set flipState(t) {\n        this._structArray.uint8[this._pos1 + 58] = t;\n      }\n    }\n    da.prototype.size = 60;\n    class fa extends na {\n      get(t) {\n        return new da(this, t);\n      }\n    }\n    Ji(fa, \"PlacedSymbolArray\");\n    class ya extends Ls {\n      get projectedAnchorX() {\n        return this._structArray.int16[this._pos2 + 0];\n      }\n      get projectedAnchorY() {\n        return this._structArray.int16[this._pos2 + 1];\n      }\n      get projectedAnchorZ() {\n        return this._structArray.int16[this._pos2 + 2];\n      }\n      get tileAnchorX() {\n        return this._structArray.float32[this._pos4 + 2];\n      }\n      get tileAnchorY() {\n        return this._structArray.float32[this._pos4 + 3];\n      }\n      get rightJustifiedTextSymbolIndex() {\n        return this._structArray.int16[this._pos2 + 8];\n      }\n      get centerJustifiedTextSymbolIndex() {\n        return this._structArray.int16[this._pos2 + 9];\n      }\n      get leftJustifiedTextSymbolIndex() {\n        return this._structArray.int16[this._pos2 + 10];\n      }\n      get verticalPlacedTextSymbolIndex() {\n        return this._structArray.int16[this._pos2 + 11];\n      }\n      get placedIconSymbolIndex() {\n        return this._structArray.int16[this._pos2 + 12];\n      }\n      get verticalPlacedIconSymbolIndex() {\n        return this._structArray.int16[this._pos2 + 13];\n      }\n      get key() {\n        return this._structArray.uint16[this._pos2 + 14];\n      }\n      get textBoxStartIndex() {\n        return this._structArray.uint16[this._pos2 + 15];\n      }\n      get textBoxEndIndex() {\n        return this._structArray.uint16[this._pos2 + 16];\n      }\n      get verticalTextBoxStartIndex() {\n        return this._structArray.uint16[this._pos2 + 17];\n      }\n      get verticalTextBoxEndIndex() {\n        return this._structArray.uint16[this._pos2 + 18];\n      }\n      get iconBoxStartIndex() {\n        return this._structArray.uint16[this._pos2 + 19];\n      }\n      get iconBoxEndIndex() {\n        return this._structArray.uint16[this._pos2 + 20];\n      }\n      get verticalIconBoxStartIndex() {\n        return this._structArray.uint16[this._pos2 + 21];\n      }\n      get verticalIconBoxEndIndex() {\n        return this._structArray.uint16[this._pos2 + 22];\n      }\n      get featureIndex() {\n        return this._structArray.uint16[this._pos2 + 23];\n      }\n      get numHorizontalGlyphVertices() {\n        return this._structArray.uint16[this._pos2 + 24];\n      }\n      get numVerticalGlyphVertices() {\n        return this._structArray.uint16[this._pos2 + 25];\n      }\n      get numIconVertices() {\n        return this._structArray.uint16[this._pos2 + 26];\n      }\n      get numVerticalIconVertices() {\n        return this._structArray.uint16[this._pos2 + 27];\n      }\n      get useRuntimeCollisionCircles() {\n        return this._structArray.uint16[this._pos2 + 28];\n      }\n      get crossTileID() {\n        return this._structArray.uint32[this._pos4 + 15];\n      }\n      set crossTileID(t) {\n        this._structArray.uint32[this._pos4 + 15] = t;\n      }\n      get textOffset0() {\n        return this._structArray.float32[this._pos4 + 16];\n      }\n      get textOffset1() {\n        return this._structArray.float32[this._pos4 + 17];\n      }\n      get collisionCircleDiameter() {\n        return this._structArray.float32[this._pos4 + 18];\n      }\n    }\n    ya.prototype.size = 76;\n    class ma extends ia {\n      get(t) {\n        return new ya(this, t);\n      }\n    }\n    Ji(ma, \"SymbolInstanceArray\");\n    class ga extends sa {\n      getoffsetX(t) {\n        return this.float32[1 * t + 0];\n      }\n    }\n    Ji(ga, \"GlyphOffsetArray\");\n    class xa extends $s {\n      getx(t) {\n        return this.int16[2 * t + 0];\n      }\n      gety(t) {\n        return this.int16[2 * t + 1];\n      }\n    }\n    Ji(xa, \"SymbolLineVertexArray\");\n    class va extends Ls {\n      get featureIndex() {\n        return this._structArray.uint32[this._pos4 + 0];\n      }\n      get sourceLayerIndex() {\n        return this._structArray.uint16[this._pos2 + 2];\n      }\n      get bucketIndex() {\n        return this._structArray.uint16[this._pos2 + 3];\n      }\n      get layoutVertexArrayOffset() {\n        return this._structArray.uint16[this._pos2 + 4];\n      }\n    }\n    va.prototype.size = 12;\n    class ba extends oa {\n      get(t) {\n        return new va(this, t);\n      }\n    }\n    Ji(ba, \"FeatureIndexArray\");\n    class wa extends la {\n      geta_centroid_pos0(t) {\n        return this.uint16[2 * t + 0];\n      }\n      geta_centroid_pos1(t) {\n        return this.uint16[2 * t + 1];\n      }\n    }\n    Ji(wa, \"FillExtrusionCentroidArray\");\n    const _a = Rs([{\n        name: \"a_pattern\",\n        components: 4,\n        type: \"Uint16\"\n      }, {\n        name: \"a_pixel_ratio\",\n        components: 1,\n        type: \"Float32\"\n      }]),\n      Aa = Rs([{\n        name: \"a_dash\",\n        components: 4,\n        type: \"Uint16\"\n      }]);\n    var Sa = {\n        exports: {}\n      },\n      ka = {\n        exports: {}\n      };\n    ka.exports = function (t, e) {\n      var r, n, i, s, a, o, l, u;\n      for (n = t.length - (r = 3 & t.length), i = e, a = 3432918353, o = 461845907, u = 0; u < n;) l = 255 & t.charCodeAt(u) | (255 & t.charCodeAt(++u)) << 8 | (255 & t.charCodeAt(++u)) << 16 | (255 & t.charCodeAt(++u)) << 24, ++u, i = 27492 + (65535 & (s = 5 * (65535 & (i = (i ^= l = (65535 & (l = (l = (65535 & l) * a + (((l >>> 16) * a & 65535) << 16) & 4294967295) << 15 | l >>> 17)) * o + (((l >>> 16) * o & 65535) << 16) & 4294967295) << 13 | i >>> 19)) + ((5 * (i >>> 16) & 65535) << 16) & 4294967295)) + ((58964 + (s >>> 16) & 65535) << 16);\n      switch (l = 0, r) {\n        case 3:\n          l ^= (255 & t.charCodeAt(u + 2)) << 16;\n        case 2:\n          l ^= (255 & t.charCodeAt(u + 1)) << 8;\n        case 1:\n          i ^= l = (65535 & (l = (l = (65535 & (l ^= 255 & t.charCodeAt(u))) * a + (((l >>> 16) * a & 65535) << 16) & 4294967295) << 15 | l >>> 17)) * o + (((l >>> 16) * o & 65535) << 16) & 4294967295;\n      }\n      return i ^= t.length, i = 2246822507 * (65535 & (i ^= i >>> 16)) + ((2246822507 * (i >>> 16) & 65535) << 16) & 4294967295, i = 3266489909 * (65535 & (i ^= i >>> 13)) + ((3266489909 * (i >>> 16) & 65535) << 16) & 4294967295, (i ^= i >>> 16) >>> 0;\n    };\n    var Ia = ka.exports,\n      Ma = {\n        exports: {}\n      };\n    Ma.exports = function (t, e) {\n      for (var r, n = t.length, i = e ^ n, s = 0; n >= 4;) r = 1540483477 * (65535 & (r = 255 & t.charCodeAt(s) | (255 & t.charCodeAt(++s)) << 8 | (255 & t.charCodeAt(++s)) << 16 | (255 & t.charCodeAt(++s)) << 24)) + ((1540483477 * (r >>> 16) & 65535) << 16), i = 1540483477 * (65535 & i) + ((1540483477 * (i >>> 16) & 65535) << 16) ^ (r = 1540483477 * (65535 & (r ^= r >>> 24)) + ((1540483477 * (r >>> 16) & 65535) << 16)), n -= 4, ++s;\n      switch (n) {\n        case 3:\n          i ^= (255 & t.charCodeAt(s + 2)) << 16;\n        case 2:\n          i ^= (255 & t.charCodeAt(s + 1)) << 8;\n        case 1:\n          i = 1540483477 * (65535 & (i ^= 255 & t.charCodeAt(s))) + ((1540483477 * (i >>> 16) & 65535) << 16);\n      }\n      return i = 1540483477 * (65535 & (i ^= i >>> 13)) + ((1540483477 * (i >>> 16) & 65535) << 16), (i ^= i >>> 15) >>> 0;\n    };\n    var Ta = Ia,\n      za = Ma.exports;\n    Sa.exports = Ta, Sa.exports.murmur3 = Ta, Sa.exports.murmur2 = za;\n    var Ba = p(Sa.exports);\n    class Ea {\n      constructor() {\n        this.ids = [], this.positions = [], this.indexed = !1;\n      }\n      add(t, e, r, n) {\n        this.ids.push(Ca(t)), this.positions.push(e, r, n);\n      }\n      getPositions(t) {\n        const e = Ca(t);\n        let r = 0,\n          n = this.ids.length - 1;\n        for (; r < n;) {\n          const t = r + n >> 1;\n          this.ids[t] >= e ? n = t : r = t + 1;\n        }\n        const i = [];\n        for (; this.ids[r] === e;) i.push({\n          index: this.positions[3 * r],\n          start: this.positions[3 * r + 1],\n          end: this.positions[3 * r + 2]\n        }), r++;\n        return i;\n      }\n      static serialize(t, e) {\n        const r = new Float64Array(t.ids),\n          n = new Uint32Array(t.positions);\n        return Pa(r, n, 0, r.length - 1), e && e.push(r.buffer, n.buffer), {\n          ids: r,\n          positions: n\n        };\n      }\n      static deserialize(t) {\n        const e = new Ea();\n        return e.ids = t.ids, e.positions = t.positions, e.indexed = !0, e;\n      }\n    }\n    function Ca(t) {\n      const e = +t;\n      return !isNaN(e) && Number.MIN_SAFE_INTEGER <= e && e <= Number.MAX_SAFE_INTEGER ? e : Ba(String(t));\n    }\n    function Pa(t, e, r, n) {\n      for (; r < n;) {\n        const i = t[r + n >> 1];\n        let s = r - 1,\n          a = n + 1;\n        for (;;) {\n          do {\n            s++;\n          } while (t[s] < i);\n          do {\n            a--;\n          } while (t[a] > i);\n          if (s >= a) break;\n          Da(t, s, a), Da(e, 3 * s, 3 * a), Da(e, 3 * s + 1, 3 * a + 1), Da(e, 3 * s + 2, 3 * a + 2);\n        }\n        a - r < n - a ? (Pa(t, e, r, a), r = a + 1) : (Pa(t, e, a + 1, n), n = a);\n      }\n    }\n    function Da(t, e, r) {\n      const n = t[e];\n      t[e] = t[r], t[r] = n;\n    }\n    Ji(Ea, \"FeaturePositionMap\");\n    class Va {\n      constructor(t) {\n        this.gl = t.gl, this.initialized = !1;\n      }\n      fetchUniformLocation(t, e) {\n        return this.location || this.initialized || (this.location = this.gl.getUniformLocation(t, e), this.initialized = !0), !!this.location;\n      }\n    }\n    class La extends Va {\n      constructor(t) {\n        super(t), this.current = 0;\n      }\n      set(t, e, r) {\n        this.fetchUniformLocation(t, e) && this.current !== r && (this.current = r, this.gl.uniform1f(this.location, r));\n      }\n    }\n    class Fa extends Va {\n      constructor(t) {\n        super(t), this.current = [0, 0, 0, 0];\n      }\n      set(t, e, r) {\n        this.fetchUniformLocation(t, e) && (r[0] === this.current[0] && r[1] === this.current[1] && r[2] === this.current[2] && r[3] === this.current[3] || (this.current = r, this.gl.uniform4f(this.location, r[0], r[1], r[2], r[3])));\n      }\n    }\n    class Ra extends Va {\n      constructor(t) {\n        super(t), this.current = Ee.transparent;\n      }\n      set(t, e, r) {\n        this.fetchUniformLocation(t, e) && (r.r === this.current.r && r.g === this.current.g && r.b === this.current.b && r.a === this.current.a || (this.current = r, this.gl.uniform4f(this.location, r.r, r.g, r.b, r.a)));\n      }\n    }\n    const Ua = new Float32Array(16),\n      $a = new Float32Array(9),\n      ja = new Float32Array(4);\n    function Oa(t) {\n      return [Ds(255 * t.r, 255 * t.g), Ds(255 * t.b, 255 * t.a)];\n    }\n    class qa {\n      constructor(t, e, r) {\n        this.value = t, this.uniformNames = e.map(t => `u_${t}`), this.type = r;\n      }\n      setUniform(t, e, r, n, i) {\n        e.set(t, i, n.constantOr(this.value));\n      }\n      getBinding(t, e) {\n        return \"color\" === this.type ? new Ra(t) : new La(t);\n      }\n    }\n    class Na {\n      constructor(t, e) {\n        this.uniformNames = e.map(t => `u_${t}`), this.pattern = null, this.pixelRatio = 1;\n      }\n      setConstantPatternPositions(t) {\n        this.pixelRatio = t.pixelRatio || 1, this.pattern = t.tl.concat(t.br);\n      }\n      setUniform(t, e, r, n, i) {\n        const s = \"u_pattern\" === i || \"u_dash\" === i ? this.pattern : \"u_pixel_ratio\" === i ? this.pixelRatio : null;\n        s && e.set(t, i, s);\n      }\n      getBinding(t, e) {\n        return \"u_pattern\" === e || \"u_dash\" === e ? new Fa(t) : new La(t);\n      }\n    }\n    class Ga {\n      constructor(t, e, r, n) {\n        this.expression = t, this.type = r, this.maxValue = 0, this.paintVertexAttributes = e.map(t => ({\n          name: `a_${t}`,\n          type: \"Float32\",\n          components: \"color\" === r ? 2 : 1,\n          offset: 0\n        })), this.paintVertexArray = new n();\n      }\n      populatePaintArray(t, e, r, n, i, s) {\n        const a = this.paintVertexArray.length,\n          o = this.expression.evaluate(new ws(0), e, {}, i, n, s);\n        this.paintVertexArray.resize(t), this._setPaintValue(a, t, o);\n      }\n      updatePaintArray(t, e, r, n, i) {\n        const s = this.expression.evaluate({\n          zoom: 0\n        }, r, n, void 0, i);\n        this._setPaintValue(t, e, s);\n      }\n      _setPaintValue(t, e, r) {\n        if (\"color\" === this.type) {\n          const n = Oa(r);\n          for (let r = t; r < e; r++) this.paintVertexArray.emplace(r, n[0], n[1]);\n        } else {\n          for (let n = t; n < e; n++) this.paintVertexArray.emplace(n, r);\n          this.maxValue = Math.max(this.maxValue, Math.abs(r));\n        }\n      }\n      upload(t) {\n        this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = t.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent));\n      }\n      destroy() {\n        this.paintVertexBuffer && this.paintVertexBuffer.destroy();\n      }\n    }\n    class Za {\n      constructor(t, e, r, n, i, s) {\n        this.expression = t, this.uniformNames = e.map(t => `u_${t}_t`), this.type = r, this.useIntegerZoom = n, this.zoom = i, this.maxValue = 0, this.paintVertexAttributes = e.map(t => ({\n          name: `a_${t}`,\n          type: \"Float32\",\n          components: \"color\" === r ? 4 : 2,\n          offset: 0\n        })), this.paintVertexArray = new s();\n      }\n      populatePaintArray(t, e, r, n, i, s) {\n        const a = this.expression.evaluate(new ws(this.zoom), e, {}, i, n, s),\n          o = this.expression.evaluate(new ws(this.zoom + 1), e, {}, i, n, s),\n          l = this.paintVertexArray.length;\n        this.paintVertexArray.resize(t), this._setPaintValue(l, t, a, o);\n      }\n      updatePaintArray(t, e, r, n, i) {\n        const s = this.expression.evaluate({\n            zoom: this.zoom\n          }, r, n, void 0, i),\n          a = this.expression.evaluate({\n            zoom: this.zoom + 1\n          }, r, n, void 0, i);\n        this._setPaintValue(t, e, s, a);\n      }\n      _setPaintValue(t, e, r, n) {\n        if (\"color\" === this.type) {\n          const i = Oa(r),\n            s = Oa(n);\n          for (let r = t; r < e; r++) this.paintVertexArray.emplace(r, i[0], i[1], s[0], s[1]);\n        } else {\n          for (let i = t; i < e; i++) this.paintVertexArray.emplace(i, r, n);\n          this.maxValue = Math.max(this.maxValue, Math.abs(r), Math.abs(n));\n        }\n      }\n      upload(t) {\n        this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = t.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent));\n      }\n      destroy() {\n        this.paintVertexBuffer && this.paintVertexBuffer.destroy();\n      }\n      setUniform(t, e, r, n, i) {\n        const s = this.useIntegerZoom ? Math.floor(r.zoom) : r.zoom,\n          a = M(this.expression.interpolationFactor(s, this.zoom, this.zoom + 1), 0, 1);\n        e.set(t, i, a);\n      }\n      getBinding(t, e) {\n        return new La(t);\n      }\n    }\n    class Ka {\n      constructor(t, e, r, n, i) {\n        this.expression = t, this.layerId = i, this.paintVertexAttributes = (\"array\" === r ? Aa : _a).members;\n        for (let t = 0; t < e.length; ++t);\n        this.paintVertexArray = new n();\n      }\n      populatePaintArray(t, e, r) {\n        const n = this.paintVertexArray.length;\n        this.paintVertexArray.resize(t), this._setPaintValues(n, t, e.patterns && e.patterns[this.layerId], r);\n      }\n      updatePaintArray(t, e, r, n, i, s) {\n        this._setPaintValues(t, e, r.patterns && r.patterns[this.layerId], s);\n      }\n      _setPaintValues(t, e, r, n) {\n        if (!n || !r) return;\n        const i = n[r];\n        if (!i) return;\n        const {\n          tl: s,\n          br: a,\n          pixelRatio: o\n        } = i;\n        for (let r = t; r < e; r++) this.paintVertexArray.emplace(r, s[0], s[1], a[0], a[1], o);\n      }\n      upload(t) {\n        this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer = t.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent));\n      }\n      destroy() {\n        this.paintVertexBuffer && this.paintVertexBuffer.destroy();\n      }\n    }\n    class Xa {\n      constructor(t, e, r = () => !0) {\n        this.binders = {}, this._buffers = [];\n        const n = [];\n        for (const i in t.paint._values) {\n          if (!r(i)) continue;\n          const s = t.paint.get(i);\n          if (!(s instanceof Ts && Ln(s.property.specification))) continue;\n          const a = Ya(i, t.type),\n            o = s.value,\n            l = s.property.specification.type,\n            u = !!s.property.useIntegerZoom,\n            c = \"line-dasharray\" === i || i.endsWith(\"pattern\"),\n            h = \"line-dasharray\" === i && \"constant\" !== t.layout.get(\"line-cap\").value.kind;\n          if (\"constant\" !== o.kind || h) {\n            if (\"source\" === o.kind || h || c) {\n              const e = to(i, l, \"source\");\n              this.binders[i] = c ? new Ka(o, a, l, e, t.id) : new Ga(o, a, l, e), n.push(`/a_${i}`);\n            } else {\n              const t = to(i, l, \"composite\");\n              this.binders[i] = new Za(o, a, l, u, e, t), n.push(`/z_${i}`);\n            }\n          } else this.binders[i] = c ? new Na(o.value, a) : new qa(o.value, a, l), n.push(`/u_${i}`);\n        }\n        this.cacheKey = n.sort().join(\"\");\n      }\n      getMaxValue(t) {\n        const e = this.binders[t];\n        return e instanceof Ga || e instanceof Za ? e.maxValue : 0;\n      }\n      populatePaintArrays(t, e, r, n, i, s) {\n        for (const a in this.binders) {\n          const o = this.binders[a];\n          (o instanceof Ga || o instanceof Za || o instanceof Ka) && o.populatePaintArray(t, e, r, n, i, s);\n        }\n      }\n      setConstantPatternPositions(t) {\n        for (const e in this.binders) {\n          const r = this.binders[e];\n          r instanceof Na && r.setConstantPatternPositions(t);\n        }\n      }\n      updatePaintArrays(t, e, r, n, i, s) {\n        let a = !1;\n        for (const o in t) {\n          const l = e.getPositions(o);\n          for (const e of l) {\n            const l = r.feature(e.index);\n            for (const r in this.binders) {\n              const u = this.binders[r];\n              if ((u instanceof Ga || u instanceof Za || u instanceof Ka) && !0 === u.expression.isStateDependent) {\n                const c = n.paint.get(r);\n                u.expression = c.value, u.updatePaintArray(e.start, e.end, l, t[o], i, s), a = !0;\n              }\n            }\n          }\n        }\n        return a;\n      }\n      defines() {\n        const t = [];\n        for (const e in this.binders) {\n          const r = this.binders[e];\n          (r instanceof qa || r instanceof Na) && t.push(...r.uniformNames.map(t => `#define HAS_UNIFORM_${t}`));\n        }\n        return t;\n      }\n      getBinderAttributes() {\n        const t = [];\n        for (const e in this.binders) {\n          const r = this.binders[e];\n          if (r instanceof Ga || r instanceof Za || r instanceof Ka) for (let e = 0; e < r.paintVertexAttributes.length; e++) t.push(r.paintVertexAttributes[e].name);\n        }\n        return t;\n      }\n      getBinderUniforms() {\n        const t = [];\n        for (const e in this.binders) {\n          const r = this.binders[e];\n          if (r instanceof qa || r instanceof Na || r instanceof Za) for (const e of r.uniformNames) t.push(e);\n        }\n        return t;\n      }\n      getPaintVertexBuffers() {\n        return this._buffers;\n      }\n      getUniforms(t) {\n        const e = [];\n        for (const r in this.binders) {\n          const n = this.binders[r];\n          if (n instanceof qa || n instanceof Na || n instanceof Za) for (const i of n.uniformNames) e.push({\n            name: i,\n            property: r,\n            binding: n.getBinding(t, i)\n          });\n        }\n        return e;\n      }\n      setUniforms(t, e, r, n, i) {\n        for (const {\n          name: e,\n          property: s,\n          binding: a\n        } of r) this.binders[s].setUniform(t, a, i, n.get(s), e);\n      }\n      updatePaintBuffers() {\n        this._buffers = [];\n        for (const t in this.binders) {\n          const e = this.binders[t];\n          (e instanceof Ga || e instanceof Za || e instanceof Ka) && e.paintVertexBuffer && this._buffers.push(e.paintVertexBuffer);\n        }\n      }\n      upload(t) {\n        for (const e in this.binders) {\n          const r = this.binders[e];\n          (r instanceof Ga || r instanceof Za || r instanceof Ka) && r.upload(t);\n        }\n        this.updatePaintBuffers();\n      }\n      destroy() {\n        for (const t in this.binders) {\n          const e = this.binders[t];\n          (e instanceof Ga || e instanceof Za || e instanceof Ka) && e.destroy();\n        }\n      }\n    }\n    class Ja {\n      constructor(t, e, r = () => !0) {\n        this.programConfigurations = {};\n        for (const n of t) this.programConfigurations[n.id] = new Xa(n, e, r);\n        this.needsUpload = !1, this._featureMap = new Ea(), this._bufferOffset = 0;\n      }\n      populatePaintArrays(t, e, r, n, i, s, a) {\n        for (const r in this.programConfigurations) this.programConfigurations[r].populatePaintArrays(t, e, n, i, s, a);\n        void 0 !== e.id && this._featureMap.add(e.id, r, this._bufferOffset, t), this._bufferOffset = t, this.needsUpload = !0;\n      }\n      updatePaintArrays(t, e, r, n, i) {\n        for (const s of r) this.needsUpload = this.programConfigurations[s.id].updatePaintArrays(t, this._featureMap, e, s, n, i) || this.needsUpload;\n      }\n      get(t) {\n        return this.programConfigurations[t];\n      }\n      upload(t) {\n        if (this.needsUpload) {\n          for (const e in this.programConfigurations) this.programConfigurations[e].upload(t);\n          this.needsUpload = !1;\n        }\n      }\n      destroy() {\n        for (const t in this.programConfigurations) this.programConfigurations[t].destroy();\n      }\n    }\n    const Ha = {\n      \"text-opacity\": [\"opacity\"],\n      \"icon-opacity\": [\"opacity\"],\n      \"text-color\": [\"fill_color\"],\n      \"icon-color\": [\"fill_color\"],\n      \"text-halo-color\": [\"halo_color\"],\n      \"icon-halo-color\": [\"halo_color\"],\n      \"text-halo-blur\": [\"halo_blur\"],\n      \"icon-halo-blur\": [\"halo_blur\"],\n      \"text-halo-width\": [\"halo_width\"],\n      \"icon-halo-width\": [\"halo_width\"],\n      \"line-gap-width\": [\"gapwidth\"],\n      \"line-pattern\": [\"pattern\", \"pixel_ratio\"],\n      \"fill-pattern\": [\"pattern\", \"pixel_ratio\"],\n      \"fill-extrusion-pattern\": [\"pattern\", \"pixel_ratio\"],\n      \"line-dasharray\": [\"dash\"]\n    };\n    function Ya(t, e) {\n      return Ha[t] || [t.replace(`${e}-`, \"\").replace(/-/g, \"_\")];\n    }\n    const Wa = {\n        \"line-pattern\": {\n          source: Gs,\n          composite: Gs\n        },\n        \"fill-pattern\": {\n          source: Gs,\n          composite: Gs\n        },\n        \"fill-extrusion-pattern\": {\n          source: Gs,\n          composite: Gs\n        },\n        \"line-dasharray\": {\n          source: Zs,\n          composite: Zs\n        }\n      },\n      Qa = {\n        color: {\n          source: ca,\n          composite: Ns\n        },\n        number: {\n          source: sa,\n          composite: ca\n        }\n      };\n    function to(t, e, r) {\n      const n = Wa[t];\n      return n && n[r] || Qa[e][r];\n    }\n    Ji(qa, \"ConstantBinder\"), Ji(Na, \"PatternConstantBinder\"), Ji(Ga, \"SourceExpressionBinder\"), Ji(Ka, \"PatternCompositeBinder\"), Ji(Za, \"CompositeExpressionBinder\"), Ji(Xa, \"ProgramConfiguration\", {\n      omit: [\"_buffers\"]\n    }), Ji(Ja, \"ProgramConfigurationSet\");\n    const eo = \"-transition\";\n    class ro extends Qt {\n      constructor(t, e) {\n        if (super(), this.id = t.id, this.type = t.type, this._featureFilter = {\n          filter: () => !0,\n          needGeometry: !1,\n          needFeature: !1\n        }, this._filterCompiled = !1, \"custom\" !== t.type && (this.metadata = t.metadata, this.minzoom = t.minzoom, this.maxzoom = t.maxzoom, \"background\" !== t.type && \"sky\" !== t.type && (this.source = t.source, this.sourceLayer = t[\"source-layer\"], this.filter = t.filter), e.layout && (this._unevaluatedLayout = new Ms(e.layout)), e.paint)) {\n          this._transitionablePaint = new Ss(e.paint);\n          for (const e in t.paint) this.setPaintProperty(e, t.paint[e], {\n            validate: !1\n          });\n          for (const e in t.layout) this.setLayoutProperty(e, t.layout[e], {\n            validate: !1\n          });\n          this._transitioningPaint = this._transitionablePaint.untransitioned(), this.paint = new zs(e.paint);\n        }\n      }\n      getLayoutProperty(t) {\n        return \"visibility\" === t ? this.visibility : this._unevaluatedLayout.getValue(t);\n      }\n      setLayoutProperty(t, e, r = {}) {\n        null != e && this._validate(ji, `layers.${this.id}.layout.${t}`, t, e, r) || (\"visibility\" !== t ? this._unevaluatedLayout.setValue(t, e) : this.visibility = e);\n      }\n      getPaintProperty(t) {\n        return U(t, eo) ? this._transitionablePaint.getTransition(t.slice(0, -11)) : this._transitionablePaint.getValue(t);\n      }\n      setPaintProperty(t, e, r = {}) {\n        if (null != e && this._validate($i, `layers.${this.id}.paint.${t}`, t, e, r)) return !1;\n        if (U(t, eo)) return this._transitionablePaint.setTransition(t.slice(0, -11), e || void 0), !1;\n        {\n          const r = this._transitionablePaint._values[t],\n            n = r.value.isDataDriven(),\n            i = r.value;\n          this._transitionablePaint.setValue(t, e), this._handleSpecialPaintPropertyUpdate(t);\n          const s = this._transitionablePaint._values[t].value,\n            a = s.isDataDriven(),\n            o = U(t, \"pattern\") || \"line-dasharray\" === t;\n          return a || n || o || this._handleOverridablePaintPropertyUpdate(t, i, s);\n        }\n      }\n      _handleSpecialPaintPropertyUpdate(t) {}\n      getProgramIds() {\n        return null;\n      }\n      getProgramConfiguration(t) {\n        return null;\n      }\n      _handleOverridablePaintPropertyUpdate(t, e, r) {\n        return !1;\n      }\n      isHidden(t) {\n        return !!(this.minzoom && t < this.minzoom) || !!(this.maxzoom && t >= this.maxzoom) || \"none\" === this.visibility;\n      }\n      updateTransitions(t) {\n        this._transitioningPaint = this._transitionablePaint.transitioned(t, this._transitioningPaint);\n      }\n      hasTransition() {\n        return this._transitioningPaint.hasTransition();\n      }\n      recalculate(t, e) {\n        this._unevaluatedLayout && (this.layout = this._unevaluatedLayout.possiblyEvaluate(t, void 0, e)), this.paint = this._transitioningPaint.possiblyEvaluate(t, void 0, e);\n      }\n      serialize() {\n        const t = {\n          id: this.id,\n          type: this.type,\n          source: this.source,\n          \"source-layer\": this.sourceLayer,\n          metadata: this.metadata,\n          minzoom: this.minzoom,\n          maxzoom: this.maxzoom,\n          filter: this.filter,\n          layout: this._unevaluatedLayout && this._unevaluatedLayout.serialize(),\n          paint: this._transitionablePaint && this._transitionablePaint.serialize()\n        };\n        return this.visibility && (t.layout = t.layout || {}, t.layout.visibility = this.visibility), j(t, (t, e) => !(void 0 === t || \"layout\" === e && !Object.keys(t).length || \"paint\" === e && !Object.keys(t).length));\n      }\n      _validate(t, e, r, n, i = {}) {\n        return (!i || !1 !== i.validate) && qi(this, t.call(Ui, {\n          key: e,\n          layerType: this.type,\n          objectKey: r,\n          value: n,\n          styleSpec: te,\n          style: {\n            glyphs: !0,\n            sprite: !0\n          }\n        }));\n      }\n      is3D() {\n        return !1;\n      }\n      isSky() {\n        return !1;\n      }\n      isTileClipped() {\n        return !1;\n      }\n      hasOffscreenPass() {\n        return !1;\n      }\n      resize() {}\n      isStateDependent() {\n        for (const t in this.paint._values) {\n          const e = this.paint.get(t);\n          if (e instanceof Ts && Ln(e.property.specification) && (\"source\" === e.value.kind || \"composite\" === e.value.kind) && e.value.isStateDependent) return !0;\n        }\n        return !1;\n      }\n      compileFilter() {\n        this._filterCompiled || (this._featureFilter = hi(this.filter), this._filterCompiled = !0);\n      }\n      invalidateCompiledFilter() {\n        this._filterCompiled = !1;\n      }\n      dynamicFilter() {\n        return this._featureFilter.dynamicFilter;\n      }\n      dynamicFilterNeedsFeature() {\n        return this._featureFilter.needFeature;\n      }\n    }\n    const no = Rs([{\n        name: \"a_pos\",\n        components: 2,\n        type: \"Int16\"\n      }], 4),\n      io = Rs([{\n        name: \"a_pos_3\",\n        components: 3,\n        type: \"Int16\"\n      }, {\n        name: \"a_pos_normal_3\",\n        components: 3,\n        type: \"Int16\"\n      }]);\n    class so {\n      constructor(t = []) {\n        this.segments = t;\n      }\n      prepareSegment(t, e, r, n) {\n        let i = this.segments[this.segments.length - 1];\n        return t > so.MAX_VERTEX_ARRAY_LENGTH && N(`Max vertices per segment is ${so.MAX_VERTEX_ARRAY_LENGTH}: bucket requested ${t}`), (!i || i.vertexLength + t > so.MAX_VERTEX_ARRAY_LENGTH || i.sortKey !== n) && (i = {\n          vertexOffset: e.length,\n          primitiveOffset: r.length,\n          vertexLength: 0,\n          primitiveLength: 0\n        }, void 0 !== n && (i.sortKey = n), this.segments.push(i)), i;\n      }\n      get() {\n        return this.segments;\n      }\n      destroy() {\n        for (const t of this.segments) for (const e in t.vaos) t.vaos[e].destroy();\n      }\n      static simpleSegment(t, e, r, n) {\n        return new so([{\n          vertexOffset: t,\n          primitiveOffset: e,\n          vertexLength: r,\n          primitiveLength: n,\n          vaos: {},\n          sortKey: 0\n        }]);\n      }\n    }\n    so.MAX_VERTEX_ARRAY_LENGTH = Math.pow(2, 16) - 1, Ji(so, \"SegmentVector\");\n    var ao = 8192;\n    class oo {\n      constructor(t, e) {\n        t && (e ? this.setSouthWest(t).setNorthEast(e) : 4 === t.length ? this.setSouthWest([t[0], t[1]]).setNorthEast([t[2], t[3]]) : this.setSouthWest(t[0]).setNorthEast(t[1]));\n      }\n      setNorthEast(t) {\n        return this._ne = t instanceof Ol ? new Ol(t.lng, t.lat) : Ol.convert(t), this;\n      }\n      setSouthWest(t) {\n        return this._sw = t instanceof Ol ? new Ol(t.lng, t.lat) : Ol.convert(t), this;\n      }\n      extend(t) {\n        const e = this._sw,\n          r = this._ne;\n        let n, i;\n        if (t instanceof Ol) n = t, i = t;else {\n          if (!(t instanceof oo)) return Array.isArray(t) ? 4 === t.length || t.every(Array.isArray) ? this.extend(oo.convert(t)) : this.extend(Ol.convert(t)) : \"object\" == typeof t && null !== t && t.hasOwnProperty(\"lat\") && (t.hasOwnProperty(\"lon\") || t.hasOwnProperty(\"lng\")) ? this.extend(Ol.convert(t)) : this;\n          if (n = t._sw, i = t._ne, !n || !i) return this;\n        }\n        return e || r ? (e.lng = Math.min(n.lng, e.lng), e.lat = Math.min(n.lat, e.lat), r.lng = Math.max(i.lng, r.lng), r.lat = Math.max(i.lat, r.lat)) : (this._sw = new Ol(n.lng, n.lat), this._ne = new Ol(i.lng, i.lat)), this;\n      }\n      getCenter() {\n        return new Ol((this._sw.lng + this._ne.lng) / 2, (this._sw.lat + this._ne.lat) / 2);\n      }\n      getSouthWest() {\n        return this._sw;\n      }\n      getNorthEast() {\n        return this._ne;\n      }\n      getNorthWest() {\n        return new Ol(this.getWest(), this.getNorth());\n      }\n      getSouthEast() {\n        return new Ol(this.getEast(), this.getSouth());\n      }\n      getWest() {\n        return this._sw.lng;\n      }\n      getSouth() {\n        return this._sw.lat;\n      }\n      getEast() {\n        return this._ne.lng;\n      }\n      getNorth() {\n        return this._ne.lat;\n      }\n      toArray() {\n        return [this._sw.toArray(), this._ne.toArray()];\n      }\n      toString() {\n        return `LngLatBounds(${this._sw.toString()}, ${this._ne.toString()})`;\n      }\n      isEmpty() {\n        return !(this._sw && this._ne);\n      }\n      contains(t) {\n        const {\n          lng: e,\n          lat: r\n        } = Ol.convert(t);\n        let n = this._sw.lng <= e && e <= this._ne.lng;\n        return this._sw.lng > this._ne.lng && (n = this._sw.lng >= e && e >= this._ne.lng), this._sw.lat <= r && r <= this._ne.lat && n;\n      }\n      static convert(t) {\n        return !t || t instanceof oo ? t : new oo(t);\n      }\n    }\n    var lo = 1e-6,\n      uo = \"undefined\" != typeof Float32Array ? Float32Array : Array;\n    function co() {\n      var t = new uo(9);\n      return uo != Float32Array && (t[1] = 0, t[2] = 0, t[3] = 0, t[5] = 0, t[6] = 0, t[7] = 0), t[0] = 1, t[4] = 1, t[8] = 1, t;\n    }\n    function ho(t, e, r) {\n      var n = e[0],\n        i = e[1],\n        s = e[2],\n        a = e[3],\n        o = e[4],\n        l = e[5],\n        u = e[6],\n        c = e[7],\n        h = e[8],\n        p = r[0],\n        d = r[1],\n        f = r[2],\n        y = r[3],\n        m = r[4],\n        g = r[5],\n        x = r[6],\n        v = r[7],\n        b = r[8];\n      return t[0] = p * n + d * a + f * u, t[1] = p * i + d * o + f * c, t[2] = p * s + d * l + f * h, t[3] = y * n + m * a + g * u, t[4] = y * i + m * o + g * c, t[5] = y * s + m * l + g * h, t[6] = x * n + v * a + b * u, t[7] = x * i + v * o + b * c, t[8] = x * s + v * l + b * h, t;\n    }\n    function po(t) {\n      return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = 1, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[10] = 1, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, t;\n    }\n    function fo(t, e) {\n      var r = e[0],\n        n = e[1],\n        i = e[2],\n        s = e[3],\n        a = e[4],\n        o = e[5],\n        l = e[6],\n        u = e[7],\n        c = e[8],\n        h = e[9],\n        p = e[10],\n        d = e[11],\n        f = e[12],\n        y = e[13],\n        m = e[14],\n        g = e[15],\n        x = r * o - n * a,\n        v = r * l - i * a,\n        b = r * u - s * a,\n        w = n * l - i * o,\n        _ = n * u - s * o,\n        A = i * u - s * l,\n        S = c * y - h * f,\n        k = c * m - p * f,\n        I = c * g - d * f,\n        M = h * m - p * y,\n        T = h * g - d * y,\n        z = p * g - d * m,\n        B = x * z - v * T + b * M + w * I - _ * k + A * S;\n      return B ? (t[0] = (o * z - l * T + u * M) * (B = 1 / B), t[1] = (i * T - n * z - s * M) * B, t[2] = (y * A - m * _ + g * w) * B, t[3] = (p * _ - h * A - d * w) * B, t[4] = (l * I - a * z - u * k) * B, t[5] = (r * z - i * I + s * k) * B, t[6] = (m * b - f * A - g * v) * B, t[7] = (c * A - p * b + d * v) * B, t[8] = (a * T - o * I + u * S) * B, t[9] = (n * I - r * T - s * S) * B, t[10] = (f * _ - y * b + g * x) * B, t[11] = (h * b - c * _ - d * x) * B, t[12] = (o * k - a * M - l * S) * B, t[13] = (r * M - n * k + i * S) * B, t[14] = (y * v - f * w - m * x) * B, t[15] = (c * w - h * v + p * x) * B, t) : null;\n    }\n    function yo(t, e, r) {\n      var n = e[0],\n        i = e[1],\n        s = e[2],\n        a = e[3],\n        o = e[4],\n        l = e[5],\n        u = e[6],\n        c = e[7],\n        h = e[8],\n        p = e[9],\n        d = e[10],\n        f = e[11],\n        y = e[12],\n        m = e[13],\n        g = e[14],\n        x = e[15],\n        v = r[0],\n        b = r[1],\n        w = r[2],\n        _ = r[3];\n      return t[0] = v * n + b * o + w * h + _ * y, t[1] = v * i + b * l + w * p + _ * m, t[2] = v * s + b * u + w * d + _ * g, t[3] = v * a + b * c + w * f + _ * x, t[4] = (v = r[4]) * n + (b = r[5]) * o + (w = r[6]) * h + (_ = r[7]) * y, t[5] = v * i + b * l + w * p + _ * m, t[6] = v * s + b * u + w * d + _ * g, t[7] = v * a + b * c + w * f + _ * x, t[8] = (v = r[8]) * n + (b = r[9]) * o + (w = r[10]) * h + (_ = r[11]) * y, t[9] = v * i + b * l + w * p + _ * m, t[10] = v * s + b * u + w * d + _ * g, t[11] = v * a + b * c + w * f + _ * x, t[12] = (v = r[12]) * n + (b = r[13]) * o + (w = r[14]) * h + (_ = r[15]) * y, t[13] = v * i + b * l + w * p + _ * m, t[14] = v * s + b * u + w * d + _ * g, t[15] = v * a + b * c + w * f + _ * x, t;\n    }\n    function mo(t, e, r) {\n      var n,\n        i,\n        s,\n        a,\n        o,\n        l,\n        u,\n        c,\n        h,\n        p,\n        d,\n        f,\n        y = r[0],\n        m = r[1],\n        g = r[2];\n      return e === t ? (t[12] = e[0] * y + e[4] * m + e[8] * g + e[12], t[13] = e[1] * y + e[5] * m + e[9] * g + e[13], t[14] = e[2] * y + e[6] * m + e[10] * g + e[14], t[15] = e[3] * y + e[7] * m + e[11] * g + e[15]) : (i = e[1], s = e[2], a = e[3], o = e[4], l = e[5], u = e[6], c = e[7], h = e[8], p = e[9], d = e[10], f = e[11], t[0] = n = e[0], t[1] = i, t[2] = s, t[3] = a, t[4] = o, t[5] = l, t[6] = u, t[7] = c, t[8] = h, t[9] = p, t[10] = d, t[11] = f, t[12] = n * y + o * m + h * g + e[12], t[13] = i * y + l * m + p * g + e[13], t[14] = s * y + u * m + d * g + e[14], t[15] = a * y + c * m + f * g + e[15]), t;\n    }\n    function go(t, e, r) {\n      var n = r[0],\n        i = r[1],\n        s = r[2];\n      return t[0] = e[0] * n, t[1] = e[1] * n, t[2] = e[2] * n, t[3] = e[3] * n, t[4] = e[4] * i, t[5] = e[5] * i, t[6] = e[6] * i, t[7] = e[7] * i, t[8] = e[8] * s, t[9] = e[9] * s, t[10] = e[10] * s, t[11] = e[11] * s, t[12] = e[12], t[13] = e[13], t[14] = e[14], t[15] = e[15], t;\n    }\n    function xo(t, e, r) {\n      var n = Math.sin(r),\n        i = Math.cos(r),\n        s = e[4],\n        a = e[5],\n        o = e[6],\n        l = e[7],\n        u = e[8],\n        c = e[9],\n        h = e[10],\n        p = e[11];\n      return e !== t && (t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t[12] = e[12], t[13] = e[13], t[14] = e[14], t[15] = e[15]), t[4] = s * i + u * n, t[5] = a * i + c * n, t[6] = o * i + h * n, t[7] = l * i + p * n, t[8] = u * i - s * n, t[9] = c * i - a * n, t[10] = h * i - o * n, t[11] = p * i - l * n, t;\n    }\n    function vo(t, e, r) {\n      var n = Math.sin(r),\n        i = Math.cos(r),\n        s = e[0],\n        a = e[1],\n        o = e[2],\n        l = e[3],\n        u = e[8],\n        c = e[9],\n        h = e[10],\n        p = e[11];\n      return e !== t && (t[4] = e[4], t[5] = e[5], t[6] = e[6], t[7] = e[7], t[12] = e[12], t[13] = e[13], t[14] = e[14], t[15] = e[15]), t[0] = s * i - u * n, t[1] = a * i - c * n, t[2] = o * i - h * n, t[3] = l * i - p * n, t[8] = s * n + u * i, t[9] = a * n + c * i, t[10] = o * n + h * i, t[11] = l * n + p * i, t;\n    }\n    function bo(t, e) {\n      return t[0] = e[0], t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = e[1], t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[10] = e[2], t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, t;\n    }\n    function wo(t, e, r) {\n      var n,\n        i,\n        s,\n        a = r[0],\n        o = r[1],\n        l = r[2],\n        u = Math.hypot(a, o, l);\n      return u < lo ? null : (a *= u = 1 / u, o *= u, l *= u, n = Math.sin(e), i = Math.cos(e), t[0] = a * a * (s = 1 - i) + i, t[1] = o * a * s + l * n, t[2] = l * a * s - o * n, t[3] = 0, t[4] = a * o * s - l * n, t[5] = o * o * s + i, t[6] = l * o * s + a * n, t[7] = 0, t[8] = a * l * s + o * n, t[9] = o * l * s - a * n, t[10] = l * l * s + i, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, t);\n    }\n    Math.hypot || (Math.hypot = function () {\n      for (var t = 0, e = arguments.length; e--;) t += arguments[e] * arguments[e];\n      return Math.sqrt(t);\n    });\n    var _o = yo;\n    function Ao() {\n      var t = new uo(3);\n      return uo != Float32Array && (t[0] = 0, t[1] = 0, t[2] = 0), t;\n    }\n    function So(t) {\n      var e = new uo(3);\n      return e[0] = t[0], e[1] = t[1], e[2] = t[2], e;\n    }\n    function ko(t) {\n      return Math.hypot(t[0], t[1], t[2]);\n    }\n    function Io(t, e, r) {\n      var n = new uo(3);\n      return n[0] = t, n[1] = e, n[2] = r, n;\n    }\n    function Mo(t, e, r) {\n      return t[0] = e[0] + r[0], t[1] = e[1] + r[1], t[2] = e[2] + r[2], t;\n    }\n    function To(t, e, r) {\n      return t[0] = e[0] - r[0], t[1] = e[1] - r[1], t[2] = e[2] - r[2], t;\n    }\n    function zo(t, e, r) {\n      return t[0] = e[0] * r[0], t[1] = e[1] * r[1], t[2] = e[2] * r[2], t;\n    }\n    function Bo(t, e, r) {\n      return t[0] = Math.min(e[0], r[0]), t[1] = Math.min(e[1], r[1]), t[2] = Math.min(e[2], r[2]), t;\n    }\n    function Eo(t, e, r) {\n      return t[0] = Math.max(e[0], r[0]), t[1] = Math.max(e[1], r[1]), t[2] = Math.max(e[2], r[2]), t;\n    }\n    function Co(t, e, r) {\n      return t[0] = e[0] * r, t[1] = e[1] * r, t[2] = e[2] * r, t;\n    }\n    function Po(t, e, r, n) {\n      return t[0] = e[0] + r[0] * n, t[1] = e[1] + r[1] * n, t[2] = e[2] + r[2] * n, t;\n    }\n    function Do(t, e) {\n      var r = e[0],\n        n = e[1],\n        i = e[2],\n        s = r * r + n * n + i * i;\n      return s > 0 && (s = 1 / Math.sqrt(s)), t[0] = e[0] * s, t[1] = e[1] * s, t[2] = e[2] * s, t;\n    }\n    function Vo(t, e) {\n      return t[0] * e[0] + t[1] * e[1] + t[2] * e[2];\n    }\n    function Lo(t, e, r) {\n      var n = e[0],\n        i = e[1],\n        s = e[2],\n        a = r[0],\n        o = r[1],\n        l = r[2];\n      return t[0] = i * l - s * o, t[1] = s * a - n * l, t[2] = n * o - i * a, t;\n    }\n    function Fo(t, e, r) {\n      var n = e[0],\n        i = e[1],\n        s = e[2],\n        a = r[3] * n + r[7] * i + r[11] * s + r[15];\n      return t[0] = (r[0] * n + r[4] * i + r[8] * s + r[12]) / (a = a || 1), t[1] = (r[1] * n + r[5] * i + r[9] * s + r[13]) / a, t[2] = (r[2] * n + r[6] * i + r[10] * s + r[14]) / a, t;\n    }\n    function Ro(t, e, r) {\n      var n = r[0],\n        i = r[1],\n        s = r[2],\n        a = e[0],\n        o = e[1],\n        l = e[2],\n        u = i * l - s * o,\n        c = s * a - n * l,\n        h = n * o - i * a,\n        p = i * h - s * c,\n        d = s * u - n * h,\n        f = n * c - i * u,\n        y = 2 * r[3];\n      return c *= y, h *= y, d *= 2, f *= 2, t[0] = a + (u *= y) + (p *= 2), t[1] = o + c + d, t[2] = l + h + f, t;\n    }\n    var Uo,\n      $o = To,\n      jo = zo,\n      Oo = ko;\n    function qo(t, e, r) {\n      return t[0] = e[0] * r, t[1] = e[1] * r, t[2] = e[2] * r, t[3] = e[3] * r, t;\n    }\n    function No(t, e) {\n      var r = e[0],\n        n = e[1],\n        i = e[2],\n        s = e[3],\n        a = r * r + n * n + i * i + s * s;\n      return a > 0 && (a = 1 / Math.sqrt(a)), t[0] = r * a, t[1] = n * a, t[2] = i * a, t[3] = s * a, t;\n    }\n    function Go(t, e, r) {\n      var n = e[0],\n        i = e[1],\n        s = e[2],\n        a = e[3];\n      return t[0] = r[0] * n + r[4] * i + r[8] * s + r[12] * a, t[1] = r[1] * n + r[5] * i + r[9] * s + r[13] * a, t[2] = r[2] * n + r[6] * i + r[10] * s + r[14] * a, t[3] = r[3] * n + r[7] * i + r[11] * s + r[15] * a, t;\n    }\n    function Zo() {\n      var t = new uo(4);\n      return uo != Float32Array && (t[0] = 0, t[1] = 0, t[2] = 0), t[3] = 1, t;\n    }\n    function Ko(t) {\n      return t[0] = 0, t[1] = 0, t[2] = 0, t[3] = 1, t;\n    }\n    function Xo(t, e, r) {\n      r *= .5;\n      var n = e[0],\n        i = e[1],\n        s = e[2],\n        a = e[3],\n        o = Math.sin(r),\n        l = Math.cos(r);\n      return t[0] = n * l + a * o, t[1] = i * l + s * o, t[2] = s * l - i * o, t[3] = a * l - n * o, t;\n    }\n    function Jo(t, e, r) {\n      r *= .5;\n      var n = e[0],\n        i = e[1],\n        s = e[2],\n        a = e[3],\n        o = Math.sin(r),\n        l = Math.cos(r);\n      return t[0] = n * l - s * o, t[1] = i * l + a * o, t[2] = s * l + n * o, t[3] = a * l - i * o, t;\n    }\n    Ao(), Uo = new uo(4), uo != Float32Array && (Uo[0] = 0, Uo[1] = 0, Uo[2] = 0, Uo[3] = 0);\n    var Ho = No;\n    Ao(), Io(1, 0, 0), Io(0, 1, 0), Zo(), Zo(), co();\n    const Yo = Rs([{\n        type: \"Float32\",\n        name: \"a_globe_pos\",\n        components: 3\n      }, {\n        type: \"Float32\",\n        name: \"a_uv\",\n        components: 2\n      }]),\n      {\n        members: Wo\n      } = Yo,\n      Qo = Rs([{\n        name: \"a_pos_3\",\n        components: 3,\n        type: \"Int16\"\n      }]);\n    var tl = Rs([{\n      name: \"a_pos\",\n      type: \"Int16\",\n      components: 2\n    }]);\n    class el {\n      constructor(t, e) {\n        this.pos = t, this.dir = e;\n      }\n      intersectsPlane(t, e, r) {\n        const n = Vo(e, this.dir);\n        if (Math.abs(n) < 1e-6) return !1;\n        const i = ((t[0] - this.pos[0]) * e[0] + (t[1] - this.pos[1]) * e[1] + (t[2] - this.pos[2]) * e[2]) / n;\n        return r[0] = this.pos[0] + this.dir[0] * i, r[1] = this.pos[1] + this.dir[1] * i, r[2] = this.pos[2] + this.dir[2] * i, !0;\n      }\n      closestPointOnSphere(t, e, r) {\n        if (function (t, e) {\n          var r = t[0],\n            n = t[1],\n            i = t[2],\n            s = e[0],\n            a = e[1],\n            o = e[2];\n          return Math.abs(r - s) <= lo * Math.max(1, Math.abs(r), Math.abs(s)) && Math.abs(n - a) <= lo * Math.max(1, Math.abs(n), Math.abs(a)) && Math.abs(i - o) <= lo * Math.max(1, Math.abs(i), Math.abs(o));\n        }(this.pos, t) || 0 === e) return r[0] = r[1] = r[2] = 0, !1;\n        const [n, i, s] = this.dir,\n          a = this.pos[0] - t[0],\n          o = this.pos[1] - t[1],\n          l = this.pos[2] - t[2],\n          u = n * n + i * i + s * s,\n          c = 2 * (a * n + o * i + l * s),\n          h = c * c - 4 * u * (a * a + o * o + l * l - e * e);\n        if (h < 0) {\n          const t = Math.max(-c / 2, 0),\n            u = a + n * t,\n            h = o + i * t,\n            p = l + s * t,\n            d = Math.hypot(u, h, p);\n          return r[0] = u * e / d, r[1] = h * e / d, r[2] = p * e / d, !1;\n        }\n        {\n          const t = (-c - Math.sqrt(h)) / (2 * u);\n          if (t < 0) {\n            const t = Math.hypot(a, o, l);\n            return r[0] = a * e / t, r[1] = o * e / t, r[2] = l * e / t, !1;\n          }\n          return r[0] = a + n * t, r[1] = o + i * t, r[2] = l + s * t, !0;\n        }\n      }\n    }\n    class rl {\n      constructor(t, e, r, n, i) {\n        this.TL = t, this.TR = e, this.BR = r, this.BL = n, this.horizon = i;\n      }\n      static fromInvProjectionMatrix(t, e, r) {\n        const n = [-1, 1, 1],\n          i = [1, 1, 1],\n          s = [1, -1, 1],\n          a = [-1, -1, 1],\n          o = Fo(n, n, t),\n          l = Fo(i, i, t),\n          u = Fo(s, s, t),\n          c = Fo(a, a, t);\n        return new rl(o, l, u, c, e / r);\n      }\n    }\n    class nl {\n      constructor(t, e) {\n        this.points = t, this.planes = e;\n      }\n      static fromInvProjectionMatrix(t, e, r, n) {\n        const i = Math.pow(2, r),\n          s = [[-1, 1, -1, 1], [1, 1, -1, 1], [1, -1, -1, 1], [-1, -1, -1, 1], [-1, 1, 1, 1], [1, 1, 1, 1], [1, -1, 1, 1], [-1, -1, 1, 1]].map(r => {\n            const s = Go([], r, t),\n              a = 1 / s[3] / e * i;\n            return function (t, e, r) {\n              return t[0] = e[0] * r[0], t[1] = e[1] * r[1], t[2] = e[2] * r[2], t[3] = e[3] * r[3], t;\n            }(s, s, [a, a, n ? 1 / s[3] : a, a]);\n          }),\n          a = [[0, 1, 2], [6, 5, 4], [0, 3, 7], [2, 1, 5], [3, 2, 6], [0, 4, 5]].map(t => {\n            const e = Do([], Lo([], $o([], s[t[0]], s[t[1]]), $o([], s[t[2]], s[t[1]]))),\n              r = -Vo(e, s[t[1]]);\n            return e.concat(r);\n          });\n        return new nl(s, a);\n      }\n    }\n    class il {\n      static fromPoints(t) {\n        const e = [1 / 0, 1 / 0, 1 / 0],\n          r = [-1 / 0, -1 / 0, -1 / 0];\n        for (const n of t) Bo(e, e, n), Eo(r, r, n);\n        return new il(e, r);\n      }\n      static applyTransform(t, e) {\n        const r = t.getCorners();\n        for (let t = 0; t < r.length; ++t) Fo(r[t], r[t], e);\n        return il.fromPoints(r);\n      }\n      constructor(t, e) {\n        this.min = t, this.max = e, this.center = Co([], Mo([], this.min, this.max), .5);\n      }\n      quadrant(t) {\n        const e = [t % 2 == 0, t < 2],\n          r = So(this.min),\n          n = So(this.max);\n        for (let t = 0; t < e.length; t++) r[t] = e[t] ? this.min[t] : this.center[t], n[t] = e[t] ? this.center[t] : this.max[t];\n        return n[2] = this.max[2], new il(r, n);\n      }\n      distanceX(t) {\n        return Math.max(Math.min(this.max[0], t[0]), this.min[0]) - t[0];\n      }\n      distanceY(t) {\n        return Math.max(Math.min(this.max[1], t[1]), this.min[1]) - t[1];\n      }\n      distanceZ(t) {\n        return Math.max(Math.min(this.max[2], t[2]), this.min[2]) - t[2];\n      }\n      getCorners() {\n        const t = this.min,\n          e = this.max;\n        return [[t[0], t[1], t[2]], [e[0], t[1], t[2]], [e[0], e[1], t[2]], [t[0], e[1], t[2]], [t[0], t[1], e[2]], [e[0], t[1], e[2]], [e[0], e[1], e[2]], [t[0], e[1], e[2]]];\n      }\n      intersects(t) {\n        const e = this.getCorners();\n        let r = !0;\n        for (let n = 0; n < t.planes.length; n++) {\n          const i = t.planes[n];\n          let s = 0;\n          for (let t = 0; t < e.length; t++) s += Vo(i, e[t]) + i[3] >= 0;\n          if (0 === s) return 0;\n          s !== e.length && (r = !1);\n        }\n        if (r) return 2;\n        for (let e = 0; e < 3; e++) {\n          let r = Number.MAX_VALUE,\n            n = -Number.MAX_VALUE;\n          for (let i = 0; i < t.points.length; i++) {\n            const s = t.points[i][e] - this.min[e];\n            r = Math.min(r, s), n = Math.max(n, s);\n          }\n          if (n < 0 || r > this.max[e] - this.min[e]) return 0;\n        }\n        return 1;\n      }\n    }\n    const sl = 5,\n      al = 6,\n      ol = ao / Math.PI / 2,\n      ll = 16383,\n      ul = 64,\n      cl = [ul, 32, 16],\n      hl = -ol,\n      pl = ol,\n      dl = [new il([hl, hl, hl], [pl, pl, pl]), new il([hl, hl, hl], [0, 0, pl]), new il([0, hl, hl], [pl, 0, pl]), new il([hl, 0, hl], [0, pl, pl]), new il([0, 0, hl], [pl, pl, pl])];\n    function fl(t) {\n      return t * ol / Ul;\n    }\n    function yl(t, e, r, n = !0) {\n      const i = Co([], t._camera.position, t.worldSize),\n        s = [e, r, 1, 1];\n      Go(s, s, t.pixelMatrixInverse), qo(s, s, 1 / s[3]);\n      const a = Do([], $o([], s, i)),\n        o = t.globeMatrix,\n        l = [o[12], o[13], o[14]],\n        u = $o([], l, i),\n        c = ko(u),\n        h = Do([], u),\n        p = t.worldSize / (2 * Math.PI),\n        d = Vo(h, a),\n        f = Math.asin(p / c);\n      if (f < Math.acos(d)) {\n        if (!n) return null;\n        const t = [],\n          e = [];\n        Co(t, a, c / d), Do(e, $o(e, t, u)), Do(a, Mo(a, u, Co(a, e, Math.tan(f) * c)));\n      }\n      const y = [];\n      new el(i, a).closestPointOnSphere(l, p, y);\n      const m = Do([], W(o, 0)),\n        g = Do([], W(o, 1)),\n        x = Do([], W(o, 2)),\n        v = Vo(m, y),\n        b = Vo(g, y),\n        w = Vo(x, y),\n        A = _(Math.asin(-b / p));\n      let S = _(Math.atan2(v, w));\n      S = t.center.lng + function (t, e) {\n        const r = (e - t + 180) % 360 - 180;\n        return r < -180 ? r + 360 : r;\n      }(t.center.lng, S);\n      const k = Nl(S),\n        I = M(Gl(A), 0, 1);\n      return new Wl(k, I);\n    }\n    class ml {\n      constructor(t, e, r) {\n        this.a = $o([], t, r), this.b = $o([], e, r), this.center = r;\n        const n = Do([], this.a),\n          i = Do([], this.b);\n        this.angle = Math.acos(Vo(n, i));\n      }\n    }\n    function gl(t, e) {\n      if (0 === t.angle) return null;\n      let r;\n      return r = 0 === t.a[e] ? 1 / t.angle * .5 * Math.PI : 1 / t.angle * Math.atan(t.b[e] / t.a[e] / Math.sin(t.angle) - 1 / Math.tan(t.angle)), r < 0 || r > 1 ? null : function (t, e, r, n) {\n        const i = Math.sin(r);\n        return t * (Math.sin((1 - n) * r) / i) + e * (Math.sin(n * r) / i);\n      }(t.a[e], t.b[e], t.angle, M(r, 0, 1)) + t.center[e];\n    }\n    function xl(t) {\n      if (t.z <= 1) return dl[t.z + 2 * t.y + t.x];\n      const e = Sl(Al(t));\n      return il.fromPoints(e);\n    }\n    function vl(t, e, r) {\n      return Co(t, t, 1 - r), Po(t, t, e, r);\n    }\n    function bl(t, e) {\n      const r = Pl(e.zoom);\n      if (0 === r) return xl(t);\n      const n = Al(t),\n        i = Sl(n),\n        s = Nl(n.getWest()) * e.worldSize,\n        a = Nl(n.getEast()) * e.worldSize,\n        o = Gl(n.getNorth()) * e.worldSize,\n        l = Gl(n.getSouth()) * e.worldSize,\n        u = [s, o, 0],\n        c = [a, o, 0],\n        h = [s, l, 0],\n        p = [a, l, 0],\n        d = fo([], e.globeMatrix);\n      return Fo(u, u, d), Fo(c, c, d), Fo(h, h, d), Fo(p, p, d), i[0] = vl(i[0], h, r), i[1] = vl(i[1], p, r), i[2] = vl(i[2], c, r), i[3] = vl(i[3], u, r), il.fromPoints(i);\n    }\n    function wl(t, e, r) {\n      for (const n of t) Fo(n, n, e), Co(n, n, r);\n    }\n    function _l(t, e, r) {\n      const n = e / t.worldSize,\n        i = t.globeMatrix;\n      if (r.z <= 1) {\n        const t = xl(r).getCorners();\n        return wl(t, i, n), il.fromPoints(t);\n      }\n      const s = Al(r),\n        a = Sl(s);\n      wl(a, i, n);\n      const o = Number.MAX_VALUE,\n        l = [-o, -o, -o],\n        u = [o, o, o];\n      if (s.contains(t.center)) {\n        for (const t of a) Bo(u, u, t), Eo(l, l, t);\n        l[2] = 0;\n        const e = t.point,\n          r = [e.x * n, e.y * n, 0];\n        return Bo(u, u, r), Eo(l, l, r), new il(u, l);\n      }\n      const c = [i[12] * n, i[13] * n, i[14] * n],\n        h = s.getCenter(),\n        p = M(t.center.lat, -Hl, Hl),\n        d = M(h.lat, -Hl, Hl),\n        f = Nl(t.center.lng),\n        y = Gl(p);\n      let m = f - Nl(h.lng);\n      const g = y - Gl(d);\n      m > .5 ? m -= 1 : m < -.5 && (m += 1);\n      let x = 0;\n      Math.abs(m) > Math.abs(g) ? x = m >= 0 ? 1 : 3 : (x = g >= 0 ? 0 : 2, Po(c, c, [i[4] * n, i[5] * n, i[6] * n], -Math.sin(w(g >= 0 ? s.getSouth() : s.getNorth())) * ol));\n      const v = a[x],\n        b = a[(x + 1) % 4],\n        _ = new ml(v, b, c),\n        A = [gl(_, 0) || v[0], gl(_, 1) || v[1], gl(_, 2) || v[2]],\n        S = Pl(t.zoom);\n      if (S > 0) {\n        const n = function ({\n          x: t,\n          y: e,\n          z: r\n        }, n, i, s, a) {\n          const o = 1 / (1 << r);\n          let l = t * o,\n            u = l + o,\n            c = e * o,\n            h = c + o,\n            p = 0;\n          const d = (l + u) / 2 - s;\n          return d > .5 ? p = -1 : d < -.5 && (p = 1), l = ((l + p) * n - (s *= n)) * i + s, u = ((u + p) * n - s) * i + s, c = (c * n - (a *= n)) * i + a, h = (h * n - a) * i + a, [[l, h, 0], [u, h, 0], [u, c, 0], [l, c, 0]];\n        }(r, e, t._pixelsPerMercatorPixel, f, y);\n        for (let t = 0; t < a.length; t++) vl(a[t], n[t], S);\n        const i = Mo([], n[x], n[(x + 1) % 4]);\n        Co(i, i, .5), vl(A, i, S);\n      }\n      for (const t of a) Bo(u, u, t), Eo(l, l, t);\n      return u[2] = Math.min(v[2], b[2]), Bo(u, u, A), Eo(l, l, A), new il(u, l);\n    }\n    function Al({\n      x: t,\n      y: e,\n      z: r\n    }) {\n      const n = 1 / (1 << r),\n        i = new Ol(Kl(t * n), Xl((e + 1) * n)),\n        s = new Ol(Kl((t + 1) * n), Xl(e * n));\n      return new oo(i, s);\n    }\n    function Sl(t) {\n      const e = w(t.getNorth()),\n        r = w(t.getSouth()),\n        n = Math.cos(e),\n        i = Math.cos(r),\n        s = Math.sin(e),\n        a = Math.sin(r),\n        o = t.getWest(),\n        l = t.getEast();\n      return [kl(i, a, o), kl(i, a, l), kl(n, s, l), kl(n, s, o)];\n    }\n    function kl(t, e, r, n = ol) {\n      return r = w(r), [t * Math.sin(r) * n, -e * n, t * Math.cos(r) * n];\n    }\n    function Il(t, e, r) {\n      return kl(Math.cos(w(t)), Math.sin(w(t)), e, r);\n    }\n    function Ml(t, e, r, n) {\n      const i = 1 << r.z,\n        s = (t / ao + r.x) / i;\n      return Il(Xl((e / ao + r.y) / i), Kl(s), n);\n    }\n    function Tl({\n      min: t,\n      max: e\n    }) {\n      return ll / Math.max(e[0] - t[0], e[1] - t[1], e[2] - t[2]);\n    }\n    const zl = new Float64Array(16);\n    function Bl(t) {\n      const e = Tl(t),\n        r = bo(zl, [e, e, e]);\n      return mo(r, r, ((n = [])[0] = -(i = t.min)[0], n[1] = -i[1], n[2] = -i[2], n));\n      var n, i;\n    }\n    function El(t) {\n      const e = (n = t.min, (r = zl)[0] = 1, r[1] = 0, r[2] = 0, r[3] = 0, r[4] = 0, r[5] = 1, r[6] = 0, r[7] = 0, r[8] = 0, r[9] = 0, r[10] = 1, r[11] = 0, r[12] = n[0], r[13] = n[1], r[14] = n[2], r[15] = 1, r);\n      var r, n;\n      const i = 1 / Tl(t);\n      return go(e, e, [i, i, i]);\n    }\n    function Cl(t, e, r, n, i) {\n      const s = function (t) {\n          const e = ao / (2 * Math.PI);\n          return t / (2 * Math.PI) / e;\n        }(r),\n        a = [t, e, -r / (2 * Math.PI)],\n        o = po(new Float64Array(16));\n      return mo(o, o, a), go(o, o, [s, s, s]), xo(o, o, w(-i)), vo(o, o, w(-n)), o;\n    }\n    function Pl(t) {\n      return T(sl, al, t);\n    }\n    function Dl(t, e) {\n      const r = Il(e.lat, e.lng),\n        n = function (t) {\n          const e = Il(t._center.lat, t._center.lng);\n          let r = Lo([], Io(0, 1, 0), e);\n          const n = wo([], -t.angle, e);\n          r = Fo(r, r, n), wo(n, -t._pitch, r);\n          const i = Do([], e);\n          return Co(i, i, fl(t.cameraToCenterDistance / t.pixelsPerMeter)), Fo(i, i, n), Mo([], e, i);\n        }(t);\n      return a = (i = To([], n, r))[0], o = i[1], l = i[2], u = (s = r)[0], c = s[1], h = s[2], d = (p = Math.sqrt(a * a + o * o + l * l) * Math.sqrt(u * u + c * c + h * h)) && Vo(i, s) / p, Math.acos(Math.min(Math.max(d, -1), 1));\n      var i, s, a, o, l, u, c, h, p, d;\n    }\n    function Vl(t, e) {\n      return Dl(t, e) > Math.PI / 2 * 1.01;\n    }\n    const Ll = w(85),\n      Fl = Math.cos(Ll),\n      Rl = Math.sin(Ll),\n      Ul = 6371008.8,\n      $l = 2 * Math.PI * Ul;\n    class jl {\n      constructor(t, e) {\n        if (isNaN(t) || isNaN(e)) throw new Error(`Invalid LngLat object: (${t}, ${e})`);\n        if (this.lng = +t, this.lat = +e, this.lat > 90 || this.lat < -90) throw new Error(\"Invalid LngLat latitude value: must be between -90 and 90\");\n      }\n      wrap() {\n        return new jl(z(this.lng, -180, 180), this.lat);\n      }\n      toArray() {\n        return [this.lng, this.lat];\n      }\n      toString() {\n        return `LngLat(${this.lng}, ${this.lat})`;\n      }\n      distanceTo(t) {\n        const e = Math.PI / 180,\n          r = this.lat * e,\n          n = t.lat * e,\n          i = Math.sin(r) * Math.sin(n) + Math.cos(r) * Math.cos(n) * Math.cos((t.lng - this.lng) * e);\n        return Ul * Math.acos(Math.min(i, 1));\n      }\n      toBounds(t = 0) {\n        const e = 360 * t / 40075017,\n          r = e / Math.cos(Math.PI / 180 * this.lat);\n        return new oo(new jl(this.lng - r, this.lat - e), new jl(this.lng + r, this.lat + e));\n      }\n      toEcef(t) {\n        const e = fl(t);\n        return Il(this.lat, this.lng, ol + e);\n      }\n      static convert(t) {\n        if (t instanceof jl) return t;\n        if (Array.isArray(t) && (2 === t.length || 3 === t.length)) return new jl(Number(t[0]), Number(t[1]));\n        if (!Array.isArray(t) && \"object\" == typeof t && null !== t) return new jl(Number(\"lng\" in t ? t.lng : t.lon), Number(t.lat));\n        throw new Error(\"`LngLatLike` argument must be specified as a LngLat instance, an object {lng: <lng>, lat: <lat>}, an object {lon: <lng>, lat: <lat>}, or an array of [<lng>, <lat>]\");\n      }\n    }\n    var Ol = jl;\n    function ql(t) {\n      return $l * Math.cos(t * Math.PI / 180);\n    }\n    function Nl(t) {\n      return (180 + t) / 360;\n    }\n    function Gl(t) {\n      return (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + t * Math.PI / 360))) / 360;\n    }\n    function Zl(t, e) {\n      return t / ql(e);\n    }\n    function Kl(t) {\n      return 360 * t - 180;\n    }\n    function Xl(t) {\n      return 360 / Math.PI * Math.atan(Math.exp((180 - 360 * t) * Math.PI / 180)) - 90;\n    }\n    function Jl(t, e) {\n      return t * ql(Xl(e));\n    }\n    const Hl = 85.051129;\n    function Yl(t) {\n      return 1 / Math.cos(t * Math.PI / 180);\n    }\n    class Wl {\n      constructor(t, e, r = 0) {\n        this.x = +t, this.y = +e, this.z = +r;\n      }\n      static fromLngLat(t, e = 0) {\n        const r = Ol.convert(t);\n        return new Wl(Nl(r.lng), Gl(r.lat), Zl(e, r.lat));\n      }\n      toLngLat() {\n        return new Ol(Kl(this.x), Xl(this.y));\n      }\n      toAltitude() {\n        return Jl(this.z, this.y);\n      }\n      meterInMercatorCoordinateUnits() {\n        return 1 / $l * Yl(Xl(this.y));\n      }\n    }\n    function Ql(t, e, r, n, i, s, a, o, l) {\n      const u = (e + n) / 2,\n        c = (r + i) / 2,\n        h = new x(u, c);\n      o(h), function (t, e, r, n, i, s) {\n        const a = r - i,\n          o = n - s;\n        return Math.abs((n - e) * a - (r - t) * o) / Math.hypot(a, o);\n      }(h.x, h.y, s.x, s.y, a.x, a.y) >= l ? (Ql(t, e, r, u, c, s, h, o, l), Ql(t, u, c, n, i, h, a, o, l)) : t.push(a);\n    }\n    function tu(t, e, r) {\n      let n = t[0],\n        i = n.x,\n        s = n.y;\n      e(n);\n      const a = [n];\n      for (let o = 1; o < t.length; o++) {\n        const l = t[o],\n          {\n            x: u,\n            y: c\n          } = l;\n        e(l), Ql(a, i, s, u, c, n, l, e, r), i = u, s = c, n = l;\n      }\n      return a;\n    }\n    function eu(t, e, r, n) {\n      if (n(e, r)) {\n        const i = e.add(r)._mult(.5);\n        eu(t, e, i, n), eu(t, i, r, n);\n      } else t.push(r);\n    }\n    function ru(t, e) {\n      let r = t[0];\n      const n = [r];\n      for (let i = 1; i < t.length; i++) {\n        const s = t[i];\n        eu(n, r, s, e), r = s;\n      }\n      return n;\n    }\n    const nu = Math.pow(2, 14) - 1,\n      iu = -nu - 1;\n    function su(t, e) {\n      const r = Math.round(t.x * e),\n        n = Math.round(t.y * e);\n      return t.x = M(r, iu, nu), t.y = M(n, iu, nu), (r < t.x || r > t.x + 1 || n < t.y || n > t.y + 1) && N(\"Geometry exceeds allowed extent, reduce your vector tile buffer size\"), t;\n    }\n    function au(t, e, r) {\n      const n = t.loadGeometry(),\n        i = t.extent,\n        s = ao / i;\n      if (e && r && r.projection.isReprojectedInTileSpace) {\n        const s = 1 << e.z,\n          {\n            scale: a,\n            x: o,\n            y: l,\n            projection: u\n          } = r,\n          c = t => {\n            const r = Kl((e.x + t.x / i) / s),\n              n = Xl((e.y + t.y / i) / s),\n              c = u.project(r, n);\n            t.x = (c.x * a - o) * i, t.y = (c.y * a - l) * i;\n          };\n        for (let e = 0; e < n.length; e++) if (1 !== t.type) n[e] = tu(n[e], c, 1);else {\n          const t = [];\n          for (const r of n[e]) r.x < 0 || r.x >= i || r.y < 0 || r.y >= i || (c(r), t.push(r));\n          n[e] = t;\n        }\n      }\n      for (const t of n) for (const e of t) su(e, s);\n      return n;\n    }\n    function ou(t, e) {\n      return {\n        type: t.type,\n        id: t.id,\n        properties: t.properties,\n        geometry: e ? au(t) : []\n      };\n    }\n    function lu(t, e, r, n, i) {\n      t.emplaceBack(2 * e + (n + 1) / 2, 2 * r + (i + 1) / 2);\n    }\n    function uu(t, e, r) {\n      const n = 16384;\n      t.emplaceBack(e.x, e.y, e.z, r[0] * n, r[1] * n, r[2] * n);\n    }\n    class cu {\n      constructor(t) {\n        this.zoom = t.zoom, this.overscaling = t.overscaling, this.layers = t.layers, this.layerIds = this.layers.map(t => t.id), this.index = t.index, this.hasPattern = !1, this.projection = t.projection, this.layoutVertexArray = new $s(), this.indexArray = new ra(), this.segments = new so(), this.programConfigurations = new Ja(t.layers, t.zoom), this.stateDependentLayerIds = this.layers.filter(t => t.isStateDependent()).map(t => t.id);\n      }\n      populate(t, e, r, n) {\n        const i = this.layers[0],\n          s = [];\n        let a = null;\n        \"circle\" === i.type && (a = i.layout.get(\"circle-sort-key\"));\n        for (const {\n          feature: e,\n          id: i,\n          index: o,\n          sourceLayerIndex: l\n        } of t) {\n          const t = this.layers[0]._featureFilter.needGeometry,\n            u = ou(e, t);\n          if (!this.layers[0]._featureFilter.filter(new ws(this.zoom), u, r)) continue;\n          const c = a ? a.evaluate(u, {}, r) : void 0,\n            h = {\n              id: i,\n              properties: e.properties,\n              type: e.type,\n              sourceLayerIndex: l,\n              index: o,\n              geometry: t ? u.geometry : au(e, r, n),\n              patterns: {},\n              sortKey: c\n            };\n          s.push(h);\n        }\n        a && s.sort((t, e) => t.sortKey - e.sortKey);\n        let o = null;\n        \"globe\" === n.projection.name && (this.globeExtVertexArray = new Ks(), o = n.projection);\n        for (const n of s) {\n          const {\n              geometry: i,\n              index: s,\n              sourceLayerIndex: a\n            } = n,\n            l = t[s].feature;\n          this.addFeature(n, i, s, e.availableImages, r, o), e.featureIndex.insert(l, i, s, a, this.index);\n        }\n      }\n      update(t, e, r, n) {\n        this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t, e, this.stateDependentLayers, r, n);\n      }\n      isEmpty() {\n        return 0 === this.layoutVertexArray.length;\n      }\n      uploadPending() {\n        return !this.uploaded || this.programConfigurations.needsUpload;\n      }\n      upload(t) {\n        this.uploaded || (this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, no.members), this.indexBuffer = t.createIndexBuffer(this.indexArray), this.globeExtVertexArray && (this.globeExtVertexBuffer = t.createVertexBuffer(this.globeExtVertexArray, io.members))), this.programConfigurations.upload(t), this.uploaded = !0;\n      }\n      destroy() {\n        this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.globeExtVertexBuffer && this.globeExtVertexBuffer.destroy());\n      }\n      addFeature(t, e, r, n, i, s) {\n        for (const r of e) for (const e of r) {\n          const r = e.x,\n            n = e.y;\n          if (r < 0 || r >= ao || n < 0 || n >= ao) continue;\n          if (s) {\n            const t = s.projectTilePoint(r, n, i),\n              e = s.upVector(i, r, n),\n              a = this.globeExtVertexArray;\n            uu(a, t, e), uu(a, t, e), uu(a, t, e), uu(a, t, e);\n          }\n          const a = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray, t.sortKey),\n            o = a.vertexLength;\n          lu(this.layoutVertexArray, r, n, -1, -1), lu(this.layoutVertexArray, r, n, 1, -1), lu(this.layoutVertexArray, r, n, 1, 1), lu(this.layoutVertexArray, r, n, -1, 1), this.indexArray.emplaceBack(o, o + 1, o + 2), this.indexArray.emplaceBack(o, o + 2, o + 3), a.vertexLength += 4, a.primitiveLength += 2;\n        }\n        this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t, r, {}, n, i);\n      }\n    }\n    function hu(t, e) {\n      for (let r = 0; r < t.length; r++) if (bu(e, t[r])) return !0;\n      for (let r = 0; r < e.length; r++) if (bu(t, e[r])) return !0;\n      return !!yu(t, e);\n    }\n    function pu(t, e, r) {\n      return !!bu(t, e) || !!gu(e, t, r);\n    }\n    function du(t, e) {\n      if (1 === t.length) return vu(e, t[0]);\n      for (let r = 0; r < e.length; r++) {\n        const n = e[r];\n        for (let e = 0; e < n.length; e++) if (bu(t, n[e])) return !0;\n      }\n      for (let r = 0; r < t.length; r++) if (vu(e, t[r])) return !0;\n      for (let r = 0; r < e.length; r++) if (yu(t, e[r])) return !0;\n      return !1;\n    }\n    function fu(t, e, r) {\n      if (t.length > 1) {\n        if (yu(t, e)) return !0;\n        for (let n = 0; n < e.length; n++) if (gu(e[n], t, r)) return !0;\n      }\n      for (let n = 0; n < t.length; n++) if (gu(t[n], e, r)) return !0;\n      return !1;\n    }\n    function yu(t, e) {\n      if (0 === t.length || 0 === e.length) return !1;\n      for (let r = 0; r < t.length - 1; r++) {\n        const n = t[r],\n          i = t[r + 1];\n        for (let t = 0; t < e.length - 1; t++) if (mu(n, i, e[t], e[t + 1])) return !0;\n      }\n      return !1;\n    }\n    function mu(t, e, r, n) {\n      return G(t, r, n) !== G(e, r, n) && G(t, e, r) !== G(t, e, n);\n    }\n    function gu(t, e, r) {\n      const n = r * r;\n      if (1 === e.length) return t.distSqr(e[0]) < n;\n      for (let r = 1; r < e.length; r++) if (xu(t, e[r - 1], e[r]) < n) return !0;\n      return !1;\n    }\n    function xu(t, e, r) {\n      const n = e.distSqr(r);\n      if (0 === n) return t.distSqr(e);\n      const i = ((t.x - e.x) * (r.x - e.x) + (t.y - e.y) * (r.y - e.y)) / n;\n      return t.distSqr(i < 0 ? e : i > 1 ? r : r.sub(e)._mult(i)._add(e));\n    }\n    function vu(t, e) {\n      let r,\n        n,\n        i,\n        s = !1;\n      for (let a = 0; a < t.length; a++) {\n        r = t[a];\n        for (let t = 0, a = r.length - 1; t < r.length; a = t++) n = r[t], i = r[a], n.y > e.y != i.y > e.y && e.x < (i.x - n.x) * (e.y - n.y) / (i.y - n.y) + n.x && (s = !s);\n      }\n      return s;\n    }\n    function bu(t, e) {\n      let r = !1;\n      for (let n = 0, i = t.length - 1; n < t.length; i = n++) {\n        const s = t[n],\n          a = t[i];\n        s.y > e.y != a.y > e.y && e.x < (a.x - s.x) * (e.y - s.y) / (a.y - s.y) + s.x && (r = !r);\n      }\n      return r;\n    }\n    function wu(t, e, r, n, i) {\n      for (const s of t) if (e <= s.x && r <= s.y && n >= s.x && i >= s.y) return !0;\n      const s = [new x(e, r), new x(e, i), new x(n, i), new x(n, r)];\n      if (t.length > 2) for (const e of s) if (bu(t, e)) return !0;\n      for (let e = 0; e < t.length - 1; e++) if (_u(t[e], t[e + 1], s)) return !0;\n      return !1;\n    }\n    function _u(t, e, r) {\n      const n = r[0],\n        i = r[2];\n      if (t.x < n.x && e.x < n.x || t.x > i.x && e.x > i.x || t.y < n.y && e.y < n.y || t.y > i.y && e.y > i.y) return !1;\n      const s = G(t, e, r[0]);\n      return s !== G(t, e, r[1]) || s !== G(t, e, r[2]) || s !== G(t, e, r[3]);\n    }\n    function Au(t, e, r) {\n      const n = e.paint.get(t).value;\n      return \"constant\" === n.kind ? n.value : r.programConfigurations.get(e.id).getMaxValue(t);\n    }\n    function Su(t) {\n      return Math.sqrt(t[0] * t[0] + t[1] * t[1]);\n    }\n    function ku(t, e, r, n, i) {\n      if (!e[0] && !e[1]) return t;\n      const s = x.convert(e)._mult(i);\n      \"viewport\" === r && s._rotate(-n);\n      const a = [];\n      for (let e = 0; e < t.length; e++) a.push(t[e].sub(s));\n      return a;\n    }\n    function Iu(t, e, r, n) {\n      const i = x.convert(t)._mult(n);\n      return \"viewport\" === e && i._rotate(-r), i;\n    }\n    Ji(cu, \"CircleBucket\", {\n      omit: [\"layers\"]\n    });\n    const Mu = new Ps({\n      \"circle-sort-key\": new Es(te.layout_circle[\"circle-sort-key\"])\n    });\n    var Tu = {\n      paint: new Ps({\n        \"circle-radius\": new Es(te.paint_circle[\"circle-radius\"]),\n        \"circle-color\": new Es(te.paint_circle[\"circle-color\"]),\n        \"circle-blur\": new Es(te.paint_circle[\"circle-blur\"]),\n        \"circle-opacity\": new Es(te.paint_circle[\"circle-opacity\"]),\n        \"circle-translate\": new Bs(te.paint_circle[\"circle-translate\"]),\n        \"circle-translate-anchor\": new Bs(te.paint_circle[\"circle-translate-anchor\"]),\n        \"circle-pitch-scale\": new Bs(te.paint_circle[\"circle-pitch-scale\"]),\n        \"circle-pitch-alignment\": new Bs(te.paint_circle[\"circle-pitch-alignment\"]),\n        \"circle-stroke-width\": new Es(te.paint_circle[\"circle-stroke-width\"]),\n        \"circle-stroke-color\": new Es(te.paint_circle[\"circle-stroke-color\"]),\n        \"circle-stroke-opacity\": new Es(te.paint_circle[\"circle-stroke-opacity\"])\n      }),\n      layout: Mu\n    };\n    function zu(t, e, r, n, i, s, a, o, l) {\n      if (s && t.queryGeometry.isAboveHorizon) return !1;\n      s && (l *= t.pixelToTileUnitsFactor);\n      const u = t.tileID.canonical,\n        c = r.projection.upVectorScale(u, r.center.lat, r.worldSize).metersToTile;\n      for (const h of e) for (const e of h) {\n        const h = e.add(o),\n          p = i && r.elevation ? r.elevation.exaggeration() * i.getElevationAt(h.x, h.y, !0) : 0,\n          d = r.projection.projectTilePoint(h.x, h.y, u);\n        if (p > 0) {\n          const t = r.projection.upVector(u, h.x, h.y);\n          d.x += t[0] * c * p, d.y += t[1] * c * p, d.z += t[2] * c * p;\n        }\n        const f = s ? h : Bu(d.x, d.y, d.z, n),\n          y = s ? t.tilespaceRays.map(t => Pu(t, p)) : t.queryGeometry.screenGeometry,\n          m = Go([], [d.x, d.y, d.z, 1], n);\n        if (!a && s ? l *= m[3] / r.cameraToCenterDistance : a && !s && (l *= r.cameraToCenterDistance / m[3]), s) {\n          const t = Xl((e.y / ao + u.y) / (1 << u.z));\n          l /= r.projection.pixelsPerMeter(t, 1) / Zl(1, t);\n        }\n        if (pu(y, f, l)) return !0;\n      }\n      return !1;\n    }\n    function Bu(t, e, r, n) {\n      const i = Go([], [t, e, r, 1], n);\n      return new x(i[0] / i[3], i[1] / i[3]);\n    }\n    const Eu = Io(0, 0, 0),\n      Cu = Io(0, 0, 1);\n    function Pu(t, e) {\n      const r = Ao();\n      return Eu[2] = e, t.intersectsPlane(Eu, Cu, r), new x(r[0], r[1]);\n    }\n    class Du extends cu {}\n    function Vu(t, {\n      width: e,\n      height: r\n    }, n, i) {\n      if (i) {\n        if (i instanceof Uint8ClampedArray) i = new Uint8Array(i.buffer);else if (i.length !== e * r * n) throw new RangeError(\"mismatched image size\");\n      } else i = new Uint8Array(e * r * n);\n      return t.width = e, t.height = r, t.data = i, t;\n    }\n    function Lu(t, e, r) {\n      const {\n        width: n,\n        height: i\n      } = e;\n      n === t.width && i === t.height || (Fu(t, e, {\n        x: 0,\n        y: 0\n      }, {\n        x: 0,\n        y: 0\n      }, {\n        width: Math.min(t.width, n),\n        height: Math.min(t.height, i)\n      }, r), t.width = n, t.height = i, t.data = e.data);\n    }\n    function Fu(t, e, r, n, i, s) {\n      if (0 === i.width || 0 === i.height) return e;\n      if (i.width > t.width || i.height > t.height || r.x > t.width - i.width || r.y > t.height - i.height) throw new RangeError(\"out of range source coordinates for image copy\");\n      if (i.width > e.width || i.height > e.height || n.x > e.width - i.width || n.y > e.height - i.height) throw new RangeError(\"out of range destination coordinates for image copy\");\n      const a = t.data,\n        o = e.data;\n      for (let l = 0; l < i.height; l++) {\n        const u = ((r.y + l) * t.width + r.x) * s,\n          c = ((n.y + l) * e.width + n.x) * s;\n        for (let t = 0; t < i.width * s; t++) o[c + t] = a[u + t];\n      }\n      return e;\n    }\n    Ji(Du, \"HeatmapBucket\", {\n      omit: [\"layers\"]\n    });\n    class Ru {\n      constructor(t, e) {\n        Vu(this, t, 1, e);\n      }\n      resize(t) {\n        Lu(this, new Ru(t), 1);\n      }\n      clone() {\n        return new Ru({\n          width: this.width,\n          height: this.height\n        }, new Uint8Array(this.data));\n      }\n      static copy(t, e, r, n, i) {\n        Fu(t, e, r, n, i, 1);\n      }\n    }\n    class Uu {\n      constructor(t, e) {\n        Vu(this, t, 4, e);\n      }\n      resize(t) {\n        Lu(this, new Uu(t), 4);\n      }\n      replace(t, e) {\n        e ? this.data.set(t) : this.data = t instanceof Uint8ClampedArray ? new Uint8Array(t.buffer) : t;\n      }\n      clone() {\n        return new Uu({\n          width: this.width,\n          height: this.height\n        }, new Uint8Array(this.data));\n      }\n      static copy(t, e, r, n, i) {\n        Fu(t, e, r, n, i, 4);\n      }\n    }\n    Ji(Ru, \"AlphaImage\"), Ji(Uu, \"RGBAImage\");\n    var $u = {\n      paint: new Ps({\n        \"heatmap-radius\": new Es(te.paint_heatmap[\"heatmap-radius\"]),\n        \"heatmap-weight\": new Es(te.paint_heatmap[\"heatmap-weight\"]),\n        \"heatmap-intensity\": new Bs(te.paint_heatmap[\"heatmap-intensity\"]),\n        \"heatmap-color\": new Cs(te.paint_heatmap[\"heatmap-color\"]),\n        \"heatmap-opacity\": new Bs(te.paint_heatmap[\"heatmap-opacity\"])\n      })\n    };\n    function ju(t) {\n      const e = {},\n        r = t.resolution || 256,\n        n = t.clips ? t.clips.length : 1,\n        i = t.image || new Uu({\n          width: r,\n          height: n\n        }),\n        s = (r, n, s) => {\n          e[t.evaluationKey] = s;\n          const a = t.expression.evaluate(e);\n          i.data[r + n + 0] = Math.floor(255 * a.r / a.a), i.data[r + n + 1] = Math.floor(255 * a.g / a.a), i.data[r + n + 2] = Math.floor(255 * a.b / a.a), i.data[r + n + 3] = Math.floor(255 * a.a);\n        };\n      if (t.clips) for (let e = 0, i = 0; e < n; ++e, i += 4 * r) for (let n = 0, a = 0; n < r; n++, a += 4) {\n        const o = n / (r - 1),\n          {\n            start: l,\n            end: u\n          } = t.clips[e];\n        s(i, a, l * (1 - o) + u * o);\n      } else for (let t = 0, e = 0; t < r; t++, e += 4) s(0, e, t / (r - 1));\n      return i;\n    }\n    var Ou = {\n      paint: new Ps({\n        \"hillshade-illumination-direction\": new Bs(te.paint_hillshade[\"hillshade-illumination-direction\"]),\n        \"hillshade-illumination-anchor\": new Bs(te.paint_hillshade[\"hillshade-illumination-anchor\"]),\n        \"hillshade-exaggeration\": new Bs(te.paint_hillshade[\"hillshade-exaggeration\"]),\n        \"hillshade-shadow-color\": new Bs(te.paint_hillshade[\"hillshade-shadow-color\"]),\n        \"hillshade-highlight-color\": new Bs(te.paint_hillshade[\"hillshade-highlight-color\"]),\n        \"hillshade-accent-color\": new Bs(te.paint_hillshade[\"hillshade-accent-color\"])\n      })\n    };\n    const qu = Rs([{\n        name: \"a_pos\",\n        components: 2,\n        type: \"Int16\"\n      }], 4),\n      {\n        members: Nu\n      } = qu;\n    var Gu = {\n      exports: {}\n    };\n    function Zu(t, e, r) {\n      r = r || 2;\n      var n,\n        i,\n        s,\n        a,\n        o,\n        l,\n        u,\n        c = e && e.length,\n        h = c ? e[0] * r : t.length,\n        p = Ku(t, 0, h, r, !0),\n        d = [];\n      if (!p || p.next === p.prev) return d;\n      if (c && (p = function (t, e, r, n) {\n        var i,\n          s,\n          a,\n          o = [];\n        for (i = 0, s = e.length; i < s; i++) (a = Ku(t, e[i] * n, i < s - 1 ? e[i + 1] * n : t.length, n, !1)) === a.next && (a.steiner = !0), o.push(ic(a));\n        for (o.sort(tc), i = 0; i < o.length; i++) r = ec(o[i], r);\n        return r;\n      }(t, e, p, r)), t.length > 80 * r) {\n        n = s = t[0], i = a = t[1];\n        for (var f = r; f < h; f += r) (o = t[f]) < n && (n = o), (l = t[f + 1]) < i && (i = l), o > s && (s = o), l > a && (a = l);\n        u = 0 !== (u = Math.max(s - n, a - i)) ? 32767 / u : 0;\n      }\n      return Ju(p, d, r, n, i, u, 0), d;\n    }\n    function Ku(t, e, r, n, i) {\n      var s, a;\n      if (i === gc(t, e, r, n) > 0) for (s = e; s < r; s += n) a = fc(s, t[s], t[s + 1], a);else for (s = r - n; s >= e; s -= n) a = fc(s, t[s], t[s + 1], a);\n      return a && lc(a, a.next) && (yc(a), a = a.next), a;\n    }\n    function Xu(t, e) {\n      if (!t) return t;\n      e || (e = t);\n      var r,\n        n = t;\n      do {\n        if (r = !1, n.steiner || !lc(n, n.next) && 0 !== oc(n.prev, n, n.next)) n = n.next;else {\n          if (yc(n), (n = e = n.prev) === n.next) break;\n          r = !0;\n        }\n      } while (r || n !== e);\n      return e;\n    }\n    function Ju(t, e, r, n, i, s, a) {\n      if (t) {\n        !a && s && function (t, e, r, n) {\n          var i = t;\n          do {\n            0 === i.z && (i.z = nc(i.x, i.y, e, r, n)), i.prevZ = i.prev, i.nextZ = i.next, i = i.next;\n          } while (i !== t);\n          i.prevZ.nextZ = null, i.prevZ = null, function (t) {\n            var e,\n              r,\n              n,\n              i,\n              s,\n              a,\n              o,\n              l,\n              u = 1;\n            do {\n              for (r = t, t = null, s = null, a = 0; r;) {\n                for (a++, n = r, o = 0, e = 0; e < u && (o++, n = n.nextZ); e++);\n                for (l = u; o > 0 || l > 0 && n;) 0 !== o && (0 === l || !n || r.z <= n.z) ? (i = r, r = r.nextZ, o--) : (i = n, n = n.nextZ, l--), s ? s.nextZ = i : t = i, i.prevZ = s, s = i;\n                r = n;\n              }\n              s.nextZ = null, u *= 2;\n            } while (a > 1);\n          }(i);\n        }(t, n, i, s);\n        for (var o, l, u = t; t.prev !== t.next;) if (o = t.prev, l = t.next, s ? Yu(t, n, i, s) : Hu(t)) e.push(o.i / r | 0), e.push(t.i / r | 0), e.push(l.i / r | 0), yc(t), t = l.next, u = l.next;else if ((t = l) === u) {\n          a ? 1 === a ? Ju(t = Wu(Xu(t), e, r), e, r, n, i, s, 2) : 2 === a && Qu(t, e, r, n, i, s) : Ju(Xu(t), e, r, n, i, s, 1);\n          break;\n        }\n      }\n    }\n    function Hu(t) {\n      var e = t.prev,\n        r = t,\n        n = t.next;\n      if (oc(e, r, n) >= 0) return !1;\n      for (var i = e.x, s = r.x, a = n.x, o = e.y, l = r.y, u = n.y, c = i < s ? i < a ? i : a : s < a ? s : a, h = o < l ? o < u ? o : u : l < u ? l : u, p = i > s ? i > a ? i : a : s > a ? s : a, d = o > l ? o > u ? o : u : l > u ? l : u, f = n.next; f !== e;) {\n        if (f.x >= c && f.x <= p && f.y >= h && f.y <= d && sc(i, o, s, l, a, u, f.x, f.y) && oc(f.prev, f, f.next) >= 0) return !1;\n        f = f.next;\n      }\n      return !0;\n    }\n    function Yu(t, e, r, n) {\n      var i = t.prev,\n        s = t,\n        a = t.next;\n      if (oc(i, s, a) >= 0) return !1;\n      for (var o = i.x, l = s.x, u = a.x, c = i.y, h = s.y, p = a.y, d = o < l ? o < u ? o : u : l < u ? l : u, f = c < h ? c < p ? c : p : h < p ? h : p, y = o > l ? o > u ? o : u : l > u ? l : u, m = c > h ? c > p ? c : p : h > p ? h : p, g = nc(d, f, e, r, n), x = nc(y, m, e, r, n), v = t.prevZ, b = t.nextZ; v && v.z >= g && b && b.z <= x;) {\n        if (v.x >= d && v.x <= y && v.y >= f && v.y <= m && v !== i && v !== a && sc(o, c, l, h, u, p, v.x, v.y) && oc(v.prev, v, v.next) >= 0) return !1;\n        if (v = v.prevZ, b.x >= d && b.x <= y && b.y >= f && b.y <= m && b !== i && b !== a && sc(o, c, l, h, u, p, b.x, b.y) && oc(b.prev, b, b.next) >= 0) return !1;\n        b = b.nextZ;\n      }\n      for (; v && v.z >= g;) {\n        if (v.x >= d && v.x <= y && v.y >= f && v.y <= m && v !== i && v !== a && sc(o, c, l, h, u, p, v.x, v.y) && oc(v.prev, v, v.next) >= 0) return !1;\n        v = v.prevZ;\n      }\n      for (; b && b.z <= x;) {\n        if (b.x >= d && b.x <= y && b.y >= f && b.y <= m && b !== i && b !== a && sc(o, c, l, h, u, p, b.x, b.y) && oc(b.prev, b, b.next) >= 0) return !1;\n        b = b.nextZ;\n      }\n      return !0;\n    }\n    function Wu(t, e, r) {\n      var n = t;\n      do {\n        var i = n.prev,\n          s = n.next.next;\n        !lc(i, s) && uc(i, n, n.next, s) && pc(i, s) && pc(s, i) && (e.push(i.i / r | 0), e.push(n.i / r | 0), e.push(s.i / r | 0), yc(n), yc(n.next), n = t = s), n = n.next;\n      } while (n !== t);\n      return Xu(n);\n    }\n    function Qu(t, e, r, n, i, s) {\n      var a = t;\n      do {\n        for (var o = a.next.next; o !== a.prev;) {\n          if (a.i !== o.i && ac(a, o)) {\n            var l = dc(a, o);\n            return a = Xu(a, a.next), l = Xu(l, l.next), Ju(a, e, r, n, i, s, 0), void Ju(l, e, r, n, i, s, 0);\n          }\n          o = o.next;\n        }\n        a = a.next;\n      } while (a !== t);\n    }\n    function tc(t, e) {\n      return t.x - e.x;\n    }\n    function ec(t, e) {\n      var r = function (t, e) {\n        var r,\n          n = e,\n          i = t.x,\n          s = t.y,\n          a = -1 / 0;\n        do {\n          if (s <= n.y && s >= n.next.y && n.next.y !== n.y) {\n            var o = n.x + (s - n.y) * (n.next.x - n.x) / (n.next.y - n.y);\n            if (o <= i && o > a && (a = o, r = n.x < n.next.x ? n : n.next, o === i)) return r;\n          }\n          n = n.next;\n        } while (n !== e);\n        if (!r) return null;\n        var l,\n          u = r,\n          c = r.x,\n          h = r.y,\n          p = 1 / 0;\n        n = r;\n        do {\n          i >= n.x && n.x >= c && i !== n.x && sc(s < h ? i : a, s, c, h, s < h ? a : i, s, n.x, n.y) && (l = Math.abs(s - n.y) / (i - n.x), pc(n, t) && (l < p || l === p && (n.x > r.x || n.x === r.x && rc(r, n))) && (r = n, p = l)), n = n.next;\n        } while (n !== u);\n        return r;\n      }(t, e);\n      if (!r) return e;\n      var n = dc(r, t);\n      return Xu(n, n.next), Xu(r, r.next);\n    }\n    function rc(t, e) {\n      return oc(t.prev, t, e.prev) < 0 && oc(e.next, t, t.next) < 0;\n    }\n    function nc(t, e, r, n, i) {\n      return (t = 1431655765 & ((t = 858993459 & ((t = 252645135 & ((t = 16711935 & ((t = (t - r) * i | 0) | t << 8)) | t << 4)) | t << 2)) | t << 1)) | (e = 1431655765 & ((e = 858993459 & ((e = 252645135 & ((e = 16711935 & ((e = (e - n) * i | 0) | e << 8)) | e << 4)) | e << 2)) | e << 1)) << 1;\n    }\n    function ic(t) {\n      var e = t,\n        r = t;\n      do {\n        (e.x < r.x || e.x === r.x && e.y < r.y) && (r = e), e = e.next;\n      } while (e !== t);\n      return r;\n    }\n    function sc(t, e, r, n, i, s, a, o) {\n      return (i - a) * (e - o) >= (t - a) * (s - o) && (t - a) * (n - o) >= (r - a) * (e - o) && (r - a) * (s - o) >= (i - a) * (n - o);\n    }\n    function ac(t, e) {\n      return t.next.i !== e.i && t.prev.i !== e.i && !function (t, e) {\n        var r = t;\n        do {\n          if (r.i !== t.i && r.next.i !== t.i && r.i !== e.i && r.next.i !== e.i && uc(r, r.next, t, e)) return !0;\n          r = r.next;\n        } while (r !== t);\n        return !1;\n      }(t, e) && (pc(t, e) && pc(e, t) && function (t, e) {\n        var r = t,\n          n = !1,\n          i = (t.x + e.x) / 2,\n          s = (t.y + e.y) / 2;\n        do {\n          r.y > s != r.next.y > s && r.next.y !== r.y && i < (r.next.x - r.x) * (s - r.y) / (r.next.y - r.y) + r.x && (n = !n), r = r.next;\n        } while (r !== t);\n        return n;\n      }(t, e) && (oc(t.prev, t, e.prev) || oc(t, e.prev, e)) || lc(t, e) && oc(t.prev, t, t.next) > 0 && oc(e.prev, e, e.next) > 0);\n    }\n    function oc(t, e, r) {\n      return (e.y - t.y) * (r.x - e.x) - (e.x - t.x) * (r.y - e.y);\n    }\n    function lc(t, e) {\n      return t.x === e.x && t.y === e.y;\n    }\n    function uc(t, e, r, n) {\n      var i = hc(oc(t, e, r)),\n        s = hc(oc(t, e, n)),\n        a = hc(oc(r, n, t)),\n        o = hc(oc(r, n, e));\n      return i !== s && a !== o || !(0 !== i || !cc(t, r, e)) || !(0 !== s || !cc(t, n, e)) || !(0 !== a || !cc(r, t, n)) || !(0 !== o || !cc(r, e, n));\n    }\n    function cc(t, e, r) {\n      return e.x <= Math.max(t.x, r.x) && e.x >= Math.min(t.x, r.x) && e.y <= Math.max(t.y, r.y) && e.y >= Math.min(t.y, r.y);\n    }\n    function hc(t) {\n      return t > 0 ? 1 : t < 0 ? -1 : 0;\n    }\n    function pc(t, e) {\n      return oc(t.prev, t, t.next) < 0 ? oc(t, e, t.next) >= 0 && oc(t, t.prev, e) >= 0 : oc(t, e, t.prev) < 0 || oc(t, t.next, e) < 0;\n    }\n    function dc(t, e) {\n      var r = new mc(t.i, t.x, t.y),\n        n = new mc(e.i, e.x, e.y),\n        i = t.next,\n        s = e.prev;\n      return t.next = e, e.prev = t, r.next = i, i.prev = r, n.next = r, r.prev = n, s.next = n, n.prev = s, n;\n    }\n    function fc(t, e, r, n) {\n      var i = new mc(t, e, r);\n      return n ? (i.next = n.next, i.prev = n, n.next.prev = i, n.next = i) : (i.prev = i, i.next = i), i;\n    }\n    function yc(t) {\n      t.next.prev = t.prev, t.prev.next = t.next, t.prevZ && (t.prevZ.nextZ = t.nextZ), t.nextZ && (t.nextZ.prevZ = t.prevZ);\n    }\n    function mc(t, e, r) {\n      this.i = t, this.x = e, this.y = r, this.prev = null, this.next = null, this.z = 0, this.prevZ = null, this.nextZ = null, this.steiner = !1;\n    }\n    function gc(t, e, r, n) {\n      for (var i = 0, s = e, a = r - n; s < r; s += n) i += (t[a] - t[s]) * (t[s + 1] + t[a + 1]), a = s;\n      return i;\n    }\n    Gu.exports = Zu, Gu.exports.default = Zu, Zu.deviation = function (t, e, r, n) {\n      var i = e && e.length,\n        s = Math.abs(gc(t, 0, i ? e[0] * r : t.length, r));\n      if (i) for (var a = 0, o = e.length; a < o; a++) s -= Math.abs(gc(t, e[a] * r, a < o - 1 ? e[a + 1] * r : t.length, r));\n      var l = 0;\n      for (a = 0; a < n.length; a += 3) {\n        var u = n[a] * r,\n          c = n[a + 1] * r,\n          h = n[a + 2] * r;\n        l += Math.abs((t[u] - t[h]) * (t[c + 1] - t[u + 1]) - (t[u] - t[c]) * (t[h + 1] - t[u + 1]));\n      }\n      return 0 === s && 0 === l ? 0 : Math.abs((l - s) / s);\n    }, Zu.flatten = function (t) {\n      for (var e = t[0][0].length, r = {\n          vertices: [],\n          holes: [],\n          dimensions: e\n        }, n = 0, i = 0; i < t.length; i++) {\n        for (var s = 0; s < t[i].length; s++) for (var a = 0; a < e; a++) r.vertices.push(t[i][s][a]);\n        i > 0 && r.holes.push(n += t[i - 1].length);\n      }\n      return r;\n    };\n    var xc = p(Gu.exports);\n    function vc(t, e, r, n, i) {\n      bc(t, e, r || 0, n || t.length - 1, i || _c);\n    }\n    function bc(t, e, r, n, i) {\n      for (; n > r;) {\n        if (n - r > 600) {\n          var s = n - r + 1,\n            a = e - r + 1,\n            o = Math.log(s),\n            l = .5 * Math.exp(2 * o / 3),\n            u = .5 * Math.sqrt(o * l * (s - l) / s) * (a - s / 2 < 0 ? -1 : 1);\n          bc(t, e, Math.max(r, Math.floor(e - a * l / s + u)), Math.min(n, Math.floor(e + (s - a) * l / s + u)), i);\n        }\n        var c = t[e],\n          h = r,\n          p = n;\n        for (wc(t, r, e), i(t[n], c) > 0 && wc(t, r, n); h < p;) {\n          for (wc(t, h, p), h++, p--; i(t[h], c) < 0;) h++;\n          for (; i(t[p], c) > 0;) p--;\n        }\n        0 === i(t[r], c) ? wc(t, r, p) : wc(t, ++p, n), p <= e && (r = p + 1), e <= p && (n = p - 1);\n      }\n    }\n    function wc(t, e, r) {\n      var n = t[e];\n      t[e] = t[r], t[r] = n;\n    }\n    function _c(t, e) {\n      return t < e ? -1 : t > e ? 1 : 0;\n    }\n    function Ac(t, e) {\n      const r = t.length;\n      if (r <= 1) return [t];\n      const n = [];\n      let i, s;\n      for (let e = 0; e < r; e++) {\n        const r = Z(t[e]);\n        0 !== r && (t[e].area = Math.abs(r), void 0 === s && (s = r < 0), s === r < 0 ? (i && n.push(i), i = [t[e]]) : i.push(t[e]));\n      }\n      if (i && n.push(i), e > 1) for (let t = 0; t < n.length; t++) n[t].length <= e || (vc(n[t], e, 1, n[t].length - 1, Sc), n[t] = n[t].slice(0, e));\n      return n;\n    }\n    function Sc(t, e) {\n      return e.area - t.area;\n    }\n    function kc(t, e, r) {\n      const n = r.patternDependencies;\n      let i = !1;\n      for (const r of e) {\n        const e = r.paint.get(`${t}-pattern`);\n        e.isConstant() || (i = !0);\n        const s = e.constantOr(null);\n        s && (i = !0, n[s] = !0);\n      }\n      return i;\n    }\n    function Ic(t, e, r, n, i) {\n      const s = i.patternDependencies;\n      for (const a of e) {\n        const e = a.paint.get(`${t}-pattern`).value;\n        if (\"constant\" !== e.kind) {\n          let t = e.evaluate({\n            zoom: n\n          }, r, {}, i.availableImages);\n          t = t && t.name ? t.name : t, s[t] = !0, r.patterns[a.id] = t;\n        }\n      }\n      return r;\n    }\n    class Mc {\n      constructor(t) {\n        this.zoom = t.zoom, this.overscaling = t.overscaling, this.layers = t.layers, this.layerIds = this.layers.map(t => t.id), this.index = t.index, this.hasPattern = !1, this.patternFeatures = [], this.layoutVertexArray = new $s(), this.indexArray = new ra(), this.indexArray2 = new la(), this.programConfigurations = new Ja(t.layers, t.zoom), this.segments = new so(), this.segments2 = new so(), this.stateDependentLayerIds = this.layers.filter(t => t.isStateDependent()).map(t => t.id), this.projection = t.projection;\n      }\n      populate(t, e, r, n) {\n        this.hasPattern = kc(\"fill\", this.layers, e);\n        const i = this.layers[0].layout.get(\"fill-sort-key\"),\n          s = [];\n        for (const {\n          feature: a,\n          id: o,\n          index: l,\n          sourceLayerIndex: u\n        } of t) {\n          const t = this.layers[0]._featureFilter.needGeometry,\n            c = ou(a, t);\n          if (!this.layers[0]._featureFilter.filter(new ws(this.zoom), c, r)) continue;\n          const h = i ? i.evaluate(c, {}, r, e.availableImages) : void 0,\n            p = {\n              id: o,\n              properties: a.properties,\n              type: a.type,\n              sourceLayerIndex: u,\n              index: l,\n              geometry: t ? c.geometry : au(a, r, n),\n              patterns: {},\n              sortKey: h\n            };\n          s.push(p);\n        }\n        i && s.sort((t, e) => t.sortKey - e.sortKey);\n        for (const n of s) {\n          const {\n            geometry: i,\n            index: s,\n            sourceLayerIndex: a\n          } = n;\n          if (this.hasPattern) {\n            const t = Ic(\"fill\", this.layers, n, this.zoom, e);\n            this.patternFeatures.push(t);\n          } else this.addFeature(n, i, s, r, {}, e.availableImages);\n          e.featureIndex.insert(t[s].feature, i, s, a, this.index);\n        }\n      }\n      update(t, e, r, n) {\n        this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t, e, this.stateDependentLayers, r, n);\n      }\n      addFeatures(t, e, r, n, i) {\n        for (const t of this.patternFeatures) this.addFeature(t, t.geometry, t.index, e, r, n);\n      }\n      isEmpty() {\n        return 0 === this.layoutVertexArray.length;\n      }\n      uploadPending() {\n        return !this.uploaded || this.programConfigurations.needsUpload;\n      }\n      upload(t) {\n        this.uploaded || (this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, Nu), this.indexBuffer = t.createIndexBuffer(this.indexArray), this.indexBuffer2 = t.createIndexBuffer(this.indexArray2)), this.programConfigurations.upload(t), this.uploaded = !0;\n      }\n      destroy() {\n        this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.indexBuffer2.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.segments2.destroy());\n      }\n      addFeature(t, e, r, n, i, s = []) {\n        for (const t of Ac(e, 500)) {\n          let e = 0;\n          for (const r of t) e += r.length;\n          const r = this.segments.prepareSegment(e, this.layoutVertexArray, this.indexArray),\n            n = r.vertexLength,\n            i = [],\n            s = [];\n          for (const e of t) {\n            if (0 === e.length) continue;\n            e !== t[0] && s.push(i.length / 2);\n            const r = this.segments2.prepareSegment(e.length, this.layoutVertexArray, this.indexArray2),\n              n = r.vertexLength;\n            this.layoutVertexArray.emplaceBack(e[0].x, e[0].y), this.indexArray2.emplaceBack(n + e.length - 1, n), i.push(e[0].x), i.push(e[0].y);\n            for (let t = 1; t < e.length; t++) this.layoutVertexArray.emplaceBack(e[t].x, e[t].y), this.indexArray2.emplaceBack(n + t - 1, n + t), i.push(e[t].x), i.push(e[t].y);\n            r.vertexLength += e.length, r.primitiveLength += e.length;\n          }\n          const a = xc(i, s);\n          for (let t = 0; t < a.length; t += 3) this.indexArray.emplaceBack(n + a[t], n + a[t + 1], n + a[t + 2]);\n          r.vertexLength += e, r.primitiveLength += a.length / 3;\n        }\n        this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t, r, i, s, n);\n      }\n    }\n    Ji(Mc, \"FillBucket\", {\n      omit: [\"layers\", \"patternFeatures\"]\n    });\n    const Tc = new Ps({\n      \"fill-sort-key\": new Es(te.layout_fill[\"fill-sort-key\"])\n    });\n    var zc = {\n      paint: new Ps({\n        \"fill-antialias\": new Bs(te.paint_fill[\"fill-antialias\"]),\n        \"fill-opacity\": new Es(te.paint_fill[\"fill-opacity\"]),\n        \"fill-color\": new Es(te.paint_fill[\"fill-color\"]),\n        \"fill-outline-color\": new Es(te.paint_fill[\"fill-outline-color\"]),\n        \"fill-translate\": new Bs(te.paint_fill[\"fill-translate\"]),\n        \"fill-translate-anchor\": new Bs(te.paint_fill[\"fill-translate-anchor\"]),\n        \"fill-pattern\": new Es(te.paint_fill[\"fill-pattern\"])\n      }),\n      layout: Tc\n    };\n    const Bc = Rs([{\n        name: \"a_pos_normal_ed\",\n        components: 4,\n        type: \"Int16\"\n      }]),\n      Ec = Rs([{\n        name: \"a_centroid_pos\",\n        components: 2,\n        type: \"Uint16\"\n      }]),\n      Cc = Rs([{\n        name: \"a_pos_3\",\n        components: 3,\n        type: \"Int16\"\n      }, {\n        name: \"a_pos_normal_3\",\n        components: 3,\n        type: \"Int16\"\n      }]),\n      {\n        members: Pc\n      } = Bc;\n    var Dc = {},\n      Vc = m,\n      Lc = Fc;\n    function Fc(t, e, r, n, i) {\n      this.properties = {}, this.extent = r, this.type = 0, this._pbf = t, this._geometry = -1, this._keys = n, this._values = i, t.readFields(Rc, this, e);\n    }\n    function Rc(t, e, r) {\n      1 == t ? e.id = r.readVarint() : 2 == t ? function (t, e) {\n        for (var r = t.readVarint() + t.pos; t.pos < r;) {\n          var n = e._keys[t.readVarint()],\n            i = e._values[t.readVarint()];\n          e.properties[n] = i;\n        }\n      }(r, e) : 3 == t ? e.type = r.readVarint() : 4 == t && (e._geometry = r.pos);\n    }\n    function Uc(t) {\n      for (var e, r, n = 0, i = 0, s = t.length, a = s - 1; i < s; a = i++) n += ((r = t[a]).x - (e = t[i]).x) * (e.y + r.y);\n      return n;\n    }\n    Fc.types = [\"Unknown\", \"Point\", \"LineString\", \"Polygon\"], Fc.prototype.loadGeometry = function () {\n      var t = this._pbf;\n      t.pos = this._geometry;\n      for (var e, r = t.readVarint() + t.pos, n = 1, i = 0, s = 0, a = 0, o = []; t.pos < r;) {\n        if (i <= 0) {\n          var l = t.readVarint();\n          n = 7 & l, i = l >> 3;\n        }\n        if (i--, 1 === n || 2 === n) s += t.readSVarint(), a += t.readSVarint(), 1 === n && (e && o.push(e), e = []), e.push(new Vc(s, a));else {\n          if (7 !== n) throw new Error(\"unknown command \" + n);\n          e && e.push(e[0].clone());\n        }\n      }\n      return e && o.push(e), o;\n    }, Fc.prototype.bbox = function () {\n      var t = this._pbf;\n      t.pos = this._geometry;\n      for (var e = t.readVarint() + t.pos, r = 1, n = 0, i = 0, s = 0, a = 1 / 0, o = -1 / 0, l = 1 / 0, u = -1 / 0; t.pos < e;) {\n        if (n <= 0) {\n          var c = t.readVarint();\n          r = 7 & c, n = c >> 3;\n        }\n        if (n--, 1 === r || 2 === r) (i += t.readSVarint()) < a && (a = i), i > o && (o = i), (s += t.readSVarint()) < l && (l = s), s > u && (u = s);else if (7 !== r) throw new Error(\"unknown command \" + r);\n      }\n      return [a, l, o, u];\n    }, Fc.prototype.toGeoJSON = function (t, e, r) {\n      var n,\n        i,\n        s = this.extent * Math.pow(2, r),\n        a = this.extent * t,\n        o = this.extent * e,\n        l = this.loadGeometry(),\n        u = Fc.types[this.type];\n      function c(t) {\n        for (var e = 0; e < t.length; e++) {\n          var r = t[e];\n          t[e] = [360 * (r.x + a) / s - 180, 360 / Math.PI * Math.atan(Math.exp((180 - 360 * (r.y + o) / s) * Math.PI / 180)) - 90];\n        }\n      }\n      switch (this.type) {\n        case 1:\n          var h = [];\n          for (n = 0; n < l.length; n++) h[n] = l[n][0];\n          c(l = h);\n          break;\n        case 2:\n          for (n = 0; n < l.length; n++) c(l[n]);\n          break;\n        case 3:\n          for (l = function (t) {\n            var e = t.length;\n            if (e <= 1) return [t];\n            for (var r, n, i = [], s = 0; s < e; s++) {\n              var a = Uc(t[s]);\n              0 !== a && (void 0 === n && (n = a < 0), n === a < 0 ? (r && i.push(r), r = [t[s]]) : r.push(t[s]));\n            }\n            return r && i.push(r), i;\n          }(l), n = 0; n < l.length; n++) for (i = 0; i < l[n].length; i++) c(l[n][i]);\n      }\n      1 === l.length ? l = l[0] : u = \"Multi\" + u;\n      var p = {\n        type: \"Feature\",\n        geometry: {\n          type: u,\n          coordinates: l\n        },\n        properties: this.properties\n      };\n      return \"id\" in this && (p.id = this.id), p;\n    };\n    var $c = Lc,\n      jc = Oc;\n    function Oc(t, e) {\n      this.version = 1, this.name = null, this.extent = 4096, this.length = 0, this._pbf = t, this._keys = [], this._values = [], this._features = [], t.readFields(qc, this, e), this.length = this._features.length;\n    }\n    function qc(t, e, r) {\n      15 === t ? e.version = r.readVarint() : 1 === t ? e.name = r.readString() : 5 === t ? e.extent = r.readVarint() : 2 === t ? e._features.push(r.pos) : 3 === t ? e._keys.push(r.readString()) : 4 === t && e._values.push(function (t) {\n        for (var e = null, r = t.readVarint() + t.pos; t.pos < r;) {\n          var n = t.readVarint() >> 3;\n          e = 1 === n ? t.readString() : 2 === n ? t.readFloat() : 3 === n ? t.readDouble() : 4 === n ? t.readVarint64() : 5 === n ? t.readVarint() : 6 === n ? t.readSVarint() : 7 === n ? t.readBoolean() : null;\n        }\n        return e;\n      }(r));\n    }\n    Oc.prototype.feature = function (t) {\n      if (t < 0 || t >= this._features.length) throw new Error(\"feature index out of bounds\");\n      this._pbf.pos = this._features[t];\n      var e = this._pbf.readVarint() + this._pbf.pos;\n      return new $c(this._pbf, e, this.extent, this._keys, this._values);\n    };\n    var Nc = jc;\n    function Gc(t, e, r) {\n      if (3 === t) {\n        var n = new Nc(r, r.readVarint() + r.pos);\n        n.length && (e[n.name] = n);\n      }\n    }\n    var Zc = Dc.VectorTile = function (t, e) {\n        this.layers = t.readFields(Gc, {}, e);\n      },\n      Kc = Dc.VectorTileFeature = Lc;\n    function Xc(t, e, r, n) {\n      const i = [],\n        s = 0 === n ? (t, e, r, n, i, s) => {\n          t.push(new x(s, r + (s - e) / (n - e) * (i - r)));\n        } : (t, e, r, n, i, s) => {\n          t.push(new x(e + (s - r) / (i - r) * (n - e), s));\n        };\n      for (const a of t) {\n        const t = [];\n        for (const i of a) {\n          if (i.length <= 2) continue;\n          const a = [];\n          for (let t = 0; t < i.length - 1; t++) {\n            const o = i[t].x,\n              l = i[t].y,\n              u = i[t + 1].x,\n              c = i[t + 1].y,\n              h = 0 === n ? o : l,\n              p = 0 === n ? u : c;\n            h < e ? p > e && s(a, o, l, u, c, e) : h > r ? p < r && s(a, o, l, u, c, r) : a.push(i[t]), p < e && h >= e && s(a, o, l, u, c, e), p > r && h <= r && s(a, o, l, u, c, r);\n          }\n          let o = i[i.length - 1];\n          const l = 0 === n ? o.x : o.y;\n          l >= e && l <= r && a.push(o), a.length && (o = a[a.length - 1], a[0].x === o.x && a[0].y === o.y || a.push(a[0]), t.push(a));\n        }\n        t.length && i.push(t);\n      }\n      return i;\n    }\n    Dc.VectorTileLayer = jc;\n    const Jc = Kc.types,\n      Hc = Math.pow(2, 13);\n    function Yc(t, e, r, n, i, s, a, o) {\n      t.emplaceBack((e << 1) + a, (r << 1) + s, (Math.floor(n * Hc) << 1) + i, Math.round(o));\n    }\n    function Wc(t, e, r) {\n      const n = 16384;\n      t.emplaceBack(e.x, e.y, e.z, r[0] * n, r[1] * n, r[2] * n);\n    }\n    class Qc {\n      constructor() {\n        this.acc = new x(0, 0), this.polyCount = [];\n      }\n      startRing(t) {\n        this.currentPolyCount = {\n          edges: 0,\n          top: 0\n        }, this.polyCount.push(this.currentPolyCount), this.min || (this.min = new x(t.x, t.y), this.max = new x(t.x, t.y));\n      }\n      append(t, e) {\n        this.currentPolyCount.edges++, this.acc._add(t);\n        const r = this.min,\n          n = this.max;\n        t.x < r.x ? r.x = t.x : t.x > n.x && (n.x = t.x), t.y < r.y ? r.y = t.y : t.y > n.y && (n.y = t.y), ((0 === t.x || t.x === ao) && t.x === e.x) != ((0 === t.y || t.y === ao) && t.y === e.y) && this.processBorderOverlap(t, e), e.x < 0 != t.x < 0 && this.addBorderIntersection(0, Er(e.y, t.y, (0 - e.x) / (t.x - e.x))), e.x > ao != t.x > ao && this.addBorderIntersection(1, Er(e.y, t.y, (ao - e.x) / (t.x - e.x))), e.y < 0 != t.y < 0 && this.addBorderIntersection(2, Er(e.x, t.x, (0 - e.y) / (t.y - e.y))), e.y > ao != t.y > ao && this.addBorderIntersection(3, Er(e.x, t.x, (ao - e.y) / (t.y - e.y)));\n      }\n      addBorderIntersection(t, e) {\n        this.borders || (this.borders = [[Number.MAX_VALUE, -Number.MAX_VALUE], [Number.MAX_VALUE, -Number.MAX_VALUE], [Number.MAX_VALUE, -Number.MAX_VALUE], [Number.MAX_VALUE, -Number.MAX_VALUE]]);\n        const r = this.borders[t];\n        e < r[0] && (r[0] = e), e > r[1] && (r[1] = e);\n      }\n      processBorderOverlap(t, e) {\n        if (t.x === e.x) {\n          if (t.y === e.y) return;\n          const r = 0 === t.x ? 0 : 1;\n          this.addBorderIntersection(r, e.y), this.addBorderIntersection(r, t.y);\n        } else {\n          const r = 0 === t.y ? 2 : 3;\n          this.addBorderIntersection(r, e.x), this.addBorderIntersection(r, t.x);\n        }\n      }\n      centroid() {\n        const t = this.polyCount.reduce((t, e) => t + e.edges, 0);\n        return 0 !== t ? this.acc.div(t)._round() : new x(0, 0);\n      }\n      span() {\n        return new x(this.max.x - this.min.x, this.max.y - this.min.y);\n      }\n      intersectsCount() {\n        return this.borders.reduce((t, e) => t + +(e[0] !== Number.MAX_VALUE), 0);\n      }\n    }\n    class th {\n      constructor(t) {\n        this.zoom = t.zoom, this.canonical = t.canonical, this.overscaling = t.overscaling, this.layers = t.layers, this.layerIds = this.layers.map(t => t.id), this.index = t.index, this.hasPattern = !1, this.edgeRadius = 0, this.projection = t.projection, this.layoutVertexArray = new Os(), this.centroidVertexArray = new wa(), this.indexArray = new ra(), this.programConfigurations = new Ja(t.layers, t.zoom), this.segments = new so(), this.stateDependentLayerIds = this.layers.filter(t => t.isStateDependent()).map(t => t.id), this.enableTerrain = t.enableTerrain;\n      }\n      populate(t, e, r, n) {\n        this.features = [], this.hasPattern = kc(\"fill-extrusion\", this.layers, e), this.featuresOnBorder = [], this.borders = [[], [], [], []], this.borderDoneWithNeighborZ = [-1, -1, -1, -1], this.tileToMeter = function (t) {\n          const e = Math.exp(Math.PI * (1 - t.y / (1 << t.z) * 2));\n          return 80150034 * e / (e * e + 1) / ao / (1 << t.z);\n        }(r), this.edgeRadius = this.layers[0].layout.get(\"fill-extrusion-edge-radius\") / this.tileToMeter;\n        for (const {\n          feature: i,\n          id: s,\n          index: a,\n          sourceLayerIndex: o\n        } of t) {\n          const t = this.layers[0]._featureFilter.needGeometry,\n            l = ou(i, t);\n          if (!this.layers[0]._featureFilter.filter(new ws(this.zoom), l, r)) continue;\n          const u = {\n              id: s,\n              sourceLayerIndex: o,\n              index: a,\n              geometry: t ? l.geometry : au(i, r, n),\n              properties: i.properties,\n              type: i.type,\n              patterns: {}\n            },\n            c = this.layoutVertexArray.length;\n          this.hasPattern ? this.features.push(Ic(\"fill-extrusion\", this.layers, u, this.zoom, e)) : this.addFeature(u, u.geometry, a, r, {}, e.availableImages, n), e.featureIndex.insert(i, u.geometry, a, o, this.index, c);\n        }\n        this.sortBorders();\n      }\n      addFeatures(t, e, r, n, i) {\n        for (const t of this.features) {\n          const {\n            geometry: s\n          } = t;\n          this.addFeature(t, s, t.index, e, r, n, i);\n        }\n        this.sortBorders();\n      }\n      update(t, e, r, n) {\n        this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t, e, this.stateDependentLayers, r, n);\n      }\n      isEmpty() {\n        return 0 === this.layoutVertexArray.length;\n      }\n      uploadPending() {\n        return !this.uploaded || this.programConfigurations.needsUpload;\n      }\n      upload(t) {\n        this.uploaded || (this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, Pc), this.indexBuffer = t.createIndexBuffer(this.indexArray), this.layoutVertexExtArray && (this.layoutVertexExtBuffer = t.createVertexBuffer(this.layoutVertexExtArray, Cc.members, !0))), this.programConfigurations.upload(t), this.uploaded = !0;\n      }\n      uploadCentroid(t) {\n        0 !== this.centroidVertexArray.length && (this.centroidVertexBuffer ? this.needsCentroidUpdate && this.centroidVertexBuffer.updateData(this.centroidVertexArray) : this.centroidVertexBuffer = t.createVertexBuffer(this.centroidVertexArray, Ec.members, !0), this.needsCentroidUpdate = !1);\n      }\n      destroy() {\n        this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.centroidVertexBuffer && this.centroidVertexBuffer.destroy(), this.layoutVertexExtBuffer && this.layoutVertexExtBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());\n      }\n      addFeature(t, e, r, n, i, s, a) {\n        const o = [new x(0, 0), new x(ao, ao)],\n          l = a.projection,\n          u = \"globe\" === l.name,\n          c = this.enableTerrain && !u ? new Qc() : null,\n          h = \"Polygon\" === Jc[t.type];\n        u && !this.layoutVertexExtArray && (this.layoutVertexExtArray = new Ks());\n        const p = Ac(e, 500);\n        for (let t = p.length - 1; t >= 0; t--) {\n          const e = p[t];\n          (0 === e.length || (d = e[0]).every(t => t.x <= 0) || d.every(t => t.x >= ao) || d.every(t => t.y <= 0) || d.every(t => t.y >= ao)) && p.splice(t, 1);\n        }\n        var d;\n        let f;\n        if (u) f = lh(p, o, n);else {\n          f = [];\n          for (const t of p) f.push({\n            polygon: t,\n            bounds: o\n          });\n        }\n        const y = h ? this.edgeRadius : 0;\n        for (const {\n          polygon: t,\n          bounds: e\n        } of f) {\n          let r = 0,\n            i = 0;\n          for (const e of t) h && !e[0].equals(e[e.length - 1]) && e.push(e[0]), i += h ? e.length - 1 : e.length;\n          const s = this.segments.prepareSegment((h ? 5 : 4) * i, this.layoutVertexArray, this.indexArray);\n          if (h) {\n            const e = [],\n              i = [];\n            r = s.vertexLength;\n            for (const r of t) {\n              let a, o;\n              r.length && r !== t[0] && i.push(e.length / 2), a = r[1].sub(r[0])._perp()._unit();\n              for (let t = 1; t < r.length; t++) {\n                const i = r[t],\n                  c = r[t === r.length - 1 ? 1 : t + 1];\n                let {\n                  x: h,\n                  y: p\n                } = i;\n                if (y) {\n                  o = c.sub(i)._perp()._unit();\n                  const t = a.add(o)._unit(),\n                    e = y * Math.min(4, 1 / (a.x * t.x + a.y * t.y));\n                  h += e * t.x, p += e * t.y, a = o;\n                }\n                Yc(this.layoutVertexArray, h, p, 0, 0, 1, 1, 0), s.vertexLength++, e.push(i.x, i.y), u && Wc(this.layoutVertexExtArray, l.projectTilePoint(h, p, n), l.upVector(n, h, p));\n              }\n            }\n            const a = xc(e, i);\n            for (let t = 0; t < a.length; t += 3) this.indexArray.emplaceBack(r + a[t], r + a[t + 2], r + a[t + 1]), s.primitiveLength++;\n          }\n          for (const i of t) {\n            c && i.length && c.startRing(i[0]);\n            let t,\n              a,\n              o,\n              p = i.length > 4 && sh(i[i.length - 2], i[0], i[1]),\n              d = y ? rh(i[i.length - 2], i[0], i[1], y) : 0;\n            a = i[1].sub(i[0])._perp()._unit();\n            let f = !0;\n            for (let m = 1, g = 0; m < i.length; m++) {\n              let x = i[m - 1],\n                v = i[m];\n              const b = i[m === i.length - 1 ? 1 : m + 1];\n              if (c && h && c.currentPolyCount.top++, ih(v, x, e)) {\n                y && (a = b.sub(v)._perp()._unit(), f = !f);\n                continue;\n              }\n              c && c.append(v, x);\n              const w = v.sub(x)._perp(),\n                _ = w.x / (Math.abs(w.x) + Math.abs(w.y)),\n                A = w.y > 0 ? 1 : 0,\n                S = x.dist(v);\n              if (g + S > 32768 && (g = 0), y) {\n                o = b.sub(v)._perp()._unit();\n                let t = nh(x, v, b, eh(a, o), y);\n                isNaN(t) && (t = 0);\n                const e = v.sub(x)._unit();\n                x = x.add(e.mult(d))._round(), v = v.add(e.mult(-t))._round(), d = t, a = o;\n              }\n              const k = s.vertexLength,\n                I = i.length > 4 && sh(x, v, b);\n              let M = ah(g, p, f);\n              if (Yc(this.layoutVertexArray, x.x, x.y, _, A, 0, 0, M), Yc(this.layoutVertexArray, x.x, x.y, _, A, 0, 1, M), g += S, M = ah(g, I, !f), p = I, Yc(this.layoutVertexArray, v.x, v.y, _, A, 0, 0, M), Yc(this.layoutVertexArray, v.x, v.y, _, A, 0, 1, M), s.vertexLength += 4, this.indexArray.emplaceBack(k + 0, k + 1, k + 2), this.indexArray.emplaceBack(k + 1, k + 3, k + 2), s.primitiveLength += 2, y) {\n                const n = r + (1 === m ? i.length - 2 : m - 2),\n                  a = 1 === m ? r : n + 1;\n                if (this.indexArray.emplaceBack(k + 1, n, k + 3), this.indexArray.emplaceBack(n, a, k + 3), s.primitiveLength += 2, void 0 === t && (t = k), !ih(b, i[m], e)) {\n                  const e = m === i.length - 1 ? t : s.vertexLength;\n                  this.indexArray.emplaceBack(k + 2, k + 3, e), this.indexArray.emplaceBack(k + 3, e + 1, e), this.indexArray.emplaceBack(k + 3, a, e + 1), s.primitiveLength += 3;\n                }\n                f = !f;\n              }\n              if (u) {\n                const t = this.layoutVertexExtArray,\n                  e = l.projectTilePoint(x.x, x.y, n),\n                  r = l.projectTilePoint(v.x, v.y, n),\n                  i = l.upVector(n, x.x, x.y),\n                  s = l.upVector(n, v.x, v.y);\n                Wc(t, e, i), Wc(t, e, i), Wc(t, r, s), Wc(t, r, s);\n              }\n            }\n            h && (r += i.length - 1);\n          }\n        }\n        if (c && c.polyCount.length > 0) {\n          if (c.borders) {\n            c.vertexArrayOffset = this.centroidVertexArray.length;\n            const t = c.borders,\n              e = this.featuresOnBorder.push(c) - 1;\n            for (let r = 0; r < 4; r++) t[r][0] !== Number.MAX_VALUE && this.borders[r].push(e);\n          }\n          this.encodeCentroid(c.borders ? void 0 : c.centroid(), c);\n        }\n        this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t, r, i, s, n);\n      }\n      sortBorders() {\n        for (let t = 0; t < 4; t++) this.borders[t].sort((e, r) => this.featuresOnBorder[e].borders[t][0] - this.featuresOnBorder[r].borders[t][0]);\n      }\n      encodeCentroid(t, e, r = !0) {\n        let n, i;\n        if (t) {\n          if (0 !== t.y) {\n            const r = e.span()._mult(this.tileToMeter);\n            n = (Math.max(t.x, 1) << 3) + Math.min(7, Math.round(r.x / 10)), i = (Math.max(t.y, 1) << 3) + Math.min(7, Math.round(r.y / 10));\n          } else n = Math.ceil(7 * (t.x + 450)), i = 0;\n        } else n = 0, i = +r;\n        let s = r ? this.centroidVertexArray.length : e.vertexArrayOffset;\n        for (const t of e.polyCount) {\n          r && this.centroidVertexArray.resize(this.centroidVertexArray.length + 4 * t.edges + t.top);\n          for (let e = 0; e < t.top; e++) this.centroidVertexArray.emplace(s++, n, i);\n          for (let e = 0; e < 2 * t.edges; e++) this.centroidVertexArray.emplace(s++, 0, i), this.centroidVertexArray.emplace(s++, n, i);\n        }\n      }\n    }\n    function eh(t, e) {\n      const r = t.add(e)._unit();\n      return t.x * r.x + t.y * r.y;\n    }\n    function rh(t, e, r, n) {\n      const i = e.sub(t)._perp()._unit(),\n        s = r.sub(e)._perp()._unit();\n      return nh(t, e, r, eh(i, s), n);\n    }\n    function nh(t, e, r, n, i) {\n      const s = Math.sqrt(1 - n * n);\n      return Math.min(t.dist(e) / 3, e.dist(r) / 3, i * s / n);\n    }\n    function ih(t, e, r) {\n      return t.x < r[0].x && e.x < r[0].x || t.x > r[1].x && e.x > r[1].x || t.y < r[0].y && e.y < r[0].y || t.y > r[1].y && e.y > r[1].y;\n    }\n    function sh(t, e, r) {\n      if (t.x < 0 || t.x >= ao || e.x < 0 || e.x >= ao || r.x < 0 || r.x >= ao) return !1;\n      const n = r.sub(e),\n        i = n.perp(),\n        s = t.sub(e);\n      return (n.x * s.x + n.y * s.y) / Math.sqrt((n.x * n.x + n.y * n.y) * (s.x * s.x + s.y * s.y)) > -.866 && i.x * s.x + i.y * s.y < 0;\n    }\n    function ah(t, e, r) {\n      const n = e ? 2 | t : -3 & t;\n      return r ? 1 | n : -2 & n;\n    }\n    function oh() {\n      const t = Math.PI / 32,\n        e = Math.tan(t),\n        r = Ul;\n      return r * Math.sqrt(1 + 2 * e * e) - r;\n    }\n    function lh(t, e, r) {\n      const n = 1 << r.z,\n        i = Kl(r.x / n),\n        s = Kl((r.x + 1) / n),\n        a = Xl(r.y / n),\n        o = Xl((r.y + 1) / n);\n      return function (t, e, r, n, i = 0, s) {\n        const a = [];\n        if (!t.length || !r || !n) return a;\n        const o = (t, e) => {\n            for (const r of t) a.push({\n              polygon: r,\n              bounds: e\n            });\n          },\n          l = Math.ceil(Math.log2(r)),\n          u = Math.ceil(Math.log2(n)),\n          c = l - u,\n          h = [];\n        for (let t = 0; t < Math.abs(c); t++) h.push(c > 0 ? 0 : 1);\n        for (let t = 0; t < Math.min(l, u); t++) h.push(0), h.push(1);\n        let p = t;\n        if (p = Xc(p, e[0].y - i, e[1].y + i, 1), p = Xc(p, e[0].x - i, e[1].x + i, 0), !p.length) return a;\n        const d = [];\n        for (h.length ? d.push({\n          polygons: p,\n          bounds: e,\n          depth: 0\n        }) : o(p, e); d.length;) {\n          const t = d.pop(),\n            e = t.depth,\n            r = h[e],\n            n = t.bounds[0],\n            a = t.bounds[1],\n            l = 0 === r ? n.x : n.y,\n            u = 0 === r ? a.x : a.y,\n            c = s ? s(r, l, u) : .5 * (l + u),\n            p = Xc(t.polygons, l - i, c + i, r),\n            f = Xc(t.polygons, c - i, u + i, r);\n          if (p.length) {\n            const t = [n, new x(0 === r ? c : a.x, 1 === r ? c : a.y)];\n            h.length > e + 1 ? d.push({\n              polygons: p,\n              bounds: t,\n              depth: e + 1\n            }) : o(p, t);\n          }\n          if (f.length) {\n            const t = [new x(0 === r ? c : n.x, 1 === r ? c : n.y), a];\n            h.length > e + 1 ? d.push({\n              polygons: f,\n              bounds: t,\n              depth: e + 1\n            }) : o(f, t);\n          }\n        }\n        return a;\n      }(t, e, Math.ceil((s - i) / 11.25), Math.ceil((a - o) / 11.25), 1, (t, e, i) => {\n        if (0 === t) return .5 * (e + i);\n        {\n          const t = Xl((r.y + e / ao) / n);\n          return (Gl(.5 * (Xl((r.y + i / ao) / n) + t)) * n - r.y) * ao;\n        }\n      });\n    }\n    Ji(th, \"FillExtrusionBucket\", {\n      omit: [\"layers\", \"features\"]\n    }), Ji(Qc, \"PartMetadata\");\n    const uh = new Ps({\n      \"fill-extrusion-edge-radius\": new Bs(te[\"layout_fill-extrusion\"][\"fill-extrusion-edge-radius\"])\n    });\n    var ch = {\n      paint: new Ps({\n        \"fill-extrusion-opacity\": new Bs(te[\"paint_fill-extrusion\"][\"fill-extrusion-opacity\"]),\n        \"fill-extrusion-color\": new Es(te[\"paint_fill-extrusion\"][\"fill-extrusion-color\"]),\n        \"fill-extrusion-translate\": new Bs(te[\"paint_fill-extrusion\"][\"fill-extrusion-translate\"]),\n        \"fill-extrusion-translate-anchor\": new Bs(te[\"paint_fill-extrusion\"][\"fill-extrusion-translate-anchor\"]),\n        \"fill-extrusion-pattern\": new Es(te[\"paint_fill-extrusion\"][\"fill-extrusion-pattern\"]),\n        \"fill-extrusion-height\": new Es(te[\"paint_fill-extrusion\"][\"fill-extrusion-height\"]),\n        \"fill-extrusion-base\": new Es(te[\"paint_fill-extrusion\"][\"fill-extrusion-base\"]),\n        \"fill-extrusion-vertical-gradient\": new Bs(te[\"paint_fill-extrusion\"][\"fill-extrusion-vertical-gradient\"]),\n        \"fill-extrusion-ambient-occlusion-intensity\": new Bs(te[\"paint_fill-extrusion\"][\"fill-extrusion-ambient-occlusion-intensity\"]),\n        \"fill-extrusion-ambient-occlusion-radius\": new Bs(te[\"paint_fill-extrusion\"][\"fill-extrusion-ambient-occlusion-radius\"]),\n        \"fill-extrusion-rounded-roof\": new Bs(te[\"paint_fill-extrusion\"][\"fill-extrusion-rounded-roof\"])\n      }),\n      layout: uh\n    };\n    function hh(t, e, r) {\n      var n = 2 * Math.PI * 6378137 / 256 / Math.pow(2, r);\n      return [t * n - 2 * Math.PI * 6378137 / 2, e * n - 2 * Math.PI * 6378137 / 2];\n    }\n    class ph {\n      constructor(t, e, r) {\n        this.z = t, this.x = e, this.y = r, this.key = yh(0, t, t, e, r);\n      }\n      equals(t) {\n        return this.z === t.z && this.x === t.x && this.y === t.y;\n      }\n      url(t, e) {\n        const r = function (t, e, r) {\n            var n = hh(256 * t, 256 * (e = Math.pow(2, r) - e - 1), r),\n              i = hh(256 * (t + 1), 256 * (e + 1), r);\n            return n[0] + \",\" + n[1] + \",\" + i[0] + \",\" + i[1];\n          }(this.x, this.y, this.z),\n          n = function (t, e, r) {\n            let n,\n              i = \"\";\n            for (let s = t; s > 0; s--) n = 1 << s - 1, i += (e & n ? 1 : 0) + (r & n ? 2 : 0);\n            return i;\n          }(this.z, this.x, this.y);\n        return t[(this.x + this.y) % t.length].replace(\"{prefix}\", (this.x % 16).toString(16) + (this.y % 16).toString(16)).replace(/{z}/g, String(this.z)).replace(/{x}/g, String(this.x)).replace(/{y}/g, String(\"tms\" === e ? Math.pow(2, this.z) - this.y - 1 : this.y)).replace(\"{quadkey}\", n).replace(\"{bbox-epsg-3857}\", r);\n      }\n      toString() {\n        return `${this.z}/${this.x}/${this.y}`;\n      }\n    }\n    class dh {\n      constructor(t, e) {\n        this.wrap = t, this.canonical = e, this.key = yh(t, e.z, e.z, e.x, e.y);\n      }\n    }\n    class fh {\n      constructor(t, e, r, n, i) {\n        this.overscaledZ = t, this.wrap = e, this.canonical = new ph(r, +n, +i), this.key = 0 === e && t === r ? this.canonical.key : yh(e, t, r, n, i);\n      }\n      equals(t) {\n        return this.overscaledZ === t.overscaledZ && this.wrap === t.wrap && this.canonical.equals(t.canonical);\n      }\n      scaledTo(t) {\n        const e = this.canonical.z - t;\n        return t > this.canonical.z ? new fh(t, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y) : new fh(t, this.wrap, t, this.canonical.x >> e, this.canonical.y >> e);\n      }\n      calculateScaledKey(t, e = !0) {\n        if (this.overscaledZ === t && e) return this.key;\n        if (t > this.canonical.z) return yh(this.wrap * +e, t, this.canonical.z, this.canonical.x, this.canonical.y);\n        {\n          const r = this.canonical.z - t;\n          return yh(this.wrap * +e, t, t, this.canonical.x >> r, this.canonical.y >> r);\n        }\n      }\n      isChildOf(t) {\n        if (t.wrap !== this.wrap) return !1;\n        const e = this.canonical.z - t.canonical.z;\n        return 0 === t.overscaledZ || t.overscaledZ < this.overscaledZ && t.canonical.x === this.canonical.x >> e && t.canonical.y === this.canonical.y >> e;\n      }\n      children(t) {\n        if (this.overscaledZ >= t) return [new fh(this.overscaledZ + 1, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y)];\n        const e = this.canonical.z + 1,\n          r = 2 * this.canonical.x,\n          n = 2 * this.canonical.y;\n        return [new fh(e, this.wrap, e, r, n), new fh(e, this.wrap, e, r + 1, n), new fh(e, this.wrap, e, r, n + 1), new fh(e, this.wrap, e, r + 1, n + 1)];\n      }\n      isLessThan(t) {\n        return this.wrap < t.wrap || !(this.wrap > t.wrap) && (this.overscaledZ < t.overscaledZ || !(this.overscaledZ > t.overscaledZ) && (this.canonical.x < t.canonical.x || !(this.canonical.x > t.canonical.x) && this.canonical.y < t.canonical.y));\n      }\n      wrapped() {\n        return new fh(this.overscaledZ, 0, this.canonical.z, this.canonical.x, this.canonical.y);\n      }\n      unwrapTo(t) {\n        return new fh(this.overscaledZ, t, this.canonical.z, this.canonical.x, this.canonical.y);\n      }\n      overscaleFactor() {\n        return Math.pow(2, this.overscaledZ - this.canonical.z);\n      }\n      toUnwrapped() {\n        return new dh(this.wrap, this.canonical);\n      }\n      toString() {\n        return `${this.overscaledZ}/${this.canonical.x}/${this.canonical.y}`;\n      }\n    }\n    function yh(t, e, r, n, i) {\n      const s = 1 << Math.min(r, 22);\n      let a = s * (i % s) + n % s;\n      return t && r < 22 && (a += s * s * ((t < 0 ? -2 * t - 1 : 2 * t) % (1 << 2 * (22 - r)))), 16 * (32 * a + r) + (e - r);\n    }\n    Ji(ph, \"CanonicalTileID\"), Ji(fh, \"OverscaledTileID\", {\n      omit: [\"projMatrix\"]\n    });\n    class mh extends x {\n      constructor(t, e, r) {\n        super(t, e), this.z = r;\n      }\n    }\n    function gh(t, e) {\n      return t.x * e.x + t.y * e.y;\n    }\n    function xh(t, e) {\n      if (1 === t.length) {\n        let r = 0;\n        const n = e[r++];\n        let i;\n        for (; !i || n.equals(i);) if (i = e[r++], !i) return 1 / 0;\n        for (; r < e.length; r++) {\n          const s = e[r],\n            a = t[0],\n            o = i.sub(n),\n            l = s.sub(n),\n            u = a.sub(n),\n            c = gh(o, o),\n            h = gh(o, l),\n            p = gh(l, l),\n            d = gh(u, o),\n            f = gh(u, l),\n            y = c * p - h * h,\n            m = (p * d - h * f) / y,\n            g = (c * f - h * d) / y,\n            x = n.z * (1 - m - g) + i.z * m + s.z * g;\n          if (isFinite(x)) return x;\n        }\n        return 1 / 0;\n      }\n      {\n        let t = 1 / 0;\n        for (const r of e) t = Math.min(t, r.z);\n        return t;\n      }\n    }\n    function vh(t, e, r, n, i, s, a, o) {\n      const l = a * i.getElevationAt(t, e, !0, !0),\n        u = 0 !== s[0],\n        c = u ? 0 === s[1] ? a * (s[0] / 7 - 450) : a * function (t, e, r) {\n          const n = Math.floor(e[0] / 8),\n            i = Math.floor(e[1] / 8),\n            s = 10 * (e[0] - 8 * n),\n            a = 10 * (e[1] - 8 * i),\n            o = t.getElevationAt(n, i, !0, !0),\n            l = t.getMeterToDEM(r),\n            u = Math.floor(.5 * (s * l - 1)),\n            c = Math.floor(.5 * (a * l - 1)),\n            h = t.tileCoordToPixel(n, i),\n            p = 2 * u + 1,\n            d = 2 * c + 1,\n            f = function (t, e, r, n, i) {\n              return [t.getElevationAtPixel(e, r, !0), t.getElevationAtPixel(e + i, r, !0), t.getElevationAtPixel(e, r + i, !0), t.getElevationAtPixel(e + n, r + i, !0)];\n            }(t, h.x - u, h.y - c, p, d),\n            y = Math.abs(f[0] - f[1]),\n            m = Math.abs(f[2] - f[3]),\n            g = Math.abs(f[0] - f[2]) + Math.abs(f[1] - f[3]),\n            x = Math.min(.25, .5 * l * (y + m) / p),\n            v = Math.min(.25, .5 * l * g / d);\n          return o + Math.max(x * s, v * a);\n        }(i, s, o) : l;\n      return {\n        base: l + (0 === r) ? -1 : r,\n        top: u ? Math.max(c + n, l + r + 2) : l + n\n      };\n    }\n    const bh = Rs([{\n        name: \"a_pos_normal\",\n        components: 2,\n        type: \"Int16\"\n      }, {\n        name: \"a_data\",\n        components: 4,\n        type: \"Uint8\"\n      }, {\n        name: \"a_linesofar\",\n        components: 1,\n        type: \"Float32\"\n      }], 4),\n      {\n        members: wh\n      } = bh,\n      _h = Rs([{\n        name: \"a_packed\",\n        components: 4,\n        type: \"Float32\"\n      }]),\n      {\n        members: Ah\n      } = _h,\n      Sh = Kc.types,\n      kh = Math.cos(Math.PI / 180 * 37.5);\n    class Ih {\n      constructor(t) {\n        this.zoom = t.zoom, this.overscaling = t.overscaling, this.layers = t.layers, this.layerIds = this.layers.map(t => t.id), this.index = t.index, this.projection = t.projection, this.hasPattern = !1, this.patternFeatures = [], this.lineClipsArray = [], this.gradients = {}, this.layers.forEach(t => {\n          this.gradients[t.id] = {};\n        }), this.layoutVertexArray = new qs(), this.layoutVertexArray2 = new Ns(), this.indexArray = new ra(), this.programConfigurations = new Ja(t.layers, t.zoom), this.segments = new so(), this.maxLineLength = 0, this.stateDependentLayerIds = this.layers.filter(t => t.isStateDependent()).map(t => t.id);\n      }\n      populate(t, e, r, n) {\n        this.hasPattern = kc(\"line\", this.layers, e);\n        const i = this.layers[0].layout.get(\"line-sort-key\"),\n          s = [];\n        for (const {\n          feature: e,\n          id: a,\n          index: o,\n          sourceLayerIndex: l\n        } of t) {\n          const t = this.layers[0]._featureFilter.needGeometry,\n            u = ou(e, t);\n          if (!this.layers[0]._featureFilter.filter(new ws(this.zoom), u, r)) continue;\n          const c = i ? i.evaluate(u, {}, r) : void 0,\n            h = {\n              id: a,\n              properties: e.properties,\n              type: e.type,\n              sourceLayerIndex: l,\n              index: o,\n              geometry: t ? u.geometry : au(e, r, n),\n              patterns: {},\n              sortKey: c\n            };\n          s.push(h);\n        }\n        i && s.sort((t, e) => t.sortKey - e.sortKey);\n        const {\n            lineAtlas: a,\n            featureIndex: o\n          } = e,\n          l = this.addConstantDashes(a);\n        for (const n of s) {\n          const {\n            geometry: i,\n            index: s,\n            sourceLayerIndex: u\n          } = n;\n          if (l && this.addFeatureDashes(n, a), this.hasPattern) {\n            const t = Ic(\"line\", this.layers, n, this.zoom, e);\n            this.patternFeatures.push(t);\n          } else this.addFeature(n, i, s, r, a.positions, e.availableImages);\n          o.insert(t[s].feature, i, s, u, this.index);\n        }\n      }\n      addConstantDashes(t) {\n        let e = !1;\n        for (const r of this.layers) {\n          const n = r.paint.get(\"line-dasharray\").value,\n            i = r.layout.get(\"line-cap\").value;\n          if (\"constant\" !== n.kind || \"constant\" !== i.kind) e = !0;else {\n            const e = i.value,\n              r = n.value;\n            if (!r) continue;\n            t.addDash(r, e);\n          }\n        }\n        return e;\n      }\n      addFeatureDashes(t, e) {\n        const r = this.zoom;\n        for (const n of this.layers) {\n          const i = n.paint.get(\"line-dasharray\").value,\n            s = n.layout.get(\"line-cap\").value;\n          if (\"constant\" === i.kind && \"constant\" === s.kind) continue;\n          let a, o;\n          if (\"constant\" === i.kind) {\n            if (a = i.value, !a) continue;\n          } else a = i.evaluate({\n            zoom: r\n          }, t);\n          o = \"constant\" === s.kind ? s.value : s.evaluate({\n            zoom: r\n          }, t), e.addDash(a, o), t.patterns[n.id] = e.getKey(a, o);\n        }\n      }\n      update(t, e, r, n) {\n        this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t, e, this.stateDependentLayers, r, n);\n      }\n      addFeatures(t, e, r, n, i) {\n        for (const t of this.patternFeatures) this.addFeature(t, t.geometry, t.index, e, r, n);\n      }\n      isEmpty() {\n        return 0 === this.layoutVertexArray.length;\n      }\n      uploadPending() {\n        return !this.uploaded || this.programConfigurations.needsUpload;\n      }\n      upload(t) {\n        this.uploaded || (0 !== this.layoutVertexArray2.length && (this.layoutVertexBuffer2 = t.createVertexBuffer(this.layoutVertexArray2, Ah)), this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, wh), this.indexBuffer = t.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(t), this.uploaded = !0;\n      }\n      destroy() {\n        this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());\n      }\n      lineFeatureClips(t) {\n        if (t.properties && t.properties.hasOwnProperty(\"mapbox_clip_start\") && t.properties.hasOwnProperty(\"mapbox_clip_end\")) return {\n          start: +t.properties.mapbox_clip_start,\n          end: +t.properties.mapbox_clip_end\n        };\n      }\n      addFeature(t, e, r, n, i, s) {\n        const a = this.layers[0].layout,\n          o = a.get(\"line-join\").evaluate(t, {}),\n          l = a.get(\"line-cap\").evaluate(t, {}),\n          u = a.get(\"line-miter-limit\"),\n          c = a.get(\"line-round-limit\");\n        this.lineClips = this.lineFeatureClips(t);\n        for (const r of e) this.addLine(r, t, o, l, u, c);\n        this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t, r, i, s, n);\n      }\n      addLine(t, e, r, n, i, s) {\n        if (this.distance = 0, this.scaledDistance = 0, this.totalDistance = 0, this.lineSoFar = 0, this.lineClips) {\n          this.lineClipsArray.push(this.lineClips);\n          for (let e = 0; e < t.length - 1; e++) this.totalDistance += t[e].dist(t[e + 1]);\n          this.updateScaledDistance(), this.maxLineLength = Math.max(this.maxLineLength, this.totalDistance);\n        }\n        const a = \"Polygon\" === Sh[e.type];\n        let o = t.length;\n        for (; o >= 2 && t[o - 1].equals(t[o - 2]);) o--;\n        let l = 0;\n        for (; l < o - 1 && t[l].equals(t[l + 1]);) l++;\n        if (o < (a ? 3 : 2)) return;\n        \"bevel\" === r && (i = 1.05);\n        const u = this.overscaling <= 16 ? 15 * ao / (512 * this.overscaling) : 0,\n          c = this.segments.prepareSegment(10 * o, this.layoutVertexArray, this.indexArray);\n        let h, p, d, f, y;\n        this.e1 = this.e2 = -1, a && (h = t[o - 2], y = t[l].sub(h)._unit()._perp());\n        for (let e = l; e < o; e++) {\n          if (d = e === o - 1 ? a ? t[l + 1] : void 0 : t[e + 1], d && t[e].equals(d)) continue;\n          y && (f = y), h && (p = h), h = t[e], y = d ? d.sub(h)._unit()._perp() : f, f = f || y;\n          let m = f.add(y);\n          0 === m.x && 0 === m.y || m._unit();\n          const g = f.x * y.x + f.y * y.y,\n            x = m.x * y.x + m.y * y.y,\n            v = 0 !== x ? 1 / x : 1 / 0,\n            b = 2 * Math.sqrt(2 - 2 * x),\n            w = x < kh && p && d,\n            _ = f.x * y.y - f.y * y.x > 0;\n          if (w && e > l) {\n            const t = h.dist(p);\n            if (t > 2 * u) {\n              const e = h.sub(h.sub(p)._mult(u / t)._round());\n              this.updateDistance(p, e), this.addCurrentVertex(e, f, 0, 0, c), p = e;\n            }\n          }\n          const A = p && d;\n          let S = A ? r : a ? \"butt\" : n;\n          if (A && \"round\" === S && (v < s ? S = \"miter\" : v <= 2 && (S = \"fakeround\")), \"miter\" === S && v > i && (S = \"bevel\"), \"bevel\" === S && (v > 2 && (S = \"flipbevel\"), v < i && (S = \"miter\")), p && this.updateDistance(p, h), \"miter\" === S) m._mult(v), this.addCurrentVertex(h, m, 0, 0, c);else if (\"flipbevel\" === S) {\n            if (v > 100) m = y.mult(-1);else {\n              const t = v * f.add(y).mag() / f.sub(y).mag();\n              m._perp()._mult(t * (_ ? -1 : 1));\n            }\n            this.addCurrentVertex(h, m, 0, 0, c), this.addCurrentVertex(h, m.mult(-1), 0, 0, c);\n          } else if (\"bevel\" === S || \"fakeround\" === S) {\n            const t = -Math.sqrt(v * v - 1),\n              e = _ ? t : 0,\n              r = _ ? 0 : t;\n            if (p && this.addCurrentVertex(h, f, e, r, c), \"fakeround\" === S) {\n              const t = Math.round(180 * b / Math.PI / 20);\n              for (let e = 1; e < t; e++) {\n                let r = e / t;\n                if (.5 !== r) {\n                  const t = r - .5;\n                  r += r * t * (r - 1) * ((1.0904 + g * (g * (3.55645 - 1.43519 * g) - 3.2452)) * t * t + (.848013 + g * (.215638 * g - 1.06021)));\n                }\n                const n = y.sub(f)._mult(r)._add(f)._unit()._mult(_ ? -1 : 1);\n                this.addHalfVertex(h, n.x, n.y, !1, _, 0, c);\n              }\n            }\n            d && this.addCurrentVertex(h, y, -e, -r, c);\n          } else if (\"butt\" === S) this.addCurrentVertex(h, m, 0, 0, c);else if (\"square\" === S) {\n            const t = p ? 1 : -1;\n            p || this.addCurrentVertex(h, m, t, t, c), this.addCurrentVertex(h, m, 0, 0, c), p && this.addCurrentVertex(h, m, t, t, c);\n          } else \"round\" === S && (p && (this.addCurrentVertex(h, f, 0, 0, c), this.addCurrentVertex(h, f, 1, 1, c, !0)), d && (this.addCurrentVertex(h, y, -1, -1, c, !0), this.addCurrentVertex(h, y, 0, 0, c)));\n          if (w && e < o - 1) {\n            const t = h.dist(d);\n            if (t > 2 * u) {\n              const e = h.add(d.sub(h)._mult(u / t)._round());\n              this.updateDistance(h, e), this.addCurrentVertex(e, y, 0, 0, c), h = e;\n            }\n          }\n        }\n      }\n      addCurrentVertex(t, e, r, n, i, s = !1) {\n        const a = e.y * n - e.x,\n          o = -e.y - e.x * n;\n        this.addHalfVertex(t, e.x + e.y * r, e.y - e.x * r, s, !1, r, i), this.addHalfVertex(t, a, o, s, !0, -n, i);\n      }\n      addHalfVertex({\n        x: t,\n        y: e\n      }, r, n, i, s, a, o) {\n        this.layoutVertexArray.emplaceBack((t << 1) + (i ? 1 : 0), (e << 1) + (s ? 1 : 0), Math.round(63 * r) + 128, Math.round(63 * n) + 128, 1 + (0 === a ? 0 : a < 0 ? -1 : 1), 0, this.lineSoFar), this.lineClips && this.layoutVertexArray2.emplaceBack(this.scaledDistance, this.lineClipsArray.length, this.lineClips.start, this.lineClips.end);\n        const l = o.vertexLength++;\n        this.e1 >= 0 && this.e2 >= 0 && (this.indexArray.emplaceBack(this.e1, this.e2, l), o.primitiveLength++), s ? this.e2 = l : this.e1 = l;\n      }\n      updateScaledDistance() {\n        if (this.lineClips) {\n          const t = this.totalDistance / (this.lineClips.end - this.lineClips.start);\n          this.scaledDistance = this.distance / this.totalDistance, this.lineSoFar = t * this.lineClips.start + this.distance;\n        } else this.lineSoFar = this.distance;\n      }\n      updateDistance(t, e) {\n        this.distance += t.dist(e), this.updateScaledDistance();\n      }\n    }\n    Ji(Ih, \"LineBucket\", {\n      omit: [\"layers\", \"patternFeatures\"]\n    });\n    const Mh = new Ps({\n      \"line-cap\": new Es(te.layout_line[\"line-cap\"]),\n      \"line-join\": new Es(te.layout_line[\"line-join\"]),\n      \"line-miter-limit\": new Bs(te.layout_line[\"line-miter-limit\"]),\n      \"line-round-limit\": new Bs(te.layout_line[\"line-round-limit\"]),\n      \"line-sort-key\": new Es(te.layout_line[\"line-sort-key\"])\n    });\n    var Th = {\n      paint: new Ps({\n        \"line-opacity\": new Es(te.paint_line[\"line-opacity\"]),\n        \"line-color\": new Es(te.paint_line[\"line-color\"]),\n        \"line-translate\": new Bs(te.paint_line[\"line-translate\"]),\n        \"line-translate-anchor\": new Bs(te.paint_line[\"line-translate-anchor\"]),\n        \"line-width\": new Es(te.paint_line[\"line-width\"]),\n        \"line-gap-width\": new Es(te.paint_line[\"line-gap-width\"]),\n        \"line-offset\": new Es(te.paint_line[\"line-offset\"]),\n        \"line-blur\": new Es(te.paint_line[\"line-blur\"]),\n        \"line-dasharray\": new Es(te.paint_line[\"line-dasharray\"]),\n        \"line-pattern\": new Es(te.paint_line[\"line-pattern\"]),\n        \"line-gradient\": new Cs(te.paint_line[\"line-gradient\"]),\n        \"line-trim-offset\": new Bs(te.paint_line[\"line-trim-offset\"])\n      }),\n      layout: Mh\n    };\n    const zh = new class extends Es {\n      possiblyEvaluate(t, e) {\n        return e = new ws(Math.floor(e.zoom), {\n          now: e.now,\n          fadeDuration: e.fadeDuration,\n          transition: e.transition\n        }), super.possiblyEvaluate(t, e);\n      }\n      evaluate(t, e, r, n) {\n        return e = C({}, e, {\n          zoom: Math.floor(e.zoom)\n        }), super.evaluate(t, e, r, n);\n      }\n    }(Th.paint.properties[\"line-width\"].specification);\n    function Bh(t, e) {\n      return e > 0 ? e + 2 * t : t;\n    }\n    zh.useIntegerZoom = !0;\n    const Eh = Rs([{\n        name: \"a_pos_offset\",\n        components: 4,\n        type: \"Int16\"\n      }, {\n        name: \"a_tex_size\",\n        components: 4,\n        type: \"Uint16\"\n      }, {\n        name: \"a_pixeloffset\",\n        components: 4,\n        type: \"Int16\"\n      }], 4),\n      Ch = Rs([{\n        name: \"a_globe_anchor\",\n        components: 3,\n        type: \"Int16\"\n      }, {\n        name: \"a_globe_normal\",\n        components: 3,\n        type: \"Float32\"\n      }], 4),\n      Ph = Rs([{\n        name: \"a_projected_pos\",\n        components: 4,\n        type: \"Float32\"\n      }], 4);\n    Rs([{\n      name: \"a_fade_opacity\",\n      components: 1,\n      type: \"Uint32\"\n    }], 4);\n    const Dh = Rs([{\n        name: \"a_placed\",\n        components: 2,\n        type: \"Uint8\"\n      }, {\n        name: \"a_shift\",\n        components: 2,\n        type: \"Float32\"\n      }]),\n      Vh = Rs([{\n        name: \"a_size_scale\",\n        components: 1,\n        type: \"Float32\"\n      }, {\n        name: \"a_padding\",\n        components: 2,\n        type: \"Float32\"\n      }]);\n    Rs([{\n      type: \"Int16\",\n      name: \"projectedAnchorX\"\n    }, {\n      type: \"Int16\",\n      name: \"projectedAnchorY\"\n    }, {\n      type: \"Int16\",\n      name: \"projectedAnchorZ\"\n    }, {\n      type: \"Int16\",\n      name: \"tileAnchorX\"\n    }, {\n      type: \"Int16\",\n      name: \"tileAnchorY\"\n    }, {\n      type: \"Float32\",\n      name: \"x1\"\n    }, {\n      type: \"Float32\",\n      name: \"y1\"\n    }, {\n      type: \"Float32\",\n      name: \"x2\"\n    }, {\n      type: \"Float32\",\n      name: \"y2\"\n    }, {\n      type: \"Int16\",\n      name: \"padding\"\n    }, {\n      type: \"Uint32\",\n      name: \"featureIndex\"\n    }, {\n      type: \"Uint16\",\n      name: \"sourceLayerIndex\"\n    }, {\n      type: \"Uint16\",\n      name: \"bucketIndex\"\n    }]);\n    const Lh = Rs([{\n        name: \"a_pos\",\n        components: 3,\n        type: \"Int16\"\n      }, {\n        name: \"a_anchor_pos\",\n        components: 2,\n        type: \"Int16\"\n      }, {\n        name: \"a_extrude\",\n        components: 2,\n        type: \"Int16\"\n      }], 4),\n      Fh = Rs([{\n        name: \"a_pos_2f\",\n        components: 2,\n        type: \"Float32\"\n      }, {\n        name: \"a_radius\",\n        components: 1,\n        type: \"Float32\"\n      }, {\n        name: \"a_flags\",\n        components: 2,\n        type: \"Int16\"\n      }], 4);\n    Rs([{\n      name: \"triangle\",\n      components: 3,\n      type: \"Uint16\"\n    }]), Rs([{\n      type: \"Int16\",\n      name: \"projectedAnchorX\"\n    }, {\n      type: \"Int16\",\n      name: \"projectedAnchorY\"\n    }, {\n      type: \"Int16\",\n      name: \"projectedAnchorZ\"\n    }, {\n      type: \"Float32\",\n      name: \"tileAnchorX\"\n    }, {\n      type: \"Float32\",\n      name: \"tileAnchorY\"\n    }, {\n      type: \"Uint16\",\n      name: \"glyphStartIndex\"\n    }, {\n      type: \"Uint16\",\n      name: \"numGlyphs\"\n    }, {\n      type: \"Uint32\",\n      name: \"vertexStartIndex\"\n    }, {\n      type: \"Uint32\",\n      name: \"lineStartIndex\"\n    }, {\n      type: \"Uint32\",\n      name: \"lineLength\"\n    }, {\n      type: \"Uint16\",\n      name: \"segment\"\n    }, {\n      type: \"Uint16\",\n      name: \"lowerSize\"\n    }, {\n      type: \"Uint16\",\n      name: \"upperSize\"\n    }, {\n      type: \"Float32\",\n      name: \"lineOffsetX\"\n    }, {\n      type: \"Float32\",\n      name: \"lineOffsetY\"\n    }, {\n      type: \"Uint8\",\n      name: \"writingMode\"\n    }, {\n      type: \"Uint8\",\n      name: \"placedOrientation\"\n    }, {\n      type: \"Uint8\",\n      name: \"hidden\"\n    }, {\n      type: \"Uint32\",\n      name: \"crossTileID\"\n    }, {\n      type: \"Int16\",\n      name: \"associatedIconIndex\"\n    }, {\n      type: \"Uint8\",\n      name: \"flipState\"\n    }]), Rs([{\n      type: \"Int16\",\n      name: \"projectedAnchorX\"\n    }, {\n      type: \"Int16\",\n      name: \"projectedAnchorY\"\n    }, {\n      type: \"Int16\",\n      name: \"projectedAnchorZ\"\n    }, {\n      type: \"Float32\",\n      name: \"tileAnchorX\"\n    }, {\n      type: \"Float32\",\n      name: \"tileAnchorY\"\n    }, {\n      type: \"Int16\",\n      name: \"rightJustifiedTextSymbolIndex\"\n    }, {\n      type: \"Int16\",\n      name: \"centerJustifiedTextSymbolIndex\"\n    }, {\n      type: \"Int16\",\n      name: \"leftJustifiedTextSymbolIndex\"\n    }, {\n      type: \"Int16\",\n      name: \"verticalPlacedTextSymbolIndex\"\n    }, {\n      type: \"Int16\",\n      name: \"placedIconSymbolIndex\"\n    }, {\n      type: \"Int16\",\n      name: \"verticalPlacedIconSymbolIndex\"\n    }, {\n      type: \"Uint16\",\n      name: \"key\"\n    }, {\n      type: \"Uint16\",\n      name: \"textBoxStartIndex\"\n    }, {\n      type: \"Uint16\",\n      name: \"textBoxEndIndex\"\n    }, {\n      type: \"Uint16\",\n      name: \"verticalTextBoxStartIndex\"\n    }, {\n      type: \"Uint16\",\n      name: \"verticalTextBoxEndIndex\"\n    }, {\n      type: \"Uint16\",\n      name: \"iconBoxStartIndex\"\n    }, {\n      type: \"Uint16\",\n      name: \"iconBoxEndIndex\"\n    }, {\n      type: \"Uint16\",\n      name: \"verticalIconBoxStartIndex\"\n    }, {\n      type: \"Uint16\",\n      name: \"verticalIconBoxEndIndex\"\n    }, {\n      type: \"Uint16\",\n      name: \"featureIndex\"\n    }, {\n      type: \"Uint16\",\n      name: \"numHorizontalGlyphVertices\"\n    }, {\n      type: \"Uint16\",\n      name: \"numVerticalGlyphVertices\"\n    }, {\n      type: \"Uint16\",\n      name: \"numIconVertices\"\n    }, {\n      type: \"Uint16\",\n      name: \"numVerticalIconVertices\"\n    }, {\n      type: \"Uint16\",\n      name: \"useRuntimeCollisionCircles\"\n    }, {\n      type: \"Uint32\",\n      name: \"crossTileID\"\n    }, {\n      type: \"Float32\",\n      components: 2,\n      name: \"textOffset\"\n    }, {\n      type: \"Float32\",\n      name: \"collisionCircleDiameter\"\n    }]), Rs([{\n      type: \"Float32\",\n      name: \"offsetX\"\n    }]), Rs([{\n      type: \"Int16\",\n      name: \"x\"\n    }, {\n      type: \"Int16\",\n      name: \"y\"\n    }]);\n    var Rh = 24;\n    const Uh = 128;\n    function $h(t, e) {\n      const {\n        expression: r\n      } = e;\n      if (\"constant\" === r.kind) return {\n        kind: \"constant\",\n        layoutSize: r.evaluate(new ws(t + 1))\n      };\n      if (\"source\" === r.kind) return {\n        kind: \"source\"\n      };\n      {\n        const {\n          zoomStops: e,\n          interpolationType: n\n        } = r;\n        let i = 0;\n        for (; i < e.length && e[i] <= t;) i++;\n        i = Math.max(0, i - 1);\n        let s = i;\n        for (; s < e.length && e[s] < t + 1;) s++;\n        s = Math.min(e.length - 1, s);\n        const a = e[i],\n          o = e[s];\n        return \"composite\" === r.kind ? {\n          kind: \"composite\",\n          minZoom: a,\n          maxZoom: o,\n          interpolationType: n\n        } : {\n          kind: \"camera\",\n          minZoom: a,\n          maxZoom: o,\n          minSize: r.evaluate(new ws(a)),\n          maxSize: r.evaluate(new ws(o)),\n          interpolationType: n\n        };\n      }\n    }\n    function jh(t, {\n      uSize: e,\n      uSizeT: r\n    }, {\n      lowerSize: n,\n      upperSize: i\n    }) {\n      return \"source\" === t.kind ? n / Uh : \"composite\" === t.kind ? Er(n / Uh, i / Uh, r) : e;\n    }\n    function Oh(t, e) {\n      let r = 0,\n        n = 0;\n      if (\"constant\" === t.kind) n = t.layoutSize;else if (\"source\" !== t.kind) {\n        const {\n            interpolationType: i,\n            minZoom: s,\n            maxZoom: a\n          } = t,\n          o = i ? M(Qr.interpolationFactor(i, e, s, a), 0, 1) : 0;\n        \"camera\" === t.kind ? n = Er(t.minSize, t.maxSize, o) : r = o;\n      }\n      return {\n        uSizeT: r,\n        uSize: n\n      };\n    }\n    var qh = Object.freeze({\n      __proto__: null,\n      SIZE_PACK_FACTOR: Uh,\n      evaluateSizeForFeature: jh,\n      evaluateSizeForZoom: Oh,\n      getSizeData: $h\n    });\n    function Nh(t, e, r) {\n      return t.sections.forEach(t => {\n        t.text = function (t, e, r) {\n          const n = e.layout.get(\"text-transform\").evaluate(r, {});\n          return \"uppercase\" === n ? t = t.toLocaleUpperCase() : \"lowercase\" === n && (t = t.toLocaleLowerCase()), bs.applyArabicShaping && (t = bs.applyArabicShaping(t)), t;\n        }(t.text, e, r);\n      }), t;\n    }\n    const Gh = {\n      \"!\": \"ï¸\",\n      \"#\": \"ï¼\",\n      $: \"ï¼\",\n      \"%\": \"ï¼\",\n      \"&\": \"ï¼\",\n      \"(\": \"ï¸µ\",\n      \")\": \"ï¸¶\",\n      \"*\": \"ï¼\",\n      \"+\": \"ï¼\",\n      \",\": \"ï¸\",\n      \"-\": \"ï¸²\",\n      \".\": \"ã»\",\n      \"/\": \"ï¼\",\n      \":\": \"ï¸\",\n      \";\": \"ï¸\",\n      \"<\": \"ï¸¿\",\n      \"=\": \"ï¼\",\n      \">\": \"ï¹\",\n      \"?\": \"ï¸\",\n      \"@\": \"ï¼ \",\n      \"[\": \"ï¹\",\n      \"\\\\\": \"ï¼¼\",\n      \"]\": \"ï¹\",\n      \"^\": \"ï¼¾\",\n      _: \"ï¸³\",\n      \"`\": \"ï½\",\n      \"{\": \"ï¸·\",\n      \"|\": \"â\",\n      \"}\": \"ï¸¸\",\n      \"~\": \"ï½\",\n      \"Â¢\": \"ï¿ \",\n      \"Â£\": \"ï¿¡\",\n      \"Â¥\": \"ï¿¥\",\n      \"Â¦\": \"ï¿¤\",\n      \"Â¬\": \"ï¿¢\",\n      \"Â¯\": \"ï¿£\",\n      \"â\": \"ï¸²\",\n      \"â\": \"ï¸±\",\n      \"â\": \"ï¹\",\n      \"â\": \"ï¹\",\n      \"â\": \"ï¹\",\n      \"â\": \"ï¹\",\n      \"â¦\": \"ï¸\",\n      \"â§\": \"ã»\",\n      \"â©\": \"ï¿¦\",\n      \"ã\": \"ï¸\",\n      \"ã\": \"ï¸\",\n      \"ã\": \"ï¸¿\",\n      \"ã\": \"ï¹\",\n      \"ã\": \"ï¸½\",\n      \"ã\": \"ï¸¾\",\n      \"ã\": \"ï¹\",\n      \"ã\": \"ï¹\",\n      \"ã\": \"ï¹\",\n      \"ã\": \"ï¹\",\n      \"ã\": \"ï¸»\",\n      \"ã\": \"ï¸¼\",\n      \"ã\": \"ï¸¹\",\n      \"ã\": \"ï¸º\",\n      \"ã\": \"ï¸\",\n      \"ã\": \"ï¸\",\n      \"ï¼\": \"ï¸\",\n      \"ï¼\": \"ï¸µ\",\n      \"ï¼\": \"ï¸¶\",\n      \"ï¼\": \"ï¸\",\n      \"ï¼\": \"ï¸²\",\n      \"ï¼\": \"ã»\",\n      \"ï¼\": \"ï¸\",\n      \"ï¼\": \"ï¸\",\n      \"ï¼\": \"ï¸¿\",\n      \"ï¼\": \"ï¹\",\n      \"ï¼\": \"ï¸\",\n      \"ï¼»\": \"ï¹\",\n      \"ï¼½\": \"ï¹\",\n      \"ï¼¿\": \"ï¸³\",\n      \"ï½\": \"ï¸·\",\n      \"ï½\": \"â\",\n      \"ï½\": \"ï¸¸\",\n      \"ï½\": \"ï¸µ\",\n      \"ï½ \": \"ï¸¶\",\n      \"ï½¡\": \"ï¸\",\n      \"ï½¢\": \"ï¹\",\n      \"ï½£\": \"ï¹\",\n      \"â\": \"â\",\n      \"â\": \"â\"\n    };\n    function Zh(t) {\n      return \"ï¸¶\" === t || \"ï¹\" === t || \"ï¸¸\" === t || \"ï¹\" === t || \"ï¹\" === t || \"ï¸¾\" === t || \"ï¸¼\" === t || \"ï¸º\" === t || \"ï¸\" === t || \"ï¹\" === t || \"ï¸\" === t || \"ï¸\" === t || \"ï¸\" === t || \"ï½\" === t || \"ï¿£\" === t || \"ï¸\" === t || \"ï¸\" === t;\n    }\n    function Kh(t) {\n      return \"ï¸µ\" === t || \"ï¹\" === t || \"ï¸·\" === t || \"ï¹\" === t || \"ï¹\" === t || \"ï¸½\" === t || \"ï¸»\" === t || \"ï¸¹\" === t || \"ï¸\" === t || \"ï¸¿\" === t;\n    }\n    var Xh = Yh,\n      Jh = function (t, e, r, n, i) {\n        var s,\n          a,\n          o = 8 * i - n - 1,\n          l = (1 << o) - 1,\n          u = l >> 1,\n          c = -7,\n          h = r ? i - 1 : 0,\n          p = r ? -1 : 1,\n          d = t[e + h];\n        for (h += p, s = d & (1 << -c) - 1, d >>= -c, c += o; c > 0; s = 256 * s + t[e + h], h += p, c -= 8);\n        for (a = s & (1 << -c) - 1, s >>= -c, c += n; c > 0; a = 256 * a + t[e + h], h += p, c -= 8);\n        if (0 === s) s = 1 - u;else {\n          if (s === l) return a ? NaN : 1 / 0 * (d ? -1 : 1);\n          a += Math.pow(2, n), s -= u;\n        }\n        return (d ? -1 : 1) * a * Math.pow(2, s - n);\n      },\n      Hh = function (t, e, r, n, i, s) {\n        var a,\n          o,\n          l,\n          u = 8 * s - i - 1,\n          c = (1 << u) - 1,\n          h = c >> 1,\n          p = 23 === i ? Math.pow(2, -24) - Math.pow(2, -77) : 0,\n          d = n ? 0 : s - 1,\n          f = n ? 1 : -1,\n          y = e < 0 || 0 === e && 1 / e < 0 ? 1 : 0;\n        for (e = Math.abs(e), isNaN(e) || e === 1 / 0 ? (o = isNaN(e) ? 1 : 0, a = c) : (a = Math.floor(Math.log(e) / Math.LN2), e * (l = Math.pow(2, -a)) < 1 && (a--, l *= 2), (e += a + h >= 1 ? p / l : p * Math.pow(2, 1 - h)) * l >= 2 && (a++, l /= 2), a + h >= c ? (o = 0, a = c) : a + h >= 1 ? (o = (e * l - 1) * Math.pow(2, i), a += h) : (o = e * Math.pow(2, h - 1) * Math.pow(2, i), a = 0)); i >= 8; t[r + d] = 255 & o, d += f, o /= 256, i -= 8);\n        for (a = a << i | o, u += i; u > 0; t[r + d] = 255 & a, d += f, a /= 256, u -= 8);\n        t[r + d - f] |= 128 * y;\n      };\n    /*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */\n    function Yh(t) {\n      this.buf = ArrayBuffer.isView && ArrayBuffer.isView(t) ? t : new Uint8Array(t || 0), this.pos = 0, this.type = 0, this.length = this.buf.length;\n    }\n    Yh.Varint = 0, Yh.Fixed64 = 1, Yh.Bytes = 2, Yh.Fixed32 = 5;\n    var Wh = 4294967296,\n      Qh = 1 / Wh,\n      tp = \"undefined\" == typeof TextDecoder ? null : new TextDecoder(\"utf8\");\n    function ep(t) {\n      return t.type === Yh.Bytes ? t.readVarint() + t.pos : t.pos + 1;\n    }\n    function rp(t, e, r) {\n      return r ? 4294967296 * e + (t >>> 0) : 4294967296 * (e >>> 0) + (t >>> 0);\n    }\n    function np(t, e, r) {\n      var n = e <= 16383 ? 1 : e <= 2097151 ? 2 : e <= 268435455 ? 3 : Math.floor(Math.log(e) / (7 * Math.LN2));\n      r.realloc(n);\n      for (var i = r.pos - 1; i >= t; i--) r.buf[i + n] = r.buf[i];\n    }\n    function ip(t, e) {\n      for (var r = 0; r < t.length; r++) e.writeVarint(t[r]);\n    }\n    function sp(t, e) {\n      for (var r = 0; r < t.length; r++) e.writeSVarint(t[r]);\n    }\n    function ap(t, e) {\n      for (var r = 0; r < t.length; r++) e.writeFloat(t[r]);\n    }\n    function op(t, e) {\n      for (var r = 0; r < t.length; r++) e.writeDouble(t[r]);\n    }\n    function lp(t, e) {\n      for (var r = 0; r < t.length; r++) e.writeBoolean(t[r]);\n    }\n    function up(t, e) {\n      for (var r = 0; r < t.length; r++) e.writeFixed32(t[r]);\n    }\n    function cp(t, e) {\n      for (var r = 0; r < t.length; r++) e.writeSFixed32(t[r]);\n    }\n    function hp(t, e) {\n      for (var r = 0; r < t.length; r++) e.writeFixed64(t[r]);\n    }\n    function pp(t, e) {\n      for (var r = 0; r < t.length; r++) e.writeSFixed64(t[r]);\n    }\n    function dp(t, e) {\n      return (t[e] | t[e + 1] << 8 | t[e + 2] << 16) + 16777216 * t[e + 3];\n    }\n    function fp(t, e, r) {\n      t[r] = e, t[r + 1] = e >>> 8, t[r + 2] = e >>> 16, t[r + 3] = e >>> 24;\n    }\n    function yp(t, e) {\n      return (t[e] | t[e + 1] << 8 | t[e + 2] << 16) + (t[e + 3] << 24);\n    }\n    Yh.prototype = {\n      destroy: function () {\n        this.buf = null;\n      },\n      readFields: function (t, e, r) {\n        for (r = r || this.length; this.pos < r;) {\n          var n = this.readVarint(),\n            i = n >> 3,\n            s = this.pos;\n          this.type = 7 & n, t(i, e, this), this.pos === s && this.skip(n);\n        }\n        return e;\n      },\n      readMessage: function (t, e) {\n        return this.readFields(t, e, this.readVarint() + this.pos);\n      },\n      readFixed32: function () {\n        var t = dp(this.buf, this.pos);\n        return this.pos += 4, t;\n      },\n      readSFixed32: function () {\n        var t = yp(this.buf, this.pos);\n        return this.pos += 4, t;\n      },\n      readFixed64: function () {\n        var t = dp(this.buf, this.pos) + dp(this.buf, this.pos + 4) * Wh;\n        return this.pos += 8, t;\n      },\n      readSFixed64: function () {\n        var t = dp(this.buf, this.pos) + yp(this.buf, this.pos + 4) * Wh;\n        return this.pos += 8, t;\n      },\n      readFloat: function () {\n        var t = Jh(this.buf, this.pos, !0, 23, 4);\n        return this.pos += 4, t;\n      },\n      readDouble: function () {\n        var t = Jh(this.buf, this.pos, !0, 52, 8);\n        return this.pos += 8, t;\n      },\n      readVarint: function (t) {\n        var e,\n          r,\n          n = this.buf;\n        return e = 127 & (r = n[this.pos++]), r < 128 ? e : (e |= (127 & (r = n[this.pos++])) << 7, r < 128 ? e : (e |= (127 & (r = n[this.pos++])) << 14, r < 128 ? e : (e |= (127 & (r = n[this.pos++])) << 21, r < 128 ? e : function (t, e, r) {\n          var n,\n            i,\n            s = r.buf;\n          if (n = (112 & (i = s[r.pos++])) >> 4, i < 128) return rp(t, n, e);\n          if (n |= (127 & (i = s[r.pos++])) << 3, i < 128) return rp(t, n, e);\n          if (n |= (127 & (i = s[r.pos++])) << 10, i < 128) return rp(t, n, e);\n          if (n |= (127 & (i = s[r.pos++])) << 17, i < 128) return rp(t, n, e);\n          if (n |= (127 & (i = s[r.pos++])) << 24, i < 128) return rp(t, n, e);\n          if (n |= (1 & (i = s[r.pos++])) << 31, i < 128) return rp(t, n, e);\n          throw new Error(\"Expected varint not more than 10 bytes\");\n        }(e |= (15 & (r = n[this.pos])) << 28, t, this))));\n      },\n      readVarint64: function () {\n        return this.readVarint(!0);\n      },\n      readSVarint: function () {\n        var t = this.readVarint();\n        return t % 2 == 1 ? (t + 1) / -2 : t / 2;\n      },\n      readBoolean: function () {\n        return Boolean(this.readVarint());\n      },\n      readString: function () {\n        var t = this.readVarint() + this.pos,\n          e = this.pos;\n        return this.pos = t, t - e >= 12 && tp ? function (t, e, r) {\n          return tp.decode(t.subarray(e, r));\n        }(this.buf, e, t) : function (t, e, r) {\n          for (var n = \"\", i = e; i < r;) {\n            var s,\n              a,\n              o,\n              l = t[i],\n              u = null,\n              c = l > 239 ? 4 : l > 223 ? 3 : l > 191 ? 2 : 1;\n            if (i + c > r) break;\n            1 === c ? l < 128 && (u = l) : 2 === c ? 128 == (192 & (s = t[i + 1])) && (u = (31 & l) << 6 | 63 & s) <= 127 && (u = null) : 3 === c ? (a = t[i + 2], 128 == (192 & (s = t[i + 1])) && 128 == (192 & a) && ((u = (15 & l) << 12 | (63 & s) << 6 | 63 & a) <= 2047 || u >= 55296 && u <= 57343) && (u = null)) : 4 === c && (a = t[i + 2], o = t[i + 3], 128 == (192 & (s = t[i + 1])) && 128 == (192 & a) && 128 == (192 & o) && ((u = (15 & l) << 18 | (63 & s) << 12 | (63 & a) << 6 | 63 & o) <= 65535 || u >= 1114112) && (u = null)), null === u ? (u = 65533, c = 1) : u > 65535 && (u -= 65536, n += String.fromCharCode(u >>> 10 & 1023 | 55296), u = 56320 | 1023 & u), n += String.fromCharCode(u), i += c;\n          }\n          return n;\n        }(this.buf, e, t);\n      },\n      readBytes: function () {\n        var t = this.readVarint() + this.pos,\n          e = this.buf.subarray(this.pos, t);\n        return this.pos = t, e;\n      },\n      readPackedVarint: function (t, e) {\n        if (this.type !== Yh.Bytes) return t.push(this.readVarint(e));\n        var r = ep(this);\n        for (t = t || []; this.pos < r;) t.push(this.readVarint(e));\n        return t;\n      },\n      readPackedSVarint: function (t) {\n        if (this.type !== Yh.Bytes) return t.push(this.readSVarint());\n        var e = ep(this);\n        for (t = t || []; this.pos < e;) t.push(this.readSVarint());\n        return t;\n      },\n      readPackedBoolean: function (t) {\n        if (this.type !== Yh.Bytes) return t.push(this.readBoolean());\n        var e = ep(this);\n        for (t = t || []; this.pos < e;) t.push(this.readBoolean());\n        return t;\n      },\n      readPackedFloat: function (t) {\n        if (this.type !== Yh.Bytes) return t.push(this.readFloat());\n        var e = ep(this);\n        for (t = t || []; this.pos < e;) t.push(this.readFloat());\n        return t;\n      },\n      readPackedDouble: function (t) {\n        if (this.type !== Yh.Bytes) return t.push(this.readDouble());\n        var e = ep(this);\n        for (t = t || []; this.pos < e;) t.push(this.readDouble());\n        return t;\n      },\n      readPackedFixed32: function (t) {\n        if (this.type !== Yh.Bytes) return t.push(this.readFixed32());\n        var e = ep(this);\n        for (t = t || []; this.pos < e;) t.push(this.readFixed32());\n        return t;\n      },\n      readPackedSFixed32: function (t) {\n        if (this.type !== Yh.Bytes) return t.push(this.readSFixed32());\n        var e = ep(this);\n        for (t = t || []; this.pos < e;) t.push(this.readSFixed32());\n        return t;\n      },\n      readPackedFixed64: function (t) {\n        if (this.type !== Yh.Bytes) return t.push(this.readFixed64());\n        var e = ep(this);\n        for (t = t || []; this.pos < e;) t.push(this.readFixed64());\n        return t;\n      },\n      readPackedSFixed64: function (t) {\n        if (this.type !== Yh.Bytes) return t.push(this.readSFixed64());\n        var e = ep(this);\n        for (t = t || []; this.pos < e;) t.push(this.readSFixed64());\n        return t;\n      },\n      skip: function (t) {\n        var e = 7 & t;\n        if (e === Yh.Varint) for (; this.buf[this.pos++] > 127;);else if (e === Yh.Bytes) this.pos = this.readVarint() + this.pos;else if (e === Yh.Fixed32) this.pos += 4;else {\n          if (e !== Yh.Fixed64) throw new Error(\"Unimplemented type: \" + e);\n          this.pos += 8;\n        }\n      },\n      writeTag: function (t, e) {\n        this.writeVarint(t << 3 | e);\n      },\n      realloc: function (t) {\n        for (var e = this.length || 16; e < this.pos + t;) e *= 2;\n        if (e !== this.length) {\n          var r = new Uint8Array(e);\n          r.set(this.buf), this.buf = r, this.length = e;\n        }\n      },\n      finish: function () {\n        return this.length = this.pos, this.pos = 0, this.buf.subarray(0, this.length);\n      },\n      writeFixed32: function (t) {\n        this.realloc(4), fp(this.buf, t, this.pos), this.pos += 4;\n      },\n      writeSFixed32: function (t) {\n        this.realloc(4), fp(this.buf, t, this.pos), this.pos += 4;\n      },\n      writeFixed64: function (t) {\n        this.realloc(8), fp(this.buf, -1 & t, this.pos), fp(this.buf, Math.floor(t * Qh), this.pos + 4), this.pos += 8;\n      },\n      writeSFixed64: function (t) {\n        this.realloc(8), fp(this.buf, -1 & t, this.pos), fp(this.buf, Math.floor(t * Qh), this.pos + 4), this.pos += 8;\n      },\n      writeVarint: function (t) {\n        (t = +t || 0) > 268435455 || t < 0 ? function (t, e) {\n          var r, n;\n          if (t >= 0 ? (r = t % 4294967296 | 0, n = t / 4294967296 | 0) : (n = ~(-t / 4294967296), 4294967295 ^ (r = ~(-t % 4294967296)) ? r = r + 1 | 0 : (r = 0, n = n + 1 | 0)), t >= 0x10000000000000000 || t < -0x10000000000000000) throw new Error(\"Given varint doesn't fit into 10 bytes\");\n          e.realloc(10), function (t, e, r) {\n            r.buf[r.pos++] = 127 & t | 128, t >>>= 7, r.buf[r.pos++] = 127 & t | 128, t >>>= 7, r.buf[r.pos++] = 127 & t | 128, t >>>= 7, r.buf[r.pos++] = 127 & t | 128, r.buf[r.pos] = 127 & (t >>>= 7);\n          }(r, 0, e), function (t, e) {\n            var r = (7 & t) << 4;\n            e.buf[e.pos++] |= r | ((t >>>= 3) ? 128 : 0), t && (e.buf[e.pos++] = 127 & t | ((t >>>= 7) ? 128 : 0), t && (e.buf[e.pos++] = 127 & t | ((t >>>= 7) ? 128 : 0), t && (e.buf[e.pos++] = 127 & t | ((t >>>= 7) ? 128 : 0), t && (e.buf[e.pos++] = 127 & t | ((t >>>= 7) ? 128 : 0), t && (e.buf[e.pos++] = 127 & t)))));\n          }(n, e);\n        }(t, this) : (this.realloc(4), this.buf[this.pos++] = 127 & t | (t > 127 ? 128 : 0), t <= 127 || (this.buf[this.pos++] = 127 & (t >>>= 7) | (t > 127 ? 128 : 0), t <= 127 || (this.buf[this.pos++] = 127 & (t >>>= 7) | (t > 127 ? 128 : 0), t <= 127 || (this.buf[this.pos++] = t >>> 7 & 127))));\n      },\n      writeSVarint: function (t) {\n        this.writeVarint(t < 0 ? 2 * -t - 1 : 2 * t);\n      },\n      writeBoolean: function (t) {\n        this.writeVarint(Boolean(t));\n      },\n      writeString: function (t) {\n        t = String(t), this.realloc(4 * t.length), this.pos++;\n        var e = this.pos;\n        this.pos = function (t, e, r) {\n          for (var n, i, s = 0; s < e.length; s++) {\n            if ((n = e.charCodeAt(s)) > 55295 && n < 57344) {\n              if (!i) {\n                n > 56319 || s + 1 === e.length ? (t[r++] = 239, t[r++] = 191, t[r++] = 189) : i = n;\n                continue;\n              }\n              if (n < 56320) {\n                t[r++] = 239, t[r++] = 191, t[r++] = 189, i = n;\n                continue;\n              }\n              n = i - 55296 << 10 | n - 56320 | 65536, i = null;\n            } else i && (t[r++] = 239, t[r++] = 191, t[r++] = 189, i = null);\n            n < 128 ? t[r++] = n : (n < 2048 ? t[r++] = n >> 6 | 192 : (n < 65536 ? t[r++] = n >> 12 | 224 : (t[r++] = n >> 18 | 240, t[r++] = n >> 12 & 63 | 128), t[r++] = n >> 6 & 63 | 128), t[r++] = 63 & n | 128);\n          }\n          return r;\n        }(this.buf, t, this.pos);\n        var r = this.pos - e;\n        r >= 128 && np(e, r, this), this.pos = e - 1, this.writeVarint(r), this.pos += r;\n      },\n      writeFloat: function (t) {\n        this.realloc(4), Hh(this.buf, t, this.pos, !0, 23, 4), this.pos += 4;\n      },\n      writeDouble: function (t) {\n        this.realloc(8), Hh(this.buf, t, this.pos, !0, 52, 8), this.pos += 8;\n      },\n      writeBytes: function (t) {\n        var e = t.length;\n        this.writeVarint(e), this.realloc(e);\n        for (var r = 0; r < e; r++) this.buf[this.pos++] = t[r];\n      },\n      writeRawMessage: function (t, e) {\n        this.pos++;\n        var r = this.pos;\n        t(e, this);\n        var n = this.pos - r;\n        n >= 128 && np(r, n, this), this.pos = r - 1, this.writeVarint(n), this.pos += n;\n      },\n      writeMessage: function (t, e, r) {\n        this.writeTag(t, Yh.Bytes), this.writeRawMessage(e, r);\n      },\n      writePackedVarint: function (t, e) {\n        e.length && this.writeMessage(t, ip, e);\n      },\n      writePackedSVarint: function (t, e) {\n        e.length && this.writeMessage(t, sp, e);\n      },\n      writePackedBoolean: function (t, e) {\n        e.length && this.writeMessage(t, lp, e);\n      },\n      writePackedFloat: function (t, e) {\n        e.length && this.writeMessage(t, ap, e);\n      },\n      writePackedDouble: function (t, e) {\n        e.length && this.writeMessage(t, op, e);\n      },\n      writePackedFixed32: function (t, e) {\n        e.length && this.writeMessage(t, up, e);\n      },\n      writePackedSFixed32: function (t, e) {\n        e.length && this.writeMessage(t, cp, e);\n      },\n      writePackedFixed64: function (t, e) {\n        e.length && this.writeMessage(t, hp, e);\n      },\n      writePackedSFixed64: function (t, e) {\n        e.length && this.writeMessage(t, pp, e);\n      },\n      writeBytesField: function (t, e) {\n        this.writeTag(t, Yh.Bytes), this.writeBytes(e);\n      },\n      writeFixed32Field: function (t, e) {\n        this.writeTag(t, Yh.Fixed32), this.writeFixed32(e);\n      },\n      writeSFixed32Field: function (t, e) {\n        this.writeTag(t, Yh.Fixed32), this.writeSFixed32(e);\n      },\n      writeFixed64Field: function (t, e) {\n        this.writeTag(t, Yh.Fixed64), this.writeFixed64(e);\n      },\n      writeSFixed64Field: function (t, e) {\n        this.writeTag(t, Yh.Fixed64), this.writeSFixed64(e);\n      },\n      writeVarintField: function (t, e) {\n        this.writeTag(t, Yh.Varint), this.writeVarint(e);\n      },\n      writeSVarintField: function (t, e) {\n        this.writeTag(t, Yh.Varint), this.writeSVarint(e);\n      },\n      writeStringField: function (t, e) {\n        this.writeTag(t, Yh.Bytes), this.writeString(e);\n      },\n      writeFloatField: function (t, e) {\n        this.writeTag(t, Yh.Fixed32), this.writeFloat(e);\n      },\n      writeDoubleField: function (t, e) {\n        this.writeTag(t, Yh.Fixed64), this.writeDouble(e);\n      },\n      writeBooleanField: function (t, e) {\n        this.writeVarintField(t, Boolean(e));\n      }\n    };\n    var mp = p(Xh);\n    const gp = 3;\n    function xp(t, e, r) {\n      e.glyphs = [], 1 === t && r.readMessage(vp, e);\n    }\n    function vp(t, e, r) {\n      if (3 === t) {\n        const {\n          id: t,\n          bitmap: n,\n          width: i,\n          height: s,\n          left: a,\n          top: o,\n          advance: l\n        } = r.readMessage(bp, {});\n        e.glyphs.push({\n          id: t,\n          bitmap: new Ru({\n            width: i + 2 * gp,\n            height: s + 2 * gp\n          }, n),\n          metrics: {\n            width: i,\n            height: s,\n            left: a,\n            top: o,\n            advance: l\n          }\n        });\n      } else 4 === t ? e.ascender = r.readSVarint() : 5 === t && (e.descender = r.readSVarint());\n    }\n    function bp(t, e, r) {\n      1 === t ? e.id = r.readVarint() : 2 === t ? e.bitmap = r.readBytes() : 3 === t ? e.width = r.readVarint() : 4 === t ? e.height = r.readVarint() : 5 === t ? e.left = r.readSVarint() : 6 === t ? e.top = r.readSVarint() : 7 === t && (e.advance = r.readVarint());\n    }\n    const wp = gp;\n    function _p(t) {\n      let e = 0,\n        r = 0;\n      for (const n of t) e += n.w * n.h, r = Math.max(r, n.w);\n      t.sort((t, e) => e.h - t.h);\n      const n = [{\n        x: 0,\n        y: 0,\n        w: Math.max(Math.ceil(Math.sqrt(e / .95)), r),\n        h: 1 / 0\n      }];\n      let i = 0,\n        s = 0;\n      for (const e of t) for (let t = n.length - 1; t >= 0; t--) {\n        const r = n[t];\n        if (!(e.w > r.w || e.h > r.h)) {\n          if (e.x = r.x, e.y = r.y, s = Math.max(s, e.y + e.h), i = Math.max(i, e.x + e.w), e.w === r.w && e.h === r.h) {\n            const e = n.pop();\n            t < n.length && (n[t] = e);\n          } else e.h === r.h ? (r.x += e.w, r.w -= e.w) : e.w === r.w ? (r.y += e.h, r.h -= e.h) : (n.push({\n            x: r.x + e.w,\n            y: r.y,\n            w: r.w - e.w,\n            h: e.h\n          }), r.y += e.h, r.h -= e.h);\n          break;\n        }\n      }\n      return {\n        w: i,\n        h: s,\n        fill: e / (i * s) || 0\n      };\n    }\n    const Ap = 1;\n    class Sp {\n      constructor(t, {\n        pixelRatio: e,\n        version: r,\n        stretchX: n,\n        stretchY: i,\n        content: s\n      }) {\n        this.paddedRect = t, this.pixelRatio = e, this.stretchX = n, this.stretchY = i, this.content = s, this.version = r;\n      }\n      get tl() {\n        return [this.paddedRect.x + Ap, this.paddedRect.y + Ap];\n      }\n      get br() {\n        return [this.paddedRect.x + this.paddedRect.w - Ap, this.paddedRect.y + this.paddedRect.h - Ap];\n      }\n      get displaySize() {\n        return [(this.paddedRect.w - 2 * Ap) / this.pixelRatio, (this.paddedRect.h - 2 * Ap) / this.pixelRatio];\n      }\n    }\n    class kp {\n      constructor(t, e) {\n        const r = {},\n          n = {};\n        this.haveRenderCallbacks = [];\n        const i = [];\n        this.addImages(t, r, i), this.addImages(e, n, i);\n        const {\n            w: s,\n            h: a\n          } = _p(i),\n          o = new Uu({\n            width: s || 1,\n            height: a || 1\n          });\n        for (const e in t) {\n          const n = t[e],\n            i = r[e].paddedRect;\n          Uu.copy(n.data, o, {\n            x: 0,\n            y: 0\n          }, {\n            x: i.x + Ap,\n            y: i.y + Ap\n          }, n.data);\n        }\n        for (const t in e) {\n          const r = e[t],\n            i = n[t].paddedRect,\n            s = i.x + Ap,\n            a = i.y + Ap,\n            l = r.data.width,\n            u = r.data.height;\n          Uu.copy(r.data, o, {\n            x: 0,\n            y: 0\n          }, {\n            x: s,\n            y: a\n          }, r.data), Uu.copy(r.data, o, {\n            x: 0,\n            y: u - 1\n          }, {\n            x: s,\n            y: a - 1\n          }, {\n            width: l,\n            height: 1\n          }), Uu.copy(r.data, o, {\n            x: 0,\n            y: 0\n          }, {\n            x: s,\n            y: a + u\n          }, {\n            width: l,\n            height: 1\n          }), Uu.copy(r.data, o, {\n            x: l - 1,\n            y: 0\n          }, {\n            x: s - 1,\n            y: a\n          }, {\n            width: 1,\n            height: u\n          }), Uu.copy(r.data, o, {\n            x: 0,\n            y: 0\n          }, {\n            x: s + l,\n            y: a\n          }, {\n            width: 1,\n            height: u\n          });\n        }\n        this.image = o, this.iconPositions = r, this.patternPositions = n;\n      }\n      addImages(t, e, r) {\n        for (const n in t) {\n          const i = t[n],\n            s = {\n              x: 0,\n              y: 0,\n              w: i.data.width + 2 * Ap,\n              h: i.data.height + 2 * Ap\n            };\n          r.push(s), e[n] = new Sp(s, i), i.hasRenderCallback && this.haveRenderCallbacks.push(n);\n        }\n      }\n      patchUpdatedImages(t, e) {\n        this.haveRenderCallbacks = this.haveRenderCallbacks.filter(e => t.hasImage(e)), t.dispatchRenderCallbacks(this.haveRenderCallbacks);\n        for (const r in t.updatedImages) this.patchUpdatedImage(this.iconPositions[r], t.getImage(r), e), this.patchUpdatedImage(this.patternPositions[r], t.getImage(r), e);\n      }\n      patchUpdatedImage(t, e, r) {\n        if (!t || !e) return;\n        if (t.version === e.version) return;\n        t.version = e.version;\n        const [n, i] = t.tl;\n        r.update(e.data, void 0, {\n          x: n,\n          y: i\n        });\n      }\n    }\n    Ji(Sp, \"ImagePosition\"), Ji(kp, \"ImageAtlas\");\n    const Ip = {\n        horizontal: 1,\n        vertical: 2,\n        horizontalOnly: 3\n      },\n      Mp = -17;\n    class Tp {\n      constructor() {\n        this.scale = 1, this.fontStack = \"\", this.imageName = null;\n      }\n      static forText(t, e) {\n        const r = new Tp();\n        return r.scale = t || 1, r.fontStack = e, r;\n      }\n      static forImage(t) {\n        const e = new Tp();\n        return e.imageName = t, e;\n      }\n    }\n    class zp {\n      constructor() {\n        this.text = \"\", this.sectionIndex = [], this.sections = [], this.imageSectionID = null;\n      }\n      static fromFeature(t, e) {\n        const r = new zp();\n        for (let n = 0; n < t.sections.length; n++) {\n          const i = t.sections[n];\n          i.image ? r.addImageSection(i) : r.addTextSection(i, e);\n        }\n        return r;\n      }\n      length() {\n        return this.text.length;\n      }\n      getSection(t) {\n        return this.sections[this.sectionIndex[t]];\n      }\n      getSections() {\n        return this.sections;\n      }\n      getSectionIndex(t) {\n        return this.sectionIndex[t];\n      }\n      getCharCode(t) {\n        return this.text.charCodeAt(t);\n      }\n      verticalizePunctuation(t) {\n        this.text = function (t, e) {\n          let r = \"\";\n          for (let n = 0; n < t.length; n++) {\n            const i = t.charCodeAt(n + 1) || null,\n              s = t.charCodeAt(n - 1) || null;\n            r += !e && (i && ss(i) && !Gh[t[n + 1]] || s && ss(s) && !Gh[t[n - 1]]) || !Gh[t[n]] ? t[n] : Gh[t[n]];\n          }\n          return r;\n        }(this.text, t);\n      }\n      trim() {\n        let t = 0;\n        for (let e = 0; e < this.text.length && Ep[this.text.charCodeAt(e)]; e++) t++;\n        let e = this.text.length;\n        for (let r = this.text.length - 1; r >= 0 && r >= t && Ep[this.text.charCodeAt(r)]; r--) e--;\n        this.text = this.text.substring(t, e), this.sectionIndex = this.sectionIndex.slice(t, e);\n      }\n      substring(t, e) {\n        const r = new zp();\n        return r.text = this.text.substring(t, e), r.sectionIndex = this.sectionIndex.slice(t, e), r.sections = this.sections, r;\n      }\n      toString() {\n        return this.text;\n      }\n      getMaxScale() {\n        return this.sectionIndex.reduce((t, e) => Math.max(t, this.sections[e].scale), 0);\n      }\n      addTextSection(t, e) {\n        this.text += t.text, this.sections.push(Tp.forText(t.scale, t.fontStack || e));\n        const r = this.sections.length - 1;\n        for (let e = 0; e < t.text.length; ++e) this.sectionIndex.push(r);\n      }\n      addImageSection(t) {\n        const e = t.image ? t.image.name : \"\";\n        if (0 === e.length) return void N(\"Can't add FormattedSection with an empty image.\");\n        const r = this.getNextImageSectionCharCode();\n        r ? (this.text += String.fromCharCode(r), this.sections.push(Tp.forImage(e)), this.sectionIndex.push(this.sections.length - 1)) : N(\"Reached maximum number of images 6401\");\n      }\n      getNextImageSectionCharCode() {\n        return this.imageSectionID ? this.imageSectionID >= 63743 ? null : ++this.imageSectionID : (this.imageSectionID = 57344, this.imageSectionID);\n      }\n    }\n    function Bp(t, e, r, n, i, s, a, o, l, u, c, h, p, d, f) {\n      const y = zp.fromFeature(t, i);\n      h === Ip.vertical && y.verticalizePunctuation(p);\n      let m = [];\n      const g = function (t, e, r, n, i, s) {\n          if (!t) return [];\n          const a = [],\n            o = function (t, e, r, n, i, s) {\n              let a = 0;\n              for (let r = 0; r < t.length(); r++) {\n                const o = t.getSection(r);\n                a += Pp(t.getCharCode(r), o, n, i, e, s);\n              }\n              return a / Math.max(1, Math.ceil(a / r));\n            }(t, e, r, n, i, s),\n            l = t.text.indexOf(\"â\") >= 0;\n          let u = 0;\n          for (let r = 0; r < t.length(); r++) {\n            const h = t.getSection(r),\n              p = t.getCharCode(r);\n            if (Ep[p] || (u += Pp(p, h, n, i, e, s)), r < t.length() - 1) {\n              const e = !((c = p) < 11904 || !(ts[\"Bopomofo Extended\"](c) || ts.Bopomofo(c) || ts[\"CJK Compatibility Forms\"](c) || ts[\"CJK Compatibility Ideographs\"](c) || ts[\"CJK Compatibility\"](c) || ts[\"CJK Radicals Supplement\"](c) || ts[\"CJK Strokes\"](c) || ts[\"CJK Symbols and Punctuation\"](c) || ts[\"CJK Unified Ideographs Extension A\"](c) || ts[\"CJK Unified Ideographs\"](c) || ts[\"Enclosed CJK Letters and Months\"](c) || ts[\"Halfwidth and Fullwidth Forms\"](c) || ts.Hiragana(c) || ts[\"Ideographic Description Characters\"](c) || ts[\"Kangxi Radicals\"](c) || ts[\"Katakana Phonetic Extensions\"](c) || ts.Katakana(c) || ts[\"Vertical Forms\"](c) || ts[\"Yi Radicals\"](c) || ts[\"Yi Syllables\"](c)));\n              (Cp[p] || e || h.imageName) && a.push(Lp(r + 1, u, o, a, Vp(p, t.getCharCode(r + 1), e && l), !1));\n            }\n          }\n          var c;\n          return Fp(Lp(t.length(), u, o, a, 0, !0));\n        }(y, u, s, e, n, d),\n        {\n          processBidirectionalText: x,\n          processStyledBidirectionalText: v\n        } = bs;\n      if (x && 1 === y.sections.length) {\n        const t = x(y.toString(), g);\n        for (const e of t) {\n          const t = new zp();\n          t.text = e, t.sections = y.sections;\n          for (let r = 0; r < e.length; r++) t.sectionIndex.push(0);\n          m.push(t);\n        }\n      } else if (v) {\n        const t = v(y.text, y.sectionIndex, g);\n        for (const e of t) {\n          const t = new zp();\n          t.text = e[0], t.sectionIndex = e[1], t.sections = y.sections, m.push(t);\n        }\n      } else m = function (t, e) {\n        const r = [],\n          n = t.text;\n        let i = 0;\n        for (const n of e) r.push(t.substring(i, n)), i = n;\n        return i < n.length && r.push(t.substring(i, n.length)), r;\n      }(y, g);\n      const b = [],\n        w = {\n          positionedLines: b,\n          text: y.toString(),\n          top: c[1],\n          bottom: c[1],\n          left: c[0],\n          right: c[0],\n          writingMode: h,\n          iconsInText: !1,\n          verticalizable: !1,\n          hasBaseline: !1\n        };\n      return function (t, e, r, n, i, s, a, o, l, u, c, h) {\n        let p = 0,\n          d = 0,\n          f = 0;\n        const y = \"right\" === o ? 1 : \"left\" === o ? 0 : .5;\n        let m = !1;\n        for (const t of i) {\n          const r = t.getSections();\n          for (const t of r) {\n            if (t.imageName) continue;\n            const r = e[t.fontStack];\n            if (r && (m = void 0 !== r.ascender && void 0 !== r.descender, !m)) break;\n          }\n          if (!m) break;\n        }\n        let g = 0;\n        for (const a of i) {\n          a.trim();\n          const i = a.getMaxScale(),\n            o = (i - 1) * Rh,\n            v = {\n              positionedGlyphs: [],\n              lineOffset: 0\n            };\n          t.positionedLines[g] = v;\n          const b = v.positionedGlyphs;\n          let w = 0;\n          if (!a.length()) {\n            d += s, ++g;\n            continue;\n          }\n          let _ = 0,\n            A = 0;\n          for (let s = 0; s < a.length(); s++) {\n            const o = a.getSection(s),\n              f = a.getSectionIndex(s),\n              y = a.getCharCode(s);\n            let g = o.scale,\n              v = null,\n              S = null,\n              k = null,\n              I = Rh,\n              M = 0;\n            const T = !(l === Ip.horizontal || !c && !is(y) || c && (Ep[y] || (x = y, ts.Arabic(x) || ts[\"Arabic Supplement\"](x) || ts[\"Arabic Extended-A\"](x) || ts[\"Arabic Presentation Forms-A\"](x) || ts[\"Arabic Presentation Forms-B\"](x))));\n            if (o.imageName) {\n              const e = n[o.imageName];\n              if (!e) continue;\n              k = o.imageName, t.iconsInText = t.iconsInText || !0, S = e.paddedRect;\n              const r = e.displaySize;\n              g = g * Rh / h, v = {\n                width: r[0],\n                height: r[1],\n                left: Ap,\n                top: -wp,\n                advance: T ? r[1] : r[0],\n                localGlyph: !1\n              }, M = m ? -v.height * g : Mp + i * Rh - r[1] * g, I = v.advance;\n              const s = (T ? r[0] : r[1]) * g - Rh * i;\n              s > 0 && s > w && (w = s);\n            } else {\n              const t = r[o.fontStack];\n              if (!t) continue;\n              t[y] && (S = t[y]);\n              const n = e[o.fontStack];\n              if (!n) continue;\n              const s = n.glyphs[y];\n              if (!s) continue;\n              if (v = s.metrics, I = 8203 !== y ? Rh : 0, m) {\n                const t = void 0 !== n.ascender ? Math.abs(n.ascender) : 0,\n                  e = void 0 !== n.descender ? Math.abs(n.descender) : 0,\n                  r = (t + e) * g;\n                _ < r && (_ = r, A = (t - e) / 2 * g), M = -t * g;\n              } else M = Mp + (i - g) * Rh;\n            }\n            T ? (t.verticalizable = !0, b.push({\n              glyph: y,\n              imageName: k,\n              x: p,\n              y: d + M,\n              vertical: T,\n              scale: g,\n              localGlyph: v.localGlyph,\n              fontStack: o.fontStack,\n              sectionIndex: f,\n              metrics: v,\n              rect: S\n            }), p += I * g + u) : (b.push({\n              glyph: y,\n              imageName: k,\n              x: p,\n              y: d + M,\n              vertical: T,\n              scale: g,\n              localGlyph: v.localGlyph,\n              fontStack: o.fontStack,\n              sectionIndex: f,\n              metrics: v,\n              rect: S\n            }), p += v.advance * g + u);\n          }\n          0 !== b.length && (f = Math.max(p - u, f), m ? Up(b, y, w, A, s * i / 2) : Up(b, y, w, 0, s / 2)), p = 0;\n          const S = s * i + w;\n          v.lineOffset = Math.max(w, o), d += S, ++g;\n        }\n        var x;\n        const v = d,\n          {\n            horizontalAlign: b,\n            verticalAlign: w\n          } = Rp(a);\n        (function (t, e, r, n, i, s) {\n          const a = (e - r) * i,\n            o = -s * n;\n          for (const e of t) for (const t of e.positionedGlyphs) t.x += a, t.y += o;\n        })(t.positionedLines, y, b, w, f, v), t.top += -w * v, t.bottom = t.top + v, t.left += -b * f, t.right = t.left + f, t.hasBaseline = m;\n      }(w, e, r, n, m, a, o, l, h, u, p, f), !function (t) {\n        for (const e of t) if (0 !== e.positionedGlyphs.length) return !1;\n        return !0;\n      }(b) && w;\n    }\n    const Ep = {\n        9: !0,\n        10: !0,\n        11: !0,\n        12: !0,\n        13: !0,\n        32: !0\n      },\n      Cp = {\n        10: !0,\n        32: !0,\n        38: !0,\n        40: !0,\n        41: !0,\n        43: !0,\n        45: !0,\n        47: !0,\n        173: !0,\n        183: !0,\n        8203: !0,\n        8208: !0,\n        8211: !0,\n        8231: !0\n      };\n    function Pp(t, e, r, n, i, s) {\n      if (e.imageName) {\n        const t = n[e.imageName];\n        return t ? t.displaySize[0] * e.scale * Rh / s + i : 0;\n      }\n      {\n        const n = r[e.fontStack],\n          s = n && n.glyphs[t];\n        return s ? s.metrics.advance * e.scale + i : 0;\n      }\n    }\n    function Dp(t, e, r, n) {\n      const i = Math.pow(t - e, 2);\n      return n ? t < e ? i / 2 : 2 * i : i + Math.abs(r) * r;\n    }\n    function Vp(t, e, r) {\n      let n = 0;\n      return 10 === t && (n -= 1e4), r && (n += 150), 40 !== t && 65288 !== t || (n += 50), 41 !== e && 65289 !== e || (n += 50), n;\n    }\n    function Lp(t, e, r, n, i, s) {\n      let a = null,\n        o = Dp(e, r, i, s);\n      for (const t of n) {\n        const n = Dp(e - t.x, r, i, s) + t.badness;\n        n <= o && (a = t, o = n);\n      }\n      return {\n        index: t,\n        x: e,\n        priorBreak: a,\n        badness: o\n      };\n    }\n    function Fp(t) {\n      return t ? Fp(t.priorBreak).concat(t.index) : [];\n    }\n    function Rp(t) {\n      let e = .5,\n        r = .5;\n      switch (t) {\n        case \"right\":\n        case \"top-right\":\n        case \"bottom-right\":\n          e = 1;\n          break;\n        case \"left\":\n        case \"top-left\":\n        case \"bottom-left\":\n          e = 0;\n      }\n      switch (t) {\n        case \"bottom\":\n        case \"bottom-right\":\n        case \"bottom-left\":\n          r = 1;\n          break;\n        case \"top\":\n        case \"top-right\":\n        case \"top-left\":\n          r = 0;\n      }\n      return {\n        horizontalAlign: e,\n        verticalAlign: r\n      };\n    }\n    function Up(t, e, r, n, i) {\n      if (!(e || r || n || i)) return;\n      const s = t.length - 1,\n        a = t[s],\n        o = (a.x + a.metrics.advance * a.scale) * e;\n      for (let e = 0; e <= s; e++) t[e].x -= o, t[e].y += r + n + i;\n    }\n    function $p(t, e, r) {\n      const {\n          horizontalAlign: n,\n          verticalAlign: i\n        } = Rp(r),\n        s = e[0] - t.displaySize[0] * n,\n        a = e[1] - t.displaySize[1] * i;\n      return {\n        image: t,\n        top: a,\n        bottom: a + t.displaySize[1],\n        left: s,\n        right: s + t.displaySize[0]\n      };\n    }\n    function jp(t, e, r, n, i, s) {\n      const a = t.image;\n      let o;\n      if (a.content) {\n        const t = a.content,\n          e = a.pixelRatio || 1;\n        o = [t[0] / e, t[1] / e, a.displaySize[0] - t[2] / e, a.displaySize[1] - t[3] / e];\n      }\n      const l = e.left * s,\n        u = e.right * s;\n      let c, h, p, d;\n      \"width\" === r || \"both\" === r ? (d = i[0] + l - n[3], h = i[0] + u + n[1]) : (d = i[0] + (l + u - a.displaySize[0]) / 2, h = d + a.displaySize[0]);\n      const f = e.top * s,\n        y = e.bottom * s;\n      return \"height\" === r || \"both\" === r ? (c = i[1] + f - n[0], p = i[1] + y + n[2]) : (c = i[1] + (f + y - a.displaySize[1]) / 2, p = c + a.displaySize[1]), {\n        image: a,\n        top: c,\n        right: h,\n        bottom: p,\n        left: d,\n        collisionPadding: o\n      };\n    }\n    class Op extends x {\n      constructor(t, e, r, n, i) {\n        super(t, e), this.angle = n, this.z = r, void 0 !== i && (this.segment = i);\n      }\n      clone() {\n        return new Op(this.x, this.y, this.z, this.angle, this.segment);\n      }\n    }\n    function qp(t, e, r, n, i) {\n      if (void 0 === e.segment) return !0;\n      let s = e,\n        a = e.segment + 1,\n        o = 0;\n      for (; o > -r / 2;) {\n        if (a--, a < 0) return !1;\n        o -= t[a].dist(s), s = t[a];\n      }\n      o += t[a].dist(t[a + 1]), a++;\n      const l = [];\n      let u = 0;\n      for (; o < r / 2;) {\n        const e = t[a],\n          r = t[a + 1];\n        if (!r) return !1;\n        let s = t[a - 1].angleTo(e) - e.angleTo(r);\n        for (s = Math.abs((s + 3 * Math.PI) % (2 * Math.PI) - Math.PI), l.push({\n          distance: o,\n          angleDelta: s\n        }), u += s; o - l[0].distance > n;) u -= l.shift().angleDelta;\n        if (u > i) return !1;\n        a++, o += e.dist(r);\n      }\n      return !0;\n    }\n    function Np(t) {\n      let e = 0;\n      for (let r = 0; r < t.length - 1; r++) e += t[r].dist(t[r + 1]);\n      return e;\n    }\n    function Gp(t, e, r) {\n      return t ? .6 * e * r : 0;\n    }\n    function Zp(t, e) {\n      return Math.max(t ? t.right - t.left : 0, e ? e.right - e.left : 0);\n    }\n    function Kp(t, e, r, n, i, s) {\n      const a = Gp(r, i, s),\n        o = Zp(r, n) * s;\n      let l = 0;\n      const u = Np(t) / 2;\n      for (let r = 0; r < t.length - 1; r++) {\n        const n = t[r],\n          i = t[r + 1],\n          s = n.dist(i);\n        if (l + s > u) {\n          const c = (u - l) / s,\n            h = Er(n.x, i.x, c),\n            p = Er(n.y, i.y, c),\n            d = new Op(h, p, 0, i.angleTo(n), r);\n          return !a || qp(t, d, o, a, e) ? d : void 0;\n        }\n        l += s;\n      }\n    }\n    function Xp(t, e, r, n, i, s, a, o, l) {\n      const u = Gp(n, s, a),\n        c = Zp(n, i),\n        h = c * a,\n        p = 0 === t[0].x || t[0].x === l || 0 === t[0].y || t[0].y === l;\n      return e - h < e / 4 && (e = h + e / 4), Jp(t, p ? e / 2 * o % e : (c / 2 + 2 * s) * a * o % e, e, u, r, h, p, !1, l);\n    }\n    function Jp(t, e, r, n, i, s, a, o, l) {\n      const u = s / 2,\n        c = Np(t);\n      let h = 0,\n        p = e - r,\n        d = [];\n      for (let e = 0; e < t.length - 1; e++) {\n        const a = t[e],\n          o = t[e + 1],\n          f = a.dist(o),\n          y = o.angleTo(a);\n        for (; p + r < h + f;) {\n          p += r;\n          const m = (p - h) / f,\n            g = Er(a.x, o.x, m),\n            x = Er(a.y, o.y, m);\n          if (g >= 0 && g < l && x >= 0 && x < l && p - u >= 0 && p + u <= c) {\n            const r = new Op(g, x, 0, y, e);\n            r._round(), n && !qp(t, r, s, n, i) || d.push(r);\n          }\n        }\n        h += f;\n      }\n      return o || d.length || a || (d = Jp(t, h / 2, r, n, i, s, a, !0, l)), d;\n    }\n    function Hp(t, e, r, n, i) {\n      const s = [];\n      for (let a = 0; a < t.length; a++) {\n        const o = t[a];\n        let l;\n        for (let t = 0; t < o.length - 1; t++) {\n          let a = o[t],\n            u = o[t + 1];\n          a.x < e && u.x < e || (a.x < e ? a = new x(e, a.y + (e - a.x) / (u.x - a.x) * (u.y - a.y))._round() : u.x < e && (u = new x(e, a.y + (e - a.x) / (u.x - a.x) * (u.y - a.y))._round()), a.y < r && u.y < r || (a.y < r ? a = new x(a.x + (r - a.y) / (u.y - a.y) * (u.x - a.x), r)._round() : u.y < r && (u = new x(a.x + (r - a.y) / (u.y - a.y) * (u.x - a.x), r)._round()), a.x >= n && u.x >= n || (a.x >= n ? a = new x(n, a.y + (n - a.x) / (u.x - a.x) * (u.y - a.y))._round() : u.x >= n && (u = new x(n, a.y + (n - a.x) / (u.x - a.x) * (u.y - a.y))._round()), a.y >= i && u.y >= i || (a.y >= i ? a = new x(a.x + (i - a.y) / (u.y - a.y) * (u.x - a.x), i)._round() : u.y >= i && (u = new x(a.x + (i - a.y) / (u.y - a.y) * (u.x - a.x), i)._round()), l && a.equals(l[l.length - 1]) || (l = [a], s.push(l)), l.push(u)))));\n        }\n      }\n      return s;\n    }\n    Ji(Op, \"Anchor\");\n    const Yp = 1e20;\n    function Wp(t, e, r, n, i, s, a, o, l) {\n      for (let u = e; u < e + n; u++) Qp(t, r * s + u, s, i, a, o, l);\n      for (let u = r; u < r + i; u++) Qp(t, u * s + e, 1, n, a, o, l);\n    }\n    function Qp(t, e, r, n, i, s, a) {\n      s[0] = 0, a[0] = -Yp, a[1] = Yp, i[0] = t[e];\n      for (let o = 1, l = 0, u = 0; o < n; o++) {\n        i[o] = t[e + o * r];\n        const n = o * o;\n        do {\n          const t = s[l];\n          u = (i[o] - i[t] + n - t * t) / (o - t) / 2;\n        } while (u <= a[l] && --l > -1);\n        l++, s[l] = o, a[l] = u, a[l + 1] = Yp;\n      }\n      for (let o = 0, l = 0; o < n; o++) {\n        for (; a[l + 1] < o;) l++;\n        const n = s[l],\n          u = o - n;\n        t[e + o * r] = i[n] + u * u;\n      }\n    }\n    const td = 2,\n      ed = {\n        none: 0,\n        ideographs: 1,\n        all: 2\n      };\n    class rd {\n      constructor(t, e, r) {\n        this.requestManager = t, this.localGlyphMode = e, this.localFontFamily = r, this.entries = {}, this.localGlyphs = {\n          200: {},\n          400: {},\n          500: {},\n          900: {}\n        };\n      }\n      setURL(t) {\n        this.url = t;\n      }\n      getGlyphs(t, e) {\n        const r = [];\n        for (const e in t) for (const n of t[e]) r.push({\n          stack: e,\n          id: n\n        });\n        B(r, ({\n          stack: t,\n          id: e\n        }, r) => {\n          let n = this.entries[t];\n          n || (n = this.entries[t] = {\n            glyphs: {},\n            requests: {},\n            ranges: {},\n            ascender: void 0,\n            descender: void 0\n          });\n          let i = n.glyphs[e];\n          if (void 0 !== i) return void r(null, {\n            stack: t,\n            id: e,\n            glyph: i\n          });\n          if (i = this._tinySDF(n, t, e), i) return n.glyphs[e] = i, void r(null, {\n            stack: t,\n            id: e,\n            glyph: i\n          });\n          const s = Math.floor(e / 256);\n          if (256 * s > 65535) return void r(new Error(\"glyphs > 65535 not supported\"));\n          if (n.ranges[s]) return void r(null, {\n            stack: t,\n            id: e,\n            glyph: i\n          });\n          let a = n.requests[s];\n          a || (a = n.requests[s] = [], rd.loadGlyphRange(t, s, this.url, this.requestManager, (t, e) => {\n            if (e) {\n              n.ascender = e.ascender, n.descender = e.descender;\n              for (const t in e.glyphs) this._doesCharSupportLocalGlyph(+t) || (n.glyphs[+t] = e.glyphs[+t]);\n              n.ranges[s] = !0;\n            }\n            for (const r of a) r(t, e);\n            delete n.requests[s];\n          })), a.push((n, i) => {\n            n ? r(n) : i && r(null, {\n              stack: t,\n              id: e,\n              glyph: i.glyphs[e] || null\n            });\n          });\n        }, (t, r) => {\n          if (t) e(t);else if (r) {\n            const t = {};\n            for (const {\n              stack: e,\n              id: n,\n              glyph: i\n            } of r) void 0 === t[e] && (t[e] = {}), void 0 === t[e].glyphs && (t[e].glyphs = {}), t[e].glyphs[n] = i && {\n              id: i.id,\n              bitmap: i.bitmap.clone(),\n              metrics: i.metrics\n            }, t[e].ascender = this.entries[e].ascender, t[e].descender = this.entries[e].descender;\n            e(null, t);\n          }\n        });\n      }\n      _doesCharSupportLocalGlyph(t) {\n        return this.localGlyphMode !== ed.none && (this.localGlyphMode === ed.all ? !!this.localFontFamily : !!this.localFontFamily && (ts[\"CJK Unified Ideographs\"](t) || ts[\"Hangul Syllables\"](t) || ts.Hiragana(t) || ts.Katakana(t) || ts[\"CJK Symbols and Punctuation\"](t)));\n      }\n      _tinySDF(t, e, r) {\n        const n = this.localFontFamily;\n        if (!n || !this._doesCharSupportLocalGlyph(r)) return;\n        let i = t.tinySDF;\n        if (!i) {\n          let r = \"400\";\n          /bold/i.test(e) ? r = \"900\" : /medium/i.test(e) ? r = \"500\" : /light/i.test(e) && (r = \"200\"), i = t.tinySDF = new rd.TinySDF({\n            fontFamily: n,\n            fontWeight: r,\n            fontSize: 24 * td,\n            buffer: 3 * td,\n            radius: 8 * td\n          }), i.fontWeight = r;\n        }\n        if (this.localGlyphs[i.fontWeight][r]) return this.localGlyphs[i.fontWeight][r];\n        const s = String.fromCharCode(r),\n          {\n            data: a,\n            width: o,\n            height: l,\n            glyphWidth: u,\n            glyphHeight: c,\n            glyphLeft: h,\n            glyphTop: p,\n            glyphAdvance: d\n          } = i.draw(s);\n        return this.localGlyphs[i.fontWeight][r] = {\n          id: r,\n          bitmap: new Ru({\n            width: o,\n            height: l\n          }, a),\n          metrics: {\n            width: u / td,\n            height: c / td,\n            left: h / td,\n            top: p / td - 27,\n            advance: d / td,\n            localGlyph: !0\n          }\n        };\n      }\n    }\n    rd.loadGlyphRange = function (t, e, r, n, i) {\n      const s = 256 * e,\n        a = s + 255,\n        o = n.transformRequest(n.normalizeGlyphsURL(r).replace(\"{fontstack}\", t).replace(\"{range}\", `${s}-${a}`), lt.Glyphs);\n      pt(o, (t, e) => {\n        if (t) i(t);else if (e) {\n          const t = {},\n            r = function (t) {\n              return new mp(t).readFields(xp, {});\n            }(e);\n          for (const e of r.glyphs) t[e.id] = e;\n          i(null, {\n            glyphs: t,\n            ascender: r.ascender,\n            descender: r.descender\n          });\n        }\n      });\n    }, rd.TinySDF = class {\n      constructor({\n        fontSize: t = 24,\n        buffer: e = 3,\n        radius: r = 8,\n        cutoff: n = .25,\n        fontFamily: i = \"sans-serif\",\n        fontWeight: s = \"normal\",\n        fontStyle: a = \"normal\"\n      } = {}) {\n        this.buffer = e, this.cutoff = n, this.radius = r;\n        const o = this.size = t + 4 * e,\n          l = this._createCanvas(o),\n          u = this.ctx = l.getContext(\"2d\", {\n            willReadFrequently: !0\n          });\n        u.font = `${a} ${s} ${t}px ${i}`, u.textBaseline = \"alphabetic\", u.textAlign = \"left\", u.fillStyle = \"black\", this.gridOuter = new Float64Array(o * o), this.gridInner = new Float64Array(o * o), this.f = new Float64Array(o), this.z = new Float64Array(o + 1), this.v = new Uint16Array(o);\n      }\n      _createCanvas(t) {\n        const e = document.createElement(\"canvas\");\n        return e.width = e.height = t, e;\n      }\n      draw(t) {\n        const {\n            width: e,\n            actualBoundingBoxAscent: r,\n            actualBoundingBoxDescent: n,\n            actualBoundingBoxLeft: i,\n            actualBoundingBoxRight: s\n          } = this.ctx.measureText(t),\n          a = Math.ceil(r),\n          o = Math.max(0, Math.min(this.size - this.buffer, Math.ceil(s - i))),\n          l = Math.min(this.size - this.buffer, a + Math.ceil(n)),\n          u = o + 2 * this.buffer,\n          c = l + 2 * this.buffer,\n          h = Math.max(u * c, 0),\n          p = new Uint8ClampedArray(h),\n          d = {\n            data: p,\n            width: u,\n            height: c,\n            glyphWidth: o,\n            glyphHeight: l,\n            glyphTop: a,\n            glyphLeft: 0,\n            glyphAdvance: e\n          };\n        if (0 === o || 0 === l) return d;\n        const {\n          ctx: f,\n          buffer: y,\n          gridInner: m,\n          gridOuter: g\n        } = this;\n        f.clearRect(y, y, o, l), f.fillText(t, y, y + a);\n        const x = f.getImageData(y, y, o, l);\n        g.fill(Yp, 0, h), m.fill(0, 0, h);\n        for (let t = 0; t < l; t++) for (let e = 0; e < o; e++) {\n          const r = x.data[4 * (t * o + e) + 3] / 255;\n          if (0 === r) continue;\n          const n = (t + y) * u + e + y;\n          if (1 === r) g[n] = 0, m[n] = Yp;else {\n            const t = .5 - r;\n            g[n] = t > 0 ? t * t : 0, m[n] = t < 0 ? t * t : 0;\n          }\n        }\n        Wp(g, 0, 0, u, c, u, this.f, this.v, this.z), Wp(m, y, y, o, l, u, this.f, this.v, this.z);\n        for (let t = 0; t < h; t++) {\n          const e = Math.sqrt(g[t]) - Math.sqrt(m[t]);\n          p[t] = Math.round(255 - 255 * (e / this.radius + this.cutoff));\n        }\n        return d;\n      }\n    };\n    const nd = Ap;\n    function id(t, e, r, n) {\n      const i = [],\n        s = t.image,\n        a = s.pixelRatio,\n        o = s.paddedRect.w - 2 * nd,\n        l = s.paddedRect.h - 2 * nd,\n        u = t.right - t.left,\n        c = t.bottom - t.top,\n        h = s.stretchX || [[0, o]],\n        p = s.stretchY || [[0, l]],\n        d = (t, e) => t + e[1] - e[0],\n        f = h.reduce(d, 0),\n        y = p.reduce(d, 0),\n        m = o - f,\n        g = l - y;\n      let v = 0,\n        b = f,\n        w = 0,\n        _ = y,\n        A = 0,\n        S = m,\n        k = 0,\n        I = g;\n      if (s.content && n) {\n        const t = s.content;\n        v = sd(h, 0, t[0]), w = sd(p, 0, t[1]), b = sd(h, t[0], t[2]), _ = sd(p, t[1], t[3]), A = t[0] - v, k = t[1] - w, S = t[2] - t[0] - b, I = t[3] - t[1] - _;\n      }\n      const M = (n, i, o, l) => {\n        const h = od(n.stretch - v, b, u, t.left),\n          p = ld(n.fixed - A, S, n.stretch, f),\n          d = od(i.stretch - w, _, c, t.top),\n          m = ld(i.fixed - k, I, i.stretch, y),\n          g = od(o.stretch - v, b, u, t.left),\n          M = ld(o.fixed - A, S, o.stretch, f),\n          T = od(l.stretch - w, _, c, t.top),\n          z = ld(l.fixed - k, I, l.stretch, y),\n          B = new x(h, d),\n          E = new x(g, d),\n          C = new x(g, T),\n          P = new x(h, T),\n          D = new x(p / a, m / a),\n          V = new x(M / a, z / a),\n          L = e * Math.PI / 180;\n        if (L) {\n          const t = Math.sin(L),\n            e = Math.cos(L),\n            r = [e, -t, t, e];\n          B._matMult(r), E._matMult(r), P._matMult(r), C._matMult(r);\n        }\n        const F = n.stretch + n.fixed,\n          R = i.stretch + i.fixed;\n        return {\n          tl: B,\n          tr: E,\n          bl: P,\n          br: C,\n          tex: {\n            x: s.paddedRect.x + nd + F,\n            y: s.paddedRect.y + nd + R,\n            w: o.stretch + o.fixed - F,\n            h: l.stretch + l.fixed - R\n          },\n          writingMode: void 0,\n          glyphOffset: [0, 0],\n          sectionIndex: 0,\n          pixelOffsetTL: D,\n          pixelOffsetBR: V,\n          minFontScaleX: S / a / u,\n          minFontScaleY: I / a / c,\n          isSDF: r\n        };\n      };\n      if (n && (s.stretchX || s.stretchY)) {\n        const t = ad(h, m, f),\n          e = ad(p, g, y);\n        for (let r = 0; r < t.length - 1; r++) {\n          const n = t[r],\n            s = t[r + 1];\n          for (let t = 0; t < e.length - 1; t++) i.push(M(n, e[t], s, e[t + 1]));\n        }\n      } else i.push(M({\n        fixed: 0,\n        stretch: -1\n      }, {\n        fixed: 0,\n        stretch: -1\n      }, {\n        fixed: 0,\n        stretch: o + 1\n      }, {\n        fixed: 0,\n        stretch: l + 1\n      }));\n      return i;\n    }\n    function sd(t, e, r) {\n      let n = 0;\n      for (const i of t) n += Math.max(e, Math.min(r, i[1])) - Math.max(e, Math.min(r, i[0]));\n      return n;\n    }\n    function ad(t, e, r) {\n      const n = [{\n        fixed: -nd,\n        stretch: 0\n      }];\n      for (const [e, r] of t) {\n        const t = n[n.length - 1];\n        n.push({\n          fixed: e - t.stretch,\n          stretch: t.stretch\n        }), n.push({\n          fixed: e - t.stretch,\n          stretch: t.stretch + (r - e)\n        });\n      }\n      return n.push({\n        fixed: e + nd,\n        stretch: r\n      }), n;\n    }\n    function od(t, e, r, n) {\n      return t / e * r + n;\n    }\n    function ld(t, e, r, n) {\n      return t - e * r / n;\n    }\n    function ud(t, e, r, n) {\n      const i = e + t.positionedLines[n].lineOffset;\n      return 0 === n ? r + i / 2 : r + (i + (e + t.positionedLines[n - 1].lineOffset)) / 2;\n    }\n    class cd {\n      constructor(t = [], e = hd) {\n        if (this.data = t, this.length = this.data.length, this.compare = e, this.length > 0) for (let t = (this.length >> 1) - 1; t >= 0; t--) this._down(t);\n      }\n      push(t) {\n        this.data.push(t), this.length++, this._up(this.length - 1);\n      }\n      pop() {\n        if (0 === this.length) return;\n        const t = this.data[0],\n          e = this.data.pop();\n        return this.length--, this.length > 0 && (this.data[0] = e, this._down(0)), t;\n      }\n      peek() {\n        return this.data[0];\n      }\n      _up(t) {\n        const {\n            data: e,\n            compare: r\n          } = this,\n          n = e[t];\n        for (; t > 0;) {\n          const i = t - 1 >> 1,\n            s = e[i];\n          if (r(n, s) >= 0) break;\n          e[t] = s, t = i;\n        }\n        e[t] = n;\n      }\n      _down(t) {\n        const {\n            data: e,\n            compare: r\n          } = this,\n          n = this.length >> 1,\n          i = e[t];\n        for (; t < n;) {\n          let n = 1 + (t << 1),\n            s = e[n];\n          const a = n + 1;\n          if (a < this.length && r(e[a], s) < 0 && (n = a, s = e[a]), r(s, i) >= 0) break;\n          e[t] = s, t = n;\n        }\n        e[t] = i;\n      }\n    }\n    function hd(t, e) {\n      return t < e ? -1 : t > e ? 1 : 0;\n    }\n    function pd(t, e = 1, r = !1) {\n      let n = 1 / 0,\n        i = 1 / 0,\n        s = -1 / 0,\n        a = -1 / 0;\n      const o = t[0];\n      for (let t = 0; t < o.length; t++) {\n        const e = o[t];\n        (!t || e.x < n) && (n = e.x), (!t || e.y < i) && (i = e.y), (!t || e.x > s) && (s = e.x), (!t || e.y > a) && (a = e.y);\n      }\n      const l = Math.min(s - n, a - i);\n      let u = l / 2;\n      const c = new cd([], dd);\n      if (0 === l) return new x(n, i);\n      for (let e = n; e < s; e += l) for (let r = i; r < a; r += l) c.push(new fd(e + u, r + u, u, t));\n      let h = function (t) {\n          let e = 0,\n            r = 0,\n            n = 0;\n          const i = t[0];\n          for (let t = 0, s = i.length, a = s - 1; t < s; a = t++) {\n            const s = i[t],\n              o = i[a],\n              l = s.x * o.y - o.x * s.y;\n            r += (s.x + o.x) * l, n += (s.y + o.y) * l, e += 3 * l;\n          }\n          return new fd(r / e, n / e, 0, t);\n        }(t),\n        p = c.length;\n      for (; c.length;) {\n        const n = c.pop();\n        (n.d > h.d || !h.d) && (h = n, r && console.log(\"found best %d after %d probes\", Math.round(1e4 * n.d) / 1e4, p)), n.max - h.d <= e || (u = n.h / 2, c.push(new fd(n.p.x - u, n.p.y - u, u, t)), c.push(new fd(n.p.x + u, n.p.y - u, u, t)), c.push(new fd(n.p.x - u, n.p.y + u, u, t)), c.push(new fd(n.p.x + u, n.p.y + u, u, t)), p += 4);\n      }\n      return r && (console.log(`num probes: ${p}`), console.log(`best distance: ${h.d}`)), h.p;\n    }\n    function dd(t, e) {\n      return e.max - t.max;\n    }\n    class fd {\n      constructor(t, e, r, n) {\n        this.p = new x(t, e), this.h = r, this.d = function (t, e) {\n          let r = !1,\n            n = 1 / 0;\n          for (let i = 0; i < e.length; i++) {\n            const s = e[i];\n            for (let e = 0, i = s.length, a = i - 1; e < i; a = e++) {\n              const i = s[e],\n                o = s[a];\n              i.y > t.y != o.y > t.y && t.x < (o.x - i.x) * (t.y - i.y) / (o.y - i.y) + i.x && (r = !r), n = Math.min(n, xu(t, i, o));\n            }\n          }\n          return (r ? 1 : -1) * Math.sqrt(n);\n        }(this.p, n), this.max = this.d + this.h * Math.SQRT2;\n      }\n    }\n    const yd = 7,\n      md = Number.POSITIVE_INFINITY,\n      gd = Math.sqrt(2);\n    function xd(t, [e, r]) {\n      let n = 0,\n        i = 0;\n      if (r === md) {\n        e < 0 && (e = 0);\n        const r = e / gd;\n        switch (t) {\n          case \"top-right\":\n          case \"top-left\":\n            i = r - yd;\n            break;\n          case \"bottom-right\":\n          case \"bottom-left\":\n            i = -r + yd;\n            break;\n          case \"bottom\":\n            i = -e + yd;\n            break;\n          case \"top\":\n            i = e - yd;\n        }\n        switch (t) {\n          case \"top-right\":\n          case \"bottom-right\":\n            n = -r;\n            break;\n          case \"top-left\":\n          case \"bottom-left\":\n            n = r;\n            break;\n          case \"left\":\n            n = e;\n            break;\n          case \"right\":\n            n = -e;\n        }\n      } else {\n        switch (e = Math.abs(e), r = Math.abs(r), t) {\n          case \"top-right\":\n          case \"top-left\":\n          case \"top\":\n            i = r - yd;\n            break;\n          case \"bottom-right\":\n          case \"bottom-left\":\n          case \"bottom\":\n            i = -r + yd;\n        }\n        switch (t) {\n          case \"top-right\":\n          case \"bottom-right\":\n          case \"right\":\n            n = -e;\n            break;\n          case \"top-left\":\n          case \"bottom-left\":\n          case \"left\":\n            n = e;\n        }\n      }\n      return [n, i];\n    }\n    function vd(t, e, r, n, i, s, a, o, l, u) {\n      t.createArrays(), t.tilePixelRatio = ao / (512 * t.overscaling), t.compareText = {}, t.iconsNeedLinear = !1;\n      const c = t.layers[0].layout,\n        h = t.layers[0]._unevaluatedLayout._values,\n        p = {};\n      if (\"composite\" === t.textSizeData.kind) {\n        const {\n          minZoom: e,\n          maxZoom: r\n        } = t.textSizeData;\n        p.compositeTextSizes = [h[\"text-size\"].possiblyEvaluate(new ws(e), o), h[\"text-size\"].possiblyEvaluate(new ws(r), o)];\n      }\n      if (\"composite\" === t.iconSizeData.kind) {\n        const {\n          minZoom: e,\n          maxZoom: r\n        } = t.iconSizeData;\n        p.compositeIconSizes = [h[\"icon-size\"].possiblyEvaluate(new ws(e), o), h[\"icon-size\"].possiblyEvaluate(new ws(r), o)];\n      }\n      p.layoutTextSize = h[\"text-size\"].possiblyEvaluate(new ws(l + 1), o), p.layoutIconSize = h[\"icon-size\"].possiblyEvaluate(new ws(l + 1), o), p.textMaxSize = h[\"text-size\"].possiblyEvaluate(new ws(18), o);\n      const d = \"map\" === c.get(\"text-rotation-alignment\") && \"point\" !== c.get(\"symbol-placement\"),\n        f = c.get(\"text-size\");\n      for (const s of t.features) {\n        const l = c.get(\"text-font\").evaluate(s, {}, o).join(\",\"),\n          h = f.evaluate(s, {}, o),\n          y = p.layoutTextSize.evaluate(s, {}, o),\n          m = (p.layoutIconSize.evaluate(s, {}, o), {\n            horizontal: {},\n            vertical: void 0\n          }),\n          g = s.text;\n        let x,\n          v = [0, 0];\n        if (g) {\n          const n = g.toString(),\n            a = c.get(\"text-letter-spacing\").evaluate(s, {}, o) * Rh,\n            u = c.get(\"text-line-height\").evaluate(s, {}, o) * Rh,\n            p = rs(n) ? a : 0,\n            f = c.get(\"text-anchor\").evaluate(s, {}, o),\n            x = c.get(\"text-variable-anchor\");\n          if (!x) {\n            const t = c.get(\"text-radial-offset\").evaluate(s, {}, o);\n            v = t ? xd(f, [t * Rh, md]) : c.get(\"text-offset\").evaluate(s, {}, o).map(t => t * Rh);\n          }\n          let b = d ? \"center\" : c.get(\"text-justify\").evaluate(s, {}, o);\n          const w = \"point\" === c.get(\"symbol-placement\"),\n            _ = w ? c.get(\"text-max-width\").evaluate(s, {}, o) * Rh : 1 / 0,\n            A = s => {\n              t.allowVerticalPlacement && es(n) && (m.vertical = Bp(g, e, r, i, l, _, u, f, s, p, v, Ip.vertical, !0, y, h));\n            };\n          if (!d && x) {\n            const t = \"auto\" === b ? x.map(t => bd(t)) : [b];\n            let n = !1;\n            for (let s = 0; s < t.length; s++) {\n              const a = t[s];\n              if (!m.horizontal[a]) if (n) m.horizontal[a] = m.horizontal[0];else {\n                const t = Bp(g, e, r, i, l, _, u, \"center\", a, p, v, Ip.horizontal, !1, y, h);\n                t && (m.horizontal[a] = t, n = 1 === t.positionedLines.length);\n              }\n            }\n            A(\"left\");\n          } else {\n            if (\"auto\" === b && (b = bd(f)), w || c.get(\"text-writing-mode\").indexOf(\"horizontal\") >= 0 || !es(n)) {\n              const t = Bp(g, e, r, i, l, _, u, f, b, p, v, Ip.horizontal, !1, y, h);\n              t && (m.horizontal[b] = t);\n            }\n            A(w ? \"left\" : b);\n          }\n        }\n        let b = !1;\n        if (s.icon && s.icon.name) {\n          const e = n[s.icon.name];\n          e && (x = $p(i[s.icon.name], c.get(\"icon-offset\").evaluate(s, {}, o), c.get(\"icon-anchor\").evaluate(s, {}, o)), b = e.sdf, void 0 === t.sdfIcons ? t.sdfIcons = e.sdf : t.sdfIcons !== e.sdf && N(\"Style sheet warning: Cannot mix SDF and non-SDF icons in one buffer\"), (e.pixelRatio !== t.pixelRatio || 0 !== c.get(\"icon-rotate\").constantOr(1)) && (t.iconsNeedLinear = !0));\n        }\n        const w = kd(m.horizontal) || m.vertical;\n        t.iconsInText || (t.iconsInText = !!w && w.iconsInText), (w || x) && wd(t, s, m, x, n, p, y, 0, v, b, a, o, u);\n      }\n      s && t.generateCollisionDebugBuffers(l, t.collisionBoxArray);\n    }\n    function bd(t) {\n      switch (t) {\n        case \"right\":\n        case \"top-right\":\n        case \"bottom-right\":\n          return \"right\";\n        case \"left\":\n        case \"top-left\":\n        case \"bottom-left\":\n          return \"left\";\n      }\n      return \"center\";\n    }\n    function wd(t, e, r, n, i, s, a, o, l, u, c, h, p) {\n      let d = s.textMaxSize.evaluate(e, {}, h);\n      void 0 === d && (d = a);\n      const f = t.layers[0].layout,\n        y = f.get(\"icon-offset\").evaluate(e, {}, h),\n        m = kd(r.horizontal) || r.vertical,\n        g = \"globe\" === p.name,\n        x = Rh,\n        v = a / x,\n        b = t.tilePixelRatio * d / x,\n        _ = (B = t.overscaling, t.zoom > 18 && B > 2 && (B >>= 1), Math.max(ao / (512 * B), 1) * f.get(\"symbol-spacing\")),\n        A = f.get(\"text-padding\") * t.tilePixelRatio,\n        S = f.get(\"icon-padding\") * t.tilePixelRatio,\n        k = w(f.get(\"text-max-angle\")),\n        I = \"map\" === f.get(\"text-rotation-alignment\") && \"point\" !== f.get(\"symbol-placement\"),\n        M = \"map\" === f.get(\"icon-rotation-alignment\") && \"point\" !== f.get(\"symbol-placement\"),\n        T = f.get(\"symbol-placement\"),\n        z = _ / 2;\n      var B;\n      const E = f.get(\"icon-text-fit\");\n      let C;\n      n && \"none\" !== E && (t.allowVerticalPlacement && r.vertical && (C = jp(n, r.vertical, E, f.get(\"icon-text-fit-padding\"), y, v)), m && (n = jp(n, m, E, f.get(\"icon-text-fit-padding\"), y, v)));\n      const P = (a, o, d) => {\n        if (o.x < 0 || o.x >= ao || o.y < 0 || o.y >= ao) return;\n        let f = null;\n        if (g) {\n          const {\n            x: t,\n            y: e,\n            z: r\n          } = p.projectTilePoint(o.x, o.y, d);\n          f = {\n            anchor: new Op(t, e, r, 0, void 0),\n            up: p.upVector(d, o.x, o.y)\n          };\n        }\n        !function (t, e, r, n, i, s, a, o, l, u, c, h, p, d, f, y, m, g, x, v, b, w, _, A, S) {\n          const k = t.addToLineVertexArray(e, n);\n          let I,\n            M,\n            T,\n            z,\n            B,\n            E,\n            C,\n            P = 0,\n            D = 0,\n            V = 0,\n            L = 0,\n            F = -1,\n            R = -1;\n          const U = {};\n          let $ = Ba(\"\");\n          const j = r ? r.anchor : e;\n          let O = 0,\n            q = 0;\n          if (void 0 === l._unevaluatedLayout.getValue(\"text-radial-offset\") ? [O, q] = l.layout.get(\"text-offset\").evaluate(b, {}, S).map(t => t * Rh) : (O = l.layout.get(\"text-radial-offset\").evaluate(b, {}, S) * Rh, q = md), t.allowVerticalPlacement && i.vertical) {\n            const t = i.vertical;\n            if (f) E = Md(t), o && (C = Md(o));else {\n              const r = l.layout.get(\"text-rotate\").evaluate(b, {}, S) + 90;\n              T = Id(u, j, e, c, h, p, t, d, r, y), o && (z = Id(u, j, e, c, h, p, o, g, r));\n            }\n          }\n          if (s) {\n            const n = l.layout.get(\"icon-rotate\").evaluate(b, {}, S),\n              i = \"none\" !== l.layout.get(\"icon-text-fit\"),\n              a = id(s, n, _, i),\n              d = o ? id(o, n, _, i) : void 0;\n            M = Id(u, j, e, c, h, p, s, g, n), P = 4 * a.length;\n            const f = t.iconSizeData;\n            let y = null;\n            \"source\" === f.kind ? (y = [Uh * l.layout.get(\"icon-size\").evaluate(b, {}, S)], y[0] > Ad && N(`${t.layerIds[0]}: Value for \"icon-size\" is >= ${_d}. Reduce your \"icon-size\".`)) : \"composite\" === f.kind && (y = [Uh * w.compositeIconSizes[0].evaluate(b, {}, S), Uh * w.compositeIconSizes[1].evaluate(b, {}, S)], (y[0] > Ad || y[1] > Ad) && N(`${t.layerIds[0]}: Value for \"icon-size\" is >= ${_d}. Reduce your \"icon-size\".`)), t.addSymbols(t.icon, a, y, v, x, b, !1, r, e, k.lineStartIndex, k.lineLength, -1, A, S), F = t.icon.placedSymbolArray.length - 1, d && (D = 4 * d.length, t.addSymbols(t.icon, d, y, v, x, b, Ip.vertical, r, e, k.lineStartIndex, k.lineLength, -1, A, S), R = t.icon.placedSymbolArray.length - 1);\n          }\n          for (const n in i.horizontal) {\n            const s = i.horizontal[n];\n            I || ($ = Ba(s.text), f ? B = Md(s) : I = Id(u, j, e, c, h, p, s, d, l.layout.get(\"text-rotate\").evaluate(b, {}, S), y));\n            const o = 1 === s.positionedLines.length;\n            if (V += Sd(t, r, e, s, a, l, f, b, y, k, i.vertical ? Ip.horizontal : Ip.horizontalOnly, o ? Object.keys(i.horizontal) : [n], U, F, w, A, S), o) break;\n          }\n          i.vertical && (L += Sd(t, r, e, i.vertical, a, l, f, b, y, k, Ip.vertical, [\"vertical\"], U, R, w, A, S));\n          let G = -1;\n          const Z = (t, e) => t ? Math.max(t, e) : e;\n          G = Z(B, G), G = Z(E, G), G = Z(C, G);\n          const K = G > -1 ? 1 : 0;\n          t.glyphOffsetArray.length >= of.MAX_GLYPHS && N(\"Too many glyphs being rendered in a tile. See https://github.com/mapbox/mapbox-gl-js/issues/2907\"), void 0 !== b.sortKey && t.addToSortKeyRanges(t.symbolInstances.length, b.sortKey), t.symbolInstances.emplaceBack(j.x, j.y, j.z, e.x, e.y, U.right >= 0 ? U.right : -1, U.center >= 0 ? U.center : -1, U.left >= 0 ? U.left : -1, U.vertical >= 0 ? U.vertical : -1, F, R, $, void 0 !== I ? I : t.collisionBoxArray.length, void 0 !== I ? I + 1 : t.collisionBoxArray.length, void 0 !== T ? T : t.collisionBoxArray.length, void 0 !== T ? T + 1 : t.collisionBoxArray.length, void 0 !== M ? M : t.collisionBoxArray.length, void 0 !== M ? M + 1 : t.collisionBoxArray.length, z || t.collisionBoxArray.length, z ? z + 1 : t.collisionBoxArray.length, c, V, L, P, D, K, 0, O, q, G);\n        }(t, o, f, a, r, n, i, C, t.layers[0], t.collisionBoxArray, e.index, e.sourceLayerIndex, t.index, A, I, l, 0, S, M, y, e, s, u, c, h);\n      };\n      if (\"line\" === T) for (const i of Hp(e.geometry, 0, 0, ao, ao)) {\n        const e = Xp(i, _, k, r.vertical || m, n, x, b, t.overscaling, ao);\n        for (const r of e) m && Td(t, m.text, z, r) || P(i, r, h);\n      } else if (\"line-center\" === T) {\n        for (const t of e.geometry) if (t.length > 1) {\n          const e = Kp(t, k, r.vertical || m, n, x, b);\n          e && P(t, e, h);\n        }\n      } else if (\"Polygon\" === e.type) for (const t of Ac(e.geometry, 0)) {\n        const e = pd(t, 16);\n        P(t[0], new Op(e.x, e.y, 0, 0, void 0), h);\n      } else if (\"LineString\" === e.type) for (const t of e.geometry) P(t, new Op(t[0].x, t[0].y, 0, 0, void 0), h);else if (\"Point\" === e.type) for (const t of e.geometry) for (const e of t) P([e], new Op(e.x, e.y, 0, 0, void 0), h);\n    }\n    const _d = 255,\n      Ad = _d * Uh;\n    function Sd(t, e, r, n, i, s, a, o, l, u, c, h, p, d, f, y, m) {\n      const g = function (t, e, r, n, i, s, a, o) {\n          const l = [];\n          if (0 === e.positionedLines.length) return l;\n          const u = n.layout.get(\"text-rotate\").evaluate(s, {}) * Math.PI / 180,\n            c = function (t) {\n              const e = t[0],\n                r = t[1],\n                n = e * r;\n              return n > 0 ? [e, -r] : n < 0 ? [-e, r] : 0 === e ? [r, e] : [r, -e];\n            }(r);\n          let h = Math.abs(e.top - e.bottom);\n          for (const t of e.positionedLines) h -= t.lineOffset;\n          const p = e.positionedLines.length,\n            d = h / p;\n          let f = e.top - r[1];\n          for (let t = 0; t < p; ++t) {\n            const n = e.positionedLines[t];\n            f = ud(e, d, f, t);\n            for (const t of n.positionedGlyphs) {\n              if (!t.rect) continue;\n              const n = t.rect || {};\n              let s = wp + 1,\n                h = !0,\n                p = 1,\n                d = 0;\n              if (t.imageName) {\n                const e = a[t.imageName];\n                if (!e) continue;\n                if (e.sdf) {\n                  N(\"SDF images are not supported in formatted text and will be ignored.\");\n                  continue;\n                }\n                h = !1, p = e.pixelRatio, s = Ap / p;\n              }\n              const y = (i || o) && t.vertical,\n                m = t.metrics.advance * t.scale / 2,\n                g = t.metrics,\n                v = t.rect;\n              if (null === v) continue;\n              o && e.verticalizable && (d = t.imageName ? m - t.metrics.width * t.scale / 2 : 0);\n              const b = i ? [t.x + m, t.y] : [0, 0];\n              let w = [0, 0],\n                _ = [0, 0],\n                A = !1;\n              i || (y ? (_ = [t.x + m + c[0], t.y + c[1] - d], A = !0) : w = [t.x + m + r[0], t.y + r[1] - d]);\n              const S = v.w * t.scale / (p * (t.localGlyph ? td : 1)),\n                k = v.h * t.scale / (p * (t.localGlyph ? td : 1));\n              let I, M, T, z;\n              if (y) {\n                const e = t.y - f,\n                  r = new x(-m, m - e),\n                  n = -Math.PI / 2,\n                  i = new x(..._);\n                I = new x(-m + w[0], w[1]), I._rotateAround(n, r)._add(i), I.x += -e + m, I.y -= (g.left - s) * t.scale;\n                const a = t.imageName ? g.advance * t.scale : Rh * t.scale,\n                  o = String.fromCharCode(t.glyph);\n                Zh(o) ? I.x += (1 - s) * t.scale : Kh(o) ? I.x += a - g.height * t.scale + (-s - 1) * t.scale : I.x += t.imageName || g.width + 2 * s === v.w && g.height + 2 * s === v.h ? (a - k) / 2 : (a - (g.height + 2 * s) * t.scale) / 2, M = new x(I.x, I.y - S), T = new x(I.x + k, I.y), z = new x(I.x + k, I.y - S);\n              } else {\n                const e = (g.left - s) * t.scale - m + w[0],\n                  r = (-g.top - s) * t.scale + w[1],\n                  n = e + S,\n                  i = r + k;\n                I = new x(e, r), M = new x(n, r), T = new x(e, i), z = new x(n, i);\n              }\n              if (u) {\n                let t;\n                t = i ? new x(0, 0) : A ? new x(c[0], c[1]) : new x(r[0], r[1]), I._rotateAround(u, t), M._rotateAround(u, t), T._rotateAround(u, t), z._rotateAround(u, t);\n              }\n              const B = new x(0, 0),\n                E = new x(0, 0);\n              l.push({\n                tl: I,\n                tr: M,\n                bl: T,\n                br: z,\n                tex: n,\n                writingMode: e.writingMode,\n                glyphOffset: b,\n                sectionIndex: t.sectionIndex,\n                isSDF: h,\n                pixelOffsetTL: B,\n                pixelOffsetBR: E,\n                minFontScaleX: 0,\n                minFontScaleY: 0\n              });\n            }\n          }\n          return l;\n        }(0, n, l, s, a, o, i, t.allowVerticalPlacement),\n        v = t.textSizeData;\n      let b = null;\n      \"source\" === v.kind ? (b = [Uh * s.layout.get(\"text-size\").evaluate(o, {}, m)], b[0] > Ad && N(`${t.layerIds[0]}: Value for \"text-size\" is >= ${_d}. Reduce your \"text-size\".`)) : \"composite\" === v.kind && (b = [Uh * f.compositeTextSizes[0].evaluate(o, {}, m), Uh * f.compositeTextSizes[1].evaluate(o, {}, m)], (b[0] > Ad || b[1] > Ad) && N(`${t.layerIds[0]}: Value for \"text-size\" is >= ${_d}. Reduce your \"text-size\".`)), t.addSymbols(t.text, g, b, l, a, o, c, e, r, u.lineStartIndex, u.lineLength, d, y, m);\n      for (const e of h) p[e] = t.text.placedSymbolArray.length - 1;\n      return 4 * g.length;\n    }\n    function kd(t) {\n      for (const e in t) return t[e];\n      return null;\n    }\n    function Id(t, e, r, n, i, s, a, o, l, u) {\n      let c = a.top,\n        h = a.bottom,\n        p = a.left,\n        d = a.right;\n      const f = a.collisionPadding;\n      if (f && (p -= f[0], c -= f[1], d += f[2], h += f[3]), l) {\n        const t = new x(p, c),\n          e = new x(d, c),\n          r = new x(p, h),\n          n = new x(d, h),\n          i = w(l);\n        let s = new x(0, 0);\n        u && (s = new x(u[0], u[1])), t._rotateAround(i, s), e._rotateAround(i, s), r._rotateAround(i, s), n._rotateAround(i, s), p = Math.min(t.x, e.x, r.x, n.x), d = Math.max(t.x, e.x, r.x, n.x), c = Math.min(t.y, e.y, r.y, n.y), h = Math.max(t.y, e.y, r.y, n.y);\n      }\n      return t.emplaceBack(e.x, e.y, e.z, r.x, r.y, p, c, d, h, o, n, i, s), t.length - 1;\n    }\n    function Md(t) {\n      t.collisionPadding && (t.top -= t.collisionPadding[1], t.bottom += t.collisionPadding[3]);\n      const e = t.bottom - t.top;\n      return e > 0 ? Math.max(10, e) : null;\n    }\n    function Td(t, e, r, n) {\n      const i = t.compareText;\n      if (e in i) {\n        const t = i[e];\n        for (let e = t.length - 1; e >= 0; e--) if (n.dist(t[e]) < r) return !0;\n      } else i[e] = [];\n      return i[e].push(n), !1;\n    }\n    function zd(t, e) {\n      const r = t.fovAboveCenter,\n        n = t.elevation ? t.elevation.getMinElevationBelowMSL() * e : 0,\n        i = (t._camera.position[2] * t.worldSize - n) / Math.cos(t._pitch),\n        s = Math.sin(r) * i / Math.sin(Math.max(Math.PI / 2 - t._pitch - r, .01)),\n        a = Math.sin(t._pitch) * s + i;\n      return Math.min(1.01 * a, i * (1 / t._horizonShift));\n    }\n    function Bd(t, e) {\n      if (!e.isReprojectedInTileSpace) return {\n        scale: 1 << t.z,\n        x: t.x,\n        y: t.y,\n        x2: t.x + 1,\n        y2: t.y + 1,\n        projection: e\n      };\n      const r = Math.pow(2, -t.z),\n        n = t.x * r,\n        i = (t.x + 1) * r,\n        s = t.y * r,\n        a = (t.y + 1) * r,\n        o = Kl(n),\n        l = Kl(i),\n        u = Xl(s),\n        c = Xl(a),\n        h = e.project(o, u),\n        p = e.project(l, u),\n        d = e.project(l, c),\n        f = e.project(o, c);\n      let y = Math.min(h.x, p.x, d.x, f.x),\n        m = Math.min(h.y, p.y, d.y, f.y),\n        g = Math.max(h.x, p.x, d.x, f.x),\n        x = Math.max(h.y, p.y, d.y, f.y);\n      const v = r / 16;\n      function b(t, r, n, i, s, a) {\n        const o = (n + s) / 2,\n          l = (i + a) / 2,\n          u = e.project(Kl(o), Xl(l)),\n          c = Math.max(0, y - u.x, m - u.y, u.x - g, u.y - x);\n        y = Math.min(y, u.x), g = Math.max(g, u.x), m = Math.min(m, u.y), x = Math.max(x, u.y), c > v && (b(t, u, n, i, o, l), b(u, r, o, l, s, a));\n      }\n      b(h, p, n, s, i, s), b(p, d, i, s, i, a), b(d, f, i, a, n, a), b(f, h, n, a, n, s), y -= v, m -= v, g += v, x += v;\n      const w = 1 / Math.max(g - y, x - m);\n      return {\n        scale: w,\n        x: y * w,\n        y: m * w,\n        x2: g * w,\n        y2: x * w,\n        projection: e\n      };\n    }\n    const Ed = po(new Float32Array(16));\n    class Cd {\n      constructor(t) {\n        this.spec = t, this.name = t.name, this.wrap = !1, this.requiresDraping = !1, this.supportsWorldCopies = !1, this.supportsTerrain = !1, this.supportsFog = !1, this.supportsFreeCamera = !1, this.zAxisUnit = \"meters\", this.isReprojectedInTileSpace = !0, this.unsupportedLayers = [\"custom\"], this.center = [0, 0], this.range = [3.5, 7];\n      }\n      project(t, e) {\n        return {\n          x: 0,\n          y: 0,\n          z: 0\n        };\n      }\n      unproject(t, e) {\n        return new Ol(0, 0);\n      }\n      projectTilePoint(t, e, r) {\n        return {\n          x: t,\n          y: e,\n          z: 0\n        };\n      }\n      locationPoint(t, e, r = !0) {\n        return t._coordinatePoint(t.locationCoordinate(e), r);\n      }\n      pixelsPerMeter(t, e) {\n        return Zl(1, t) * e;\n      }\n      pixelSpaceConversion(t, e, r) {\n        return 1;\n      }\n      farthestPixelDistance(t) {\n        return zd(t, t.pixelsPerMeter);\n      }\n      pointCoordinate(t, e, r, n) {\n        const i = t.horizonLineFromTop(!1),\n          s = new x(e, Math.max(i, r));\n        return t.rayIntersectionCoordinate(t.pointRayIntersection(s, n));\n      }\n      pointCoordinate3D(t, e, r) {\n        const n = new x(e, r);\n        if (t.elevation) return t.elevation.pointCoordinate(n);\n        {\n          const e = this.pointCoordinate(t, n.x, n.y, 0);\n          return [e.x, e.y, e.z];\n        }\n      }\n      isPointAboveHorizon(t, e) {\n        if (t.elevation) return !this.pointCoordinate3D(t, e.x, e.y);\n        const r = t.horizonLineFromTop();\n        return e.y < r;\n      }\n      createInversionMatrix(t, e) {\n        return Ed;\n      }\n      createTileMatrix(t, e, r) {\n        let n, i, s;\n        const a = r.canonical,\n          o = po(new Float64Array(16));\n        if (this.isReprojectedInTileSpace) {\n          const l = Bd(a, this);\n          n = 1, i = l.x + r.wrap * l.scale, s = l.y, go(o, o, [n / l.scale, n / l.scale, t.pixelsPerMeter / e]);\n        } else n = e / t.zoomScale(a.z), i = (a.x + Math.pow(2, a.z) * r.wrap) * n, s = a.y * n;\n        return mo(o, o, [i, s, 0]), go(o, o, [n / ao, n / ao, 1]), o;\n      }\n      upVector(t, e, r) {\n        return [0, 0, 1];\n      }\n      upVectorScale(t, e, r) {\n        return {\n          metersToTile: 1\n        };\n      }\n    }\n    class Pd extends Cd {\n      constructor(t) {\n        super(t), this.range = [4, 7], this.center = t.center || [-96, 37.5];\n        const [e, r] = this.parallels = t.parallels || [29.5, 45.5],\n          n = Math.sin(w(e));\n        this.n = (n + Math.sin(w(r))) / 2, this.c = 1 + n * (2 * this.n - n), this.r0 = Math.sqrt(this.c) / this.n;\n      }\n      project(t, e) {\n        const {\n            n: r,\n            c: n,\n            r0: i\n          } = this,\n          s = w(t - this.center[0]),\n          a = w(e),\n          o = Math.sqrt(n - 2 * r * Math.sin(a)) / r;\n        return {\n          x: o * Math.sin(s * r),\n          y: o * Math.cos(s * r) - i,\n          z: 0\n        };\n      }\n      unproject(t, e) {\n        const {\n            n: r,\n            c: n,\n            r0: i\n          } = this,\n          s = i + e;\n        let a = Math.atan2(t, Math.abs(s)) * Math.sign(s);\n        s * r < 0 && (a -= Math.PI * Math.sign(t) * Math.sign(s));\n        const o = w(this.center[0]) * r;\n        a = z(a, -Math.PI - o, Math.PI - o);\n        const l = M(_(a / r) + this.center[0], -180, 180),\n          u = Math.asin(M((n - (t * t + s * s) * r * r) / (2 * r), -1, 1)),\n          c = M(_(u), -Hl, Hl);\n        return new Ol(l, c);\n      }\n    }\n    const Dd = 1.340264,\n      Vd = -.081106,\n      Ld = 893e-6,\n      Fd = .003796,\n      Rd = Math.sqrt(3) / 2;\n    class Ud extends Cd {\n      project(t, e) {\n        e = e / 180 * Math.PI, t = t / 180 * Math.PI;\n        const r = Math.asin(Rd * Math.sin(e)),\n          n = r * r,\n          i = n * n * n;\n        return {\n          x: .5 * (t * Math.cos(r) / (Rd * (Dd + 3 * Vd * n + i * (7 * Ld + 9 * Fd * n))) / Math.PI + .5),\n          y: 1 - .5 * (r * (Dd + Vd * n + i * (Ld + Fd * n)) / Math.PI + 1),\n          z: 0\n        };\n      }\n      unproject(t, e) {\n        t = (2 * t - .5) * Math.PI;\n        let r = e = (2 * (1 - e) - 1) * Math.PI,\n          n = r * r,\n          i = n * n * n;\n        for (let t, s, a, o = 0; o < 12 && (s = r * (Dd + Vd * n + i * (Ld + Fd * n)) - e, a = Dd + 3 * Vd * n + i * (7 * Ld + 9 * Fd * n), t = s / a, r = M(r - t, -Math.PI / 3, Math.PI / 3), n = r * r, i = n * n * n, !(Math.abs(t) < 1e-12)); ++o);\n        const s = Rd * t * (Dd + 3 * Vd * n + i * (7 * Ld + 9 * Fd * n)) / Math.cos(r),\n          a = Math.asin(Math.sin(r) / Rd),\n          o = M(180 * s / Math.PI, -180, 180),\n          l = M(180 * a / Math.PI, -Hl, Hl);\n        return new Ol(o, l);\n      }\n    }\n    class $d extends Cd {\n      constructor(t) {\n        super(t), this.wrap = !0, this.supportsWorldCopies = !0;\n      }\n      project(t, e) {\n        return {\n          x: .5 + t / 360,\n          y: .5 - e / 360,\n          z: 0\n        };\n      }\n      unproject(t, e) {\n        const r = 360 * (t - .5),\n          n = M(360 * (.5 - e), -Hl, Hl);\n        return new Ol(r, n);\n      }\n    }\n    const jd = Math.PI / 2;\n    function Od(t) {\n      return Math.tan((jd + t) / 2);\n    }\n    class qd extends Cd {\n      constructor(t) {\n        super(t), this.center = t.center || [0, 30];\n        const [e, r] = this.parallels = t.parallels || [30, 30];\n        let n = w(e),\n          i = w(r);\n        this.southernCenter = n + i < 0, this.southernCenter && (n = -n, i = -i);\n        const s = Math.cos(n),\n          a = Od(n);\n        this.n = n === i ? Math.sin(n) : Math.log(s / Math.cos(i)) / Math.log(Od(i) / a), this.f = s * Math.pow(Od(n), this.n) / this.n;\n      }\n      project(t, e) {\n        e = w(e), this.southernCenter && (e = -e), t = w(t - this.center[0]);\n        const r = 1e-6,\n          {\n            n: n,\n            f: i\n          } = this;\n        i > 0 ? e < -jd + r && (e = -jd + r) : e > jd - r && (e = jd - r);\n        const s = i / Math.pow(Od(e), n);\n        let a = s * Math.sin(n * t),\n          o = i - s * Math.cos(n * t);\n        return a = .5 * (a / Math.PI + .5), o = .5 * (o / Math.PI + .5), {\n          x: a,\n          y: this.southernCenter ? o : 1 - o,\n          z: 0\n        };\n      }\n      unproject(t, e) {\n        t = (2 * t - .5) * Math.PI, this.southernCenter && (e = 1 - e), e = (2 * (1 - e) - .5) * Math.PI;\n        const {\n            n: r,\n            f: n\n          } = this,\n          i = n - e,\n          s = Math.sign(i),\n          a = Math.sign(r) * Math.sqrt(t * t + i * i);\n        let o = Math.atan2(t, Math.abs(i)) * s;\n        i * r < 0 && (o -= Math.PI * Math.sign(t) * s);\n        const l = M(_(o / r) + this.center[0], -180, 180),\n          u = M(_(2 * Math.atan(Math.pow(n / a, 1 / r)) - jd), -Hl, Hl);\n        return new Ol(l, this.southernCenter ? -u : u);\n      }\n    }\n    class Nd extends Cd {\n      constructor(t) {\n        super(t), this.wrap = !0, this.supportsWorldCopies = !0, this.supportsTerrain = !0, this.supportsFog = !0, this.supportsFreeCamera = !0, this.isReprojectedInTileSpace = !1, this.unsupportedLayers = [], this.range = null;\n      }\n      project(t, e) {\n        return {\n          x: Nl(t),\n          y: Gl(e),\n          z: 0\n        };\n      }\n      unproject(t, e) {\n        const r = Kl(t),\n          n = Xl(e);\n        return new Ol(r, n);\n      }\n    }\n    const Gd = w(Hl);\n    class Zd extends Cd {\n      project(t, e) {\n        const r = (e = w(e)) * e,\n          n = r * r;\n        return {\n          x: .5 * ((t = w(t)) * (.8707 - .131979 * r + n * (n * (.003971 * r - .001529 * n) - .013791)) / Math.PI + .5),\n          y: 1 - .5 * (e * (1.007226 + r * (.015085 + n * (.028874 * r - .044475 - .005916 * n))) / Math.PI + 1),\n          z: 0\n        };\n      }\n      unproject(t, e) {\n        t = (2 * t - .5) * Math.PI;\n        let r = e = (2 * (1 - e) - 1) * Math.PI,\n          n = 25,\n          i = 0,\n          s = r * r;\n        do {\n          s = r * r;\n          const t = s * s;\n          i = (r * (1.007226 + s * (.015085 + t * (.028874 * s - .044475 - .005916 * t))) - e) / (1.007226 + s * (.045255 + t * (.259866 * s - .311325 - .005916 * 11 * t))), r = M(r - i, -Gd, Gd);\n        } while (Math.abs(i) > 1e-6 && --n > 0);\n        s = r * r;\n        const a = M(_(t / (.8707 + s * (s * (s * s * s * (.003971 - .001529 * s) - .013791) - .131979))), -180, 180),\n          o = _(r);\n        return new Ol(a, o);\n      }\n    }\n    const Kd = w(Hl);\n    class Xd extends Cd {\n      project(t, e) {\n        e = w(e), t = w(t);\n        const r = Math.cos(e),\n          n = 2 / Math.PI,\n          i = Math.acos(r * Math.cos(t / 2)),\n          s = Math.sin(i) / i,\n          a = .5 * (t * n + 2 * r * Math.sin(t / 2) / s) || 0,\n          o = .5 * (e + Math.sin(e) / s) || 0;\n        return {\n          x: .5 * (a / Math.PI + .5),\n          y: 1 - .5 * (o / Math.PI + 1),\n          z: 0\n        };\n      }\n      unproject(t, e) {\n        let r = t = (2 * t - .5) * Math.PI,\n          n = e = (2 * (1 - e) - 1) * Math.PI,\n          i = 25;\n        const s = 1e-6;\n        let a = 0,\n          o = 0;\n        do {\n          const i = Math.cos(n),\n            s = Math.sin(n),\n            l = 2 * s * i,\n            u = s * s,\n            c = i * i,\n            h = Math.cos(r / 2),\n            p = Math.sin(r / 2),\n            d = 2 * h * p,\n            f = p * p,\n            y = 1 - c * h * h,\n            m = y ? 1 / y : 0,\n            g = y ? Math.acos(i * h) * Math.sqrt(1 / y) : 0,\n            x = .5 * (2 * g * i * p + 2 * r / Math.PI) - t,\n            v = .5 * (g * s + n) - e,\n            b = .5 * m * (c * f + g * i * h * u) + 1 / Math.PI,\n            w = m * (d * l / 4 - g * s * p),\n            _ = .125 * m * (l * p - g * s * c * d),\n            A = .5 * m * (u * h + g * f * i) + .5,\n            S = w * _ - A * b;\n          a = (v * w - x * A) / S, o = (x * _ - v * b) / S, r = M(r - a, -Math.PI, Math.PI), n = M(n - o, -Kd, Kd);\n        } while ((Math.abs(a) > s || Math.abs(o) > s) && --i > 0);\n        return new Ol(_(r), _(n));\n      }\n    }\n    class Jd extends Cd {\n      constructor(t) {\n        super(t), this.center = t.center || [0, 0], this.parallels = t.parallels || [0, 0], this.cosPhi = Math.max(.01, Math.cos(w(this.parallels[0]))), this.scale = 1 / (2 * Math.max(Math.PI * this.cosPhi, 1 / this.cosPhi)), this.wrap = !0, this.supportsWorldCopies = !0;\n      }\n      project(t, e) {\n        const {\n          scale: r,\n          cosPhi: n\n        } = this;\n        return {\n          x: w(t) * n * r + .5,\n          y: -Math.sin(w(e)) / n * r + .5,\n          z: 0\n        };\n      }\n      unproject(t, e) {\n        const {\n            scale: r,\n            cosPhi: n\n          } = this,\n          i = -(e - .5) / r,\n          s = M(_((t - .5) / r) / n, -180, 180),\n          a = Math.asin(M(i * n, -1, 1)),\n          o = M(_(a), -Hl, Hl);\n        return new Ol(s, o);\n      }\n    }\n    class Hd extends Nd {\n      constructor(t) {\n        super(t), this.requiresDraping = !0, this.supportsWorldCopies = !1, this.supportsFog = !0, this.zAxisUnit = \"pixels\", this.unsupportedLayers = [\"debug\"], this.range = [3, 5];\n      }\n      projectTilePoint(t, e, r) {\n        const n = Ml(t, e, r);\n        return Fo(n, n, Bl(xl(r))), {\n          x: n[0],\n          y: n[1],\n          z: n[2]\n        };\n      }\n      locationPoint(t, e) {\n        const r = Il(e.lat, e.lng),\n          n = Do([], r),\n          i = t.elevation ? t.elevation.getAtPointOrZero(t.locationCoordinate(e), t._centerAltitude) : t._centerAltitude;\n        Po(r, r, n, Zl(1, 0) * ao * i);\n        const s = po(new Float64Array(16));\n        return yo(s, t.pixelMatrix, t.globeMatrix), Fo(r, r, s), new x(r[0], r[1]);\n      }\n      pixelsPerMeter(t, e) {\n        return Zl(1, 0) * e;\n      }\n      pixelSpaceConversion(t, e, r) {\n        const n = Zl(1, t) * e,\n          i = Er(Zl(1, 45) * e, n, r);\n        return this.pixelsPerMeter(t, e) / i;\n      }\n      createTileMatrix(t, e, r) {\n        const n = El(xl(r.canonical));\n        return yo(new Float64Array(16), t.globeMatrix, n);\n      }\n      createInversionMatrix(t, e) {\n        const {\n            center: r\n          } = t,\n          n = Bl(xl(e));\n        return vo(n, n, w(r.lng)), xo(n, n, w(r.lat)), go(n, n, [t._pixelsPerMercatorPixel, t._pixelsPerMercatorPixel, 1]), Float32Array.from(n);\n      }\n      pointCoordinate(t, e, r, n) {\n        return yl(t, e, r, !0) || new Wl(0, 0);\n      }\n      pointCoordinate3D(t, e, r) {\n        const n = this.pointCoordinate(t, e, r, 0);\n        return [n.x, n.y, n.z];\n      }\n      isPointAboveHorizon(t, e) {\n        return !yl(t, e.x, e.y, !1);\n      }\n      farthestPixelDistance(t) {\n        const e = function (t, e) {\n            const r = t.cameraToCenterDistance,\n              n = t._centerAltitude * e,\n              i = t._camera,\n              s = t._camera.forward(),\n              a = Mo([], Co([], s, -r), [0, 0, n]),\n              o = t.worldSize / (2 * Math.PI),\n              l = [0, 0, -o],\n              u = t.width / t.height,\n              c = Math.tan(t.fovAboveCenter),\n              h = Co([], i.up(), c),\n              p = Co([], i.right(), c * u),\n              d = Do([], Mo([], Mo([], s, h), p)),\n              f = [];\n            let y;\n            if (new el(a, d).closestPointOnSphere(l, o, f)) {\n              const e = Mo([], f, l),\n                r = $o([], e, a);\n              y = Math.cos(t.fovAboveCenter) * ko(r);\n            } else {\n              const t = $o([], a, l),\n                e = $o([], l, a);\n              Do(e, e);\n              const r = ko(t) - o;\n              y = Math.sqrt(r * (r + 2 * o));\n              const n = Math.acos(y / (o + r)) - Math.acos(Vo(s, e));\n              y *= Math.cos(n);\n            }\n            return 1.01 * y;\n          }(t, this.pixelsPerMeter(t.center.lat, t.worldSize)),\n          r = Pl(t.zoom);\n        if (r > 0) {\n          const n = zd(t, Zl(1, t.center.lat) * t.worldSize),\n            i = t.worldSize / (2 * Math.PI),\n            s = Math.max(t.width, t.height) / t.worldSize * Math.PI;\n          return Er(e, n + i * (1 - Math.cos(s)), Math.pow(r, 10));\n        }\n        return e;\n      }\n      upVector(t, e, r) {\n        return Ml(e, r, t, 1);\n      }\n      upVectorScale(t) {\n        return {\n          metersToTile: fl(Tl(xl(t)))\n        };\n      }\n    }\n    function Yd(t) {\n      const e = t.parallels,\n        r = !!e && Math.abs(e[0] + e[1]) < .01;\n      switch (t.name) {\n        case \"mercator\":\n          return new Nd(t);\n        case \"equirectangular\":\n          return new $d(t);\n        case \"naturalEarth\":\n          return new Zd(t);\n        case \"equalEarth\":\n          return new Ud(t);\n        case \"winkelTripel\":\n          return new Xd(t);\n        case \"albers\":\n          return r ? new Jd(t) : new Pd(t);\n        case \"lambertConformalConic\":\n          return r ? new Jd(t) : new qd(t);\n        case \"globe\":\n          return new Hd(t);\n      }\n      throw new Error(`Invalid projection name: ${t.name}`);\n    }\n    const Wd = Kc.types,\n      Qd = [{\n        name: \"a_fade_opacity\",\n        components: 1,\n        type: \"Uint8\",\n        offset: 0\n      }];\n    function tf(t, e, r, n, i, s, a, o, l, u, c, h, p) {\n      const d = o ? Math.min(Ad, Math.round(o[0])) : 0,\n        f = o ? Math.min(Ad, Math.round(o[1])) : 0;\n      t.emplaceBack(e, r, Math.round(32 * n), Math.round(32 * i), s, a, (d << 1) + (l ? 1 : 0), f, 16 * u, 16 * c, 256 * h, 256 * p);\n    }\n    function ef(t, e, r, n, i, s, a) {\n      t.emplaceBack(e, r, n, i, s, a);\n    }\n    function rf(t, e, r, n, i) {\n      t.emplaceBack(e, r, n, i), t.emplaceBack(e, r, n, i), t.emplaceBack(e, r, n, i), t.emplaceBack(e, r, n, i);\n    }\n    function nf(t) {\n      for (const e of t.sections) if (ls(e.text)) return !0;\n      return !1;\n    }\n    class sf {\n      constructor(t) {\n        this.layoutVertexArray = new Xs(), this.indexArray = new ra(), this.programConfigurations = t, this.segments = new so(), this.dynamicLayoutVertexArray = new Ns(), this.opacityVertexArray = new Hs(), this.placedSymbolArray = new fa(), this.globeExtVertexArray = new Js();\n      }\n      isEmpty() {\n        return 0 === this.layoutVertexArray.length && 0 === this.indexArray.length && 0 === this.dynamicLayoutVertexArray.length && 0 === this.opacityVertexArray.length;\n      }\n      upload(t, e, r, n) {\n        this.isEmpty() || (r && (this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, Eh.members), this.indexBuffer = t.createIndexBuffer(this.indexArray, e), this.dynamicLayoutVertexBuffer = t.createVertexBuffer(this.dynamicLayoutVertexArray, Ph.members, !0), this.opacityVertexBuffer = t.createVertexBuffer(this.opacityVertexArray, Qd, !0), this.globeExtVertexArray.length > 0 && (this.globeExtVertexBuffer = t.createVertexBuffer(this.globeExtVertexArray, Ch.members, !0)), this.opacityVertexBuffer.itemSize = 1), (r || n) && this.programConfigurations.upload(t));\n      }\n      destroy() {\n        this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.dynamicLayoutVertexBuffer.destroy(), this.opacityVertexBuffer.destroy(), this.globeExtVertexBuffer && this.globeExtVertexBuffer.destroy());\n      }\n    }\n    Ji(sf, \"SymbolBuffers\");\n    class af {\n      constructor(t, e, r) {\n        this.layoutVertexArray = new t(), this.layoutAttributes = e, this.indexArray = new r(), this.segments = new so(), this.collisionVertexArray = new ta(), this.collisionVertexArrayExt = new ea();\n      }\n      upload(t) {\n        this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, this.layoutAttributes), this.indexBuffer = t.createIndexBuffer(this.indexArray), this.collisionVertexBuffer = t.createVertexBuffer(this.collisionVertexArray, Dh.members, !0), this.collisionVertexBufferExt = t.createVertexBuffer(this.collisionVertexArrayExt, Vh.members, !0);\n      }\n      destroy() {\n        this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy(), this.collisionVertexBuffer.destroy(), this.collisionVertexBufferExt.destroy());\n      }\n    }\n    Ji(af, \"CollisionBuffers\");\n    class of {\n      constructor(t) {\n        this.collisionBoxArray = t.collisionBoxArray, this.zoom = t.zoom, this.overscaling = t.overscaling, this.layers = t.layers, this.layerIds = this.layers.map(t => t.id), this.index = t.index, this.pixelRatio = t.pixelRatio, this.sourceLayerIndex = t.sourceLayerIndex, this.hasPattern = !1, this.hasRTLText = !1, this.fullyClipped = !1, this.sortKeyRanges = [], this.collisionCircleArray = [], this.placementInvProjMatrix = po([]), this.placementViewportMatrix = po([]);\n        const e = this.layers[0]._unevaluatedLayout._values;\n        this.textSizeData = $h(this.zoom, e[\"text-size\"]), this.iconSizeData = $h(this.zoom, e[\"icon-size\"]);\n        const r = this.layers[0].layout,\n          n = r.get(\"symbol-sort-key\"),\n          i = r.get(\"symbol-z-order\");\n        this.canOverlap = r.get(\"text-allow-overlap\") || r.get(\"icon-allow-overlap\") || r.get(\"text-ignore-placement\") || r.get(\"icon-ignore-placement\"), this.sortFeaturesByKey = \"viewport-y\" !== i && void 0 !== n.constantOr(1), this.sortFeaturesByY = (\"viewport-y\" === i || \"auto\" === i && !this.sortFeaturesByKey) && this.canOverlap, this.writingModes = r.get(\"text-writing-mode\").map(t => Ip[t]), this.stateDependentLayerIds = this.layers.filter(t => t.isStateDependent()).map(t => t.id), this.sourceID = t.sourceID, this.projection = t.projection;\n      }\n      createArrays() {\n        this.text = new sf(new Ja(this.layers, this.zoom, t => /^text/.test(t))), this.icon = new sf(new Ja(this.layers, this.zoom, t => /^icon/.test(t))), this.glyphOffsetArray = new ga(), this.lineVertexArray = new xa(), this.symbolInstances = new ma();\n      }\n      calculateGlyphDependencies(t, e, r, n, i) {\n        for (let r = 0; r < t.length; r++) if (e[t.charCodeAt(r)] = !0, n && i) {\n          const n = Gh[t.charAt(r)];\n          n && (e[n.charCodeAt(0)] = !0);\n        }\n      }\n      populate(t, e, r, n) {\n        const i = this.layers[0],\n          s = i.layout,\n          a = \"globe\" === this.projection.name,\n          o = s.get(\"text-font\"),\n          l = s.get(\"text-field\"),\n          u = s.get(\"icon-image\"),\n          c = (\"constant\" !== l.value.kind || l.value.value instanceof De && !l.value.value.isEmpty() || l.value.value.toString().length > 0) && (\"constant\" !== o.value.kind || o.value.value.length > 0),\n          h = \"constant\" !== u.value.kind || !!u.value.value || Object.keys(u.parameters).length > 0,\n          p = s.get(\"symbol-sort-key\");\n        if (this.features = [], !c && !h) return;\n        const d = e.iconDependencies,\n          f = e.glyphDependencies,\n          y = e.availableImages,\n          m = new ws(this.zoom);\n        for (const {\n          feature: e,\n          id: l,\n          index: u,\n          sourceLayerIndex: g\n        } of t) {\n          const t = i._featureFilter.needGeometry,\n            x = ou(e, t);\n          if (!i._featureFilter.filter(m, x, r)) continue;\n          if (t || (x.geometry = au(e, r, n)), a && 1 !== e.type && r.z <= 5) {\n            const t = x.geometry,\n              e = .98078528056,\n              n = (t, n) => Vo(Ml(t.x, t.y, r, 1), Ml(n.x, n.y, r, 1)) < e;\n            for (let e = 0; e < t.length; e++) t[e] = ru(t[e], n);\n          }\n          let v, b;\n          if (c) {\n            const t = i.getValueAndResolveTokens(\"text-field\", x, r, y),\n              e = De.factory(t);\n            nf(e) && (this.hasRTLText = !0), (!this.hasRTLText || \"unavailable\" === xs() || this.hasRTLText && bs.isParsed()) && (v = Nh(e, i, x));\n          }\n          if (h) {\n            const t = i.getValueAndResolveTokens(\"icon-image\", x, r, y);\n            b = t instanceof Ve ? t : Ve.fromString(t);\n          }\n          if (!v && !b) continue;\n          const w = this.sortFeaturesByKey ? p.evaluate(x, {}, r) : void 0;\n          if (this.features.push({\n            id: l,\n            text: v,\n            icon: b,\n            index: u,\n            sourceLayerIndex: g,\n            geometry: x.geometry,\n            properties: e.properties,\n            type: Wd[e.type],\n            sortKey: w\n          }), b && (d[b.name] = !0), v) {\n            const t = o.evaluate(x, {}, r).join(\",\"),\n              e = \"map\" === s.get(\"text-rotation-alignment\") && \"point\" !== s.get(\"symbol-placement\");\n            this.allowVerticalPlacement = this.writingModes && this.writingModes.indexOf(Ip.vertical) >= 0;\n            for (const r of v.sections) if (r.image) d[r.image.name] = !0;else {\n              const n = es(v.toString()),\n                i = r.fontStack || t,\n                s = f[i] = f[i] || {};\n              this.calculateGlyphDependencies(r.text, s, e, this.allowVerticalPlacement, n);\n            }\n          }\n        }\n        \"line\" === s.get(\"symbol-placement\") && (this.features = function (t) {\n          const e = {},\n            r = {},\n            n = [];\n          let i = 0;\n          function s(e) {\n            n.push(t[e]), i++;\n          }\n          function a(t, e, i) {\n            const s = r[t];\n            return delete r[t], r[e] = s, n[s].geometry[0].pop(), n[s].geometry[0] = n[s].geometry[0].concat(i[0]), s;\n          }\n          function o(t, r, i) {\n            const s = e[r];\n            return delete e[r], e[t] = s, n[s].geometry[0].shift(), n[s].geometry[0] = i[0].concat(n[s].geometry[0]), s;\n          }\n          function l(t, e, r) {\n            const n = r ? e[0][e[0].length - 1] : e[0][0];\n            return `${t}:${n.x}:${n.y}`;\n          }\n          for (let u = 0; u < t.length; u++) {\n            const c = t[u],\n              h = c.geometry,\n              p = c.text ? c.text.toString() : null;\n            if (!p) {\n              s(u);\n              continue;\n            }\n            const d = l(p, h),\n              f = l(p, h, !0);\n            if (d in r && f in e && r[d] !== e[f]) {\n              const t = o(d, f, h),\n                i = a(d, f, n[t].geometry);\n              delete e[d], delete r[f], r[l(p, n[i].geometry, !0)] = i, n[t].geometry = null;\n            } else d in r ? a(d, f, h) : f in e ? o(d, f, h) : (s(u), e[d] = i - 1, r[f] = i - 1);\n          }\n          return n.filter(t => t.geometry);\n        }(this.features)), this.sortFeaturesByKey && this.features.sort((t, e) => t.sortKey - e.sortKey);\n      }\n      update(t, e, r, n) {\n        this.stateDependentLayers.length && (this.text.programConfigurations.updatePaintArrays(t, e, this.layers, r, n), this.icon.programConfigurations.updatePaintArrays(t, e, this.layers, r, n));\n      }\n      isEmpty() {\n        return 0 === this.symbolInstances.length && !this.hasRTLText;\n      }\n      uploadPending() {\n        return !this.uploaded || this.text.programConfigurations.needsUpload || this.icon.programConfigurations.needsUpload;\n      }\n      upload(t) {\n        !this.uploaded && this.hasDebugData() && (this.textCollisionBox.upload(t), this.iconCollisionBox.upload(t)), this.text.upload(t, this.sortFeaturesByY, !this.uploaded, this.text.programConfigurations.needsUpload), this.icon.upload(t, this.sortFeaturesByY, !this.uploaded, this.icon.programConfigurations.needsUpload), this.uploaded = !0;\n      }\n      destroyDebugData() {\n        this.textCollisionBox.destroy(), this.iconCollisionBox.destroy();\n      }\n      getProjection() {\n        return this.projectionInstance || (this.projectionInstance = Yd(this.projection)), this.projectionInstance;\n      }\n      destroy() {\n        this.text.destroy(), this.icon.destroy(), this.hasDebugData() && this.destroyDebugData();\n      }\n      addToLineVertexArray(t, e) {\n        const r = this.lineVertexArray.length;\n        if (void 0 !== t.segment) for (const {\n          x: t,\n          y: r\n        } of e) this.lineVertexArray.emplaceBack(t, r);\n        return {\n          lineStartIndex: r,\n          lineLength: this.lineVertexArray.length - r\n        };\n      }\n      addSymbols(t, e, r, n, i, s, a, o, l, u, c, h, p, d) {\n        const f = t.indexArray,\n          y = t.layoutVertexArray,\n          m = t.globeExtVertexArray,\n          g = t.segments.prepareSegment(4 * e.length, y, f, this.canOverlap ? s.sortKey : void 0),\n          x = this.glyphOffsetArray.length,\n          v = g.vertexLength,\n          b = this.allowVerticalPlacement && a === Ip.vertical ? Math.PI / 2 : 0,\n          w = s.text && s.text.sections;\n        for (let n = 0; n < e.length; n++) {\n          const {\n              tl: i,\n              tr: a,\n              bl: u,\n              br: c,\n              tex: h,\n              pixelOffsetTL: x,\n              pixelOffsetBR: v,\n              minFontScaleX: _,\n              minFontScaleY: A,\n              glyphOffset: S,\n              isSDF: k,\n              sectionIndex: I\n            } = e[n],\n            M = g.vertexLength,\n            T = S[1];\n          if (tf(y, l.x, l.y, i.x, T + i.y, h.x, h.y, r, k, x.x, x.y, _, A), tf(y, l.x, l.y, a.x, T + a.y, h.x + h.w, h.y, r, k, v.x, x.y, _, A), tf(y, l.x, l.y, u.x, T + u.y, h.x, h.y + h.h, r, k, x.x, v.y, _, A), tf(y, l.x, l.y, c.x, T + c.y, h.x + h.w, h.y + h.h, r, k, v.x, v.y, _, A), o) {\n            const {\n                x: e,\n                y: r,\n                z: n\n              } = o.anchor,\n              [i, s, a] = o.up;\n            ef(m, e, r, n, i, s, a), ef(m, e, r, n, i, s, a), ef(m, e, r, n, i, s, a), ef(m, e, r, n, i, s, a), rf(t.dynamicLayoutVertexArray, e, r, n, b);\n          } else rf(t.dynamicLayoutVertexArray, l.x, l.y, l.z, b);\n          f.emplaceBack(M, M + 1, M + 2), f.emplaceBack(M + 1, M + 2, M + 3), g.vertexLength += 4, g.primitiveLength += 2, this.glyphOffsetArray.emplaceBack(S[0]), n !== e.length - 1 && I === e[n + 1].sectionIndex || t.programConfigurations.populatePaintArrays(y.length, s, s.index, {}, p, d, w && w[I]);\n        }\n        const _ = o ? o.anchor : l;\n        t.placedSymbolArray.emplaceBack(_.x, _.y, _.z, l.x, l.y, x, this.glyphOffsetArray.length - x, v, u, c, l.segment, r ? r[0] : 0, r ? r[1] : 0, n[0], n[1], a, 0, !1, 0, h, 0);\n      }\n      _commitLayoutVertex(t, e, r, n, i, s, a) {\n        t.emplaceBack(e, r, n, i, s, Math.round(a.x), Math.round(a.y));\n      }\n      _addCollisionDebugVertices(t, e, r, n, i, s, a) {\n        const o = r.segments.prepareSegment(4, r.layoutVertexArray, r.indexArray),\n          l = o.vertexLength,\n          u = a.tileAnchorX,\n          c = a.tileAnchorY;\n        for (let t = 0; t < 4; t++) r.collisionVertexArray.emplaceBack(0, 0, 0, 0);\n        r.collisionVertexArrayExt.emplaceBack(e, -t.padding, -t.padding), r.collisionVertexArrayExt.emplaceBack(e, t.padding, -t.padding), r.collisionVertexArrayExt.emplaceBack(e, t.padding, t.padding), r.collisionVertexArrayExt.emplaceBack(e, -t.padding, t.padding), this._commitLayoutVertex(r.layoutVertexArray, n, i, s, u, c, new x(t.x1, t.y1)), this._commitLayoutVertex(r.layoutVertexArray, n, i, s, u, c, new x(t.x2, t.y1)), this._commitLayoutVertex(r.layoutVertexArray, n, i, s, u, c, new x(t.x2, t.y2)), this._commitLayoutVertex(r.layoutVertexArray, n, i, s, u, c, new x(t.x1, t.y2)), o.vertexLength += 4;\n        const h = r.indexArray;\n        h.emplaceBack(l, l + 1), h.emplaceBack(l + 1, l + 2), h.emplaceBack(l + 2, l + 3), h.emplaceBack(l + 3, l), o.primitiveLength += 4;\n      }\n      _addTextDebugCollisionBoxes(t, e, r, n, i, s) {\n        for (let a = n; a < i; a++) {\n          const n = r.get(a),\n            i = this.getSymbolInstanceTextSize(t, s, e, a);\n          this._addCollisionDebugVertices(n, i, this.textCollisionBox, n.projectedAnchorX, n.projectedAnchorY, n.projectedAnchorZ, s);\n        }\n      }\n      _addIconDebugCollisionBoxes(t, e, r, n, i, s) {\n        for (let a = n; a < i; a++) {\n          const n = r.get(a),\n            i = this.getSymbolInstanceIconSize(t, e, s.placedIconSymbolIndex);\n          this._addCollisionDebugVertices(n, i, this.iconCollisionBox, n.projectedAnchorX, n.projectedAnchorY, n.projectedAnchorZ, s);\n        }\n      }\n      generateCollisionDebugBuffers(t, e) {\n        this.hasDebugData() && this.destroyDebugData(), this.textCollisionBox = new af(Ws, Lh.members, la), this.iconCollisionBox = new af(Ws, Lh.members, la);\n        const r = Oh(this.iconSizeData, t),\n          n = Oh(this.textSizeData, t);\n        for (let i = 0; i < this.symbolInstances.length; i++) {\n          const s = this.symbolInstances.get(i);\n          this._addTextDebugCollisionBoxes(n, t, e, s.textBoxStartIndex, s.textBoxEndIndex, s), this._addTextDebugCollisionBoxes(n, t, e, s.verticalTextBoxStartIndex, s.verticalTextBoxEndIndex, s), this._addIconDebugCollisionBoxes(r, t, e, s.iconBoxStartIndex, s.iconBoxEndIndex, s), this._addIconDebugCollisionBoxes(r, t, e, s.verticalIconBoxStartIndex, s.verticalIconBoxEndIndex, s);\n        }\n      }\n      getSymbolInstanceTextSize(t, e, r, n) {\n        const i = this.text.placedSymbolArray.get(e.rightJustifiedTextSymbolIndex >= 0 ? e.rightJustifiedTextSymbolIndex : e.centerJustifiedTextSymbolIndex >= 0 ? e.centerJustifiedTextSymbolIndex : e.leftJustifiedTextSymbolIndex >= 0 ? e.leftJustifiedTextSymbolIndex : e.verticalPlacedTextSymbolIndex >= 0 ? e.verticalPlacedTextSymbolIndex : n),\n          s = jh(this.textSizeData, t, i) / Rh;\n        return this.tilePixelRatio * s;\n      }\n      getSymbolInstanceIconSize(t, e, r) {\n        const n = this.icon.placedSymbolArray.get(r),\n          i = jh(this.iconSizeData, t, n);\n        return this.tilePixelRatio * i;\n      }\n      _commitDebugCollisionVertexUpdate(t, e, r) {\n        t.emplaceBack(e, -r, -r), t.emplaceBack(e, r, -r), t.emplaceBack(e, r, r), t.emplaceBack(e, -r, r);\n      }\n      _updateTextDebugCollisionBoxes(t, e, r, n, i, s) {\n        for (let a = n; a < i; a++) {\n          const n = r.get(a),\n            i = this.getSymbolInstanceTextSize(t, s, e, a);\n          this._commitDebugCollisionVertexUpdate(this.textCollisionBox.collisionVertexArrayExt, i, n.padding);\n        }\n      }\n      _updateIconDebugCollisionBoxes(t, e, r, n, i, s) {\n        for (let a = n; a < i; a++) {\n          const n = r.get(a),\n            i = this.getSymbolInstanceIconSize(t, e, s);\n          this._commitDebugCollisionVertexUpdate(this.iconCollisionBox.collisionVertexArrayExt, i, n.padding);\n        }\n      }\n      updateCollisionDebugBuffers(t, e) {\n        if (!this.hasDebugData()) return;\n        this.hasTextCollisionBoxData() && this.textCollisionBox.collisionVertexArrayExt.clear(), this.hasIconCollisionBoxData() && this.iconCollisionBox.collisionVertexArrayExt.clear();\n        const r = Oh(this.iconSizeData, t),\n          n = Oh(this.textSizeData, t);\n        for (let i = 0; i < this.symbolInstances.length; i++) {\n          const s = this.symbolInstances.get(i);\n          this._updateTextDebugCollisionBoxes(n, t, e, s.textBoxStartIndex, s.textBoxEndIndex, s), this._updateTextDebugCollisionBoxes(n, t, e, s.verticalTextBoxStartIndex, s.verticalTextBoxEndIndex, s), this._updateIconDebugCollisionBoxes(r, t, e, s.iconBoxStartIndex, s.iconBoxEndIndex, s.placedIconSymbolIndex), this._updateIconDebugCollisionBoxes(r, t, e, s.verticalIconBoxStartIndex, s.verticalIconBoxEndIndex, s.placedIconSymbolIndex);\n        }\n        this.hasTextCollisionBoxData() && this.textCollisionBox.collisionVertexBufferExt && this.textCollisionBox.collisionVertexBufferExt.updateData(this.textCollisionBox.collisionVertexArrayExt), this.hasIconCollisionBoxData() && this.iconCollisionBox.collisionVertexBufferExt && this.iconCollisionBox.collisionVertexBufferExt.updateData(this.iconCollisionBox.collisionVertexArrayExt);\n      }\n      _deserializeCollisionBoxesForSymbol(t, e, r, n, i, s, a, o, l) {\n        const u = {};\n        if (e < r) {\n          const {\n            x1: r,\n            y1: n,\n            x2: i,\n            y2: s,\n            padding: a,\n            projectedAnchorX: o,\n            projectedAnchorY: l,\n            projectedAnchorZ: c,\n            tileAnchorX: h,\n            tileAnchorY: p,\n            featureIndex: d\n          } = t.get(e);\n          u.textBox = {\n            x1: r,\n            y1: n,\n            x2: i,\n            y2: s,\n            padding: a,\n            projectedAnchorX: o,\n            projectedAnchorY: l,\n            projectedAnchorZ: c,\n            tileAnchorX: h,\n            tileAnchorY: p\n          }, u.textFeatureIndex = d;\n        }\n        if (n < i) {\n          const {\n            x1: e,\n            y1: r,\n            x2: i,\n            y2: s,\n            padding: a,\n            projectedAnchorX: o,\n            projectedAnchorY: l,\n            projectedAnchorZ: c,\n            tileAnchorX: h,\n            tileAnchorY: p,\n            featureIndex: d\n          } = t.get(n);\n          u.verticalTextBox = {\n            x1: e,\n            y1: r,\n            x2: i,\n            y2: s,\n            padding: a,\n            projectedAnchorX: o,\n            projectedAnchorY: l,\n            projectedAnchorZ: c,\n            tileAnchorX: h,\n            tileAnchorY: p\n          }, u.verticalTextFeatureIndex = d;\n        }\n        if (s < a) {\n          const {\n            x1: e,\n            y1: r,\n            x2: n,\n            y2: i,\n            padding: a,\n            projectedAnchorX: o,\n            projectedAnchorY: l,\n            projectedAnchorZ: c,\n            tileAnchorX: h,\n            tileAnchorY: p,\n            featureIndex: d\n          } = t.get(s);\n          u.iconBox = {\n            x1: e,\n            y1: r,\n            x2: n,\n            y2: i,\n            padding: a,\n            projectedAnchorX: o,\n            projectedAnchorY: l,\n            projectedAnchorZ: c,\n            tileAnchorX: h,\n            tileAnchorY: p\n          }, u.iconFeatureIndex = d;\n        }\n        if (o < l) {\n          const {\n            x1: e,\n            y1: r,\n            x2: n,\n            y2: i,\n            padding: s,\n            projectedAnchorX: a,\n            projectedAnchorY: l,\n            projectedAnchorZ: c,\n            tileAnchorX: h,\n            tileAnchorY: p,\n            featureIndex: d\n          } = t.get(o);\n          u.verticalIconBox = {\n            x1: e,\n            y1: r,\n            x2: n,\n            y2: i,\n            padding: s,\n            projectedAnchorX: a,\n            projectedAnchorY: l,\n            projectedAnchorZ: c,\n            tileAnchorX: h,\n            tileAnchorY: p\n          }, u.verticalIconFeatureIndex = d;\n        }\n        return u;\n      }\n      deserializeCollisionBoxes(t) {\n        this.collisionArrays = [];\n        for (let e = 0; e < this.symbolInstances.length; e++) {\n          const r = this.symbolInstances.get(e);\n          this.collisionArrays.push(this._deserializeCollisionBoxesForSymbol(t, r.textBoxStartIndex, r.textBoxEndIndex, r.verticalTextBoxStartIndex, r.verticalTextBoxEndIndex, r.iconBoxStartIndex, r.iconBoxEndIndex, r.verticalIconBoxStartIndex, r.verticalIconBoxEndIndex));\n        }\n      }\n      hasTextData() {\n        return this.text.segments.get().length > 0;\n      }\n      hasIconData() {\n        return this.icon.segments.get().length > 0;\n      }\n      hasDebugData() {\n        return this.textCollisionBox && this.iconCollisionBox;\n      }\n      hasTextCollisionBoxData() {\n        return this.hasDebugData() && this.textCollisionBox.segments.get().length > 0;\n      }\n      hasIconCollisionBoxData() {\n        return this.hasDebugData() && this.iconCollisionBox.segments.get().length > 0;\n      }\n      addIndicesForPlacedSymbol(t, e) {\n        const r = t.placedSymbolArray.get(e),\n          n = r.vertexStartIndex + 4 * r.numGlyphs;\n        for (let e = r.vertexStartIndex; e < n; e += 4) t.indexArray.emplaceBack(e, e + 1, e + 2), t.indexArray.emplaceBack(e + 1, e + 2, e + 3);\n      }\n      getSortedSymbolIndexes(t) {\n        if (this.sortedAngle === t && void 0 !== this.symbolInstanceIndexes) return this.symbolInstanceIndexes;\n        const e = Math.sin(t),\n          r = Math.cos(t),\n          n = [],\n          i = [],\n          s = [];\n        for (let t = 0; t < this.symbolInstances.length; ++t) {\n          s.push(t);\n          const a = this.symbolInstances.get(t);\n          n.push(0 | Math.round(e * a.tileAnchorX + r * a.tileAnchorY)), i.push(a.featureIndex);\n        }\n        return s.sort((t, e) => n[t] - n[e] || i[e] - i[t]), s;\n      }\n      addToSortKeyRanges(t, e) {\n        const r = this.sortKeyRanges[this.sortKeyRanges.length - 1];\n        r && r.sortKey === e ? r.symbolInstanceEnd = t + 1 : this.sortKeyRanges.push({\n          sortKey: e,\n          symbolInstanceStart: t,\n          symbolInstanceEnd: t + 1\n        });\n      }\n      sortFeatures(t) {\n        if (this.sortFeaturesByY && this.sortedAngle !== t && !(this.text.segments.get().length > 1 || this.icon.segments.get().length > 1)) {\n          this.symbolInstanceIndexes = this.getSortedSymbolIndexes(t), this.sortedAngle = t, this.text.indexArray.clear(), this.icon.indexArray.clear(), this.featureSortOrder = [];\n          for (const t of this.symbolInstanceIndexes) {\n            const e = this.symbolInstances.get(t);\n            this.featureSortOrder.push(e.featureIndex);\n            const {\n              rightJustifiedTextSymbolIndex: r,\n              centerJustifiedTextSymbolIndex: n,\n              leftJustifiedTextSymbolIndex: i,\n              verticalPlacedTextSymbolIndex: s,\n              placedIconSymbolIndex: a,\n              verticalPlacedIconSymbolIndex: o\n            } = e;\n            r >= 0 && this.addIndicesForPlacedSymbol(this.text, r), n >= 0 && n !== r && this.addIndicesForPlacedSymbol(this.text, n), i >= 0 && i !== n && i !== r && this.addIndicesForPlacedSymbol(this.text, i), s >= 0 && this.addIndicesForPlacedSymbol(this.text, s), a >= 0 && this.addIndicesForPlacedSymbol(this.icon, a), o >= 0 && this.addIndicesForPlacedSymbol(this.icon, o);\n          }\n          this.text.indexBuffer && this.text.indexBuffer.updateData(this.text.indexArray), this.icon.indexBuffer && this.icon.indexBuffer.updateData(this.icon.indexArray);\n        }\n      }\n    }\n    Ji(of, \"SymbolBucket\", {\n      omit: [\"layers\", \"collisionBoxArray\", \"features\", \"compareText\"]\n    }), of.MAX_GLYPHS = 65535, of.addDynamicAttributes = rf;\n    const lf = new Ps({\n      \"symbol-placement\": new Bs(te.layout_symbol[\"symbol-placement\"]),\n      \"symbol-spacing\": new Bs(te.layout_symbol[\"symbol-spacing\"]),\n      \"symbol-avoid-edges\": new Bs(te.layout_symbol[\"symbol-avoid-edges\"]),\n      \"symbol-sort-key\": new Es(te.layout_symbol[\"symbol-sort-key\"]),\n      \"symbol-z-order\": new Bs(te.layout_symbol[\"symbol-z-order\"]),\n      \"icon-allow-overlap\": new Bs(te.layout_symbol[\"icon-allow-overlap\"]),\n      \"icon-ignore-placement\": new Bs(te.layout_symbol[\"icon-ignore-placement\"]),\n      \"icon-optional\": new Bs(te.layout_symbol[\"icon-optional\"]),\n      \"icon-rotation-alignment\": new Bs(te.layout_symbol[\"icon-rotation-alignment\"]),\n      \"icon-size\": new Es(te.layout_symbol[\"icon-size\"]),\n      \"icon-text-fit\": new Bs(te.layout_symbol[\"icon-text-fit\"]),\n      \"icon-text-fit-padding\": new Bs(te.layout_symbol[\"icon-text-fit-padding\"]),\n      \"icon-image\": new Es(te.layout_symbol[\"icon-image\"]),\n      \"icon-rotate\": new Es(te.layout_symbol[\"icon-rotate\"]),\n      \"icon-padding\": new Bs(te.layout_symbol[\"icon-padding\"]),\n      \"icon-keep-upright\": new Bs(te.layout_symbol[\"icon-keep-upright\"]),\n      \"icon-offset\": new Es(te.layout_symbol[\"icon-offset\"]),\n      \"icon-anchor\": new Es(te.layout_symbol[\"icon-anchor\"]),\n      \"icon-pitch-alignment\": new Bs(te.layout_symbol[\"icon-pitch-alignment\"]),\n      \"text-pitch-alignment\": new Bs(te.layout_symbol[\"text-pitch-alignment\"]),\n      \"text-rotation-alignment\": new Bs(te.layout_symbol[\"text-rotation-alignment\"]),\n      \"text-field\": new Es(te.layout_symbol[\"text-field\"]),\n      \"text-font\": new Es(te.layout_symbol[\"text-font\"]),\n      \"text-size\": new Es(te.layout_symbol[\"text-size\"]),\n      \"text-max-width\": new Es(te.layout_symbol[\"text-max-width\"]),\n      \"text-line-height\": new Es(te.layout_symbol[\"text-line-height\"]),\n      \"text-letter-spacing\": new Es(te.layout_symbol[\"text-letter-spacing\"]),\n      \"text-justify\": new Es(te.layout_symbol[\"text-justify\"]),\n      \"text-radial-offset\": new Es(te.layout_symbol[\"text-radial-offset\"]),\n      \"text-variable-anchor\": new Bs(te.layout_symbol[\"text-variable-anchor\"]),\n      \"text-anchor\": new Es(te.layout_symbol[\"text-anchor\"]),\n      \"text-max-angle\": new Bs(te.layout_symbol[\"text-max-angle\"]),\n      \"text-writing-mode\": new Bs(te.layout_symbol[\"text-writing-mode\"]),\n      \"text-rotate\": new Es(te.layout_symbol[\"text-rotate\"]),\n      \"text-padding\": new Bs(te.layout_symbol[\"text-padding\"]),\n      \"text-keep-upright\": new Bs(te.layout_symbol[\"text-keep-upright\"]),\n      \"text-transform\": new Es(te.layout_symbol[\"text-transform\"]),\n      \"text-offset\": new Es(te.layout_symbol[\"text-offset\"]),\n      \"text-allow-overlap\": new Bs(te.layout_symbol[\"text-allow-overlap\"]),\n      \"text-ignore-placement\": new Bs(te.layout_symbol[\"text-ignore-placement\"]),\n      \"text-optional\": new Bs(te.layout_symbol[\"text-optional\"])\n    });\n    var uf = {\n      paint: new Ps({\n        \"icon-opacity\": new Es(te.paint_symbol[\"icon-opacity\"]),\n        \"icon-color\": new Es(te.paint_symbol[\"icon-color\"]),\n        \"icon-halo-color\": new Es(te.paint_symbol[\"icon-halo-color\"]),\n        \"icon-halo-width\": new Es(te.paint_symbol[\"icon-halo-width\"]),\n        \"icon-halo-blur\": new Es(te.paint_symbol[\"icon-halo-blur\"]),\n        \"icon-translate\": new Bs(te.paint_symbol[\"icon-translate\"]),\n        \"icon-translate-anchor\": new Bs(te.paint_symbol[\"icon-translate-anchor\"]),\n        \"text-opacity\": new Es(te.paint_symbol[\"text-opacity\"]),\n        \"text-color\": new Es(te.paint_symbol[\"text-color\"], {\n          runtimeType: pe,\n          getOverride: t => t.textColor,\n          hasOverride: t => !!t.textColor\n        }),\n        \"text-halo-color\": new Es(te.paint_symbol[\"text-halo-color\"]),\n        \"text-halo-width\": new Es(te.paint_symbol[\"text-halo-width\"]),\n        \"text-halo-blur\": new Es(te.paint_symbol[\"text-halo-blur\"]),\n        \"text-translate\": new Bs(te.paint_symbol[\"text-translate\"]),\n        \"text-translate-anchor\": new Bs(te.paint_symbol[\"text-translate-anchor\"])\n      }),\n      layout: lf\n    };\n    class cf {\n      constructor(t) {\n        this.type = t.property.overrides ? t.property.overrides.runtimeType : le, this.defaultValue = t;\n      }\n      evaluate(t) {\n        if (t.formattedSection) {\n          const e = this.defaultValue.property.overrides;\n          if (e && e.hasOverride(t.formattedSection)) return e.getOverride(t.formattedSection);\n        }\n        return t.feature && t.featureState ? this.defaultValue.evaluate(t.feature, t.featureState) : this.defaultValue.property.specification.default;\n      }\n      eachChild(t) {\n        this.defaultValue.isConstant() || t(this.defaultValue.value._styleExpression.expression);\n      }\n      outputDefined() {\n        return !1;\n      }\n      serialize() {\n        return null;\n      }\n    }\n    Ji(cf, \"FormatSectionOverride\", {\n      omit: [\"defaultValue\"]\n    });\n    class hf extends ro {\n      constructor(t) {\n        super(t, uf);\n      }\n      recalculate(t, e) {\n        super.recalculate(t, e), \"auto\" === this.layout.get(\"icon-rotation-alignment\") && (this.layout._values[\"icon-rotation-alignment\"] = \"point\" !== this.layout.get(\"symbol-placement\") ? \"map\" : \"viewport\"), \"auto\" === this.layout.get(\"text-rotation-alignment\") && (this.layout._values[\"text-rotation-alignment\"] = \"point\" !== this.layout.get(\"symbol-placement\") ? \"map\" : \"viewport\"), \"auto\" === this.layout.get(\"text-pitch-alignment\") && (this.layout._values[\"text-pitch-alignment\"] = this.layout.get(\"text-rotation-alignment\")), \"auto\" === this.layout.get(\"icon-pitch-alignment\") && (this.layout._values[\"icon-pitch-alignment\"] = this.layout.get(\"icon-rotation-alignment\"));\n        const r = this.layout.get(\"text-writing-mode\");\n        if (r) {\n          const t = [];\n          for (const e of r) t.indexOf(e) < 0 && t.push(e);\n          this.layout._values[\"text-writing-mode\"] = t;\n        } else this.layout._values[\"text-writing-mode\"] = \"point\" === this.layout.get(\"symbol-placement\") ? [\"horizontal\"] : [\"horizontal\", \"vertical\"];\n        this._setPaintOverrides();\n      }\n      getValueAndResolveTokens(t, e, r, n) {\n        const i = this.layout.get(t).evaluate(e, {}, r, n),\n          s = this._unevaluatedLayout._values[t];\n        return s.isDataDriven() || Jn(s.value) || !i ? i : function (t, e) {\n          return e.replace(/{([^{}]+)}/g, (e, r) => r in t ? String(t[r]) : \"\");\n        }(e.properties, i);\n      }\n      createBucket(t) {\n        return new of(t);\n      }\n      queryRadius() {\n        return 0;\n      }\n      queryIntersectsFeature() {\n        return !1;\n      }\n      _setPaintOverrides() {\n        for (const t of uf.paint.overridableProperties) {\n          if (!hf.hasPaintOverride(this.layout, t)) continue;\n          const e = this.paint.get(t),\n            r = new cf(e),\n            n = new Xn(r, e.property.specification);\n          let i = null;\n          i = \"constant\" === e.value.kind || \"source\" === e.value.kind ? new Yn(\"source\", n) : new Wn(\"composite\", n, e.value.zoomStops, e.value._interpolationType), this.paint._values[t] = new Ts(e.property, i, e.parameters);\n        }\n      }\n      _handleOverridablePaintPropertyUpdate(t, e, r) {\n        return !(!this.layout || e.isDataDriven() || r.isDataDriven()) && hf.hasPaintOverride(this.layout, t);\n      }\n      static hasPaintOverride(t, e) {\n        const r = t.get(\"text-field\"),\n          n = uf.paint.properties[e];\n        let i = !1;\n        const s = t => {\n          for (const e of t) if (n.overrides && n.overrides.hasOverride(e)) return void (i = !0);\n        };\n        if (\"constant\" === r.value.kind && r.value.value instanceof De) s(r.value.value.sections);else if (\"source\" === r.value.kind) {\n          const t = e => {\n              i || (e instanceof je && Re(e.value) === me ? s(e.value.sections) : e instanceof Ze ? s(e.sections) : e.eachChild(t));\n            },\n            e = r.value;\n          e._styleExpression && t(e._styleExpression.expression);\n        }\n        return i;\n      }\n      getProgramConfiguration(t) {\n        return new Xa(this, t);\n      }\n    }\n    var pf = {\n        paint: new Ps({\n          \"background-color\": new Bs(te.paint_background[\"background-color\"]),\n          \"background-pattern\": new Bs(te.paint_background[\"background-pattern\"]),\n          \"background-opacity\": new Bs(te.paint_background[\"background-opacity\"])\n        })\n      },\n      df = {\n        paint: new Ps({\n          \"raster-opacity\": new Bs(te.paint_raster[\"raster-opacity\"]),\n          \"raster-hue-rotate\": new Bs(te.paint_raster[\"raster-hue-rotate\"]),\n          \"raster-brightness-min\": new Bs(te.paint_raster[\"raster-brightness-min\"]),\n          \"raster-brightness-max\": new Bs(te.paint_raster[\"raster-brightness-max\"]),\n          \"raster-saturation\": new Bs(te.paint_raster[\"raster-saturation\"]),\n          \"raster-contrast\": new Bs(te.paint_raster[\"raster-contrast\"]),\n          \"raster-resampling\": new Bs(te.paint_raster[\"raster-resampling\"]),\n          \"raster-fade-duration\": new Bs(te.paint_raster[\"raster-fade-duration\"])\n        })\n      };\n    class ff extends ro {\n      constructor(t) {\n        super(t, {}), this.implementation = t;\n      }\n      is3D() {\n        return \"3d\" === this.implementation.renderingMode;\n      }\n      hasOffscreenPass() {\n        return void 0 !== this.implementation.prerender;\n      }\n      isLayerDraped() {\n        return void 0 !== this.implementation.renderToTile;\n      }\n      shouldRedrape() {\n        return !!this.implementation.shouldRerenderTiles && this.implementation.shouldRerenderTiles();\n      }\n      recalculate() {}\n      updateTransitions() {}\n      hasTransition() {\n        return !1;\n      }\n      serialize() {}\n      onAdd(t) {\n        this.implementation.onAdd && this.implementation.onAdd(t, t.painter.context.gl);\n      }\n      onRemove(t) {\n        this.implementation.onRemove && this.implementation.onRemove(t, t.painter.context.gl);\n      }\n    }\n    var yf = {\n      paint: new Ps({\n        \"sky-type\": new Bs(te.paint_sky[\"sky-type\"]),\n        \"sky-atmosphere-sun\": new Bs(te.paint_sky[\"sky-atmosphere-sun\"]),\n        \"sky-atmosphere-sun-intensity\": new Bs(te.paint_sky[\"sky-atmosphere-sun-intensity\"]),\n        \"sky-gradient-center\": new Bs(te.paint_sky[\"sky-gradient-center\"]),\n        \"sky-gradient-radius\": new Bs(te.paint_sky[\"sky-gradient-radius\"]),\n        \"sky-gradient\": new Cs(te.paint_sky[\"sky-gradient\"]),\n        \"sky-atmosphere-halo-color\": new Bs(te.paint_sky[\"sky-atmosphere-halo-color\"]),\n        \"sky-atmosphere-color\": new Bs(te.paint_sky[\"sky-atmosphere-color\"]),\n        \"sky-opacity\": new Bs(te.paint_sky[\"sky-opacity\"])\n      })\n    };\n    function mf(t, e, r) {\n      const n = [0, 0, 1],\n        i = Ko([]);\n      return Jo(i, i, r ? -w(t) + Math.PI : w(t)), Xo(i, i, -w(e)), Ro(n, n, i), Do(n, n);\n    }\n    const gf = {\n      circle: class extends ro {\n        constructor(t) {\n          super(t, Tu);\n        }\n        createBucket(t) {\n          return new cu(t);\n        }\n        queryRadius(t) {\n          const e = t;\n          return Au(\"circle-radius\", this, e) + Au(\"circle-stroke-width\", this, e) + Su(this.paint.get(\"circle-translate\"));\n        }\n        queryIntersectsFeature(t, e, r, n, i, s, a, o) {\n          const l = Iu(this.paint.get(\"circle-translate\"), this.paint.get(\"circle-translate-anchor\"), s.angle, t.pixelToTileUnitsFactor),\n            u = this.paint.get(\"circle-radius\").evaluate(e, r) + this.paint.get(\"circle-stroke-width\").evaluate(e, r);\n          return zu(t, n, s, a, o, \"map\" === this.paint.get(\"circle-pitch-alignment\"), \"map\" === this.paint.get(\"circle-pitch-scale\"), l, u);\n        }\n        getProgramIds() {\n          return [\"circle\"];\n        }\n        getProgramConfiguration(t) {\n          return new Xa(this, t);\n        }\n      },\n      heatmap: class extends ro {\n        createBucket(t) {\n          return new Du(t);\n        }\n        constructor(t) {\n          super(t, $u), this._updateColorRamp();\n        }\n        _handleSpecialPaintPropertyUpdate(t) {\n          \"heatmap-color\" === t && this._updateColorRamp();\n        }\n        _updateColorRamp() {\n          this.colorRamp = ju({\n            expression: this._transitionablePaint._values[\"heatmap-color\"].value.expression,\n            evaluationKey: \"heatmapDensity\",\n            image: this.colorRamp\n          }), this.colorRampTexture = null;\n        }\n        resize() {\n          this.heatmapFbo && (this.heatmapFbo.destroy(), this.heatmapFbo = null);\n        }\n        queryRadius(t) {\n          return Au(\"heatmap-radius\", this, t);\n        }\n        queryIntersectsFeature(t, e, r, n, i, s, a, o) {\n          const l = this.paint.get(\"heatmap-radius\").evaluate(e, r);\n          return zu(t, n, s, a, o, !0, !0, new x(0, 0), l);\n        }\n        hasOffscreenPass() {\n          return 0 !== this.paint.get(\"heatmap-opacity\") && \"none\" !== this.visibility;\n        }\n        getProgramIds() {\n          return [\"heatmap\", \"heatmapTexture\"];\n        }\n        getProgramConfiguration(t) {\n          return new Xa(this, t);\n        }\n      },\n      hillshade: class extends ro {\n        constructor(t) {\n          super(t, Ou);\n        }\n        hasOffscreenPass() {\n          return 0 !== this.paint.get(\"hillshade-exaggeration\") && \"none\" !== this.visibility;\n        }\n        getProgramIds() {\n          return [\"hillshade\", \"hillshadePrepare\"];\n        }\n      },\n      fill: class extends ro {\n        constructor(t) {\n          super(t, zc);\n        }\n        getProgramIds() {\n          const t = this.paint.get(\"fill-pattern\"),\n            e = t && t.constantOr(1),\n            r = [e ? \"fillPattern\" : \"fill\"];\n          return this.paint.get(\"fill-antialias\") && r.push(e && !this.getPaintProperty(\"fill-outline-color\") ? \"fillOutlinePattern\" : \"fillOutline\"), r;\n        }\n        getProgramConfiguration(t) {\n          return new Xa(this, t);\n        }\n        recalculate(t, e) {\n          super.recalculate(t, e);\n          const r = this.paint._values[\"fill-outline-color\"];\n          \"constant\" === r.value.kind && void 0 === r.value.value && (this.paint._values[\"fill-outline-color\"] = this.paint._values[\"fill-color\"]);\n        }\n        createBucket(t) {\n          return new Mc(t);\n        }\n        queryRadius() {\n          return Su(this.paint.get(\"fill-translate\"));\n        }\n        queryIntersectsFeature(t, e, r, n, i, s) {\n          return !t.queryGeometry.isAboveHorizon && du(ku(t.tilespaceGeometry, this.paint.get(\"fill-translate\"), this.paint.get(\"fill-translate-anchor\"), s.angle, t.pixelToTileUnitsFactor), n);\n        }\n        isTileClipped() {\n          return !0;\n        }\n      },\n      \"fill-extrusion\": class extends ro {\n        constructor(t) {\n          super(t, ch);\n        }\n        createBucket(t) {\n          return new th(t);\n        }\n        queryRadius() {\n          return Su(this.paint.get(\"fill-extrusion-translate\"));\n        }\n        is3D() {\n          return !0;\n        }\n        getProgramIds() {\n          return [this.paint.get(\"fill-extrusion-pattern\").constantOr(1) ? \"fillExtrusionPattern\" : \"fillExtrusion\"];\n        }\n        getProgramConfiguration(t) {\n          return new Xa(this, t);\n        }\n        queryIntersectsFeature(t, e, r, n, i, s, a, o, l) {\n          const u = Iu(this.paint.get(\"fill-extrusion-translate\"), this.paint.get(\"fill-extrusion-translate-anchor\"), s.angle, t.pixelToTileUnitsFactor),\n            c = this.paint.get(\"fill-extrusion-height\").evaluate(e, r),\n            h = this.paint.get(\"fill-extrusion-base\").evaluate(e, r),\n            p = [0, 0],\n            d = o && s.elevation,\n            f = s.elevation ? s.elevation.exaggeration() : 1,\n            y = t.tile.getBucket(this);\n          if (d && y instanceof th) {\n            const t = y.centroidVertexArray,\n              e = l + 1;\n            e < t.length && (p[0] = t.geta_centroid_pos0(e), p[1] = t.geta_centroid_pos1(e));\n          }\n          if (0 === p[0] && 1 === p[1]) return !1;\n          \"globe\" === s.projection.name && (n = lh([n], [new x(0, 0), new x(ao, ao)], t.tileID.canonical).map(t => t.polygon).flat());\n          const m = d ? o : null,\n            [g, v] = function (t, e, r, n, i, s, a, o, l, u, c) {\n              return \"globe\" === t.projection.name ? function (t, e, r, n, i, s, a, o, l, u, c) {\n                const h = [],\n                  p = [],\n                  d = t.projection.upVectorScale(c, t.center.lat, t.worldSize).metersToTile,\n                  f = [0, 0, 0, 1],\n                  y = [0, 0, 0, 1],\n                  m = (t, e, r, n) => {\n                    t[0] = e, t[1] = r, t[2] = n, t[3] = 1;\n                  },\n                  g = oh();\n                r > 0 && (r += g), n += g;\n                for (const g of e) {\n                  const e = [],\n                    x = [];\n                  for (const h of g) {\n                    const p = h.x + i.x,\n                      g = h.y + i.y,\n                      v = t.projection.projectTilePoint(p, g, c),\n                      b = t.projection.upVector(c, h.x, h.y);\n                    let w = r,\n                      _ = n;\n                    if (a) {\n                      const t = vh(p, g, r, n, a, o, l, u);\n                      w += t.base, _ += t.top;\n                    }\n                    0 !== r ? m(f, v.x + b[0] * d * w, v.y + b[1] * d * w, v.z + b[2] * d * w) : m(f, v.x, v.y, v.z), m(y, v.x + b[0] * d * _, v.y + b[1] * d * _, v.z + b[2] * d * _), Fo(f, f, s), Fo(y, y, s), e.push(new mh(f[0], f[1], f[2])), x.push(new mh(y[0], y[1], y[2]));\n                  }\n                  h.push(e), p.push(x);\n                }\n                return [h, p];\n              }(t, e, r, n, i, s, a, o, l, u, c) : a ? function (t, e, r, n, i, s, a, o, l) {\n                const u = [],\n                  c = [],\n                  h = [0, 0, 0, 1];\n                for (const p of t) {\n                  const t = [],\n                    d = [];\n                  for (const u of p) {\n                    const c = u.x + n.x,\n                      p = u.y + n.y,\n                      f = vh(c, p, e, r, s, a, o, l);\n                    h[0] = c, h[1] = p, h[2] = f.base, h[3] = 1, Go(h, h, i), h[3] = Math.max(h[3], 1e-5);\n                    const y = new mh(h[0] / h[3], h[1] / h[3], h[2] / h[3]);\n                    h[0] = c, h[1] = p, h[2] = f.top, h[3] = 1, Go(h, h, i), h[3] = Math.max(h[3], 1e-5);\n                    const m = new mh(h[0] / h[3], h[1] / h[3], h[2] / h[3]);\n                    t.push(y), d.push(m);\n                  }\n                  u.push(t), c.push(d);\n                }\n                return [u, c];\n              }(e, r, n, i, s, a, o, l, u) : function (t, e, r, n, i) {\n                const s = [],\n                  a = [],\n                  o = i[8] * e,\n                  l = i[9] * e,\n                  u = i[10] * e,\n                  c = i[11] * e,\n                  h = i[8] * r,\n                  p = i[9] * r,\n                  d = i[10] * r,\n                  f = i[11] * r;\n                for (const e of t) {\n                  const t = [],\n                    r = [];\n                  for (const s of e) {\n                    const e = s.x + n.x,\n                      a = s.y + n.y,\n                      y = i[0] * e + i[4] * a + i[12],\n                      m = i[1] * e + i[5] * a + i[13],\n                      g = i[2] * e + i[6] * a + i[14],\n                      x = i[3] * e + i[7] * a + i[15],\n                      v = y + o,\n                      b = m + l,\n                      w = g + u,\n                      _ = Math.max(x + c, 1e-5),\n                      A = y + h,\n                      S = m + p,\n                      k = g + d,\n                      I = Math.max(x + f, 1e-5);\n                    t.push(new mh(v / _, b / _, w / _)), r.push(new mh(A / I, S / I, k / I));\n                  }\n                  s.push(t), a.push(r);\n                }\n                return [s, a];\n              }(e, r, n, i, s);\n            }(s, n, h, c, u, a, m, p, f, s.center.lat, t.tileID.canonical),\n            b = t.queryGeometry;\n          return function (t, e, r) {\n            let n = 1 / 0;\n            du(r, e) && (n = xh(r, e[0]));\n            for (let i = 0; i < e.length; i++) {\n              const s = e[i],\n                a = t[i];\n              for (let t = 0; t < s.length - 1; t++) {\n                const e = s[t],\n                  i = [e, s[t + 1], a[t + 1], a[t], e];\n                hu(r, i) && (n = Math.min(n, xh(r, i)));\n              }\n            }\n            return n !== 1 / 0 && n;\n          }(g, v, b.isPointQuery() ? b.screenBounds : b.screenGeometry);\n        }\n      },\n      line: class extends ro {\n        constructor(t) {\n          super(t, Th), this.gradientVersion = 0;\n        }\n        _handleSpecialPaintPropertyUpdate(t) {\n          if (\"line-gradient\" === t) {\n            const t = this._transitionablePaint._values[\"line-gradient\"].value.expression;\n            this.stepInterpolant = t._styleExpression && t._styleExpression.expression instanceof Br, this.gradientVersion = (this.gradientVersion + 1) % Number.MAX_SAFE_INTEGER;\n          }\n        }\n        gradientExpression() {\n          return this._transitionablePaint._values[\"line-gradient\"].value.expression;\n        }\n        widthExpression() {\n          return this._transitionablePaint._values[\"line-width\"].value.expression;\n        }\n        recalculate(t, e) {\n          super.recalculate(t, e), this.paint._values[\"line-floorwidth\"] = zh.possiblyEvaluate(this._transitioningPaint._values[\"line-width\"].value, t);\n        }\n        createBucket(t) {\n          return new Ih(t);\n        }\n        getProgramIds() {\n          return [this.paint.get(\"line-pattern\").constantOr(1) ? \"linePattern\" : \"line\"];\n        }\n        getProgramConfiguration(t) {\n          return new Xa(this, t);\n        }\n        queryRadius(t) {\n          const e = t,\n            r = Bh(Au(\"line-width\", this, e), Au(\"line-gap-width\", this, e)),\n            n = Au(\"line-offset\", this, e);\n          return r / 2 + Math.abs(n) + Su(this.paint.get(\"line-translate\"));\n        }\n        queryIntersectsFeature(t, e, r, n, i, s) {\n          if (t.queryGeometry.isAboveHorizon) return !1;\n          const a = ku(t.tilespaceGeometry, this.paint.get(\"line-translate\"), this.paint.get(\"line-translate-anchor\"), s.angle, t.pixelToTileUnitsFactor),\n            o = t.pixelToTileUnitsFactor / 2 * Bh(this.paint.get(\"line-width\").evaluate(e, r), this.paint.get(\"line-gap-width\").evaluate(e, r)),\n            l = this.paint.get(\"line-offset\").evaluate(e, r);\n          return l && (n = function (t, e) {\n            const r = [],\n              n = new x(0, 0);\n            for (let i = 0; i < t.length; i++) {\n              const s = t[i],\n                a = [];\n              for (let t = 0; t < s.length; t++) {\n                const r = s[t],\n                  i = s[t + 1],\n                  o = 0 === t ? n : r.sub(s[t - 1])._unit()._perp(),\n                  l = t === s.length - 1 ? n : i.sub(r)._unit()._perp(),\n                  u = o._add(l)._unit();\n                u._mult(1 / (u.x * l.x + u.y * l.y)), a.push(u._mult(e)._add(r));\n              }\n              r.push(a);\n            }\n            return r;\n          }(n, l * t.pixelToTileUnitsFactor)), function (t, e, r) {\n            for (let n = 0; n < e.length; n++) {\n              const i = e[n];\n              if (t.length >= 3) for (let e = 0; e < i.length; e++) if (bu(t, i[e])) return !0;\n              if (fu(t, i, r)) return !0;\n            }\n            return !1;\n          }(a, n, o);\n        }\n        isTileClipped() {\n          return !0;\n        }\n      },\n      symbol: hf,\n      background: class extends ro {\n        constructor(t) {\n          super(t, pf);\n        }\n        getProgramIds() {\n          return [this.paint.get(\"background-pattern\") ? \"backgroundPattern\" : \"background\"];\n        }\n      },\n      raster: class extends ro {\n        constructor(t) {\n          super(t, df);\n        }\n        getProgramIds() {\n          return [\"raster\"];\n        }\n      },\n      sky: class extends ro {\n        constructor(t) {\n          super(t, yf), this._updateColorRamp();\n        }\n        _handleSpecialPaintPropertyUpdate(t) {\n          \"sky-gradient\" === t ? this._updateColorRamp() : \"sky-atmosphere-sun\" !== t && \"sky-atmosphere-halo-color\" !== t && \"sky-atmosphere-color\" !== t && \"sky-atmosphere-sun-intensity\" !== t || (this._skyboxInvalidated = !0);\n        }\n        _updateColorRamp() {\n          this.colorRamp = ju({\n            expression: this._transitionablePaint._values[\"sky-gradient\"].value.expression,\n            evaluationKey: \"skyRadialProgress\"\n          }), this.colorRampTexture && (this.colorRampTexture.destroy(), this.colorRampTexture = null);\n        }\n        needsSkyboxCapture(t) {\n          if (this._skyboxInvalidated || !this.skyboxTexture || !this.skyboxGeometry) return !0;\n          if (!this.paint.get(\"sky-atmosphere-sun\")) {\n            const e = t.style.light.properties.get(\"position\");\n            return this._lightPosition.azimuthal !== e.azimuthal || this._lightPosition.polar !== e.polar;\n          }\n          return !1;\n        }\n        getCenter(t, e) {\n          if (\"atmosphere\" === this.paint.get(\"sky-type\")) {\n            const r = this.paint.get(\"sky-atmosphere-sun\"),\n              n = !r,\n              i = t.style.light,\n              s = i.properties.get(\"position\");\n            return n && \"viewport\" === i.properties.get(\"anchor\") && N(\"The sun direction is attached to a light with viewport anchor, lighting may behave unexpectedly.\"), n ? mf(s.azimuthal, 90 - s.polar, e) : mf(r[0], 90 - r[1], e);\n          }\n          const r = this.paint.get(\"sky-gradient-center\");\n          return mf(r[0], 90 - r[1], e);\n        }\n        is3D() {\n          return !1;\n        }\n        isSky() {\n          return !0;\n        }\n        markSkyboxValid(t) {\n          this._skyboxInvalidated = !1, this._lightPosition = t.style.light.properties.get(\"position\");\n        }\n        hasOffscreenPass() {\n          return !0;\n        }\n        getProgramIds() {\n          const t = this.paint.get(\"sky-type\");\n          return \"atmosphere\" === t ? [\"skyboxCapture\", \"skybox\"] : \"gradient\" === t ? [\"skyboxGradient\"] : null;\n        }\n      }\n    };\n    class xf {\n      constructor(t, e, r, n) {\n        this.context = t, this.format = r, this.texture = t.gl.createTexture(), this.update(e, n);\n      }\n      update(t, r, n) {\n        const {\n            width: i,\n            height: s\n          } = t,\n          {\n            context: a\n          } = this,\n          {\n            gl: o\n          } = a,\n          {\n            HTMLImageElement: l,\n            HTMLCanvasElement: u,\n            HTMLVideoElement: c,\n            ImageData: h,\n            ImageBitmap: p\n          } = e;\n        if (o.bindTexture(o.TEXTURE_2D, this.texture), a.pixelStoreUnpackFlipY.set(!1), a.pixelStoreUnpack.set(1), a.pixelStoreUnpackPremultiplyAlpha.set(this.format === o.RGBA && (!r || !1 !== r.premultiply)), n || this.size && this.size[0] === i && this.size[1] === s) {\n          const {\n            x: e,\n            y: r\n          } = n || {\n            x: 0,\n            y: 0\n          };\n          t instanceof l || t instanceof u || t instanceof c || t instanceof h || p && t instanceof p ? o.texSubImage2D(o.TEXTURE_2D, 0, e, r, o.RGBA, o.UNSIGNED_BYTE, t) : o.texSubImage2D(o.TEXTURE_2D, 0, e, r, i, s, o.RGBA, o.UNSIGNED_BYTE, t.data);\n        } else this.size = [i, s], t instanceof l || t instanceof u || t instanceof c || t instanceof h || p && t instanceof p ? o.texImage2D(o.TEXTURE_2D, 0, this.format, this.format, o.UNSIGNED_BYTE, t) : o.texImage2D(o.TEXTURE_2D, 0, this.format, i, s, 0, this.format, o.UNSIGNED_BYTE, t.data);\n        this.useMipmap = Boolean(r && r.useMipmap && this.isSizePowerOfTwo()), this.useMipmap && o.generateMipmap(o.TEXTURE_2D);\n      }\n      bind(t, e) {\n        const {\n            context: r\n          } = this,\n          {\n            gl: n\n          } = r;\n        n.bindTexture(n.TEXTURE_2D, this.texture), t !== this.filter && (n.texParameteri(n.TEXTURE_2D, n.TEXTURE_MAG_FILTER, t), n.texParameteri(n.TEXTURE_2D, n.TEXTURE_MIN_FILTER, this.useMipmap ? t === n.NEAREST ? n.NEAREST_MIPMAP_NEAREST : n.LINEAR_MIPMAP_NEAREST : t), this.filter = t), e !== this.wrap && (n.texParameteri(n.TEXTURE_2D, n.TEXTURE_WRAP_S, e), n.texParameteri(n.TEXTURE_2D, n.TEXTURE_WRAP_T, e), this.wrap = e);\n      }\n      isSizePowerOfTwo() {\n        return this.size[0] === this.size[1] && Math.log(this.size[0]) / Math.LN2 % 1 == 0;\n      }\n      destroy() {\n        const {\n          gl: t\n        } = this.context;\n        t.deleteTexture(this.texture), this.texture = null;\n      }\n    }\n    class vf {\n      constructor(t) {\n        this._callback = t, this._triggered = !1, \"undefined\" != typeof MessageChannel && (this._channel = new MessageChannel(), this._channel.port2.onmessage = () => {\n          this._triggered = !1, this._callback();\n        });\n      }\n      trigger() {\n        this._triggered || (this._triggered = !0, this._channel ? this._channel.port1.postMessage(!0) : setTimeout(() => {\n          this._triggered = !1, this._callback();\n        }, 0));\n      }\n      remove() {\n        this._channel = void 0, this._callback = () => {};\n      }\n    }\n    class bf {\n      constructor() {\n        this.tasks = {}, this.taskQueue = [], R([\"process\"], this), this.invoker = new vf(this.process), this.nextId = 0;\n      }\n      add(t, e) {\n        const r = this.nextId++,\n          n = function ({\n            type: t,\n            isSymbolTile: e,\n            zoom: r\n          }) {\n            return r = r || 0, \"message\" === t ? 0 : \"maybePrepare\" !== t || e ? \"parseTile\" !== t || e ? \"parseTile\" === t && e ? 300 - r : \"maybePrepare\" === t && e ? 400 - r : 500 : 200 - r : 100 - r;\n          }(e);\n        if (0 === n) {\n          K();\n          try {\n            t();\n          } finally {}\n          return {\n            cancel: () => {}\n          };\n        }\n        return this.tasks[r] = {\n          fn: t,\n          metadata: e,\n          priority: n,\n          id: r\n        }, this.taskQueue.push(r), this.invoker.trigger(), {\n          cancel: () => {\n            delete this.tasks[r];\n          }\n        };\n      }\n      process() {\n        K();\n        try {\n          if (this.taskQueue = this.taskQueue.filter(t => !!this.tasks[t]), !this.taskQueue.length) return;\n          const t = this.pick();\n          if (null === t) return;\n          const e = this.tasks[t];\n          if (delete this.tasks[t], this.taskQueue.length && this.invoker.trigger(), !e) return;\n          e.fn();\n        } finally {}\n      }\n      pick() {\n        let t = null,\n          e = 1 / 0;\n        for (let r = 0; r < this.taskQueue.length; r++) {\n          const n = this.tasks[this.taskQueue[r]];\n          n.priority < e && (e = n.priority, t = r);\n        }\n        if (null === t) return null;\n        const r = this.taskQueue[t];\n        return this.taskQueue.splice(t, 1), r;\n      }\n      remove() {\n        this.invoker.remove();\n      }\n    }\n    class wf {\n      constructor(t) {\n        this._stringToNumber = {}, this._numberToString = [];\n        for (let e = 0; e < t.length; e++) {\n          const r = t[e];\n          this._stringToNumber[r] = e, this._numberToString[e] = r;\n        }\n      }\n      encode(t) {\n        return this._stringToNumber[t];\n      }\n      decode(t) {\n        return this._numberToString[t];\n      }\n    }\n    const _f = [\"tile\", \"layer\", \"source\", \"sourceLayer\", \"state\"];\n    class Af {\n      constructor(t, e, r, n, i) {\n        this.type = \"Feature\", this._vectorTileFeature = t, this._z = e, this._x = r, this._y = n, this.properties = t.properties, this.id = i;\n      }\n      get geometry() {\n        return void 0 === this._geometry && (this._geometry = this._vectorTileFeature.toGeoJSON(this._x, this._y, this._z).geometry), this._geometry;\n      }\n      set geometry(t) {\n        this._geometry = t;\n      }\n      toJSON() {\n        const t = {\n          type: \"Feature\",\n          state: void 0,\n          geometry: this.geometry,\n          properties: this.properties\n        };\n        void 0 !== this.id && (t.id = this.id);\n        for (const e of _f) void 0 !== this[e] && (t[e] = this[e]);\n        return t;\n      }\n    }\n    const Sf = 32,\n      kf = 33,\n      If = new Uint16Array(8184);\n    for (let t = 0; t < 2046; t++) {\n      let e = t + 2,\n        r = 0,\n        n = 0,\n        i = 0,\n        s = 0,\n        a = 0,\n        o = 0;\n      for (1 & e ? i = s = a = Sf : r = n = o = Sf; (e >>= 1) > 1;) {\n        const t = r + i >> 1,\n          l = n + s >> 1;\n        1 & e ? (i = r, s = n, r = a, n = o) : (r = i, n = s, i = a, s = o), a = t, o = l;\n      }\n      const l = 4 * t;\n      If[l + 0] = r, If[l + 1] = n, If[l + 2] = i, If[l + 3] = s;\n    }\n    const Mf = new Uint16Array(2178),\n      Tf = new Uint8Array(1089),\n      zf = new Uint16Array(1089);\n    function Bf(t) {\n      return 0 === t ? -.03125 : 32 === t ? .03125 : 0;\n    }\n    var Ef = Rs([{\n      name: \"a_pos\",\n      type: \"Int16\",\n      components: 2\n    }, {\n      name: \"a_texture_pos\",\n      type: \"Int16\",\n      components: 2\n    }]);\n    const Cf = {\n      type: 2,\n      extent: ao,\n      loadGeometry: () => [[new x(0, 0), new x(ao + 1, 0), new x(ao + 1, ao + 1), new x(0, ao + 1), new x(0, 0)]]\n    };\n    class Pf {\n      constructor(t, e, r, n, i) {\n        this.tileID = t, this.uid = D(), this.uses = 0, this.tileSize = e, this.tileZoom = r, this.buckets = {}, this.expirationTime = null, this.queryPadding = 0, this.hasSymbolBuckets = !1, this.hasRTLText = !1, this.dependencies = {}, this.isRaster = i, this.expiredRequestCount = 0, this.state = \"loading\", n && n.transform && (this.projection = n.transform.projection);\n      }\n      registerFadeDuration(t) {\n        const e = t + this.timeAdded;\n        e < Xt.now() || this.fadeEndTime && e < this.fadeEndTime || (this.fadeEndTime = e);\n      }\n      wasRequested() {\n        return \"errored\" === this.state || \"loaded\" === this.state || \"reloading\" === this.state;\n      }\n      get tileTransform() {\n        return this._tileTransform || (this._tileTransform = Bd(this.tileID.canonical, this.projection)), this._tileTransform;\n      }\n      loadVectorData(t, e, r) {\n        if (this.unloadVectorData(), this.state = \"loaded\", t) {\n          t.featureIndex && (this.latestFeatureIndex = t.featureIndex, t.rawTileData ? (this.latestRawTileData = t.rawTileData, this.latestFeatureIndex.rawTileData = t.rawTileData) : this.latestRawTileData && (this.latestFeatureIndex.rawTileData = this.latestRawTileData)), this.collisionBoxArray = t.collisionBoxArray, this.buckets = function (t, e) {\n            const r = {};\n            if (!e) return r;\n            for (const n of t) {\n              const t = n.layerIds.map(t => e.getLayer(t)).filter(Boolean);\n              if (0 !== t.length) {\n                n.layers = t, n.stateDependentLayerIds && (n.stateDependentLayers = n.stateDependentLayerIds.map(e => t.filter(t => t.id === e)[0]));\n                for (const e of t) r[e.id] = n;\n              }\n            }\n            return r;\n          }(t.buckets, e.style), this.hasSymbolBuckets = !1;\n          for (const t in this.buckets) {\n            const e = this.buckets[t];\n            if (e instanceof of) {\n              if (this.hasSymbolBuckets = !0, !r) break;\n              e.justReloaded = !0;\n            }\n          }\n          if (this.hasRTLText = !1, this.hasSymbolBuckets) for (const t in this.buckets) {\n            const e = this.buckets[t];\n            if (e instanceof of && e.hasRTLText) {\n              this.hasRTLText = !0, bs.isLoading() || bs.isLoaded() || \"deferred\" !== xs() || vs();\n              break;\n            }\n          }\n          this.queryPadding = 0;\n          for (const t in this.buckets) {\n            const r = this.buckets[t];\n            this.queryPadding = Math.max(this.queryPadding, e.style.getLayer(t).queryRadius(r));\n          }\n          t.imageAtlas && (this.imageAtlas = t.imageAtlas), t.glyphAtlasImage && (this.glyphAtlasImage = t.glyphAtlasImage), t.lineAtlas && (this.lineAtlas = t.lineAtlas);\n        } else this.collisionBoxArray = new pa();\n      }\n      unloadVectorData() {\n        if (this.hasData()) {\n          for (const t in this.buckets) this.buckets[t].destroy();\n          this.buckets = {}, this.imageAtlas && (this.imageAtlas = null), this.lineAtlas && (this.lineAtlas = null), this.imageAtlasTexture && this.imageAtlasTexture.destroy(), this.glyphAtlasTexture && this.glyphAtlasTexture.destroy(), this.lineAtlasTexture && this.lineAtlasTexture.destroy(), this._tileBoundsBuffer && (this._tileBoundsBuffer.destroy(), this._tileBoundsIndexBuffer.destroy(), this._tileBoundsSegments.destroy(), this._tileBoundsBuffer = null), this._tileDebugBuffer && (this._tileDebugBuffer.destroy(), this._tileDebugSegments.destroy(), this._tileDebugBuffer = null), this._tileDebugIndexBuffer && (this._tileDebugIndexBuffer.destroy(), this._tileDebugIndexBuffer = null), this._globeTileDebugBorderBuffer && (this._globeTileDebugBorderBuffer.destroy(), this._globeTileDebugBorderBuffer = null), this._tileDebugTextBuffer && (this._tileDebugTextBuffer.destroy(), this._tileDebugTextSegments.destroy(), this._tileDebugTextIndexBuffer.destroy(), this._tileDebugTextBuffer = null), this._globeTileDebugTextBuffer && (this._globeTileDebugTextBuffer.destroy(), this._globeTileDebugTextBuffer = null), this.latestFeatureIndex = null, this.state = \"unloaded\";\n        }\n      }\n      getBucket(t) {\n        return this.buckets[t.id];\n      }\n      upload(t) {\n        for (const e in this.buckets) {\n          const r = this.buckets[e];\n          r.uploadPending() && r.upload(t);\n        }\n        const e = t.gl;\n        this.imageAtlas && !this.imageAtlas.uploaded && (this.imageAtlasTexture = new xf(t, this.imageAtlas.image, e.RGBA), this.imageAtlas.uploaded = !0), this.glyphAtlasImage && (this.glyphAtlasTexture = new xf(t, this.glyphAtlasImage, e.ALPHA), this.glyphAtlasImage = null), this.lineAtlas && !this.lineAtlas.uploaded && (this.lineAtlasTexture = new xf(t, this.lineAtlas.image, e.ALPHA), this.lineAtlas.uploaded = !0);\n      }\n      prepare(t) {\n        this.imageAtlas && this.imageAtlas.patchUpdatedImages(t, this.imageAtlasTexture);\n      }\n      queryRenderedFeatures(t, e, r, n, i, s, a, o) {\n        return this.latestFeatureIndex && this.latestFeatureIndex.rawTileData ? this.latestFeatureIndex.query({\n          tileResult: n,\n          pixelPosMatrix: a,\n          transform: s,\n          params: i,\n          tileTransform: this.tileTransform\n        }, t, e, r) : {};\n      }\n      querySourceFeatures(t, e) {\n        const r = this.latestFeatureIndex;\n        if (!r || !r.rawTileData) return;\n        const n = r.loadVTLayers(),\n          i = e ? e.sourceLayer : \"\",\n          s = n._geojsonTileLayer || n[i];\n        if (!s) return;\n        const a = hi(e && e.filter),\n          {\n            z: o,\n            x: l,\n            y: u\n          } = this.tileID.canonical,\n          c = {\n            z: o,\n            x: l,\n            y: u\n          };\n        for (let e = 0; e < s.length; e++) {\n          const n = s.feature(e);\n          if (a.needGeometry) {\n            const t = ou(n, !0);\n            if (!a.filter(new ws(this.tileID.overscaledZ), t, this.tileID.canonical)) continue;\n          } else if (!a.filter(new ws(this.tileID.overscaledZ), n)) continue;\n          const h = r.getId(n, i),\n            p = new Af(n, o, l, u, h);\n          p.tile = c, t.push(p);\n        }\n      }\n      hasData() {\n        return \"loaded\" === this.state || \"reloading\" === this.state || \"expired\" === this.state;\n      }\n      patternsLoaded() {\n        return !!this.imageAtlas && !!Object.keys(this.imageAtlas.patternPositions).length;\n      }\n      setExpiryData(t) {\n        const e = this.expirationTime;\n        if (t.cacheControl) {\n          const e = X(t.cacheControl);\n          e[\"max-age\"] && (this.expirationTime = Date.now() + 1e3 * e[\"max-age\"]);\n        } else t.expires && (this.expirationTime = new Date(t.expires).getTime());\n        if (this.expirationTime) {\n          const t = Date.now();\n          let r = !1;\n          if (this.expirationTime > t) r = !1;else if (e) {\n            if (this.expirationTime < e) r = !0;else {\n              const n = this.expirationTime - e;\n              n ? this.expirationTime = t + Math.max(n, 3e4) : r = !0;\n            }\n          } else r = !0;\n          r ? (this.expiredRequestCount++, this.state = \"expired\") : this.expiredRequestCount = 0;\n        }\n      }\n      getExpiryTimeout() {\n        if (this.expirationTime) return this.expiredRequestCount ? 1e3 * (1 << Math.min(this.expiredRequestCount - 1, 31)) : Math.min(this.expirationTime - new Date().getTime(), Math.pow(2, 31) - 1);\n      }\n      setFeatureState(t, e) {\n        if (!this.latestFeatureIndex || !this.latestFeatureIndex.rawTileData || 0 === Object.keys(t).length || !e) return;\n        const r = this.latestFeatureIndex.loadVTLayers(),\n          n = e.style.listImages();\n        for (const i in this.buckets) {\n          if (!e.style.hasLayer(i)) continue;\n          const s = this.buckets[i],\n            a = s.layers[0].sourceLayer || \"_geojsonTileLayer\",\n            o = r[a],\n            l = t[a];\n          if (!o || !l || 0 === Object.keys(l).length) continue;\n          if (s.update(l, o, n, this.imageAtlas && this.imageAtlas.patternPositions || {}), s instanceof Ih || s instanceof Mc) {\n            const t = e.style._getSourceCache(s.layers[0].source);\n            e._terrain && e._terrain.enabled && t && s.programConfigurations.needsUpload && e._terrain._clearRenderCacheForTile(t.id, this.tileID);\n          }\n          const u = e && e.style && e.style.getLayer(i);\n          u && (this.queryPadding = Math.max(this.queryPadding, u.queryRadius(s)));\n        }\n      }\n      holdingForFade() {\n        return void 0 !== this.symbolFadeHoldUntil;\n      }\n      symbolFadeFinished() {\n        return !this.symbolFadeHoldUntil || this.symbolFadeHoldUntil < Xt.now();\n      }\n      clearFadeHold() {\n        this.symbolFadeHoldUntil = void 0;\n      }\n      setHoldDuration(t) {\n        this.symbolFadeHoldUntil = Xt.now() + t;\n      }\n      setTexture(t, e) {\n        const r = e.context,\n          n = r.gl;\n        this.texture = this.texture || e.getTileTexture(t.width), this.texture ? this.texture.update(t, {\n          useMipmap: !0\n        }) : (this.texture = new xf(r, t, n.RGBA, {\n          useMipmap: !0\n        }), this.texture.bind(n.LINEAR, n.CLAMP_TO_EDGE));\n      }\n      setDependencies(t, e) {\n        const r = {};\n        for (const t of e) r[t] = !0;\n        this.dependencies[t] = r;\n      }\n      hasDependency(t, e) {\n        for (const r of t) {\n          const t = this.dependencies[r];\n          if (t) for (const r of e) if (t[r]) return !0;\n        }\n        return !1;\n      }\n      clearQueryDebugViz() {}\n      _makeDebugTileBoundsBuffers(t, e) {\n        if (!e || \"mercator\" === e.name || this._tileDebugBuffer) return;\n        const r = au(Cf, this.tileID.canonical, this.tileTransform)[0],\n          n = new $s(),\n          i = new ua();\n        for (let t = 0; t < r.length; t++) {\n          const {\n            x: e,\n            y: s\n          } = r[t];\n          n.emplaceBack(e, s), i.emplaceBack(t);\n        }\n        i.emplaceBack(0), this._tileDebugIndexBuffer = t.createIndexBuffer(i), this._tileDebugBuffer = t.createVertexBuffer(n, tl.members), this._tileDebugSegments = so.simpleSegment(0, 0, n.length, i.length);\n      }\n      _makeTileBoundsBuffers(t, e) {\n        if (this._tileBoundsBuffer || !e || \"mercator\" === e.name) return;\n        const r = au(Cf, this.tileID.canonical, this.tileTransform)[0];\n        let n, i;\n        if (this.isRaster) {\n          const t = function (t, e) {\n            const r = Bd(t, e),\n              n = Math.pow(2, t.z);\n            for (let i = 0; i < kf; i++) for (let s = 0; s < kf; s++) {\n              const a = Kl((t.x + (s + Bf(s)) / Sf) / n),\n                o = Xl((t.y + (i + Bf(i)) / Sf) / n),\n                l = e.project(a, o),\n                u = i * kf + s;\n              Mf[2 * u + 0] = Math.round((l.x * r.scale - r.x) * ao), Mf[2 * u + 1] = Math.round((l.y * r.scale - r.y) * ao);\n            }\n            Tf.fill(0), zf.fill(0);\n            for (let t = 2045; t >= 0; t--) {\n              const e = 4 * t,\n                r = If[e + 0],\n                n = If[e + 1],\n                i = If[e + 2],\n                s = If[e + 3],\n                a = r + i >> 1,\n                o = n + s >> 1,\n                l = a + o - n,\n                u = o + r - a,\n                c = n * kf + r,\n                h = s * kf + i,\n                p = o * kf + a,\n                d = Math.hypot((Mf[2 * c + 0] + Mf[2 * h + 0]) / 2 - Mf[2 * p + 0], (Mf[2 * c + 1] + Mf[2 * h + 1]) / 2 - Mf[2 * p + 1]) >= 16;\n              Tf[p] = Tf[p] || (d ? 1 : 0), t < 1022 && (Tf[p] = Tf[p] || Tf[(n + u >> 1) * kf + (r + l >> 1)] || Tf[(s + u >> 1) * kf + (i + l >> 1)]);\n            }\n            const i = new Os(),\n              s = new ra();\n            let a = 0;\n            function o(t, e) {\n              const r = e * kf + t;\n              return 0 === zf[r] && (i.emplaceBack(Mf[2 * r + 0], Mf[2 * r + 1], t * ao / Sf, e * ao / Sf), zf[r] = ++a), zf[r] - 1;\n            }\n            function l(t, e, r, n, i, a) {\n              const u = t + r >> 1,\n                c = e + n >> 1;\n              if (Math.abs(t - i) + Math.abs(e - a) > 1 && Tf[c * kf + u]) l(i, a, t, e, u, c), l(r, n, i, a, u, c);else {\n                const l = o(t, e),\n                  u = o(r, n),\n                  c = o(i, a);\n                s.emplaceBack(l, u, c);\n              }\n            }\n            return l(0, 0, Sf, Sf, Sf, 0), l(Sf, Sf, 0, 0, 0, Sf), {\n              vertices: i,\n              indices: s\n            };\n          }(this.tileID.canonical, e);\n          n = t.vertices, i = t.indices;\n        } else {\n          n = new Os(), i = new ra();\n          for (const {\n            x: t,\n            y: e\n          } of r) n.emplaceBack(t, e, 0, 0);\n          const t = xc(n.int16, void 0, 4);\n          for (let e = 0; e < t.length; e += 3) i.emplaceBack(t[e], t[e + 1], t[e + 2]);\n        }\n        this._tileBoundsBuffer = t.createVertexBuffer(n, Ef.members), this._tileBoundsIndexBuffer = t.createIndexBuffer(i), this._tileBoundsSegments = so.simpleSegment(0, 0, n.length, i.length);\n      }\n      _makeGlobeTileDebugBuffers(t, e) {\n        const r = e.projection;\n        if (!r || \"globe\" !== r.name || e.freezeTileCoverage) return;\n        const n = this.tileID.canonical,\n          i = Bl(bl(n, e)),\n          s = Pl(e.zoom);\n        let a;\n        s > 0 && (a = fo(new Float64Array(16), e.globeMatrix)), this._makeGlobeTileDebugBorderBuffer(t, n, e, i, a, s), this._makeGlobeTileDebugTextBuffer(t, n, e, i, a, s);\n      }\n      _globePoint(t, e, r, n, i, s, a) {\n        let o = Ml(t, e, r);\n        if (s) {\n          const i = 1 << r.z,\n            l = Nl(n.center.lng),\n            u = Gl(n.center.lat),\n            c = (r.x + .5) / i - l;\n          let h = 0;\n          c > .5 ? h = -1 : c < -.5 && (h = 1);\n          let p = (t / ao + r.x) / i + h,\n            d = (e / ao + r.y) / i;\n          p = (p - l) * n._pixelsPerMercatorPixel + l, d = (d - u) * n._pixelsPerMercatorPixel + u;\n          const f = [p * n.worldSize, d * n.worldSize, 0];\n          Fo(f, f, s), o = vl(o, f, a);\n        }\n        return Fo(o, o, i);\n      }\n      _makeGlobeTileDebugBorderBuffer(t, e, r, n, i, s) {\n        const a = new $s(),\n          o = new ua(),\n          l = new js(),\n          u = (t, u, c, h, p) => {\n            const d = (c - t) / (p - 1),\n              f = (h - u) / (p - 1),\n              y = a.length;\n            for (let c = 0; c < p; c++) {\n              const h = t + c * d,\n                p = u + c * f;\n              a.emplaceBack(h, p);\n              const m = this._globePoint(h, p, e, r, n, i, s);\n              l.emplaceBack(m[0], m[1], m[2]), o.emplaceBack(y + c);\n            }\n          },\n          c = ao;\n        u(0, 0, c, 0, 16), u(c, 0, c, c, 16), u(c, c, 0, c, 16), u(0, c, 0, 0, 16), this._tileDebugIndexBuffer = t.createIndexBuffer(o), this._tileDebugBuffer = t.createVertexBuffer(a, tl.members), this._globeTileDebugBorderBuffer = t.createVertexBuffer(l, Qo.members), this._tileDebugSegments = so.simpleSegment(0, 0, a.length, o.length);\n      }\n      _makeGlobeTileDebugTextBuffer(t, e, r, n, i, s) {\n        const a = ao / 4,\n          o = new $s(),\n          l = new ra(),\n          u = new js(),\n          c = 25;\n        l.reserve(32), o.reserve(c), u.reserve(c);\n        const h = (t, e) => c * t + e;\n        for (let t = 0; t < c; t++) {\n          const l = t * a;\n          for (let t = 0; t < c; t++) {\n            const c = t * a;\n            o.emplaceBack(c, l);\n            const h = this._globePoint(c, l, e, r, n, i, s);\n            u.emplaceBack(h[0], h[1], h[2]);\n          }\n        }\n        for (let t = 0; t < 4; t++) for (let e = 0; e < 4; e++) {\n          const r = h(t, e),\n            n = h(t, e + 1),\n            i = h(t + 1, e),\n            s = h(t + 1, e + 1);\n          l.emplaceBack(r, n, i), l.emplaceBack(i, n, s);\n        }\n        this._tileDebugTextIndexBuffer = t.createIndexBuffer(l), this._tileDebugTextBuffer = t.createVertexBuffer(o, tl.members), this._globeTileDebugTextBuffer = t.createVertexBuffer(u, Qo.members), this._tileDebugTextSegments = so.simpleSegment(0, 0, c, 32);\n      }\n    }\n    class Df {\n      constructor() {\n        this.state = {}, this.stateChanges = {}, this.deletedStates = {};\n      }\n      updateState(t, e, r) {\n        const n = String(e);\n        if (this.stateChanges[t] = this.stateChanges[t] || {}, this.stateChanges[t][n] = this.stateChanges[t][n] || {}, C(this.stateChanges[t][n], r), null === this.deletedStates[t]) {\n          this.deletedStates[t] = {};\n          for (const e in this.state[t]) e !== n && (this.deletedStates[t][e] = null);\n        } else if (this.deletedStates[t] && null === this.deletedStates[t][n]) {\n          this.deletedStates[t][n] = {};\n          for (const e in this.state[t][n]) r[e] || (this.deletedStates[t][n][e] = null);\n        } else for (const e in r) this.deletedStates[t] && this.deletedStates[t][n] && null === this.deletedStates[t][n][e] && delete this.deletedStates[t][n][e];\n      }\n      removeFeatureState(t, e, r) {\n        if (null === this.deletedStates[t]) return;\n        const n = String(e);\n        if (this.deletedStates[t] = this.deletedStates[t] || {}, r && void 0 !== e) null !== this.deletedStates[t][n] && (this.deletedStates[t][n] = this.deletedStates[t][n] || {}, this.deletedStates[t][n][r] = null);else if (void 0 !== e) {\n          if (this.stateChanges[t] && this.stateChanges[t][n]) for (r in this.deletedStates[t][n] = {}, this.stateChanges[t][n]) this.deletedStates[t][n][r] = null;else this.deletedStates[t][n] = null;\n        } else this.deletedStates[t] = null;\n      }\n      getState(t, e) {\n        const r = String(e),\n          n = C({}, (this.state[t] || {})[r], (this.stateChanges[t] || {})[r]);\n        if (null === this.deletedStates[t]) return {};\n        if (this.deletedStates[t]) {\n          const r = this.deletedStates[t][e];\n          if (null === r) return {};\n          for (const t in r) delete n[t];\n        }\n        return n;\n      }\n      initializeTileState(t, e) {\n        t.setFeatureState(this.state, e);\n      }\n      coalesceChanges(t, e) {\n        const r = {};\n        for (const t in this.stateChanges) {\n          this.state[t] = this.state[t] || {};\n          const e = {};\n          for (const r in this.stateChanges[t]) this.state[t][r] || (this.state[t][r] = {}), C(this.state[t][r], this.stateChanges[t][r]), e[r] = this.state[t][r];\n          r[t] = e;\n        }\n        for (const t in this.deletedStates) {\n          this.state[t] = this.state[t] || {};\n          const e = {};\n          if (null === this.deletedStates[t]) for (const r in this.state[t]) e[r] = {}, this.state[t][r] = {};else for (const r in this.deletedStates[t]) {\n            if (null === this.deletedStates[t][r]) this.state[t][r] = {};else if (this.state[t][r]) for (const e of Object.keys(this.deletedStates[t][r])) delete this.state[t][r][e];\n            e[r] = this.state[t][r];\n          }\n          r[t] = r[t] || {}, C(r[t], e);\n        }\n        if (this.stateChanges = {}, this.deletedStates = {}, 0 !== Object.keys(r).length) for (const n in t) t[n].setFeatureState(r, e);\n      }\n    }\n    class Vf {\n      constructor(t) {\n        this.size = t, this.minimums = [], this.maximums = [], this.leaves = [];\n      }\n      getElevation(t, e) {\n        const r = this.toIdx(t, e);\n        return {\n          min: this.minimums[r],\n          max: this.maximums[r]\n        };\n      }\n      isLeaf(t, e) {\n        return this.leaves[this.toIdx(t, e)];\n      }\n      toIdx(t, e) {\n        return e * this.size + t;\n      }\n    }\n    function Lf(t, e, r, n) {\n      let i = 0,\n        s = Number.MAX_VALUE;\n      for (let a = 0; a < 3; a++) if (Math.abs(n[a]) < 1e-15) {\n        if (r[a] < t[a] || r[a] > e[a]) return null;\n      } else {\n        const o = 1 / n[a];\n        let l = (t[a] - r[a]) * o,\n          u = (e[a] - r[a]) * o;\n        if (l > u) {\n          const t = l;\n          l = u, u = t;\n        }\n        if (l > i && (i = l), u < s && (s = u), i > s) return null;\n      }\n      return i;\n    }\n    function Ff(t, e, r, n, i, s, a, o, l, u, c) {\n      const h = n - t,\n        p = i - e,\n        d = s - r,\n        f = a - t,\n        y = o - e,\n        m = l - r,\n        g = c[1] * m - c[2] * y,\n        x = c[2] * f - c[0] * m,\n        v = c[0] * y - c[1] * f,\n        b = h * g + p * x + d * v;\n      if (Math.abs(b) < 1e-15) return null;\n      const w = 1 / b,\n        _ = u[0] - t,\n        A = u[1] - e,\n        S = u[2] - r,\n        k = (_ * g + A * x + S * v) * w;\n      if (k < 0 || k > 1) return null;\n      const I = A * d - S * p,\n        M = S * h - _ * d,\n        T = _ * p - A * h,\n        z = (c[0] * I + c[1] * M + c[2] * T) * w;\n      return z < 0 || k + z > 1 ? null : (f * I + y * M + m * T) * w;\n    }\n    function Rf(t, e, r) {\n      return (t - e) / (r - e);\n    }\n    function Uf(t, e, r, n, i, s, a, o, l) {\n      const u = 1 << r,\n        c = s - n,\n        h = a - i,\n        p = (t + 1) / u * c + n,\n        d = (e + 0) / u * h + i,\n        f = (e + 1) / u * h + i;\n      o[0] = (t + 0) / u * c + n, o[1] = d, l[0] = p, l[1] = f;\n    }\n    class $f {\n      constructor(t) {\n        if (this.maximums = [], this.minimums = [], this.leaves = [], this.childOffsets = [], this.nodeCount = 0, this.dem = t, this._siblingOffset = [[0, 0], [1, 0], [0, 1], [1, 1]], !this.dem) return;\n        const e = function (t) {\n            const e = Math.ceil(Math.log2(t.dim / 8)),\n              r = [];\n            let n = Math.ceil(Math.pow(2, e));\n            const i = 1 / n,\n              s = (t, e, r, n, i) => {\n                const s = n ? 1 : 0,\n                  a = (t + 1) * r - s,\n                  o = e * r,\n                  l = (e + 1) * r - s;\n                i[0] = t * r, i[1] = o, i[2] = a, i[3] = l;\n              };\n            let a = new Vf(n);\n            const o = [];\n            for (let e = 0; e < n * n; e++) {\n              s(e % n, Math.floor(e / n), i, !1, o);\n              const r = Of(o[0], o[1], t),\n                l = Of(o[2], o[1], t),\n                u = Of(o[2], o[3], t),\n                c = Of(o[0], o[3], t);\n              a.minimums.push(Math.min(r, l, u, c)), a.maximums.push(Math.max(r, l, u, c)), a.leaves.push(1);\n            }\n            for (r.push(a), n /= 2; n >= 1; n /= 2) {\n              const t = r[r.length - 1];\n              a = new Vf(n);\n              for (let e = 0; e < n * n; e++) {\n                s(e % n, Math.floor(e / n), 2, !0, o);\n                const r = t.getElevation(o[0], o[1]),\n                  i = t.getElevation(o[2], o[1]),\n                  l = t.getElevation(o[2], o[3]),\n                  u = t.getElevation(o[0], o[3]),\n                  c = t.isLeaf(o[0], o[1]),\n                  h = t.isLeaf(o[2], o[1]),\n                  p = t.isLeaf(o[2], o[3]),\n                  d = t.isLeaf(o[0], o[3]),\n                  f = Math.min(r.min, i.min, l.min, u.min),\n                  y = Math.max(r.max, i.max, l.max, u.max),\n                  m = c && h && p && d;\n                a.maximums.push(y), a.minimums.push(f), a.leaves.push(y - f <= 5 && m ? 1 : 0);\n              }\n              r.push(a);\n            }\n            return r;\n          }(this.dem),\n          r = e.length - 1,\n          n = e[r];\n        this._addNode(n.minimums[0], n.maximums[0], n.leaves[0]), this._construct(e, 0, 0, r, 0);\n      }\n      raycastRoot(t, e, r, n, i, s, a = 1) {\n        return Lf([t, e, -100], [r, n, this.maximums[0] * a], i, s);\n      }\n      raycast(t, e, r, n, i, s, a = 1) {\n        if (!this.nodeCount) return null;\n        const o = this.raycastRoot(t, e, r, n, i, s, a);\n        if (null == o) return null;\n        const l = [],\n          u = [],\n          c = [],\n          h = [],\n          p = [{\n            idx: 0,\n            t: o,\n            nodex: 0,\n            nodey: 0,\n            depth: 0\n          }];\n        for (; p.length > 0;) {\n          const {\n            idx: o,\n            t: d,\n            nodex: f,\n            nodey: y,\n            depth: m\n          } = p.pop();\n          if (this.leaves[o]) {\n            Uf(f, y, m, t, e, r, n, c, h);\n            const o = 1 << m,\n              l = (f + 0) / o,\n              u = (f + 1) / o,\n              p = (y + 0) / o,\n              g = (y + 1) / o,\n              x = Of(l, p, this.dem) * a,\n              v = Of(u, p, this.dem) * a,\n              b = Of(u, g, this.dem) * a,\n              w = Of(l, g, this.dem) * a,\n              _ = Ff(c[0], c[1], x, h[0], c[1], v, h[0], h[1], b, i, s),\n              A = Ff(h[0], h[1], b, c[0], h[1], w, c[0], c[1], x, i, s),\n              S = Math.min(null !== _ ? _ : Number.MAX_VALUE, null !== A ? A : Number.MAX_VALUE);\n            if (S !== Number.MAX_VALUE) return S;\n            {\n              const t = Po([], i, s, d);\n              if (jf(x, v, w, b, Rf(t[0], c[0], h[0]), Rf(t[1], c[1], h[1])) >= t[2]) return d;\n            }\n            continue;\n          }\n          let g = 0;\n          for (let p = 0; p < this._siblingOffset.length; p++) {\n            Uf((f << 1) + this._siblingOffset[p][0], (y << 1) + this._siblingOffset[p][1], m + 1, t, e, r, n, c, h), c[2] = -100, h[2] = this.maximums[this.childOffsets[o] + p] * a;\n            const d = Lf(c, h, i, s);\n            if (null != d) {\n              const t = d;\n              l[p] = t;\n              let e = !1;\n              for (let r = 0; r < g && !e; r++) t >= l[u[r]] && (u.splice(r, 0, p), e = !0);\n              e || (u[g] = p), g++;\n            }\n          }\n          for (let t = 0; t < g; t++) {\n            const e = u[t];\n            p.push({\n              idx: this.childOffsets[o] + e,\n              t: l[e],\n              nodex: (f << 1) + this._siblingOffset[e][0],\n              nodey: (y << 1) + this._siblingOffset[e][1],\n              depth: m + 1\n            });\n          }\n        }\n        return null;\n      }\n      _addNode(t, e, r) {\n        return this.minimums.push(t), this.maximums.push(e), this.leaves.push(r), this.childOffsets.push(0), this.nodeCount++;\n      }\n      _construct(t, e, r, n, i) {\n        if (1 === t[n].isLeaf(e, r)) return;\n        this.childOffsets[i] || (this.childOffsets[i] = this.nodeCount);\n        const s = n - 1,\n          a = t[s];\n        let o = 0,\n          l = 0;\n        for (let t = 0; t < this._siblingOffset.length; t++) {\n          const n = 2 * e + this._siblingOffset[t][0],\n            i = 2 * r + this._siblingOffset[t][1],\n            s = a.getElevation(n, i),\n            u = a.isLeaf(n, i),\n            c = this._addNode(s.min, s.max, u);\n          u && (o |= 1 << t), l || (l = c);\n        }\n        for (let n = 0; n < this._siblingOffset.length; n++) o & 1 << n || this._construct(t, 2 * e + this._siblingOffset[n][0], 2 * r + this._siblingOffset[n][1], s, l + n);\n      }\n    }\n    function jf(t, e, r, n, i, s) {\n      return Er(Er(t, r, s), Er(e, n, s), i);\n    }\n    function Of(t, e, r) {\n      const n = r.dim,\n        i = M(t * n - .5, 0, n - 1),\n        s = M(e * n - .5, 0, n - 1),\n        a = Math.floor(i),\n        o = Math.floor(s),\n        l = Math.min(a + 1, n - 1),\n        u = Math.min(o + 1, n - 1);\n      return jf(r.get(a, o), r.get(l, o), r.get(a, u), r.get(l, u), i - a, s - o);\n    }\n    const qf = {\n      mapbox: [6553.6, 25.6, .1, 1e4],\n      terrarium: [256, 1, 1 / 256, 32768]\n    };\n    function Nf(t, e, r) {\n      return (256 * t * 256 + 256 * e + r) / 10 - 1e4;\n    }\n    function Gf(t, e, r) {\n      return 256 * t + e + r / 256 - 32768;\n    }\n    class Zf {\n      get tree() {\n        return this._tree || this._buildQuadTree(), this._tree;\n      }\n      constructor(t, e, r, n = !1, i = !1) {\n        if (this.uid = t, e.height !== e.width) throw new RangeError(\"DEM tiles must be square\");\n        if (r && \"mapbox\" !== r && \"terrarium\" !== r) return N(`\"${r}\" is not a valid encoding type. Valid types include \"mapbox\" and \"terrarium\".`);\n        this.stride = e.height;\n        const s = this.dim = e.height - 2,\n          a = new Uint32Array(e.data.buffer);\n        if (this.pixels = new Uint8Array(e.data.buffer), this.encoding = r || \"mapbox\", this.borderReady = n, !n) {\n          for (let t = 0; t < s; t++) a[this._idx(-1, t)] = a[this._idx(0, t)], a[this._idx(s, t)] = a[this._idx(s - 1, t)], a[this._idx(t, -1)] = a[this._idx(t, 0)], a[this._idx(t, s)] = a[this._idx(t, s - 1)];\n          a[this._idx(-1, -1)] = a[this._idx(0, 0)], a[this._idx(s, -1)] = a[this._idx(s - 1, 0)], a[this._idx(-1, s)] = a[this._idx(0, s - 1)], a[this._idx(s, s)] = a[this._idx(s - 1, s - 1)], i && this._buildQuadTree();\n        }\n      }\n      _buildQuadTree() {\n        this._tree = new $f(this);\n      }\n      get(t, e, r = !1) {\n        r && (t = M(t, -1, this.dim), e = M(e, -1, this.dim));\n        const n = 4 * this._idx(t, e);\n        return (\"terrarium\" === this.encoding ? Gf : Nf)(this.pixels[n], this.pixels[n + 1], this.pixels[n + 2]);\n      }\n      static getUnpackVector(t) {\n        return qf[t];\n      }\n      get unpackVector() {\n        return qf[this.encoding];\n      }\n      _idx(t, e) {\n        if (t < -1 || t >= this.dim + 1 || e < -1 || e >= this.dim + 1) throw new RangeError(\"out of range source coordinates for DEM data\");\n        return (e + 1) * this.stride + (t + 1);\n      }\n      static pack(t, e) {\n        const r = [0, 0, 0, 0],\n          n = Zf.getUnpackVector(e);\n        let i = Math.floor((t + n[3]) / n[2]);\n        return r[2] = i % 256, i = Math.floor(i / 256), r[1] = i % 256, i = Math.floor(i / 256), r[0] = i, r;\n      }\n      getPixels() {\n        return new Uu({\n          width: this.stride,\n          height: this.stride\n        }, this.pixels);\n      }\n      backfillBorder(t, e, r) {\n        if (this.dim !== t.dim) throw new Error(\"dem dimension mismatch\");\n        let n = e * this.dim,\n          i = e * this.dim + this.dim,\n          s = r * this.dim,\n          a = r * this.dim + this.dim;\n        switch (e) {\n          case -1:\n            n = i - 1;\n            break;\n          case 1:\n            i = n + 1;\n        }\n        switch (r) {\n          case -1:\n            s = a - 1;\n            break;\n          case 1:\n            a = s + 1;\n        }\n        const o = -e * this.dim,\n          l = -r * this.dim;\n        for (let e = s; e < a; e++) for (let r = n; r < i; r++) {\n          const n = 4 * this._idx(r, e),\n            i = 4 * this._idx(r + o, e + l);\n          this.pixels[n + 0] = t.pixels[i + 0], this.pixels[n + 1] = t.pixels[i + 1], this.pixels[n + 2] = t.pixels[i + 2], this.pixels[n + 3] = t.pixels[i + 3];\n        }\n      }\n      onDeserialize() {\n        this._tree && (this._tree.dem = this);\n      }\n    }\n    Ji(Zf, \"DEMData\"), Ji($f, \"DemMinMaxQuadTree\", {\n      omit: [\"dem\"]\n    });\n    class Kf {\n      constructor(t, e) {\n        this.max = t, this.onRemove = e, this.reset();\n      }\n      reset() {\n        for (const t in this.data) for (const e of this.data[t]) e.timeout && clearTimeout(e.timeout), this.onRemove(e.value);\n        return this.data = {}, this.order = [], this;\n      }\n      add(t, e, r) {\n        const n = t.wrapped().key;\n        void 0 === this.data[n] && (this.data[n] = []);\n        const i = {\n          value: e,\n          timeout: void 0\n        };\n        if (void 0 !== r && (i.timeout = setTimeout(() => {\n          this.remove(t, i);\n        }, r)), this.data[n].push(i), this.order.push(n), this.order.length > this.max) {\n          const t = this._getAndRemoveByKey(this.order[0]);\n          t && this.onRemove(t);\n        }\n        return this;\n      }\n      has(t) {\n        return t.wrapped().key in this.data;\n      }\n      getAndRemove(t) {\n        return this.has(t) ? this._getAndRemoveByKey(t.wrapped().key) : null;\n      }\n      _getAndRemoveByKey(t) {\n        const e = this.data[t].shift();\n        return e.timeout && clearTimeout(e.timeout), 0 === this.data[t].length && delete this.data[t], this.order.splice(this.order.indexOf(t), 1), e.value;\n      }\n      getByKey(t) {\n        const e = this.data[t];\n        return e ? e[0].value : null;\n      }\n      get(t) {\n        return this.has(t) ? this.data[t.wrapped().key][0].value : null;\n      }\n      remove(t, e) {\n        if (!this.has(t)) return this;\n        const r = t.wrapped().key,\n          n = void 0 === e ? 0 : this.data[r].indexOf(e),\n          i = this.data[r][n];\n        return this.data[r].splice(n, 1), i.timeout && clearTimeout(i.timeout), 0 === this.data[r].length && delete this.data[r], this.onRemove(i.value), this.order.splice(this.order.indexOf(r), 1), this;\n      }\n      setMaxSize(t) {\n        for (this.max = t; this.order.length > this.max;) {\n          const t = this._getAndRemoveByKey(this.order[0]);\n          t && this.onRemove(t);\n        }\n        return this;\n      }\n      filter(t) {\n        const e = [];\n        for (const r in this.data) for (const n of this.data[r]) t(n.value) || e.push(n);\n        for (const t of e) this.remove(t.value.tileID, t);\n      }\n    }\n    class Xf {\n      constructor(t, e, r) {\n        this.func = t, this.mask = e, this.range = r;\n      }\n    }\n    Xf.ReadOnly = !1, Xf.ReadWrite = !0, Xf.disabled = new Xf(519, Xf.ReadOnly, [0, 1]);\n    const Jf = 7680;\n    class Hf {\n      constructor(t, e, r, n, i, s) {\n        this.test = t, this.ref = e, this.mask = r, this.fail = n, this.depthFail = i, this.pass = s;\n      }\n    }\n    Hf.disabled = new Hf({\n      func: 519,\n      mask: 0\n    }, 0, 0, Jf, Jf, Jf);\n    class Yf {\n      constructor(t, e, r) {\n        this.blendFunction = t, this.blendColor = e, this.mask = r;\n      }\n    }\n    Yf.Replace = [1, 0], Yf.disabled = new Yf(Yf.Replace, Ee.transparent, [!1, !1, !1, !1]), Yf.unblended = new Yf(Yf.Replace, Ee.transparent, [!0, !0, !0, !0]), Yf.alphaBlended = new Yf([1, 771], Ee.transparent, [!0, !0, !0, !0]);\n    const Wf = 1029,\n      Qf = 2305;\n    class ty {\n      constructor(t, e, r) {\n        this.enable = t, this.mode = e, this.frontFace = r;\n      }\n    }\n    ty.disabled = new ty(!1, Wf, Qf), ty.backCCW = new ty(!0, Wf, Qf), ty.backCW = new ty(!0, Wf, 2304), ty.frontCW = new ty(!0, 1028, 2304), ty.frontCCW = new ty(!0, 1028, Qf);\n    class ey extends Qt {\n      constructor(t, e, r) {\n        super(), this.id = t, this._onlySymbols = r, e.on(\"data\", t => {\n          \"source\" === t.dataType && \"metadata\" === t.sourceDataType && (this._sourceLoaded = !0), this._sourceLoaded && !this._paused && \"source\" === t.dataType && \"content\" === t.sourceDataType && (this.reload(), this.transform && this.update(this.transform));\n        }), e.on(\"error\", () => {\n          this._sourceErrored = !0;\n        }), this._source = e, this._tiles = {}, this._cache = new Kf(0, this._unloadTile.bind(this)), this._timers = {}, this._cacheTimers = {}, this._minTileCacheSize = e.minTileCacheSize, this._maxTileCacheSize = e.maxTileCacheSize, this._loadedParentTiles = {}, this._coveredTiles = {}, this._state = new Df(), this._isRaster = \"raster\" === this._source.type || \"raster-dem\" === this._source.type || \"custom\" === this._source.type && \"raster\" === this._source._dataType;\n      }\n      onAdd(t) {\n        this.map = t, this._minTileCacheSize = void 0 === this._minTileCacheSize && t ? t._minTileCacheSize : this._minTileCacheSize, this._maxTileCacheSize = void 0 === this._maxTileCacheSize && t ? t._maxTileCacheSize : this._maxTileCacheSize;\n      }\n      loaded() {\n        if (this._sourceErrored) return !0;\n        if (!this._sourceLoaded) return !1;\n        if (!this._source.loaded()) return !1;\n        for (const t in this._tiles) {\n          const e = this._tiles[t];\n          if (\"loaded\" !== e.state && \"errored\" !== e.state) return !1;\n        }\n        return !0;\n      }\n      getSource() {\n        return this._source;\n      }\n      pause() {\n        this._paused = !0;\n      }\n      resume() {\n        if (!this._paused) return;\n        const t = this._shouldReloadOnResume;\n        this._paused = !1, this._shouldReloadOnResume = !1, t && this.reload(), this.transform && this.update(this.transform);\n      }\n      _loadTile(t, e) {\n        return t.isSymbolTile = this._onlySymbols, this._source.loadTile(t, e);\n      }\n      _unloadTile(t) {\n        if (this._source.unloadTile) return this._source.unloadTile(t, () => {});\n      }\n      _abortTile(t) {\n        if (this._source.abortTile) return this._source.abortTile(t, () => {});\n      }\n      serialize() {\n        return this._source.serialize();\n      }\n      prepare(t) {\n        this._source.prepare && this._source.prepare(), this._state.coalesceChanges(this._tiles, this.map ? this.map.painter : null);\n        for (const e in this._tiles) {\n          const r = this._tiles[e];\n          r.upload(t), r.prepare(this.map.style.imageManager);\n        }\n      }\n      getIds() {\n        return E(this._tiles).map(t => t.tileID).sort(ry).map(t => t.key);\n      }\n      getRenderableIds(t) {\n        const e = [];\n        for (const r in this._tiles) this._isIdRenderable(+r, t) && e.push(this._tiles[r]);\n        return t ? e.sort((t, e) => {\n          const r = t.tileID,\n            n = e.tileID,\n            i = new x(r.canonical.x, r.canonical.y)._rotate(this.transform.angle),\n            s = new x(n.canonical.x, n.canonical.y)._rotate(this.transform.angle);\n          return r.overscaledZ - n.overscaledZ || s.y - i.y || s.x - i.x;\n        }).map(t => t.tileID.key) : e.map(t => t.tileID).sort(ry).map(t => t.key);\n      }\n      hasRenderableParent(t) {\n        const e = this.findLoadedParent(t, 0);\n        return !!e && this._isIdRenderable(e.tileID.key);\n      }\n      _isIdRenderable(t, e) {\n        return this._tiles[t] && this._tiles[t].hasData() && !this._coveredTiles[t] && (e || !this._tiles[t].holdingForFade());\n      }\n      reload() {\n        if (this._paused) this._shouldReloadOnResume = !0;else {\n          this._cache.reset();\n          for (const t in this._tiles) \"errored\" !== this._tiles[t].state && this._reloadTile(+t, \"reloading\");\n        }\n      }\n      _reloadTile(t, e) {\n        const r = this._tiles[t];\n        r && (\"loading\" !== r.state && (r.state = e), this._loadTile(r, this._tileLoaded.bind(this, r, t, e)));\n      }\n      _tileLoaded(t, e, r, n) {\n        if (n) {\n          if (t.state = \"errored\", 404 !== n.status) this._source.fire(new Wt(n, {\n            tile: t\n          }));else if (\"raster-dem\" === this._source.type && this.usedForTerrain && this.map.painter.terrain) {\n            const t = this.map.painter.terrain;\n            this.update(this.transform, t.getScaledDemTileSize(), !0), t.resetTileLookupCache(this.id);\n          } else this.update(this.transform);\n        } else t.timeAdded = Xt.now(), \"expired\" === r && (t.refreshedUponExpiration = !0), this._setTileReloadTimer(e, t), \"raster-dem\" === this._source.type && t.dem && this._backfillDEM(t), this._state.initializeTileState(t, this.map ? this.map.painter : null), this._source.fire(new Yt(\"data\", {\n          dataType: \"source\",\n          tile: t,\n          coord: t.tileID,\n          sourceCacheId: this.id\n        }));\n      }\n      _backfillDEM(t) {\n        const e = this.getRenderableIds();\n        for (let n = 0; n < e.length; n++) {\n          const i = e[n];\n          if (t.neighboringTiles && t.neighboringTiles[i]) {\n            const e = this.getTileByID(i);\n            r(t, e), r(e, t);\n          }\n        }\n        function r(t, e) {\n          if (!t.dem || t.dem.borderReady) return;\n          t.needsHillshadePrepare = !0, t.needsDEMTextureUpload = !0;\n          let r = e.tileID.canonical.x - t.tileID.canonical.x;\n          const n = e.tileID.canonical.y - t.tileID.canonical.y,\n            i = Math.pow(2, t.tileID.canonical.z),\n            s = e.tileID.key;\n          0 === r && 0 === n || Math.abs(n) > 1 || (Math.abs(r) > 1 && (1 === Math.abs(r + i) ? r += i : 1 === Math.abs(r - i) && (r -= i)), e.dem && t.dem && (t.dem.backfillBorder(e.dem, r, n), t.neighboringTiles && t.neighboringTiles[s] && (t.neighboringTiles[s].backfilled = !0)));\n        }\n      }\n      getTile(t) {\n        return this.getTileByID(t.key);\n      }\n      getTileByID(t) {\n        return this._tiles[t];\n      }\n      _retainLoadedChildren(t, e, r, n) {\n        for (const i in this._tiles) {\n          let s = this._tiles[i];\n          if (n[i] || !s.hasData() || s.tileID.overscaledZ <= e || s.tileID.overscaledZ > r) continue;\n          let a = s.tileID;\n          for (; s && s.tileID.overscaledZ > e + 1;) {\n            const t = s.tileID.scaledTo(s.tileID.overscaledZ - 1);\n            s = this._tiles[t.key], s && s.hasData() && (a = t);\n          }\n          let o = a;\n          for (; o.overscaledZ > e;) if (o = o.scaledTo(o.overscaledZ - 1), t[o.key]) {\n            n[a.key] = a;\n            break;\n          }\n        }\n      }\n      findLoadedParent(t, e) {\n        if (t.key in this._loadedParentTiles) {\n          const r = this._loadedParentTiles[t.key];\n          return r && r.tileID.overscaledZ >= e ? r : null;\n        }\n        for (let r = t.overscaledZ - 1; r >= e; r--) {\n          const e = t.scaledTo(r),\n            n = this._getLoadedTile(e);\n          if (n) return n;\n        }\n      }\n      _getLoadedTile(t) {\n        const e = this._tiles[t.key];\n        return e && e.hasData() ? e : this._cache.getByKey(this._source.reparseOverscaled ? t.wrapped().key : t.canonical.key);\n      }\n      updateCacheSize(t, e) {\n        e = e || this._source.tileSize;\n        const r = Math.ceil(t.width / e) + 1,\n          n = Math.ceil(t.height / e) + 1,\n          i = Math.floor(r * n * 5),\n          s = \"number\" == typeof this._minTileCacheSize ? Math.max(this._minTileCacheSize, i) : i,\n          a = \"number\" == typeof this._maxTileCacheSize ? Math.min(this._maxTileCacheSize, s) : s;\n        this._cache.setMaxSize(a);\n      }\n      handleWrapJump(t) {\n        const e = Math.round((t - (void 0 === this._prevLng ? t : this._prevLng)) / 360);\n        if (this._prevLng = t, e) {\n          const t = {};\n          for (const r in this._tiles) {\n            const n = this._tiles[r];\n            n.tileID = n.tileID.unwrapTo(n.tileID.wrap + e), t[n.tileID.key] = n;\n          }\n          this._tiles = t;\n          for (const t in this._timers) clearTimeout(this._timers[t]), delete this._timers[t];\n          for (const t in this._tiles) this._setTileReloadTimer(+t, this._tiles[t]);\n        }\n      }\n      update(t, e, r) {\n        if (this.transform = t, !this._sourceLoaded || this._paused || this.transform.freezeTileCoverage) return;\n        if (this.usedForTerrain && !r) return;\n        let n;\n        this.updateCacheSize(t, e), \"globe\" !== this.transform.projection.name && this.handleWrapJump(this.transform.center.lng), this._coveredTiles = {}, this.used || this.usedForTerrain ? this._source.tileID ? n = t.getVisibleUnwrappedCoordinates(this._source.tileID).map(t => new fh(t.canonical.z, t.wrap, t.canonical.z, t.canonical.x, t.canonical.y)) : (n = t.coveringTiles({\n          tileSize: e || this._source.tileSize,\n          minzoom: this._source.minzoom,\n          maxzoom: this._source.maxzoom,\n          roundZoom: this._source.roundZoom && !r,\n          reparseOverscaled: this._source.reparseOverscaled,\n          isTerrainDEM: this.usedForTerrain\n        }), this._source.hasTile && (n = n.filter(t => this._source.hasTile(t)))) : n = [];\n        const i = this._updateRetainedTiles(n);\n        if (ny(this._source.type) && 0 !== n.length) {\n          const t = {},\n            e = {},\n            r = Object.keys(i);\n          for (const n of r) {\n            const r = i[n],\n              s = this._tiles[n];\n            if (!s || s.fadeEndTime && s.fadeEndTime <= Xt.now()) continue;\n            const a = this.findLoadedParent(r, Math.max(r.overscaledZ - ey.maxOverzooming, this._source.minzoom));\n            a && (this._addTile(a.tileID), t[a.tileID.key] = a.tileID), e[n] = r;\n          }\n          const s = n[n.length - 1].overscaledZ;\n          for (const t in this._tiles) {\n            const r = this._tiles[t];\n            if (i[t] || !r.hasData()) continue;\n            let n = r.tileID;\n            for (; n.overscaledZ > s;) {\n              n = n.scaledTo(n.overscaledZ - 1);\n              const s = this._tiles[n.key];\n              if (s && s.hasData() && e[n.key]) {\n                i[t] = r.tileID;\n                break;\n              }\n            }\n          }\n          for (const e in t) i[e] || (this._coveredTiles[e] = !0, i[e] = t[e]);\n        }\n        for (const t in i) this._tiles[t].clearFadeHold();\n        const s = function (t, e) {\n          const r = [];\n          for (const n in t) n in e || r.push(n);\n          return r;\n        }(this._tiles, i);\n        for (const t of s) {\n          const e = this._tiles[t];\n          e.hasSymbolBuckets && !e.holdingForFade() ? e.setHoldDuration(this.map._fadeDuration) : e.hasSymbolBuckets && !e.symbolFadeFinished() || this._removeTile(+t);\n        }\n        this._updateLoadedParentTileCache(), this._onlySymbols && this._source.afterUpdate && this._source.afterUpdate();\n      }\n      releaseSymbolFadeTiles() {\n        for (const t in this._tiles) this._tiles[t].holdingForFade() && this._removeTile(+t);\n      }\n      _updateRetainedTiles(t) {\n        const e = {};\n        if (0 === t.length) return e;\n        const r = {},\n          n = t.reduce((t, e) => Math.min(t, e.overscaledZ), 1 / 0),\n          i = t[0].overscaledZ,\n          s = Math.max(i - ey.maxOverzooming, this._source.minzoom),\n          a = Math.max(i + ey.maxUnderzooming, this._source.minzoom),\n          o = {};\n        for (const r of t) {\n          const t = this._addTile(r);\n          e[r.key] = r, t.hasData() || n < this._source.maxzoom && (o[r.key] = r);\n        }\n        this._retainLoadedChildren(o, n, a, e);\n        for (const n of t) {\n          let t = this._tiles[n.key];\n          if (t.hasData()) continue;\n          if (n.canonical.z >= this._source.maxzoom) {\n            const t = n.children(this._source.maxzoom)[0],\n              r = this.getTile(t);\n            if (r && r.hasData()) {\n              e[t.key] = t;\n              continue;\n            }\n          } else {\n            const t = n.children(this._source.maxzoom);\n            if (e[t[0].key] && e[t[1].key] && e[t[2].key] && e[t[3].key]) continue;\n          }\n          let i = t.wasRequested();\n          for (let a = n.overscaledZ - 1; a >= s; --a) {\n            const s = n.scaledTo(a);\n            if (r[s.key]) break;\n            if (r[s.key] = !0, t = this.getTile(s), !t && i && (t = this._addTile(s)), t && (e[s.key] = s, i = t.wasRequested(), t.hasData())) break;\n          }\n        }\n        return e;\n      }\n      _updateLoadedParentTileCache() {\n        this._loadedParentTiles = {};\n        for (const t in this._tiles) {\n          const e = [];\n          let r,\n            n = this._tiles[t].tileID;\n          for (; n.overscaledZ > 0;) {\n            if (n.key in this._loadedParentTiles) {\n              r = this._loadedParentTiles[n.key];\n              break;\n            }\n            e.push(n.key);\n            const t = n.scaledTo(n.overscaledZ - 1);\n            if (r = this._getLoadedTile(t), r) break;\n            n = t;\n          }\n          for (const t of e) this._loadedParentTiles[t] = r;\n        }\n      }\n      _addTile(t) {\n        let e = this._tiles[t.key];\n        if (e) return e;\n        e = this._cache.getAndRemove(t), e && (this._setTileReloadTimer(t.key, e), e.tileID = t, this._state.initializeTileState(e, this.map ? this.map.painter : null), this._cacheTimers[t.key] && (clearTimeout(this._cacheTimers[t.key]), delete this._cacheTimers[t.key], this._setTileReloadTimer(t.key, e)));\n        const r = Boolean(e);\n        if (!r) {\n          const r = this.map ? this.map.painter : null;\n          e = new Pf(t, this._source.tileSize * t.overscaleFactor(), this.transform.tileZoom, r, this._isRaster), this._loadTile(e, this._tileLoaded.bind(this, e, t.key, e.state));\n        }\n        return e ? (e.uses++, this._tiles[t.key] = e, r || this._source.fire(new Yt(\"dataloading\", {\n          tile: e,\n          coord: e.tileID,\n          dataType: \"source\"\n        })), e) : null;\n      }\n      _setTileReloadTimer(t, e) {\n        t in this._timers && (clearTimeout(this._timers[t]), delete this._timers[t]);\n        const r = e.getExpiryTimeout();\n        r && (this._timers[t] = setTimeout(() => {\n          this._reloadTile(t, \"expired\"), delete this._timers[t];\n        }, r));\n      }\n      _removeTile(t) {\n        const e = this._tiles[t];\n        e && (e.uses--, delete this._tiles[t], this._timers[t] && (clearTimeout(this._timers[t]), delete this._timers[t]), e.uses > 0 || (e.hasData() && \"reloading\" !== e.state ? this._cache.add(e.tileID, e, e.getExpiryTimeout()) : (e.aborted = !0, this._abortTile(e), this._unloadTile(e))));\n      }\n      clearTiles() {\n        this._shouldReloadOnResume = !1, this._paused = !1;\n        for (const t in this._tiles) this._removeTile(+t);\n        this._source._clear && this._source._clear(), this._cache.reset(), this.map && this.usedForTerrain && this.map.painter.terrain && this.map.painter.terrain.resetTileLookupCache(this.id);\n      }\n      tilesIn(t, e, r) {\n        const n = [],\n          i = this.transform;\n        if (!i) return n;\n        const s = \"globe\" === i.projection.name,\n          a = Nl(i.center.lng);\n        for (const o in this._tiles) {\n          const l = this._tiles[o];\n          if (r && l.clearQueryDebugViz(), l.holdingForFade()) continue;\n          let u;\n          if (s) {\n            const t = l.tileID.canonical;\n            if (0 === t.z) {\n              const e = [Math.abs(M(a, ...iy(t, -1)) - a), Math.abs(M(a, ...iy(t, 1)) - a)];\n              u = [0, 2 * e.indexOf(Math.min(...e)) - 1];\n            } else {\n              const e = [Math.abs(M(a, ...iy(t, -1)) - a), Math.abs(M(a, ...iy(t, 0)) - a), Math.abs(M(a, ...iy(t, 1)) - a)];\n              u = [e.indexOf(Math.min(...e)) - 1];\n            }\n          } else u = [0];\n          for (const r of u) {\n            const s = t.containsTile(l, i, e, r);\n            s && n.push(s);\n          }\n        }\n        return n;\n      }\n      getVisibleCoordinates(t) {\n        const e = this.getRenderableIds(t).map(t => this._tiles[t].tileID);\n        for (const t of e) t.projMatrix = this.transform.calculateProjMatrix(t.toUnwrapped());\n        return e;\n      }\n      hasTransition() {\n        if (this._source.hasTransition()) return !0;\n        if (ny(this._source.type)) for (const t in this._tiles) {\n          const e = this._tiles[t];\n          if (void 0 !== e.fadeEndTime && e.fadeEndTime >= Xt.now()) return !0;\n        }\n        return !1;\n      }\n      setFeatureState(t, e, r) {\n        this._state.updateState(t = t || \"_geojsonTileLayer\", e, r);\n      }\n      removeFeatureState(t, e, r) {\n        this._state.removeFeatureState(t = t || \"_geojsonTileLayer\", e, r);\n      }\n      getFeatureState(t, e) {\n        return this._state.getState(t = t || \"_geojsonTileLayer\", e);\n      }\n      setDependencies(t, e, r) {\n        const n = this._tiles[t];\n        n && n.setDependencies(e, r);\n      }\n      reloadTilesForDependencies(t, e) {\n        for (const r in this._tiles) this._tiles[r].hasDependency(t, e) && this._reloadTile(+r, \"reloading\");\n        this._cache.filter(r => !r.hasDependency(t, e));\n      }\n      _preloadTiles(t, e) {\n        if (!this._sourceLoaded) {\n          const r = () => {\n            this._sourceLoaded && (this._source.off(\"data\", r), this._preloadTiles(t, e));\n          };\n          return void this._source.on(\"data\", r);\n        }\n        const r = new Map(),\n          n = Array.isArray(t) ? t : [t],\n          i = this.map.painter.terrain,\n          s = this.usedForTerrain && i ? i.getScaledDemTileSize() : this._source.tileSize;\n        for (const t of n) {\n          const e = t.coveringTiles({\n            tileSize: s,\n            minzoom: this._source.minzoom,\n            maxzoom: this._source.maxzoom,\n            roundZoom: this._source.roundZoom && !this.usedForTerrain,\n            reparseOverscaled: this._source.reparseOverscaled,\n            isTerrainDEM: this.usedForTerrain\n          });\n          for (const t of e) r.set(t.key, t);\n          this.usedForTerrain && t.updateElevation(!1);\n        }\n        B(Array.from(r.values()), (t, e) => {\n          const r = new Pf(t, this._source.tileSize * t.overscaleFactor(), this.transform.tileZoom, this.map.painter, this._isRaster);\n          this._loadTile(r, t => {\n            \"raster-dem\" === this._source.type && r.dem && this._backfillDEM(r), e(t, r);\n          });\n        }, e);\n      }\n    }\n    function ry(t, e) {\n      const r = Math.abs(2 * t.wrap) - +(t.wrap < 0),\n        n = Math.abs(2 * e.wrap) - +(e.wrap < 0);\n      return t.overscaledZ - e.overscaledZ || n - r || e.canonical.y - t.canonical.y || e.canonical.x - t.canonical.x;\n    }\n    function ny(t) {\n      return \"raster\" === t || \"image\" === t || \"video\" === t || \"custom\" === t;\n    }\n    function iy(t, e) {\n      const r = 1 << t.z;\n      return [t.x / r + e, (t.x + 1) / r + e];\n    }\n    ey.maxOverzooming = 10, ey.maxUnderzooming = 3;\n    class sy {\n      constructor(t, e, r) {\n        this._demTile = t, this._dem = this._demTile.dem, this._scale = e, this._offset = r;\n      }\n      static create(t, e, r) {\n        const n = r || t.findDEMTileFor(e);\n        if (!n || !n.dem) return;\n        const i = n.dem,\n          s = n.tileID,\n          a = 1 << e.canonical.z - s.canonical.z;\n        return new sy(n, n.tileSize / ao / a, [(e.canonical.x / a - s.canonical.x) * i.dim, (e.canonical.y / a - s.canonical.y) * i.dim]);\n      }\n      tileCoordToPixel(t, e) {\n        const r = e * this._scale + this._offset[1],\n          n = Math.floor(t * this._scale + this._offset[0]),\n          i = Math.floor(r);\n        return new x(n, i);\n      }\n      getElevationAt(t, e, r, n) {\n        const i = t * this._scale + this._offset[0],\n          s = e * this._scale + this._offset[1],\n          a = Math.floor(i),\n          o = Math.floor(s),\n          l = this._dem;\n        return n = !!n, r ? Er(Er(l.get(a, o, n), l.get(a, o + 1, n), s - o), Er(l.get(a + 1, o, n), l.get(a + 1, o + 1, n), s - o), i - a) : l.get(a, o, n);\n      }\n      getElevationAtPixel(t, e, r) {\n        return this._dem.get(t, e, !!r);\n      }\n      getMeterToDEM(t) {\n        return (1 << this._demTile.tileID.canonical.z) * Zl(1, t) * this._dem.stride;\n      }\n    }\n    class ay {\n      constructor(t, e) {\n        this.tileID = t, this.x = t.canonical.x, this.y = t.canonical.y, this.z = t.canonical.z, this.grid = new Ki(ao, 16, 0), this.featureIndexArray = new ba(), this.promoteId = e;\n      }\n      insert(t, e, r, n, i, s = 0) {\n        const a = this.featureIndexArray.length;\n        this.featureIndexArray.emplaceBack(r, n, i, s);\n        const o = this.grid;\n        for (let t = 0; t < e.length; t++) {\n          const r = e[t],\n            n = [1 / 0, 1 / 0, -1 / 0, -1 / 0];\n          for (let t = 0; t < r.length; t++) {\n            const e = r[t];\n            n[0] = Math.min(n[0], e.x), n[1] = Math.min(n[1], e.y), n[2] = Math.max(n[2], e.x), n[3] = Math.max(n[3], e.y);\n          }\n          n[0] < ao && n[1] < ao && n[2] >= 0 && n[3] >= 0 && o.insert(a, n[0], n[1], n[2], n[3]);\n        }\n      }\n      loadVTLayers() {\n        if (!this.vtLayers) {\n          this.vtLayers = new Zc(new mp(this.rawTileData)).layers, this.sourceLayerCoder = new wf(this.vtLayers ? Object.keys(this.vtLayers).sort() : [\"_geojsonTileLayer\"]), this.vtFeatures = {};\n          for (const t in this.vtLayers) this.vtFeatures[t] = [];\n        }\n        return this.vtLayers;\n      }\n      query(t, e, r, n) {\n        this.loadVTLayers();\n        const i = t.params || {},\n          s = hi(i.filter),\n          a = t.tileResult,\n          o = t.transform,\n          l = a.bufferedTilespaceBounds,\n          u = this.grid.query(l.min.x, l.min.y, l.max.x, l.max.y, (t, e, r, n) => wu(a.bufferedTilespaceGeometry, t, e, r, n));\n        u.sort(ly);\n        let c = null;\n        o.elevation && u.length > 0 && (c = sy.create(o.elevation, this.tileID));\n        const h = {};\n        let p;\n        for (let o = 0; o < u.length; o++) {\n          const l = u[o];\n          if (l === p) continue;\n          p = l;\n          const d = this.featureIndexArray.get(l);\n          let f = null;\n          this.loadMatchingFeature(h, d, s, i.layers, i.availableImages, e, r, n, (e, r, n, i = 0) => (f || (f = au(e, this.tileID.canonical, t.tileTransform)), r.queryIntersectsFeature(a, e, n, f, this.z, t.transform, t.pixelPosMatrix, c, i)));\n        }\n        return h;\n      }\n      loadMatchingFeature(t, e, r, n, i, s, a, o, l) {\n        const {\n            featureIndex: u,\n            bucketIndex: c,\n            sourceLayerIndex: h,\n            layoutVertexArrayOffset: p\n          } = e,\n          d = this.bucketLayerIDs[c];\n        if (n && !function (t, e) {\n          for (let r = 0; r < t.length; r++) if (e.indexOf(t[r]) >= 0) return !0;\n          return !1;\n        }(n, d)) return;\n        const f = this.sourceLayerCoder.decode(h),\n          y = this.vtLayers[f].feature(u);\n        if (r.needGeometry) {\n          const t = ou(y, !0);\n          if (!r.filter(new ws(this.tileID.overscaledZ), t, this.tileID.canonical)) return;\n        } else if (!r.filter(new ws(this.tileID.overscaledZ), y)) return;\n        const m = this.getId(y, f);\n        for (let e = 0; e < d.length; e++) {\n          const r = d[e];\n          if (n && n.indexOf(r) < 0) continue;\n          const c = s[r];\n          if (!c) continue;\n          let h = {};\n          void 0 !== m && o && (h = o.getState(c.sourceLayer || \"_geojsonTileLayer\", m));\n          const f = C({}, a[r]);\n          f.paint = oy(f.paint, c.paint, y, h, i), f.layout = oy(f.layout, c.layout, y, h, i);\n          const g = !l || l(y, c, h, p);\n          if (!g) continue;\n          const x = new Af(y, this.z, this.x, this.y, m);\n          x.layer = f;\n          let v = t[r];\n          void 0 === v && (v = t[r] = []), v.push({\n            featureIndex: u,\n            feature: x,\n            intersectionZ: g\n          });\n        }\n      }\n      lookupSymbolFeatures(t, e, r, n, i, s, a, o) {\n        const l = {};\n        this.loadVTLayers();\n        const u = hi(i);\n        for (const i of t) this.loadMatchingFeature(l, {\n          bucketIndex: r,\n          sourceLayerIndex: n,\n          featureIndex: i,\n          layoutVertexArrayOffset: 0\n        }, u, s, a, o, e);\n        return l;\n      }\n      loadFeature(t) {\n        const {\n          featureIndex: e,\n          sourceLayerIndex: r\n        } = t;\n        this.loadVTLayers();\n        const n = this.sourceLayerCoder.decode(r),\n          i = this.vtFeatures[n];\n        if (i[e]) return i[e];\n        const s = this.vtLayers[n].feature(e);\n        return i[e] = s, s;\n      }\n      hasLayer(t) {\n        for (const e of this.bucketLayerIDs) for (const r of e) if (t === r) return !0;\n        return !1;\n      }\n      getId(t, e) {\n        let r = t.id;\n        if (this.promoteId) {\n          const n = \"string\" == typeof this.promoteId ? this.promoteId : this.promoteId[e];\n          null != n && (r = t.properties[n]), \"boolean\" == typeof r && (r = Number(r));\n        }\n        return r;\n      }\n    }\n    function oy(t, e, r, n, i) {\n      return $(t, (t, s) => {\n        const a = e instanceof zs ? e.get(s) : null;\n        return a && a.evaluate ? a.evaluate(r, n, i) : a;\n      });\n    }\n    function ly(t, e) {\n      return e - t;\n    }\n    Ji(ay, \"FeatureIndex\", {\n      omit: [\"rawTileData\", \"sourceLayerCoder\"]\n    });\n    class uy {\n      constructor(t, e) {\n        this.width = t, this.height = e, this.nextRow = 0, this.image = new Ru({\n          width: t,\n          height: e\n        }), this.positions = {}, this.uploaded = !1;\n      }\n      getDash(t, e) {\n        const r = this.getKey(t, e);\n        return this.positions[r];\n      }\n      trim() {\n        const t = this.width,\n          e = this.height = L(this.nextRow);\n        this.image.resize({\n          width: t,\n          height: e\n        });\n      }\n      getKey(t, e) {\n        return t.join(\",\") + e;\n      }\n      getDashRanges(t, e, r) {\n        const n = [];\n        let i = t.length % 2 == 1 ? -t[t.length - 1] * r : 0,\n          s = t[0] * r,\n          a = !0;\n        n.push({\n          left: i,\n          right: s,\n          isDash: a,\n          zeroLength: 0 === t[0]\n        });\n        let o = t[0];\n        for (let e = 1; e < t.length; e++) {\n          a = !a;\n          const l = t[e];\n          i = o * r, o += l, s = o * r, n.push({\n            left: i,\n            right: s,\n            isDash: a,\n            zeroLength: 0 === l\n          });\n        }\n        return n;\n      }\n      addRoundDash(t, e, r) {\n        const n = e / 2;\n        for (let e = -r; e <= r; e++) {\n          const i = this.width * (this.nextRow + r + e);\n          let s = 0,\n            a = t[s];\n          for (let o = 0; o < this.width; o++) {\n            o / a.right > 1 && (a = t[++s]);\n            const l = Math.abs(o - a.left),\n              u = Math.abs(o - a.right),\n              c = Math.min(l, u);\n            let h;\n            const p = e / r * (n + 1);\n            if (a.isDash) {\n              const t = n - Math.abs(p);\n              h = Math.sqrt(c * c + t * t);\n            } else h = n - Math.sqrt(c * c + p * p);\n            this.image.data[i + o] = Math.max(0, Math.min(255, h + 128));\n          }\n        }\n      }\n      addRegularDash(t, e) {\n        for (let e = t.length - 1; e >= 0; --e) {\n          const r = t[e],\n            n = t[e + 1];\n          r.zeroLength ? t.splice(e, 1) : n && n.isDash === r.isDash && (n.left = r.left, t.splice(e, 1));\n        }\n        const r = t[0],\n          n = t[t.length - 1];\n        r.isDash === n.isDash && (r.left = n.left - this.width, n.right = r.right + this.width);\n        const i = this.width * this.nextRow;\n        let s = 0,\n          a = t[s];\n        for (let r = 0; r < this.width; r++) {\n          r / a.right > 1 && (a = t[++s]);\n          const n = Math.abs(r - a.left),\n            o = Math.abs(r - a.right),\n            l = Math.min(n, o);\n          this.image.data[i + r] = Math.max(0, Math.min(255, (a.isDash ? l : -l) + e + 128));\n        }\n      }\n      addDash(t, e) {\n        const r = this.getKey(t, e);\n        if (this.positions[r]) return this.positions[r];\n        const n = \"round\" === e,\n          i = n ? 7 : 0,\n          s = 2 * i + 1;\n        if (this.nextRow + s > this.height) return N(\"LineAtlas out of space\"), null;\n        0 === t.length && t.push(1);\n        let a = 0;\n        for (let e = 0; e < t.length; e++) t[e] < 0 && (N(\"Negative value is found in line dasharray, replacing values with 0\"), t[e] = 0), a += t[e];\n        if (0 !== a) {\n          const r = this.width / a,\n            s = this.getDashRanges(t, this.width, r);\n          n ? this.addRoundDash(s, r, i) : this.addRegularDash(s, \"square\" === e ? .5 * r : 0);\n        }\n        const o = this.nextRow + i;\n        this.nextRow += s;\n        const l = {\n          tl: [o, i],\n          br: [a, 0]\n        };\n        return this.positions[r] = l, l;\n      }\n    }\n    Ji(uy, \"LineAtlas\");\n    const cy = 1 * td;\n    class hy {\n      constructor(t) {\n        const e = {},\n          r = [];\n        for (const n in t) {\n          const i = t[n],\n            s = e[n] = {};\n          for (const t in i.glyphs) {\n            const e = i.glyphs[+t];\n            if (!e || 0 === e.bitmap.width || 0 === e.bitmap.height) continue;\n            const n = e.metrics.localGlyph ? cy : 1,\n              a = {\n                x: 0,\n                y: 0,\n                w: e.bitmap.width + 2 * n,\n                h: e.bitmap.height + 2 * n\n              };\n            r.push(a), s[t] = a;\n          }\n        }\n        const {\n            w: n,\n            h: i\n          } = _p(r),\n          s = new Ru({\n            width: n || 1,\n            height: i || 1\n          });\n        for (const r in t) {\n          const n = t[r];\n          for (const t in n.glyphs) {\n            const i = n.glyphs[+t];\n            if (!i || 0 === i.bitmap.width || 0 === i.bitmap.height) continue;\n            const a = e[r][t],\n              o = i.metrics.localGlyph ? cy : 1;\n            Ru.copy(i.bitmap, s, {\n              x: 0,\n              y: 0\n            }, {\n              x: a.x + o,\n              y: a.y + o\n            }, i.bitmap);\n          }\n        }\n        this.image = s, this.positions = e;\n      }\n    }\n    Ji(hy, \"GlyphAtlas\");\n    class py {\n      constructor(t) {\n        this.tileID = new fh(t.tileID.overscaledZ, t.tileID.wrap, t.tileID.canonical.z, t.tileID.canonical.x, t.tileID.canonical.y), this.tileZoom = t.tileZoom, this.uid = t.uid, this.zoom = t.zoom, this.canonical = t.tileID.canonical, this.pixelRatio = t.pixelRatio, this.tileSize = t.tileSize, this.source = t.source, this.overscaling = this.tileID.overscaleFactor(), this.showCollisionBoxes = t.showCollisionBoxes, this.collectResourceTiming = !!t.collectResourceTiming, this.returnDependencies = !!t.returnDependencies, this.promoteId = t.promoteId, this.enableTerrain = !!t.enableTerrain, this.isSymbolTile = t.isSymbolTile, this.tileTransform = Bd(t.tileID.canonical, t.projection), this.projection = t.projection;\n      }\n      parse(t, e, r, n, i) {\n        this.status = \"parsing\", this.data = t, this.collisionBoxArray = new pa();\n        const s = new wf(Object.keys(t.layers).sort()),\n          a = new ay(this.tileID, this.promoteId);\n        a.bucketLayerIDs = [];\n        const o = {},\n          l = new uy(256, 256),\n          u = {\n            featureIndex: a,\n            iconDependencies: {},\n            patternDependencies: {},\n            glyphDependencies: {},\n            lineAtlas: l,\n            availableImages: r\n          },\n          c = e.familiesBySource[this.source];\n        for (const e in c) {\n          const n = t.layers[e];\n          if (!n) continue;\n          let i = !1,\n            l = !1;\n          for (const t of c[e]) \"symbol\" === t[0].type ? i = !0 : l = !0;\n          if (!0 === this.isSymbolTile && !i) continue;\n          if (!1 === this.isSymbolTile && !l) continue;\n          1 === n.version && N(`Vector tile source \"${this.source}\" layer \"${e}\" does not use vector tile spec v2 and therefore may have some rendering errors.`);\n          const h = s.encode(e),\n            p = [];\n          for (let t = 0; t < n.length; t++) {\n            const r = n.feature(t),\n              i = a.getId(r, e);\n            p.push({\n              feature: r,\n              id: i,\n              index: t,\n              sourceLayerIndex: h\n            });\n          }\n          for (const t of c[e]) {\n            const e = t[0];\n            void 0 !== this.isSymbolTile && \"symbol\" === e.type !== this.isSymbolTile || e.minzoom && this.zoom < Math.floor(e.minzoom) || e.maxzoom && this.zoom >= e.maxzoom || \"none\" !== e.visibility && (dy(t, this.zoom, r), (o[e.id] = e.createBucket({\n              index: a.bucketLayerIDs.length,\n              layers: t,\n              zoom: this.zoom,\n              canonical: this.canonical,\n              pixelRatio: this.pixelRatio,\n              overscaling: this.overscaling,\n              collisionBoxArray: this.collisionBoxArray,\n              sourceLayerIndex: h,\n              sourceID: this.source,\n              enableTerrain: this.enableTerrain,\n              projection: this.projection.spec,\n              availableImages: r\n            })).populate(p, u, this.tileID.canonical, this.tileTransform), a.bucketLayerIDs.push(t.map(t => t.id)));\n          }\n        }\n        let h, p, d, f;\n        l.trim();\n        const y = {\n            type: \"maybePrepare\",\n            isSymbolTile: this.isSymbolTile,\n            zoom: this.zoom\n          },\n          m = () => {\n            if (h) return i(h);\n            if (p && d && f) {\n              const t = new hy(p),\n                e = new kp(d, f);\n              for (const n in o) {\n                const i = o[n];\n                i instanceof of ? (dy(i.layers, this.zoom, r), vd(i, p, t.positions, d, e.iconPositions, this.showCollisionBoxes, r, this.tileID.canonical, this.tileZoom, this.projection)) : i.hasPattern && (i instanceof Ih || i instanceof Mc || i instanceof th) && (dy(i.layers, this.zoom, r), i.addFeatures(u, this.tileID.canonical, e.patternPositions, r, this.tileTransform));\n              }\n              this.status = \"done\", i(null, {\n                buckets: E(o).filter(t => !t.isEmpty()),\n                featureIndex: a,\n                collisionBoxArray: this.collisionBoxArray,\n                glyphAtlasImage: t.image,\n                lineAtlas: l,\n                imageAtlas: e,\n                glyphMap: this.returnDependencies ? p : null,\n                iconMap: this.returnDependencies ? d : null,\n                glyphPositions: this.returnDependencies ? t.positions : null\n              });\n            }\n          },\n          g = $(u.glyphDependencies, t => Object.keys(t).map(Number));\n        Object.keys(g).length ? n.send(\"getGlyphs\", {\n          uid: this.uid,\n          stacks: g\n        }, (t, e) => {\n          h || (h = t, p = e, m());\n        }, void 0, !1, y) : p = {};\n        const x = Object.keys(u.iconDependencies);\n        x.length ? n.send(\"getImages\", {\n          icons: x,\n          source: this.source,\n          tileID: this.tileID,\n          type: \"icons\"\n        }, (t, e) => {\n          h || (h = t, d = e, m());\n        }, void 0, !1, y) : d = {};\n        const v = Object.keys(u.patternDependencies);\n        v.length ? n.send(\"getImages\", {\n          icons: v,\n          source: this.source,\n          tileID: this.tileID,\n          type: \"patterns\"\n        }, (t, e) => {\n          h || (h = t, f = e, m());\n        }, void 0, !1, y) : f = {}, m();\n      }\n    }\n    function dy(t, e, r) {\n      const n = new ws(e);\n      for (const e of t) e.recalculate(n, r);\n    }\n    class fy {\n      constructor(t) {\n        this.entries = {}, this.scheduler = t;\n      }\n      request(t, e, r, n) {\n        const i = this.entries[t] = this.entries[t] || {\n          callbacks: []\n        };\n        if (i.result) {\n          const [t, r] = i.result;\n          return this.scheduler ? this.scheduler.add(() => {\n            n(t, r);\n          }, e) : n(t, r), () => {};\n        }\n        return i.callbacks.push(n), i.cancel || (i.cancel = r((r, n) => {\n          i.result = [r, n];\n          for (const t of i.callbacks) this.scheduler ? this.scheduler.add(() => {\n            t(r, n);\n          }, e) : t(r, n);\n          setTimeout(() => delete this.entries[t], 3e3);\n        })), () => {\n          i.result || (i.callbacks = i.callbacks.filter(t => t !== n), i.callbacks.length || (i.cancel(), delete this.entries[t]));\n        };\n      }\n    }\n    function yy(t, e, r) {\n      const n = JSON.stringify(t.request);\n      return t.data && (this.deduped.entries[n] = {\n        result: [null, t.data]\n      }), this.deduped.request(n, {\n        type: \"parseTile\",\n        isSymbolTile: t.isSymbolTile,\n        zoom: t.tileZoom\n      }, e => {\n        const n = pt(t.request, (t, n, i, s) => {\n          t ? e(t) : n && e(null, {\n            vectorTile: r ? void 0 : new Zc(new mp(n)),\n            rawData: n,\n            cacheControl: i,\n            expires: s\n          });\n        });\n        return () => {\n          n.cancel(), e();\n        };\n      }, e);\n    }\n    const my = [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array];\n    class gy {\n      static from(t) {\n        if (!(t instanceof ArrayBuffer)) throw new Error(\"Data must be an instance of ArrayBuffer.\");\n        const [e, r] = new Uint8Array(t, 0, 2);\n        if (219 !== e) throw new Error(\"Data does not appear to be in a KDBush format.\");\n        const n = r >> 4;\n        if (1 !== n) throw new Error(`Got v${n} data when expected v1.`);\n        const i = my[15 & r];\n        if (!i) throw new Error(\"Unrecognized array type.\");\n        const [s] = new Uint16Array(t, 2, 1),\n          [a] = new Uint32Array(t, 4, 1);\n        return new gy(a, s, i, t);\n      }\n      constructor(t, e = 64, r = Float64Array, n) {\n        if (isNaN(t) || t < 0) throw new Error(`Unpexpected numItems value: ${t}.`);\n        this.numItems = +t, this.nodeSize = Math.min(Math.max(+e, 2), 65535), this.ArrayType = r, this.IndexArrayType = t < 65536 ? Uint16Array : Uint32Array;\n        const i = my.indexOf(this.ArrayType),\n          s = 2 * t * this.ArrayType.BYTES_PER_ELEMENT,\n          a = t * this.IndexArrayType.BYTES_PER_ELEMENT,\n          o = (8 - a % 8) % 8;\n        if (i < 0) throw new Error(`Unexpected typed array class: ${r}.`);\n        n && n instanceof ArrayBuffer ? (this.data = n, this.ids = new this.IndexArrayType(this.data, 8, t), this.coords = new this.ArrayType(this.data, 8 + a + o, 2 * t), this._pos = 2 * t, this._finished = !0) : (this.data = new ArrayBuffer(8 + s + a + o), this.ids = new this.IndexArrayType(this.data, 8, t), this.coords = new this.ArrayType(this.data, 8 + a + o, 2 * t), this._pos = 0, this._finished = !1, new Uint8Array(this.data, 0, 2).set([219, 16 + i]), new Uint16Array(this.data, 2, 1)[0] = e, new Uint32Array(this.data, 4, 1)[0] = t);\n      }\n      add(t, e) {\n        const r = this._pos >> 1;\n        return this.ids[r] = r, this.coords[this._pos++] = t, this.coords[this._pos++] = e, r;\n      }\n      finish() {\n        const t = this._pos >> 1;\n        if (t !== this.numItems) throw new Error(`Added ${t} items when expected ${this.numItems}.`);\n        return xy(this.ids, this.coords, this.nodeSize, 0, this.numItems - 1, 0), this._finished = !0, this;\n      }\n      range(t, e, r, n) {\n        if (!this._finished) throw new Error(\"Data not yet indexed - call index.finish().\");\n        const {\n            ids: i,\n            coords: s,\n            nodeSize: a\n          } = this,\n          o = [0, i.length - 1, 0],\n          l = [];\n        for (; o.length;) {\n          const u = o.pop() || 0,\n            c = o.pop() || 0,\n            h = o.pop() || 0;\n          if (c - h <= a) {\n            for (let a = h; a <= c; a++) {\n              const o = s[2 * a],\n                u = s[2 * a + 1];\n              o >= t && o <= r && u >= e && u <= n && l.push(i[a]);\n            }\n            continue;\n          }\n          const p = h + c >> 1,\n            d = s[2 * p],\n            f = s[2 * p + 1];\n          d >= t && d <= r && f >= e && f <= n && l.push(i[p]), (0 === u ? t <= d : e <= f) && (o.push(h), o.push(p - 1), o.push(1 - u)), (0 === u ? r >= d : n >= f) && (o.push(p + 1), o.push(c), o.push(1 - u));\n        }\n        return l;\n      }\n      within(t, e, r) {\n        if (!this._finished) throw new Error(\"Data not yet indexed - call index.finish().\");\n        const {\n            ids: n,\n            coords: i,\n            nodeSize: s\n          } = this,\n          a = [0, n.length - 1, 0],\n          o = [],\n          l = r * r;\n        for (; a.length;) {\n          const u = a.pop() || 0,\n            c = a.pop() || 0,\n            h = a.pop() || 0;\n          if (c - h <= s) {\n            for (let r = h; r <= c; r++) _y(i[2 * r], i[2 * r + 1], t, e) <= l && o.push(n[r]);\n            continue;\n          }\n          const p = h + c >> 1,\n            d = i[2 * p],\n            f = i[2 * p + 1];\n          _y(d, f, t, e) <= l && o.push(n[p]), (0 === u ? t - r <= d : e - r <= f) && (a.push(h), a.push(p - 1), a.push(1 - u)), (0 === u ? t + r >= d : e + r >= f) && (a.push(p + 1), a.push(c), a.push(1 - u));\n        }\n        return o;\n      }\n    }\n    function xy(t, e, r, n, i, s) {\n      if (i - n <= r) return;\n      const a = n + i >> 1;\n      vy(t, e, a, n, i, s), xy(t, e, r, n, a - 1, 1 - s), xy(t, e, r, a + 1, i, 1 - s);\n    }\n    function vy(t, e, r, n, i, s) {\n      for (; i > n;) {\n        if (i - n > 600) {\n          const a = i - n + 1,\n            o = r - n + 1,\n            l = Math.log(a),\n            u = .5 * Math.exp(2 * l / 3),\n            c = .5 * Math.sqrt(l * u * (a - u) / a) * (o - a / 2 < 0 ? -1 : 1);\n          vy(t, e, r, Math.max(n, Math.floor(r - o * u / a + c)), Math.min(i, Math.floor(r + (a - o) * u / a + c)), s);\n        }\n        const a = e[2 * r + s];\n        let o = n,\n          l = i;\n        for (by(t, e, n, r), e[2 * i + s] > a && by(t, e, n, i); o < l;) {\n          for (by(t, e, o, l), o++, l--; e[2 * o + s] < a;) o++;\n          for (; e[2 * l + s] > a;) l--;\n        }\n        e[2 * n + s] === a ? by(t, e, n, l) : (l++, by(t, e, l, i)), l <= r && (n = l + 1), r <= l && (i = l - 1);\n      }\n    }\n    function by(t, e, r, n) {\n      wy(t, r, n), wy(e, 2 * r, 2 * n), wy(e, 2 * r + 1, 2 * n + 1);\n    }\n    function wy(t, e, r) {\n      const n = t[e];\n      t[e] = t[r], t[r] = n;\n    }\n    function _y(t, e, r, n) {\n      const i = t - r,\n        s = e - n;\n      return i * i + s * s;\n    }\n    t.ARRAY_TYPE = uo, t.AUTH_ERR_MSG = xt, t.Aabb = il, t.Actor = class {\n      constructor(t, r, n) {\n        this.target = t, this.parent = r, this.mapId = n, this.callbacks = {}, this.cancelCallbacks = {}, R([\"receive\"], this), this.target.addEventListener(\"message\", this.receive, !1), this.globalScope = K() ? t : e, this.scheduler = new bf();\n      }\n      send(t, e, r, n, i = !1, s) {\n        const a = Math.round(1e18 * Math.random()).toString(36).substring(0, 10);\n        r && (r.metadata = s, this.callbacks[a] = r);\n        const o = H(this.globalScope) ? void 0 : [];\n        return this.target.postMessage({\n          id: a,\n          type: t,\n          hasCallback: !!r,\n          targetMapId: n,\n          mustQueue: i,\n          sourceMapId: this.mapId,\n          data: Wi(e, o)\n        }, o), {\n          cancel: () => {\n            r && delete this.callbacks[a], this.target.postMessage({\n              id: a,\n              type: \"<cancel>\",\n              targetMapId: n,\n              sourceMapId: this.mapId\n            });\n          }\n        };\n      }\n      receive(t) {\n        const e = t.data,\n          r = e.id;\n        if (r && (!e.targetMapId || this.mapId === e.targetMapId)) if (\"<cancel>\" === e.type) {\n          const t = this.cancelCallbacks[r];\n          delete this.cancelCallbacks[r], t && t.cancel();\n        } else if (e.mustQueue || K()) {\n          const t = this.callbacks[r];\n          this.cancelCallbacks[r] = this.scheduler.add(() => this.processTask(r, e), t && t.metadata || {\n            type: \"message\"\n          });\n        } else this.processTask(r, e);\n      }\n      processTask(t, e) {\n        if (\"<response>\" === e.type) {\n          const r = this.callbacks[t];\n          delete this.callbacks[t], r && (e.error ? r(Qi(e.error)) : r(null, Qi(e.data)));\n        } else {\n          const r = H(this.globalScope) ? void 0 : [],\n            n = e.hasCallback ? (e, n) => {\n              delete this.cancelCallbacks[t], this.target.postMessage({\n                id: t,\n                type: \"<response>\",\n                sourceMapId: this.mapId,\n                error: e ? Wi(e) : null,\n                data: Wi(n, r)\n              }, r);\n            } : t => {},\n            i = Qi(e.data);\n          if (this.parent[e.type]) this.parent[e.type](e.sourceMapId, i, n);else if (this.parent.getWorkerSource) {\n            const t = e.type.split(\".\");\n            this.parent.getWorkerSource(e.sourceMapId, t[0], i.source)[t[1]](i, n);\n          } else n(new Error(`Could not find function ${e.type}`));\n        }\n      }\n      remove() {\n        this.scheduler.remove(), this.target.removeEventListener(\"message\", this.receive, !1);\n      }\n    }, t.CanonicalTileID = ph, t.Color = Ee, t.ColorMode = Yf, t.CullFaceMode = ty, t.DEMData = Zf, t.DataConstantProperty = Bs, t.DedupedRequest = fy, t.DepthMode = Xf, t.EXTENT = ao, t.Elevation = class {\n      isDataAvailableAtPoint(t) {\n        const e = this._source();\n        if (this.isUsingMockSource() || !e || t.y < 0 || t.y > 1) return !1;\n        const r = e.getSource().maxzoom,\n          n = 1 << r,\n          i = Math.floor(t.x),\n          s = Math.floor((t.x - i) * n),\n          a = Math.floor(t.y * n),\n          o = this.findDEMTileFor(new fh(r, i, r, s, a));\n        return !(!o || !o.dem);\n      }\n      getAtPointOrZero(t, e = 0) {\n        return this.getAtPoint(t, e) || 0;\n      }\n      getAtPoint(t, e, r = !0) {\n        if (this.isUsingMockSource()) return null;\n        null == e && (e = null);\n        const n = this._source();\n        if (!n) return e;\n        if (t.y < 0 || t.y > 1) return e;\n        const i = n.getSource().maxzoom,\n          s = 1 << i,\n          a = Math.floor(t.x),\n          o = t.x - a,\n          l = new fh(i, a, i, Math.floor(o * s), Math.floor(t.y * s)),\n          u = this.findDEMTileFor(l);\n        if (!u || !u.dem) return e;\n        const c = u.dem,\n          h = 1 << u.tileID.canonical.z,\n          p = (o * h - u.tileID.canonical.x) * c.dim,\n          d = (t.y * h - u.tileID.canonical.y) * c.dim,\n          f = Math.floor(p),\n          y = Math.floor(d);\n        return (r ? this.exaggeration() : 1) * Er(Er(c.get(f, y), c.get(f, y + 1), d - y), Er(c.get(f + 1, y), c.get(f + 1, y + 1), d - y), p - f);\n      }\n      getAtTileOffset(t, e, r) {\n        const n = 1 << t.canonical.z;\n        return this.getAtPointOrZero(new Wl(t.wrap + (t.canonical.x + e / ao) / n, (t.canonical.y + r / ao) / n));\n      }\n      getAtTileOffsetFunc(t, e, r, n) {\n        return i => {\n          const s = this.getAtTileOffset(t, i.x, i.y),\n            a = n.upVector(t.canonical, i.x, i.y);\n          return Co(a, a, s * n.upVectorScale(t.canonical, e, r).metersToTile), a;\n        };\n      }\n      getForTilePoints(t, e, r, n) {\n        if (this.isUsingMockSource()) return !1;\n        const i = sy.create(this, t, n);\n        return !!i && (e.forEach(t => {\n          t[2] = this.exaggeration() * i.getElevationAt(t[0], t[1], r);\n        }), !0);\n      }\n      getMinMaxForTile(t) {\n        if (this.isUsingMockSource()) return null;\n        const e = this.findDEMTileFor(t);\n        if (!e || !e.dem) return null;\n        const r = e.dem.tree,\n          n = e.tileID,\n          i = 1 << t.canonical.z - n.canonical.z;\n        let s = t.canonical.x / i - n.canonical.x,\n          a = t.canonical.y / i - n.canonical.y,\n          o = 0;\n        for (let e = 0; e < t.canonical.z - n.canonical.z && !r.leaves[o]; e++) {\n          s *= 2, a *= 2;\n          const t = 2 * Math.floor(a) + Math.floor(s);\n          o = r.childOffsets[o] + t, s %= 1, a %= 1;\n        }\n        return {\n          min: this.exaggeration() * r.minimums[o],\n          max: this.exaggeration() * r.maximums[o]\n        };\n      }\n      getMinElevationBelowMSL() {\n        throw new Error(\"Pure virtual method called.\");\n      }\n      raycast(t, e, r) {\n        throw new Error(\"Pure virtual method called.\");\n      }\n      pointCoordinate(t) {\n        throw new Error(\"Pure virtual method called.\");\n      }\n      _source() {\n        throw new Error(\"Pure virtual method called.\");\n      }\n      isUsingMockSource() {\n        throw new Error(\"Pure virtual method called.\");\n      }\n      exaggeration() {\n        throw new Error(\"Pure virtual method called.\");\n      }\n      findDEMTileFor(t) {\n        throw new Error(\"Pure virtual method called.\");\n      }\n      get visibleDemTiles() {\n        throw new Error(\"Getter must be implemented in subclass.\");\n      }\n    }, t.ErrorEvent = Wt, t.EvaluationParameters = ws, t.Event = Yt, t.Evented = Qt, t.FillExtrusionBucket = th, t.Frustum = nl, t.FrustumCorners = rl, t.GLOBE_RADIUS = ol, t.GLOBE_SCALE_MATCH_LATITUDE = 45, t.GLOBE_ZOOM_THRESHOLD_MAX = al, t.GLOBE_ZOOM_THRESHOLD_MIN = sl, t.GlobeSharedBuffers = class {\n      constructor(t) {\n        this._createGrid(t), this._createPoles(t);\n      }\n      destroy() {\n        this._poleIndexBuffer.destroy(), this._gridBuffer.destroy(), this._gridIndexBuffer.destroy(), this._poleNorthVertexBuffer.destroy(), this._poleSouthVertexBuffer.destroy();\n        for (const t of this._poleSegments) t.destroy();\n        for (const t of this._gridSegments) t.withSkirts.destroy(), t.withoutSkirts.destroy();\n        if (this._wireframeIndexBuffer) {\n          this._wireframeIndexBuffer.destroy();\n          for (const t of this._wireframeSegments) t.destroy();\n        }\n      }\n      _fillGridMeshWithLods(t, e) {\n        const r = new $s(),\n          n = new ra(),\n          i = [],\n          s = t + 1 + 2,\n          a = e[0] + 1,\n          o = e[0] + 1 + (1 + e.length),\n          l = (t, e, r) => {\n            let n = t === s - 1 ? t - 2 : 0 === t ? t : t - 1;\n            return n += r ? 24575 : 0, [n, e];\n          };\n        for (let t = 0; t < s; ++t) r.emplaceBack(...l(t, 0, !0));\n        for (let t = 0; t < a; ++t) for (let e = 0; e < s; ++e) r.emplaceBack(...l(e, t, (0 === e || e === s - 1) && !0));\n        for (let t = 0; t < e.length; ++t) {\n          const n = e[t];\n          for (let t = 0; t < s; ++t) r.emplaceBack(...l(t, n, !0));\n        }\n        for (let t = 0; t < e.length; ++t) {\n          const a = n.length,\n            l = e[t] + 1 + 2,\n            u = new ra();\n          for (let r = 0; r < l - 1; r++) {\n            const i = r === l - 2,\n              a = i ? s * (o - e.length + t - r) : s;\n            for (let t = 0; t < s - 1; t++) {\n              const e = r * s + t;\n              0 === r || i || 0 === t || t === s - 2 ? (u.emplaceBack(e + 1, e, e + a), u.emplaceBack(e + a, e + a + 1, e + 1)) : (n.emplaceBack(e + 1, e, e + a), n.emplaceBack(e + a, e + a + 1, e + 1));\n            }\n          }\n          const c = so.simpleSegment(0, a, r.length, n.length - a);\n          for (let t = 0; t < u.uint16.length; t += 3) n.emplaceBack(u.uint16[t], u.uint16[t + 1], u.uint16[t + 2]);\n          const h = so.simpleSegment(0, a, r.length, n.length - a);\n          i.push({\n            withoutSkirts: c,\n            withSkirts: h\n          });\n        }\n        return {\n          vertices: r,\n          indices: n,\n          segments: i\n        };\n      }\n      _createGrid(t) {\n        const e = this._fillGridMeshWithLods(ul, cl);\n        this._gridSegments = e.segments, this._gridBuffer = t.createVertexBuffer(e.vertices, tl.members), this._gridIndexBuffer = t.createIndexBuffer(e.indices, !0);\n      }\n      _createPoles(t) {\n        const e = new ra();\n        for (let t = 0; t <= ul; t++) e.emplaceBack(0, t + 1, t + 2);\n        this._poleIndexBuffer = t.createIndexBuffer(e, !0);\n        const r = new aa(),\n          n = new aa();\n        this._poleSegments = [];\n        for (let t = 0, e = 0; t < sl; t++) {\n          const i = 360 / (1 << t);\n          r.emplaceBack(0, -ol, 0, .5, 0), n.emplaceBack(0, -ol, 0, .5, 1);\n          for (let t = 0; t <= ul; t++) {\n            const e = t / ul,\n              s = Er(0, i, e),\n              [a, o, l] = kl(Fl, Rl, s, ol);\n            r.emplaceBack(a, o, l, e, 0), n.emplaceBack(a, o, l, e, 1);\n          }\n          this._poleSegments.push(so.simpleSegment(e, 0, 66, 64)), e += 66;\n        }\n        this._poleNorthVertexBuffer = t.createVertexBuffer(r, Wo, !1), this._poleSouthVertexBuffer = t.createVertexBuffer(n, Wo, !1);\n      }\n      getGridBuffers(t, e) {\n        return [this._gridBuffer, this._gridIndexBuffer, e ? this._gridSegments[t].withSkirts : this._gridSegments[t].withoutSkirts];\n      }\n      getPoleBuffers(t) {\n        return [this._poleNorthVertexBuffer, this._poleSouthVertexBuffer, this._poleIndexBuffer, this._poleSegments[t]];\n      }\n      getWirefameBuffers(t, e) {\n        if (!this._wireframeSegments) {\n          const e = new la(),\n            r = ul,\n            n = r + 1 + 2,\n            i = 1;\n          this._wireframeSegments = [];\n          for (let t = 0, s = 0; t < cl.length; t++) {\n            const a = cl[t];\n            for (let t = i; t < a + i; t++) for (let s = i; s < r + i; s++) {\n              const r = t * n + s;\n              e.emplaceBack(r, r + 1), e.emplaceBack(r, r + n), e.emplaceBack(r, r + n + 1);\n            }\n            const o = a * r * 3;\n            this._wireframeSegments.push(so.simpleSegment(0, s, (a + 1) * n, o)), s += o;\n          }\n          this._wireframeIndexBuffer = t.createIndexBuffer(e);\n        }\n        return [this._gridBuffer, this._wireframeIndexBuffer, this._wireframeSegments[e]];\n      }\n    }, t.GlyphManager = rd, t.ImagePosition = Sp, t.KDBush = gy, t.LivePerformanceUtils = $t, t.LngLat = Ol, t.LngLatBounds = oo, t.LocalGlyphMode = ed, t.MAX_MERCATOR_LATITUDE = Hl, t.MercatorCoordinate = Wl, t.ONE_EM = Rh, t.OverscaledTileID = fh, t.PerformanceMarkers = Ut, t.Point = x, t.Properties = Ps, t.RGBAImage = Uu, t.Ray = el, t.RequestManager = class {\n      constructor(t, e, r) {\n        this._transformRequestFn = t, this._customAccessToken = e, this._silenceAuthErrors = !!r, this._createSkuToken();\n      }\n      _createSkuToken() {\n        const t = function () {\n          let t = \"\";\n          for (let e = 0; e < 10; e++) t += \"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"[Math.floor(62 * Math.random())];\n          return {\n            token: [\"1\", h, t].join(\"\"),\n            tokenExpiresAt: Date.now() + 432e5\n          };\n        }();\n        this._skuToken = t.token, this._skuTokenExpiresAt = t.tokenExpiresAt;\n      }\n      _isSkuTokenExpired() {\n        return Date.now() > this._skuTokenExpiresAt;\n      }\n      transformRequest(t, e) {\n        return this._transformRequestFn && this._transformRequestFn(t, e) || {\n          url: t\n        };\n      }\n      normalizeStyleURL(t, e) {\n        if (!vt(t)) return t;\n        const r = kt(t);\n        return r.path = `/styles/v1${r.path}`, this._makeAPIURL(r, this._customAccessToken || e);\n      }\n      normalizeGlyphsURL(t, e) {\n        if (!vt(t)) return t;\n        const r = kt(t);\n        return r.path = `/fonts/v1${r.path}`, this._makeAPIURL(r, this._customAccessToken || e);\n      }\n      normalizeSourceURL(t, e, r, n) {\n        if (!vt(t)) return t;\n        const i = kt(t);\n        return i.path = `/v4/${i.authority}.json`, i.params.push(\"secure\"), r && i.params.push(`language=${r}`), n && i.params.push(`worldview=${n}`), this._makeAPIURL(i, this._customAccessToken || e);\n      }\n      normalizeSpriteURL(t, e, r, n) {\n        const i = kt(t);\n        return vt(t) ? (i.path = `/styles/v1${i.path}/sprite${e}${r}`, this._makeAPIURL(i, this._customAccessToken || n)) : (i.path += `${e}${r}`, It(i));\n      }\n      normalizeTileURL(t, e, r) {\n        if (this._isSkuTokenExpired() && this._createSkuToken(), t && !vt(t)) return t;\n        const n = kt(t);\n        n.path = n.path.replace(/(\\.(png|jpg)\\d*)(?=$)/, `${e || r && \"raster\" !== n.authority && 512 === r ? \"@2x\" : \"\"}${s.supported ? \".webp\" : \"$1\"}`), \"raster\" === n.authority ? n.path = `/${i.RASTER_URL_PREFIX}${n.path}` : (n.path = n.path.replace(/^.+\\/v4\\//, \"/\"), n.path = `/${i.TILE_URL_VERSION}${n.path}`);\n        const a = this._customAccessToken || function (t) {\n          for (const e of t) {\n            const t = e.match(/^access_token=(.*)$/);\n            if (t) return t[1];\n          }\n          return null;\n        }(n.params) || i.ACCESS_TOKEN;\n        return i.REQUIRE_ACCESS_TOKEN && a && this._skuToken && n.params.push(`sku=${this._skuToken}`), this._makeAPIURL(n, a);\n      }\n      canonicalizeTileURL(t, e) {\n        const r = kt(t);\n        if (!r.path.match(/^(\\/v4\\/|\\/raster\\/v1\\/)/) || !r.path.match(/\\.[\\w]+$/)) return t;\n        let n = \"mapbox://\";\n        r.path.match(/^\\/raster\\/v1\\//) ? n += `raster/${r.path.replace(`/${i.RASTER_URL_PREFIX}/`, \"\")}` : n += `tiles/${r.path.replace(`/${i.TILE_URL_VERSION}/`, \"\")}`;\n        let s = r.params;\n        return e && (s = s.filter(t => !t.match(/^access_token=/))), s.length && (n += `?${s.join(\"&\")}`), n;\n      }\n      canonicalizeTileset(t, e) {\n        const r = !!e && vt(e),\n          n = [];\n        for (const e of t.tiles || []) bt(e) ? n.push(this.canonicalizeTileURL(e, r)) : n.push(e);\n        return n;\n      }\n      _makeAPIURL(t, e) {\n        const r = \"See https://docs.mapbox.com/api/overview/#access-tokens-and-token-scopes\",\n          n = kt(i.API_URL);\n        if (t.protocol = n.protocol, t.authority = n.authority, \"http\" === t.protocol) {\n          const e = t.params.indexOf(\"secure\");\n          e >= 0 && t.params.splice(e, 1);\n        }\n        if (\"/\" !== n.path && (t.path = `${n.path}${t.path}`), !i.REQUIRE_ACCESS_TOKEN) return It(t);\n        if (e = e || i.ACCESS_TOKEN, !this._silenceAuthErrors) {\n          if (!e) throw new Error(`An API access token is required to use Mapbox GL. ${r}`);\n          if (\"s\" === e[0]) throw new Error(`Use a public access token (pk.*) with Mapbox GL, not a secret access token (sk.*). ${r}`);\n        }\n        return t.params = t.params.filter(t => -1 === t.indexOf(\"access_token\")), t.params.push(`access_token=${e || \"\"}`), It(t);\n      }\n    }, t.ResourceType = lt, t.SegmentVector = so, t.SourceCache = ey, t.StencilMode = Hf, t.StructArrayLayout1ui2 = ua, t.StructArrayLayout2f1f2i16 = Qs, t.StructArrayLayout2i4 = $s, t.StructArrayLayout2ui4 = la, t.StructArrayLayout3f12 = ea, t.StructArrayLayout3ui6 = ra, t.StructArrayLayout4i8 = Os, t.StructArrayLayout5f20 = aa, t.Texture = xf, t.Tile = Pf, t.Transitionable = Ss, t.Uniform1f = La, t.Uniform1i = class extends Va {\n      constructor(t) {\n        super(t), this.current = 0;\n      }\n      set(t, e, r) {\n        this.fetchUniformLocation(t, e) && this.current !== r && (this.current = r, this.gl.uniform1i(this.location, r));\n      }\n    }, t.Uniform2f = class extends Va {\n      constructor(t) {\n        super(t), this.current = [0, 0];\n      }\n      set(t, e, r) {\n        this.fetchUniformLocation(t, e) && (r[0] === this.current[0] && r[1] === this.current[1] || (this.current = r, this.gl.uniform2f(this.location, r[0], r[1])));\n      }\n    }, t.Uniform3f = class extends Va {\n      constructor(t) {\n        super(t), this.current = [0, 0, 0];\n      }\n      set(t, e, r) {\n        this.fetchUniformLocation(t, e) && (r[0] === this.current[0] && r[1] === this.current[1] && r[2] === this.current[2] || (this.current = r, this.gl.uniform3f(this.location, r[0], r[1], r[2])));\n      }\n    }, t.Uniform4f = Fa, t.UniformColor = Ra, t.UniformMatrix2f = class extends Va {\n      constructor(t) {\n        super(t), this.current = ja;\n      }\n      set(t, e, r) {\n        if (this.fetchUniformLocation(t, e)) for (let t = 0; t < 4; t++) if (r[t] !== this.current[t]) {\n          this.current = r, this.gl.uniformMatrix2fv(this.location, !1, r);\n          break;\n        }\n      }\n    }, t.UniformMatrix3f = class extends Va {\n      constructor(t) {\n        super(t), this.current = $a;\n      }\n      set(t, e, r) {\n        if (this.fetchUniformLocation(t, e)) for (let t = 0; t < 9; t++) if (r[t] !== this.current[t]) {\n          this.current = r, this.gl.uniformMatrix3fv(this.location, !1, r);\n          break;\n        }\n      }\n    }, t.UniformMatrix4f = class extends Va {\n      constructor(t) {\n        super(t), this.current = Ua;\n      }\n      set(t, e, r) {\n        if (this.fetchUniformLocation(t, e)) {\n          if (r[12] !== this.current[12] || r[0] !== this.current[0]) return this.current = r, void this.gl.uniformMatrix4fv(this.location, !1, r);\n          for (let t = 1; t < 16; t++) if (r[t] !== this.current[t]) {\n            this.current = r, this.gl.uniformMatrix4fv(this.location, !1, r);\n            break;\n          }\n        }\n      }\n    }, t.UnwrappedTileID = dh, t.ValidationError = ri, t.VectorTileFeature = Kc, t.VectorTileWorkerSource = class extends Qt {\n      constructor(t, e, r, n, i) {\n        super(), this.actor = t, this.layerIndex = e, this.availableImages = r, this.loadVectorData = i || yy, this.loading = {}, this.loaded = {}, this.deduped = new fy(t.scheduler), this.isSpriteLoaded = n, this.scheduler = t.scheduler;\n      }\n      loadTile(t, e) {\n        const r = t.uid,\n          n = t && t.request,\n          i = n && n.collectResourceTiming,\n          s = this.loading[r] = new py(t);\n        s.abort = this.loadVectorData(t, (a, o) => {\n          const l = !this.loading[r];\n          if (delete this.loading[r], l || a || !o) return s.status = \"done\", l || (this.loaded[r] = s), e(a);\n          const u = o.rawData,\n            c = {};\n          o.expires && (c.expires = o.expires), o.cacheControl && (c.cacheControl = o.cacheControl), s.vectorTile = o.vectorTile || new Zc(new mp(u));\n          const h = () => {\n            s.parse(s.vectorTile, this.layerIndex, this.availableImages, this.actor, (t, r) => {\n              if (t || !r) return e(t);\n              const s = {};\n              if (i) {\n                const t = qt(n);\n                t.length > 0 && (s.resourceTiming = JSON.parse(JSON.stringify(t)));\n              }\n              e(null, C({\n                rawTileData: u.slice(0)\n              }, r, c, s));\n            });\n          };\n          this.isSpriteLoaded ? h() : this.once(\"isSpriteLoaded\", () => {\n            this.scheduler ? this.scheduler.add(h, {\n              type: \"parseTile\",\n              isSymbolTile: t.isSymbolTile,\n              zoom: t.tileZoom\n            }) : h();\n          }), this.loaded = this.loaded || {}, this.loaded[r] = s;\n        });\n      }\n      reloadTile(t, e) {\n        const r = this.loaded,\n          n = t.uid,\n          i = this;\n        if (r && r[n]) {\n          const s = r[n];\n          s.showCollisionBoxes = t.showCollisionBoxes, s.enableTerrain = !!t.enableTerrain, s.projection = t.projection, s.tileTransform = Bd(t.tileID.canonical, t.projection);\n          const a = (t, r) => {\n            const n = s.reloadCallback;\n            n && (delete s.reloadCallback, s.parse(s.vectorTile, i.layerIndex, this.availableImages, i.actor, n)), e(t, r);\n          };\n          \"parsing\" === s.status ? s.reloadCallback = a : \"done\" === s.status && (s.vectorTile ? s.parse(s.vectorTile, this.layerIndex, this.availableImages, this.actor, a) : a());\n        }\n      }\n      abortTile(t, e) {\n        const r = t.uid,\n          n = this.loading[r];\n        n && (n.abort && n.abort(), delete this.loading[r]), e();\n      }\n      removeTile(t, e) {\n        const r = this.loaded,\n          n = t.uid;\n        r && r[n] && delete r[n], e();\n      }\n    }, t.WritingMode = Ip, t.ZoomDependentExpression = Wn, t.add = Mo, t.addDynamicAttributes = rf, t.adjoint = function (t, e) {\n      var r = e[0],\n        n = e[1],\n        i = e[2],\n        s = e[3],\n        a = e[4],\n        o = e[5],\n        l = e[6],\n        u = e[7],\n        c = e[8];\n      return t[0] = a * c - o * u, t[1] = i * u - n * c, t[2] = n * o - i * a, t[3] = o * l - s * c, t[4] = r * c - i * l, t[5] = i * s - r * o, t[6] = s * u - a * l, t[7] = n * l - r * u, t[8] = r * a - n * s, t;\n    }, t.asyncAll = B, t.bezier = k, t.bindAll = R, t.boundsAttributes = Ef, t.bufferConvexPolygon = function (t, e) {\n      const r = [];\n      for (let n = 0; n < t.length; n++) {\n        const i = z(n - 1, -1, t.length - 1),\n          s = z(n + 1, -1, t.length - 1),\n          a = t[n],\n          o = t[s],\n          l = t[i].sub(a).unit(),\n          u = o.sub(a).unit(),\n          c = u.angleWithSep(l.x, l.y),\n          h = l.add(u).unit().mult(-1 * e / Math.sin(c / 2));\n        r.push(a.add(h));\n      }\n      return r;\n    }, t.cacheEntryPossiblyAdded = function (t) {\n      ot++, ot > et && (t.getActor().send(\"enforceCacheSizeLimit\", tt), ot = 0);\n    }, t.calculateGlobeLabelMatrix = function (t, e) {\n      const {\n          x: r,\n          y: n\n        } = t.point,\n        i = Cl(r, n, t.worldSize / t._pixelsPerMercatorPixel, 0, 0);\n      return yo(i, i, El(xl(e)));\n    }, t.calculateGlobeMatrix = function (t) {\n      const {\n          x: e,\n          y: r\n        } = t.point,\n        {\n          lng: n,\n          lat: i\n        } = t._center;\n      return Cl(e, r, t.worldSize, n, i);\n    }, t.calculateGlobeMercatorMatrix = function (t) {\n      const e = t.pixelsPerMeter,\n        r = e / Zl(1, t.center.lat),\n        n = po(new Float64Array(16));\n      return mo(n, n, [t.point.x, t.point.y, 0]), go(n, n, [r, r, e]), Float32Array.from(n);\n    }, t.circumferenceAtLatitude = ql, t.clamp = M, t.clearTileCache = function (t) {\n      if (!it()) return;\n      const r = e.caches.delete(Q);\n      t && r.catch(t).then(() => t());\n    }, t.clipLine = Hp, t.clone = function (t) {\n      var e = new uo(16);\n      return e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e[4] = t[4], e[5] = t[5], e[6] = t[6], e[7] = t[7], e[8] = t[8], e[9] = t[9], e[10] = t[10], e[11] = t[11], e[12] = t[12], e[13] = t[13], e[14] = t[14], e[15] = t[15], e;\n    }, t.clone$1 = O, t.collisionCircleLayout = Fh, t.config = i, t.conjugate = function (t, e) {\n      return t[0] = -e[0], t[1] = -e[1], t[2] = -e[2], t[3] = e[3], t;\n    }, t.create = function () {\n      var t = new uo(16);\n      return uo != Float32Array && (t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0), t[0] = 1, t[5] = 1, t[10] = 1, t[15] = 1, t;\n    }, t.create$1 = co, t.createExpression = Hn, t.createLayout = Rs, t.createStyleLayer = function (t) {\n      return \"custom\" === t.type ? new ff(t) : new gf[t.type](t);\n    }, t.cross = Lo, t.degToRad = w, t.distance = function (t, e) {\n      return Math.hypot(e[0] - t[0], e[1] - t[1], e[2] - t[2]);\n    }, t.div = function (t, e, r) {\n      return t[0] = e[0] / r[0], t[1] = e[1] / r[1], t[2] = e[2] / r[2], t;\n    }, t.dot = Vo, t.earthRadius = Ul, t.ease = I, t.easeCubicInOut = S, t.ecefToLatLng = function ([t, e, r]) {\n      const n = Math.hypot(t, e, r),\n        i = Math.atan2(t, r),\n        s = .5 * Math.PI - Math.acos(-e / n);\n      return new Ol(_(i), _(s));\n    }, t.emitValidationErrors = qi, t.endsWith = U, t.enforceCacheSizeLimit = function (t) {\n      st(), rt && rt.then(e => {\n        e.keys().then(r => {\n          for (let n = 0; n < r.length - t; n++) e.delete(r[n]);\n        });\n      });\n    }, t.evaluateSizeForFeature = jh, t.evaluateSizeForZoom = Oh, t.evaluateVariableOffset = xd, t.evented = gs, t.exactEquals = function (t, e) {\n      return t[0] === e[0] && t[1] === e[1] && t[2] === e[2] && t[3] === e[3];\n    }, t.exactEquals$1 = function (t, e) {\n      return t[0] === e[0] && t[1] === e[1] && t[2] === e[2];\n    }, t.exported = Xt, t.exported$1 = s, t.extend = C, t.extend$1 = ee, t.fillExtrusionHeightLift = oh, t.filterObject = j, t.fromMat4 = function (t, e) {\n      return t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[4], t[4] = e[5], t[5] = e[6], t[6] = e[8], t[7] = e[9], t[8] = e[10], t;\n    }, t.fromQuat = function (t, e) {\n      var r = e[0],\n        n = e[1],\n        i = e[2],\n        s = e[3],\n        a = r + r,\n        o = n + n,\n        l = i + i,\n        u = r * a,\n        c = n * a,\n        h = n * o,\n        p = i * a,\n        d = i * o,\n        f = i * l,\n        y = s * a,\n        m = s * o,\n        g = s * l;\n      return t[0] = 1 - h - f, t[1] = c + g, t[2] = p - m, t[3] = 0, t[4] = c - g, t[5] = 1 - u - f, t[6] = d + y, t[7] = 0, t[8] = p + m, t[9] = d - y, t[10] = 1 - u - h, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, t;\n    }, t.fromRotation = function (t, e) {\n      var r = Math.sin(e),\n        n = Math.cos(e);\n      return t[0] = n, t[1] = r, t[2] = 0, t[3] = -r, t[4] = n, t[5] = 0, t[6] = 0, t[7] = 0, t[8] = 1, t;\n    }, t.fromScaling = bo, t.furthestTileCorner = function (t) {\n      const e = Math.round((t + 45 + 360) % 360 / 90) % 4;\n      return A[e];\n    }, t.getAABBPointSquareDist = function (t, e, r) {\n      let n = 0;\n      for (let i = 0; i < 2; ++i) {\n        const s = r ? r[i] : 0;\n        t[i] > s && (n += (t[i] - s) * (t[i] - s)), e[i] < s && (n += (s - e[i]) * (s - e[i]));\n      }\n      return n;\n    }, t.getAnchorAlignment = Rp, t.getAnchorJustification = bd, t.getBounds = function (t) {\n      let e = 1 / 0,\n        r = 1 / 0,\n        n = -1 / 0,\n        i = -1 / 0;\n      for (const s of t) e = Math.min(e, s.x), r = Math.min(r, s.y), n = Math.max(n, s.x), i = Math.max(i, s.y);\n      return {\n        min: new x(e, r),\n        max: new x(n, i)\n      };\n    }, t.getColumn = W, t.getDefaultExportFromCjs = p, t.getGridMatrix = function (t, e, r, n) {\n      const i = e.getNorth(),\n        s = e.getSouth(),\n        a = e.getWest(),\n        o = e.getEast(),\n        l = 1 << t.z,\n        u = o - a,\n        c = i - s,\n        h = u / ul,\n        p = -c / cl[r],\n        d = [0, h, 0, p, 0, 0, i, a, 0];\n      if (t.z > 0) {\n        const t = 180 / n;\n        ho(d, d, [t / u + 1, 0, 0, 0, t / c + 1, 0, -.5 * t / h, .5 * t / p, 1]);\n      }\n      return d[2] = l, d[5] = t.x, d[8] = t.y, d;\n    }, t.getImage = gt, t.getJSON = function (t, e) {\n      return ht(C(t, {\n        type: \"json\"\n      }), e);\n    }, t.getLatitudinalLod = function (t) {\n      const e = Hl - 5;\n      t = M(t, -e, e) / e * 90;\n      const r = Math.pow(Math.abs(Math.sin(w(t))), 3);\n      return Math.round(r * (cl.length - 1));\n    }, t.getMapSessionAPI = Ft, t.getPerformanceMeasurement = qt, t.getProjection = Yd, t.getRTLTextPluginStatus = xs, t.getReferrer = ct, t.getTilePoint = function (t, {\n      x: e,\n      y: r\n    }, n = 0) {\n      return new x(((e - n) * t.scale - t.x) * ao, (r * t.scale - t.y) * ao);\n    }, t.getTileVec3 = function (t, e, r = 0) {\n      return Io(((e.x - r) * t.scale - t.x) * ao, (e.y * t.scale - t.y) * ao, Jl(e.z, e.y));\n    }, t.getVideo = function (t, r) {\n      const n = e.document.createElement(\"video\");\n      n.muted = !0, n.onloadstart = function () {\n        r(null, n);\n      };\n      for (let r = 0; r < t.length; r++) {\n        const i = e.document.createElement(\"source\");\n        dt(t[r]) || (n.crossOrigin = \"Anonymous\"), i.src = t[r], n.appendChild(i);\n      }\n      return {\n        cancel: () => {}\n      };\n    }, t.globeCenterToScreenPoint = function (t) {\n      const e = [0, 0, 0],\n        r = po(new Float64Array(16));\n      return yo(r, t.pixelMatrix, t.globeMatrix), Fo(e, e, r), new x(e[0], e[1]);\n    }, t.globeDenormalizeECEF = El, t.globeECEFOrigin = function (t, e) {\n      const r = [0, 0, 0];\n      return Fo(r, r, Bl(xl(e.canonical))), Fo(r, r, t), r;\n    }, t.globeMetersToEcef = fl, t.globeNormalizeECEF = Bl, t.globePixelsToTileUnits = function (t, e) {\n      return ao / (512 * Math.pow(2, t)) * Tl(xl(e));\n    }, t.globePoleMatrixForTile = function (t, e, r) {\n      const n = po(new Float64Array(16)),\n        i = (e / (1 << t) - .5) * Math.PI * 2;\n      return vo(n, r.globeMatrix, i), Float32Array.from(n);\n    }, t.globeTileBounds = xl, t.globeTiltAtLngLat = Dl, t.globeToMercatorTransition = Pl, t.globeUseCustomAntiAliasing = function (t, e, r) {\n      const n = Pl(r.zoom),\n        i = t.style.map._antialias,\n        s = !!e.extStandardDerivatives,\n        a = e.extStandardDerivativesForceOff || t.terrain && t.terrain.exaggeration() > 0;\n      return 0 === n && !i && !a && s;\n    }, t.identity = po, t.identity$1 = Ko, t.invert = fo, t.isFullscreen = function () {\n      return !!e.document.fullscreenElement || !!e.document.webkitFullscreenElement;\n    }, t.isLngLatBehindGlobe = Vl, t.isMapAuthenticated = function (t) {\n      return Rt.has(t);\n    }, t.isMapboxURL = vt, t.isSafariWithAntialiasingBug = function (t) {\n      const e = t.navigator ? t.navigator.userAgent : null;\n      return !!H(t) && e && (e.match(\"Version/15.4\") || e.match(\"Version/15.5\") || e.match(/CPU (OS|iPhone OS) (15_4|15_5) like Mac OS X/));\n    }, t.latFromMercatorY = Xl, t.latLngToECEF = Il, t.len = Oo, t.length = ko, t.length$1 = function (t) {\n      return Math.hypot(t[0], t[1], t[2], t[3]);\n    }, t.lngFromMercatorX = Kl, t.loadVectorTile = yy, t.makeRequest = ht, t.mapValue = function (t, e, r, n, i) {\n      return M((t - e) / (r - e) * (i - n) + n, n, i);\n    }, t.mercatorScale = Yl, t.mercatorXfromLng = Nl, t.mercatorYfromLat = Gl, t.mercatorZfromAltitude = Zl, t.mul = _o, t.mul$1 = jo, t.multiply = yo, t.multiply$1 = ho, t.multiply$2 = zo, t.nextPowerOfTwo = L, t.normalize = Do, t.normalize$1 = Ho, t.normalize$2 = No, t.number = Er, t.ortho = function (t, e, r, n, i, s, a) {\n      var o = 1 / (e - r),\n        l = 1 / (n - i),\n        u = 1 / (s - a);\n      return t[0] = -2 * o, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = -2 * l, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[10] = 2 * u, t[11] = 0, t[12] = (e + r) * o, t[13] = (i + n) * l, t[14] = (a + s) * u, t[15] = 1, t;\n    }, t.pbf = Xh, t.perspective = function (t, e, r, n, i) {\n      var s,\n        a = 1 / Math.tan(e / 2);\n      return t[0] = a / r, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = a, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[11] = -1, t[12] = 0, t[13] = 0, t[15] = 0, null != i && i !== 1 / 0 ? (t[10] = (i + n) * (s = 1 / (n - i)), t[14] = 2 * i * n * s) : (t[10] = -1, t[14] = -2 * n), t;\n    }, t.pick = function (t, e) {\n      const r = {};\n      for (let n = 0; n < e.length; n++) {\n        const i = e[n];\n        i in t && (r[i] = t[i]);\n      }\n      return r;\n    }, t.plugin = bs, t.pointGeometry = m, t.polesInViewport = function (t) {\n      const e = po(new Float64Array(16));\n      yo(e, t.pixelMatrix, t.globeMatrix);\n      const r = [0, hl, 0],\n        n = [0, pl, 0];\n      return Fo(r, r, e), Fo(n, n, e), [r[0] > 0 && r[0] <= t.width && r[1] > 0 && r[1] <= t.height && !Vl(t, new Ol(t.center.lat, 90)), n[0] > 0 && n[0] <= t.width && n[1] > 0 && n[1] <= t.height && !Vl(t, new Ol(t.center.lat, -90))];\n    }, t.polygonContainsPoint = bu, t.polygonIntersectsBox = wu, t.polygonIntersectsPolygon = hu, t.polygonizeBounds = function (t, e, r = 0, n = !0) {\n      const i = new x(r, r),\n        s = t.sub(i),\n        a = e.add(i),\n        o = [s, new x(a.x, s.y), a, new x(s.x, a.y)];\n      return n && o.push(s.clone()), o;\n    }, t.posAttributes = tl, t.postMapLoadEvent = Pt, t.postPerformanceEvent = Vt, t.postTurnstileEvent = Et, t.potpack = _p, t.prevPowerOfTwo = function (t) {\n      return t <= 1 ? 1 : Math.pow(2, Math.floor(Math.log(t) / Math.LN2));\n    }, t.radToDeg = _, t.refProperties = [\"type\", \"source\", \"source-layer\", \"minzoom\", \"maxzoom\", \"filter\", \"layout\"], t.registerForPluginStateChange = function (t) {\n      return t({\n        pluginStatus: ds,\n        pluginURL: fs\n      }), gs.on(\"pluginStateChange\", t), t;\n    }, t.removeAuthState = function (t) {\n      Rt.delete(t);\n    }, t.renderColorRamp = ju, t.resample = tu, t.rotateX = xo, t.rotateX$1 = Xo, t.rotateY = vo, t.rotateY$1 = Jo, t.rotateZ = function (t, e, r) {\n      var n = Math.sin(r),\n        i = Math.cos(r),\n        s = e[0],\n        a = e[1],\n        o = e[2],\n        l = e[3],\n        u = e[4],\n        c = e[5],\n        h = e[6],\n        p = e[7];\n      return e !== t && (t[8] = e[8], t[9] = e[9], t[10] = e[10], t[11] = e[11], t[12] = e[12], t[13] = e[13], t[14] = e[14], t[15] = e[15]), t[0] = s * i + u * n, t[1] = a * i + c * n, t[2] = o * i + h * n, t[3] = l * i + p * n, t[4] = u * i - s * n, t[5] = c * i - a * n, t[6] = h * i - o * n, t[7] = p * i - l * n, t;\n    }, t.rotateZ$1 = function (t, e, r) {\n      r *= .5;\n      var n = e[0],\n        i = e[1],\n        s = e[2],\n        a = e[3],\n        o = Math.sin(r),\n        l = Math.cos(r);\n      return t[0] = n * l + i * o, t[1] = i * l - n * o, t[2] = s * l + a * o, t[3] = a * l - s * o, t;\n    }, t.scale = go, t.scale$1 = qo, t.scale$2 = Co, t.scaleAndAdd = Po, t.set = function (t, e, r, n) {\n      return t[0] = e, t[1] = r, t[2] = n, t;\n    }, t.setCacheLimits = function (t, e) {\n      tt = t, et = e;\n    }, t.setColumn = function (t, e, r) {\n      t[4 * e + 0] = r[0], t[4 * e + 1] = r[1], t[4 * e + 2] = r[2], t[4 * e + 3] = r[3];\n    }, t.setRTLTextPlugin = function (t, e, r = !1) {\n      if (ds === us || ds === cs || ds === hs) throw new Error(\"setRTLTextPlugin cannot be called multiple times.\");\n      fs = Xt.resolveURL(t), ds = us, ps = e, ms(), r || vs();\n    }, t.smoothstep = T, t.spec = te, t.squaredLength = function (t) {\n      var e = t[0],\n        r = t[1],\n        n = t[2];\n      return e * e + r * r + n * n;\n    }, t.storeAuthState = function (t, e) {\n      e ? Rt.add(t) : Rt.delete(t);\n    }, t.sub = $o, t.subtract = To, t.symbolSize = qh, t.tileAABB = function (t, e, r, n, i, s, a, o, l) {\n      if (\"globe\" === l.name) return _l(t, e, new ph(r, n, i));\n      const u = Bd({\n        z: r,\n        x: n,\n        y: i\n      }, l);\n      return new il([(s + u.x / u.scale) * e, e * (u.y / u.scale), a], [(s + u.x2 / u.scale) * e, e * (u.y2 / u.scale), o]);\n    }, t.tileCornersToBounds = Al, t.tileTransform = Bd, t.transformMat3 = function (t, e, r) {\n      var n = e[0],\n        i = e[1],\n        s = e[2];\n      return t[0] = n * r[0] + i * r[3] + s * r[6], t[1] = n * r[1] + i * r[4] + s * r[7], t[2] = n * r[2] + i * r[5] + s * r[8], t;\n    }, t.transformMat4 = Fo, t.transformMat4$1 = Go, t.transformQuat = Ro, t.transitionTileAABBinECEF = bl, t.translate = mo, t.transpose = function (t, e) {\n      if (t === e) {\n        var r = e[1],\n          n = e[2],\n          i = e[5];\n        t[1] = e[3], t[2] = e[6], t[3] = r, t[5] = e[7], t[6] = n, t[7] = i;\n      } else t[0] = e[0], t[1] = e[3], t[2] = e[6], t[3] = e[1], t[4] = e[4], t[5] = e[7], t[6] = e[2], t[7] = e[5], t[8] = e[8];\n      return t;\n    }, t.triggerPluginCompletionEvent = ys, t.uniqueId = D, t.updateGlobeVertexNormal = function (t, e, r, n, i) {\n      const s = 5 * e + 2;\n      t.float32[s + 0] = r, t.float32[s + 1] = n, t.float32[s + 2] = i;\n    }, t.validateCustomStyleLayer = function (t) {\n      const e = [],\n        r = t.id;\n      return void 0 === r && e.push({\n        message: `layers.${r}: missing required property \"id\"`\n      }), void 0 === t.render && e.push({\n        message: `layers.${r}: missing required method \"render\"`\n      }), t.renderingMode && \"2d\" !== t.renderingMode && \"3d\" !== t.renderingMode && e.push({\n        message: `layers.${r}: property \"renderingMode\" must be either \"2d\" or \"3d\"`\n      }), e;\n    }, t.validateFilter = t => Oi(Ai(t)), t.validateFog = t => Oi(Vi(t)), t.validateLayer = t => Oi(Ti(t)), t.validateLight = t => Oi(Pi(t)), t.validateSource = t => Oi(Ei(t)), t.validateStyle = Ui, t.validateTerrain = t => Oi(Di(t)), t.values = E, t.vectorTile = Dc, t.version = r, t.warnOnce = N, t.window = e, t.wrap = z;\n  });\n  define([\"./shared\"], function (e) {\n    \"use strict\";\n\n    function t(e) {\n      if (\"number\" == typeof e || \"boolean\" == typeof e || \"string\" == typeof e || null == e) return JSON.stringify(e);\n      if (Array.isArray(e)) {\n        let r = \"[\";\n        for (const o of e) r += `${t(o)},`;\n        return `${r}]`;\n      }\n      let r = \"{\";\n      for (const o of Object.keys(e).sort()) r += `${o}:${t(e[o])},`;\n      return `${r}}`;\n    }\n    function r(r) {\n      let o = \"\";\n      for (const i of e.refProperties) o += `/${t(r[i])}`;\n      return o;\n    }\n    class o {\n      constructor(e) {\n        this.keyCache = {}, e && this.replace(e);\n      }\n      replace(e) {\n        this._layerConfigs = {}, this._layers = {}, this.update(e, []);\n      }\n      update(t, o) {\n        for (const r of t) this._layerConfigs[r.id] = r, (this._layers[r.id] = e.createStyleLayer(r)).compileFilter(), this.keyCache[r.id] && delete this.keyCache[r.id];\n        for (const e of o) delete this.keyCache[e], delete this._layerConfigs[e], delete this._layers[e];\n        this.familiesBySource = {};\n        const i = function (e, t) {\n          const o = {};\n          for (let i = 0; i < e.length; i++) {\n            const n = t && t[e[i].id] || r(e[i]);\n            t && (t[e[i].id] = n);\n            let s = o[n];\n            s || (s = o[n] = []), s.push(e[i]);\n          }\n          const i = [];\n          for (const e in o) i.push(o[e]);\n          return i;\n        }(e.values(this._layerConfigs), this.keyCache);\n        for (const e of i) {\n          const t = e.map(e => this._layers[e.id]),\n            r = t[0];\n          if (\"none\" === r.visibility) continue;\n          const o = r.source || \"\";\n          let i = this.familiesBySource[o];\n          i || (i = this.familiesBySource[o] = {});\n          const n = r.sourceLayer || \"_geojsonTileLayer\";\n          let s = i[n];\n          s || (s = i[n] = []), s.push(t);\n        }\n      }\n    }\n    class i {\n      loadTile(t, r) {\n        const {\n            uid: o,\n            encoding: i,\n            rawImageData: n,\n            padding: s,\n            buildQuadTree: a\n          } = t,\n          l = e.window.ImageBitmap && n instanceof e.window.ImageBitmap ? this.getImageData(n, s) : n;\n        r(null, new e.DEMData(o, l, i, s < 1, a));\n      }\n      getImageData(e, t) {\n        this.offscreenCanvas && this.offscreenCanvasContext || (this.offscreenCanvas = new OffscreenCanvas(e.width, e.height), this.offscreenCanvasContext = this.offscreenCanvas.getContext(\"2d\", {\n          willReadFrequently: !0\n        })), this.offscreenCanvas.width = e.width, this.offscreenCanvas.height = e.height, this.offscreenCanvasContext.drawImage(e, 0, 0, e.width, e.height);\n        const r = this.offscreenCanvasContext.getImageData(-t, -t, e.width + 2 * t, e.height + 2 * t);\n        return this.offscreenCanvasContext.clearRect(0, 0, this.offscreenCanvas.width, this.offscreenCanvas.height), r;\n      }\n    }\n    function n(e, t) {\n      if (0 !== e.length) {\n        s(e[0], t);\n        for (var r = 1; r < e.length; r++) s(e[r], !t);\n      }\n    }\n    function s(e, t) {\n      for (var r = 0, o = 0, i = 0, n = e.length, s = n - 1; i < n; s = i++) {\n        var a = (e[i][0] - e[s][0]) * (e[s][1] + e[i][1]),\n          l = r + a;\n        o += Math.abs(r) >= Math.abs(a) ? r - l + a : a - l + r, r = l;\n      }\n      r + o >= 0 != !!t && e.reverse();\n    }\n    var a = e.getDefaultExportFromCjs(function e(t, r) {\n      var o,\n        i = t && t.type;\n      if (\"FeatureCollection\" === i) for (o = 0; o < t.features.length; o++) e(t.features[o], r);else if (\"GeometryCollection\" === i) for (o = 0; o < t.geometries.length; o++) e(t.geometries[o], r);else if (\"Feature\" === i) e(t.geometry, r);else if (\"Polygon\" === i) n(t.coordinates, r);else if (\"MultiPolygon\" === i) for (o = 0; o < t.coordinates.length; o++) n(t.coordinates[o], r);\n      return t;\n    });\n    const l = e.VectorTileFeature.prototype.toGeoJSON;\n    var u = {\n        exports: {}\n      },\n      h = e.pointGeometry,\n      c = e.vectorTile.VectorTileFeature,\n      f = p;\n    function p(e, t) {\n      this.options = t || {}, this.features = e, this.length = e.length;\n    }\n    function g(e, t) {\n      this.id = \"number\" == typeof e.id ? e.id : void 0, this.type = e.type, this.rawGeometry = 1 === e.type ? [e.geometry] : e.geometry, this.properties = e.tags, this.extent = t || 4096;\n    }\n    p.prototype.feature = function (e) {\n      return new g(this.features[e], this.options.extent);\n    }, g.prototype.loadGeometry = function () {\n      var e = this.rawGeometry;\n      this.geometry = [];\n      for (var t = 0; t < e.length; t++) {\n        for (var r = e[t], o = [], i = 0; i < r.length; i++) o.push(new h(r[i][0], r[i][1]));\n        this.geometry.push(o);\n      }\n      return this.geometry;\n    }, g.prototype.bbox = function () {\n      this.geometry || this.loadGeometry();\n      for (var e = this.geometry, t = 1 / 0, r = -1 / 0, o = 1 / 0, i = -1 / 0, n = 0; n < e.length; n++) for (var s = e[n], a = 0; a < s.length; a++) {\n        var l = s[a];\n        t = Math.min(t, l.x), r = Math.max(r, l.x), o = Math.min(o, l.y), i = Math.max(i, l.y);\n      }\n      return [t, o, r, i];\n    }, g.prototype.toGeoJSON = c.prototype.toGeoJSON;\n    var d = e.pbf,\n      m = f;\n    function y(e) {\n      var t = new d();\n      return function (e, t) {\n        for (var r in e.layers) t.writeMessage(3, v, e.layers[r]);\n      }(e, t), t.finish();\n    }\n    function v(e, t) {\n      var r;\n      t.writeVarintField(15, e.version || 1), t.writeStringField(1, e.name || \"\"), t.writeVarintField(5, e.extent || 4096);\n      var o = {\n        keys: [],\n        values: [],\n        keycache: {},\n        valuecache: {}\n      };\n      for (r = 0; r < e.length; r++) o.feature = e.feature(r), t.writeMessage(2, x, o);\n      var i = o.keys;\n      for (r = 0; r < i.length; r++) t.writeStringField(3, i[r]);\n      var n = o.values;\n      for (r = 0; r < n.length; r++) t.writeMessage(4, b, n[r]);\n    }\n    function x(e, t) {\n      var r = e.feature;\n      void 0 !== r.id && t.writeVarintField(1, r.id), t.writeMessage(2, w, e), t.writeVarintField(3, r.type), t.writeMessage(4, P, r);\n    }\n    function w(e, t) {\n      var r = e.feature,\n        o = e.keys,\n        i = e.values,\n        n = e.keycache,\n        s = e.valuecache;\n      for (var a in r.properties) {\n        var l = r.properties[a],\n          u = n[a];\n        if (null !== l) {\n          void 0 === u && (o.push(a), n[a] = u = o.length - 1), t.writeVarint(u);\n          var h = typeof l;\n          \"string\" !== h && \"boolean\" !== h && \"number\" !== h && (l = JSON.stringify(l));\n          var c = h + \":\" + l,\n            f = s[c];\n          void 0 === f && (i.push(l), s[c] = f = i.length - 1), t.writeVarint(f);\n        }\n      }\n    }\n    function S(e, t) {\n      return (t << 3) + (7 & e);\n    }\n    function M(e) {\n      return e << 1 ^ e >> 31;\n    }\n    function P(e, t) {\n      for (var r = e.loadGeometry(), o = e.type, i = 0, n = 0, s = r.length, a = 0; a < s; a++) {\n        var l = r[a],\n          u = 1;\n        1 === o && (u = l.length), t.writeVarint(S(1, u));\n        for (var h = 3 === o ? l.length - 1 : l.length, c = 0; c < h; c++) {\n          1 === c && 1 !== o && t.writeVarint(S(2, h - 1));\n          var f = l[c].x - i,\n            p = l[c].y - n;\n          t.writeVarint(M(f)), t.writeVarint(M(p)), i += f, n += p;\n        }\n        3 === o && t.writeVarint(S(7, 1));\n      }\n    }\n    function b(e, t) {\n      var r = typeof e;\n      \"string\" === r ? t.writeStringField(1, e) : \"boolean\" === r ? t.writeBooleanField(7, e) : \"number\" === r && (e % 1 != 0 ? t.writeDoubleField(3, e) : e < 0 ? t.writeSVarintField(6, e) : t.writeVarintField(5, e));\n    }\n    u.exports = y, u.exports.fromVectorTileJs = y, u.exports.fromGeojsonVt = function (e, t) {\n      t = t || {};\n      var r = {};\n      for (var o in e) r[o] = new m(e[o].features, t), r[o].name = o, r[o].version = t.version, r[o].extent = t.extent;\n      return y({\n        layers: r\n      });\n    }, u.exports.GeoJSONWrapper = m;\n    var T = e.getDefaultExportFromCjs(u.exports);\n    const k = {\n        minZoom: 0,\n        maxZoom: 16,\n        minPoints: 2,\n        radius: 40,\n        extent: 512,\n        nodeSize: 64,\n        log: !1,\n        generateId: !1,\n        reduce: null,\n        map: e => e\n      },\n      I = Math.fround || (_ = new Float32Array(1), e => (_[0] = +e, _[0]));\n    var _;\n    const C = 3,\n      L = 5,\n      O = 6;\n    class E {\n      constructor(e) {\n        this.options = Object.assign(Object.create(k), e), this.trees = new Array(this.options.maxZoom + 1), this.stride = this.options.reduce ? 7 : 6, this.clusterProps = [];\n      }\n      load(e) {\n        const {\n          log: t,\n          minZoom: r,\n          maxZoom: o\n        } = this.options;\n        t && console.time(\"total time\");\n        const i = `prepare ${e.length} points`;\n        t && console.time(i), this.points = e;\n        const n = [];\n        for (let t = 0; t < e.length; t++) {\n          const r = e[t];\n          if (!r.geometry) continue;\n          const [o, i] = r.geometry.coordinates,\n            s = I(N(o)),\n            a = I(Z(i));\n          n.push(s, a, 1 / 0, t, -1, 1), this.options.reduce && n.push(0);\n        }\n        let s = this.trees[o + 1] = this._createTree(n);\n        t && console.timeEnd(i);\n        for (let e = o; e >= r; e--) {\n          const r = +Date.now();\n          s = this.trees[e] = this._createTree(this._cluster(s, e)), t && console.log(\"z%d: %d clusters in %dms\", e, s.numItems, +Date.now() - r);\n        }\n        return t && console.timeEnd(\"total time\"), this;\n      }\n      getClusters(e, t) {\n        let r = ((e[0] + 180) % 360 + 360) % 360 - 180;\n        const o = Math.max(-90, Math.min(90, e[1]));\n        let i = 180 === e[2] ? 180 : ((e[2] + 180) % 360 + 360) % 360 - 180;\n        const n = Math.max(-90, Math.min(90, e[3]));\n        if (e[2] - e[0] >= 360) r = -180, i = 180;else if (r > i) {\n          const e = this.getClusters([r, o, 180, n], t),\n            s = this.getClusters([-180, o, i, n], t);\n          return e.concat(s);\n        }\n        const s = this.trees[this._limitZoom(t)],\n          a = s.range(N(r), Z(n), N(i), Z(o)),\n          l = s.data,\n          u = [];\n        for (const e of a) {\n          const t = this.stride * e;\n          u.push(l[t + L] > 1 ? j(l, t, this.clusterProps) : this.points[l[t + C]]);\n        }\n        return u;\n      }\n      getChildren(e) {\n        const t = this._getOriginId(e),\n          r = this._getOriginZoom(e),\n          o = \"No cluster with the specified id.\",\n          i = this.trees[r];\n        if (!i) throw new Error(o);\n        const n = i.data;\n        if (t * this.stride >= n.length) throw new Error(o);\n        const s = this.options.radius / (this.options.extent * Math.pow(2, r - 1)),\n          a = i.within(n[t * this.stride], n[t * this.stride + 1], s),\n          l = [];\n        for (const t of a) {\n          const r = t * this.stride;\n          n[r + 4] === e && l.push(n[r + L] > 1 ? j(n, r, this.clusterProps) : this.points[n[r + C]]);\n        }\n        if (0 === l.length) throw new Error(o);\n        return l;\n      }\n      getLeaves(e, t, r) {\n        const o = [];\n        return this._appendLeaves(o, e, t = t || 10, r = r || 0, 0), o;\n      }\n      getTile(e, t, r) {\n        const o = this.trees[this._limitZoom(e)],\n          i = Math.pow(2, e),\n          {\n            extent: n,\n            radius: s\n          } = this.options,\n          a = s / n,\n          l = (r - a) / i,\n          u = (r + 1 + a) / i,\n          h = {\n            features: []\n          };\n        return this._addTileFeatures(o.range((t - a) / i, l, (t + 1 + a) / i, u), o.data, t, r, i, h), 0 === t && this._addTileFeatures(o.range(1 - a / i, l, 1, u), o.data, i, r, i, h), t === i - 1 && this._addTileFeatures(o.range(0, l, a / i, u), o.data, -1, r, i, h), h.features.length ? h : null;\n      }\n      getClusterExpansionZoom(e) {\n        let t = this._getOriginZoom(e) - 1;\n        for (; t <= this.options.maxZoom;) {\n          const r = this.getChildren(e);\n          if (t++, 1 !== r.length) break;\n          e = r[0].properties.cluster_id;\n        }\n        return t;\n      }\n      _appendLeaves(e, t, r, o, i) {\n        const n = this.getChildren(t);\n        for (const t of n) {\n          const n = t.properties;\n          if (n && n.cluster ? i + n.point_count <= o ? i += n.point_count : i = this._appendLeaves(e, n.cluster_id, r, o, i) : i < o ? i++ : e.push(t), e.length === r) break;\n        }\n        return i;\n      }\n      _createTree(t) {\n        const r = new e.KDBush(t.length / this.stride | 0, this.options.nodeSize, Float32Array);\n        for (let e = 0; e < t.length; e += this.stride) r.add(t[e], t[e + 1]);\n        return r.finish(), r.data = t, r;\n      }\n      _addTileFeatures(e, t, r, o, i, n) {\n        for (const s of e) {\n          const e = s * this.stride,\n            a = t[e + L] > 1;\n          let l, u, h;\n          if (a) l = F(t, e, this.clusterProps), u = t[e], h = t[e + 1];else {\n            const r = this.points[t[e + C]];\n            l = r.properties;\n            const [o, i] = r.geometry.coordinates;\n            u = N(o), h = Z(i);\n          }\n          const c = {\n            type: 1,\n            geometry: [[Math.round(this.options.extent * (u * i - r)), Math.round(this.options.extent * (h * i - o))]],\n            tags: l\n          };\n          let f;\n          f = a || this.options.generateId ? t[e + C] : this.points[t[e + C]].id, void 0 !== f && (c.id = f), n.features.push(c);\n        }\n      }\n      _limitZoom(e) {\n        return Math.max(this.options.minZoom, Math.min(Math.floor(+e), this.options.maxZoom + 1));\n      }\n      _cluster(e, t) {\n        const {\n            radius: r,\n            extent: o,\n            reduce: i,\n            minPoints: n\n          } = this.options,\n          s = r / (o * Math.pow(2, t)),\n          a = e.data,\n          l = [],\n          u = this.stride;\n        for (let r = 0; r < a.length; r += u) {\n          if (a[r + 2] <= t) continue;\n          a[r + 2] = t;\n          const o = a[r],\n            h = a[r + 1],\n            c = e.within(a[r], a[r + 1], s),\n            f = a[r + L];\n          let p = f;\n          for (const e of c) {\n            const r = e * u;\n            a[r + 2] > t && (p += a[r + L]);\n          }\n          if (p > f && p >= n) {\n            let e,\n              n = o * f,\n              s = h * f,\n              g = -1;\n            const d = ((r / u | 0) << 5) + (t + 1) + this.points.length;\n            for (const o of c) {\n              const l = o * u;\n              if (a[l + 2] <= t) continue;\n              a[l + 2] = t;\n              const h = a[l + L];\n              n += a[l] * h, s += a[l + 1] * h, a[l + 4] = d, i && (e || (e = this._map(a, r, !0), g = this.clusterProps.length, this.clusterProps.push(e)), i(e, this._map(a, l)));\n            }\n            a[r + 4] = d, l.push(n / p, s / p, 1 / 0, d, -1, p), i && l.push(g);\n          } else {\n            for (let e = 0; e < u; e++) l.push(a[r + e]);\n            if (p > 1) for (const e of c) {\n              const r = e * u;\n              if (!(a[r + 2] <= t)) {\n                a[r + 2] = t;\n                for (let e = 0; e < u; e++) l.push(a[r + e]);\n              }\n            }\n          }\n        }\n        return l;\n      }\n      _getOriginId(e) {\n        return e - this.points.length >> 5;\n      }\n      _getOriginZoom(e) {\n        return (e - this.points.length) % 32;\n      }\n      _map(e, t, r) {\n        if (e[t + L] > 1) {\n          const o = this.clusterProps[e[t + O]];\n          return r ? Object.assign({}, o) : o;\n        }\n        const o = this.points[e[t + C]].properties,\n          i = this.options.map(o);\n        return r && i === o ? Object.assign({}, i) : i;\n      }\n    }\n    function j(e, t, r) {\n      return {\n        type: \"Feature\",\n        id: e[t + C],\n        properties: F(e, t, r),\n        geometry: {\n          type: \"Point\",\n          coordinates: [(o = e[t], 360 * (o - .5)), J(e[t + 1])]\n        }\n      };\n      var o;\n    }\n    function F(e, t, r) {\n      const o = e[t + L],\n        i = o >= 1e4 ? `${Math.round(o / 1e3)}k` : o >= 1e3 ? Math.round(o / 100) / 10 + \"k\" : o,\n        n = e[t + O],\n        s = -1 === n ? {} : Object.assign({}, r[n]);\n      return Object.assign(s, {\n        cluster: !0,\n        cluster_id: e[t + C],\n        point_count: o,\n        point_count_abbreviated: i\n      });\n    }\n    function N(e) {\n      return e / 360 + .5;\n    }\n    function Z(e) {\n      const t = Math.sin(e * Math.PI / 180),\n        r = .5 - .25 * Math.log((1 + t) / (1 - t)) / Math.PI;\n      return r < 0 ? 0 : r > 1 ? 1 : r;\n    }\n    function J(e) {\n      const t = (180 - 360 * e) * Math.PI / 180;\n      return 360 * Math.atan(Math.exp(t)) / Math.PI - 90;\n    }\n    function z(e, t, r, o) {\n      for (var i, n = o, s = r - t >> 1, a = r - t, l = e[t], u = e[t + 1], h = e[r], c = e[r + 1], f = t + 3; f < r; f += 3) {\n        var p = G(e[f], e[f + 1], l, u, h, c);\n        if (p > n) i = f, n = p;else if (p === n) {\n          var g = Math.abs(f - s);\n          g < a && (i = f, a = g);\n        }\n      }\n      n > o && (i - t > 3 && z(e, t, i, o), e[i + 2] = n, r - i > 3 && z(e, i, r, o));\n    }\n    function G(e, t, r, o, i, n) {\n      var s = i - r,\n        a = n - o;\n      if (0 !== s || 0 !== a) {\n        var l = ((e - r) * s + (t - o) * a) / (s * s + a * a);\n        l > 1 ? (r = i, o = n) : l > 0 && (r += s * l, o += a * l);\n      }\n      return (s = e - r) * s + (a = t - o) * a;\n    }\n    function W(e, t, r, o) {\n      var i = {\n        id: void 0 === e ? null : e,\n        type: t,\n        geometry: r,\n        tags: o,\n        minX: 1 / 0,\n        minY: 1 / 0,\n        maxX: -1 / 0,\n        maxY: -1 / 0\n      };\n      return function (e) {\n        var t = e.geometry,\n          r = e.type;\n        if (\"Point\" === r || \"MultiPoint\" === r || \"LineString\" === r) Y(e, t);else if (\"Polygon\" === r || \"MultiLineString\" === r) for (var o = 0; o < t.length; o++) Y(e, t[o]);else if (\"MultiPolygon\" === r) for (o = 0; o < t.length; o++) for (var i = 0; i < t[o].length; i++) Y(e, t[o][i]);\n      }(i), i;\n    }\n    function Y(e, t) {\n      for (var r = 0; r < t.length; r += 3) e.minX = Math.min(e.minX, t[r]), e.minY = Math.min(e.minY, t[r + 1]), e.maxX = Math.max(e.maxX, t[r]), e.maxY = Math.max(e.maxY, t[r + 1]);\n    }\n    function X(e, t, r, o) {\n      if (t.geometry) {\n        var i = t.geometry.coordinates,\n          n = t.geometry.type,\n          s = Math.pow(r.tolerance / ((1 << r.maxZoom) * r.extent), 2),\n          a = [],\n          l = t.id;\n        if (r.promoteId ? l = t.properties[r.promoteId] : r.generateId && (l = o || 0), \"Point\" === n) V(i, a);else if (\"MultiPoint\" === n) for (var u = 0; u < i.length; u++) V(i[u], a);else if (\"LineString\" === n) D(i, a, s, !1);else if (\"MultiLineString\" === n) {\n          if (r.lineMetrics) {\n            for (u = 0; u < i.length; u++) D(i[u], a = [], s, !1), e.push(W(l, \"LineString\", a, t.properties));\n            return;\n          }\n          $(i, a, s, !1);\n        } else if (\"Polygon\" === n) $(i, a, s, !0);else {\n          if (\"MultiPolygon\" !== n) {\n            if (\"GeometryCollection\" === n) {\n              for (u = 0; u < t.geometry.geometries.length; u++) X(e, {\n                id: l,\n                geometry: t.geometry.geometries[u],\n                properties: t.properties\n              }, r, o);\n              return;\n            }\n            throw new Error(\"Input data is not a valid GeoJSON object.\");\n          }\n          for (u = 0; u < i.length; u++) {\n            var h = [];\n            $(i[u], h, s, !0), a.push(h);\n          }\n        }\n        e.push(W(l, n, a, t.properties));\n      }\n    }\n    function V(e, t) {\n      t.push(A(e[0])), t.push(B(e[1])), t.push(0);\n    }\n    function D(e, t, r, o) {\n      for (var i, n, s = 0, a = 0; a < e.length; a++) {\n        var l = A(e[a][0]),\n          u = B(e[a][1]);\n        t.push(l), t.push(u), t.push(0), a > 0 && (s += o ? (i * u - l * n) / 2 : Math.sqrt(Math.pow(l - i, 2) + Math.pow(u - n, 2))), i = l, n = u;\n      }\n      var h = t.length - 3;\n      t[2] = 1, z(t, 0, h, r), t[h + 2] = 1, t.size = Math.abs(s), t.start = 0, t.end = t.size;\n    }\n    function $(e, t, r, o) {\n      for (var i = 0; i < e.length; i++) {\n        var n = [];\n        D(e[i], n, r, o), t.push(n);\n      }\n    }\n    function A(e) {\n      return e / 360 + .5;\n    }\n    function B(e) {\n      var t = Math.sin(e * Math.PI / 180),\n        r = .5 - .25 * Math.log((1 + t) / (1 - t)) / Math.PI;\n      return r < 0 ? 0 : r > 1 ? 1 : r;\n    }\n    function R(e, t, r, o, i, n, s, a) {\n      if (o /= t, n >= (r /= t) && s < o) return e;\n      if (s < r || n >= o) return null;\n      for (var l = [], u = 0; u < e.length; u++) {\n        var h = e[u],\n          c = h.geometry,\n          f = h.type,\n          p = 0 === i ? h.minX : h.minY,\n          g = 0 === i ? h.maxX : h.maxY;\n        if (p >= r && g < o) l.push(h);else if (!(g < r || p >= o)) {\n          var d = [];\n          if (\"Point\" === f || \"MultiPoint\" === f) q(c, d, r, o, i);else if (\"LineString\" === f) Q(c, d, r, o, i, !1, a.lineMetrics);else if (\"MultiLineString\" === f) K(c, d, r, o, i, !1);else if (\"Polygon\" === f) K(c, d, r, o, i, !0);else if (\"MultiPolygon\" === f) for (var m = 0; m < c.length; m++) {\n            var y = [];\n            K(c[m], y, r, o, i, !0), y.length && d.push(y);\n          }\n          if (d.length) {\n            if (a.lineMetrics && \"LineString\" === f) {\n              for (m = 0; m < d.length; m++) l.push(W(h.id, f, d[m], h.tags));\n              continue;\n            }\n            \"LineString\" !== f && \"MultiLineString\" !== f || (1 === d.length ? (f = \"LineString\", d = d[0]) : f = \"MultiLineString\"), \"Point\" !== f && \"MultiPoint\" !== f || (f = 3 === d.length ? \"Point\" : \"MultiPoint\"), l.push(W(h.id, f, d, h.tags));\n          }\n        }\n      }\n      return l.length ? l : null;\n    }\n    function q(e, t, r, o, i) {\n      for (var n = 0; n < e.length; n += 3) {\n        var s = e[n + i];\n        s >= r && s <= o && (t.push(e[n]), t.push(e[n + 1]), t.push(e[n + 2]));\n      }\n    }\n    function Q(e, t, r, o, i, n, s) {\n      for (var a, l, u = U(e), h = 0 === i ? ee : te, c = e.start, f = 0; f < e.length - 3; f += 3) {\n        var p = e[f],\n          g = e[f + 1],\n          d = e[f + 2],\n          m = e[f + 3],\n          y = e[f + 4],\n          v = 0 === i ? p : g,\n          x = 0 === i ? m : y,\n          w = !1;\n        s && (a = Math.sqrt(Math.pow(p - m, 2) + Math.pow(g - y, 2))), v < r ? x > r && (l = h(u, p, g, m, y, r), s && (u.start = c + a * l)) : v > o ? x < o && (l = h(u, p, g, m, y, o), s && (u.start = c + a * l)) : H(u, p, g, d), x < r && v >= r && (l = h(u, p, g, m, y, r), w = !0), x > o && v <= o && (l = h(u, p, g, m, y, o), w = !0), !n && w && (s && (u.end = c + a * l), t.push(u), u = U(e)), s && (c += a);\n      }\n      var S = e.length - 3;\n      p = e[S], g = e[S + 1], d = e[S + 2], (v = 0 === i ? p : g) >= r && v <= o && H(u, p, g, d), S = u.length - 3, n && S >= 3 && (u[S] !== u[0] || u[S + 1] !== u[1]) && H(u, u[0], u[1], u[2]), u.length && t.push(u);\n    }\n    function U(e) {\n      var t = [];\n      return t.size = e.size, t.start = e.start, t.end = e.end, t;\n    }\n    function K(e, t, r, o, i, n) {\n      for (var s = 0; s < e.length; s++) Q(e[s], t, r, o, i, n, !1);\n    }\n    function H(e, t, r, o) {\n      e.push(t), e.push(r), e.push(o);\n    }\n    function ee(e, t, r, o, i, n) {\n      var s = (n - t) / (o - t);\n      return e.push(n), e.push(r + (i - r) * s), e.push(1), s;\n    }\n    function te(e, t, r, o, i, n) {\n      var s = (n - r) / (i - r);\n      return e.push(t + (o - t) * s), e.push(n), e.push(1), s;\n    }\n    function re(e, t) {\n      for (var r = [], o = 0; o < e.length; o++) {\n        var i,\n          n = e[o],\n          s = n.type;\n        if (\"Point\" === s || \"MultiPoint\" === s || \"LineString\" === s) i = oe(n.geometry, t);else if (\"MultiLineString\" === s || \"Polygon\" === s) {\n          i = [];\n          for (var a = 0; a < n.geometry.length; a++) i.push(oe(n.geometry[a], t));\n        } else if (\"MultiPolygon\" === s) for (i = [], a = 0; a < n.geometry.length; a++) {\n          for (var l = [], u = 0; u < n.geometry[a].length; u++) l.push(oe(n.geometry[a][u], t));\n          i.push(l);\n        }\n        r.push(W(n.id, s, i, n.tags));\n      }\n      return r;\n    }\n    function oe(e, t) {\n      var r = [];\n      r.size = e.size, void 0 !== e.start && (r.start = e.start, r.end = e.end);\n      for (var o = 0; o < e.length; o += 3) r.push(e[o] + t, e[o + 1], e[o + 2]);\n      return r;\n    }\n    function ie(e, t) {\n      if (e.transformed) return e;\n      var r,\n        o,\n        i,\n        n = 1 << e.z,\n        s = e.x,\n        a = e.y;\n      for (r = 0; r < e.features.length; r++) {\n        var l = e.features[r],\n          u = l.geometry,\n          h = l.type;\n        if (l.geometry = [], 1 === h) for (o = 0; o < u.length; o += 2) l.geometry.push(ne(u[o], u[o + 1], t, n, s, a));else for (o = 0; o < u.length; o++) {\n          var c = [];\n          for (i = 0; i < u[o].length; i += 2) c.push(ne(u[o][i], u[o][i + 1], t, n, s, a));\n          l.geometry.push(c);\n        }\n      }\n      return e.transformed = !0, e;\n    }\n    function ne(e, t, r, o, i, n) {\n      return [Math.round(r * (e * o - i)), Math.round(r * (t * o - n))];\n    }\n    function se(e, t, r, o, i) {\n      for (var n = t === i.maxZoom ? 0 : i.tolerance / ((1 << t) * i.extent), s = {\n          features: [],\n          numPoints: 0,\n          numSimplified: 0,\n          numFeatures: 0,\n          source: null,\n          x: r,\n          y: o,\n          z: t,\n          transformed: !1,\n          minX: 2,\n          minY: 1,\n          maxX: -1,\n          maxY: 0\n        }, a = 0; a < e.length; a++) {\n        s.numFeatures++, ae(s, e[a], n, i);\n        var l = e[a].minX,\n          u = e[a].minY,\n          h = e[a].maxX,\n          c = e[a].maxY;\n        l < s.minX && (s.minX = l), u < s.minY && (s.minY = u), h > s.maxX && (s.maxX = h), c > s.maxY && (s.maxY = c);\n      }\n      return s;\n    }\n    function ae(e, t, r, o) {\n      var i = t.geometry,\n        n = t.type,\n        s = [];\n      if (\"Point\" === n || \"MultiPoint\" === n) for (var a = 0; a < i.length; a += 3) s.push(i[a]), s.push(i[a + 1]), e.numPoints++, e.numSimplified++;else if (\"LineString\" === n) le(s, i, e, r, !1, !1);else if (\"MultiLineString\" === n || \"Polygon\" === n) for (a = 0; a < i.length; a++) le(s, i[a], e, r, \"Polygon\" === n, 0 === a);else if (\"MultiPolygon\" === n) for (var l = 0; l < i.length; l++) {\n        var u = i[l];\n        for (a = 0; a < u.length; a++) le(s, u[a], e, r, !0, 0 === a);\n      }\n      if (s.length) {\n        var h = t.tags || null;\n        if (\"LineString\" === n && o.lineMetrics) {\n          for (var c in h = {}, t.tags) h[c] = t.tags[c];\n          h.mapbox_clip_start = i.start / i.size, h.mapbox_clip_end = i.end / i.size;\n        }\n        var f = {\n          geometry: s,\n          type: \"Polygon\" === n || \"MultiPolygon\" === n ? 3 : \"LineString\" === n || \"MultiLineString\" === n ? 2 : 1,\n          tags: h\n        };\n        null !== t.id && (f.id = t.id), e.features.push(f);\n      }\n    }\n    function le(e, t, r, o, i, n) {\n      var s = o * o;\n      if (o > 0 && t.size < (i ? s : o)) r.numPoints += t.length / 3;else {\n        for (var a = [], l = 0; l < t.length; l += 3) (0 === o || t[l + 2] > s) && (r.numSimplified++, a.push(t[l]), a.push(t[l + 1])), r.numPoints++;\n        i && function (e, t) {\n          for (var r = 0, o = 0, i = e.length, n = i - 2; o < i; n = o, o += 2) r += (e[o] - e[n]) * (e[o + 1] + e[n + 1]);\n          if (r > 0 === t) for (o = 0, i = e.length; o < i / 2; o += 2) {\n            var s = e[o],\n              a = e[o + 1];\n            e[o] = e[i - 2 - o], e[o + 1] = e[i - 1 - o], e[i - 2 - o] = s, e[i - 1 - o] = a;\n          }\n        }(a, n), e.push(a);\n      }\n    }\n    function ue(e, t) {\n      var r = (t = this.options = function (e, t) {\n        for (var r in t) e[r] = t[r];\n        return e;\n      }(Object.create(this.options), t)).debug;\n      if (r && console.time(\"preprocess data\"), t.maxZoom < 0 || t.maxZoom > 24) throw new Error(\"maxZoom should be in the 0-24 range\");\n      if (t.promoteId && t.generateId) throw new Error(\"promoteId and generateId cannot be used together.\");\n      var o = function (e, t) {\n        var r = [];\n        if (\"FeatureCollection\" === e.type) for (var o = 0; o < e.features.length; o++) X(r, e.features[o], t, o);else X(r, \"Feature\" === e.type ? e : {\n          geometry: e\n        }, t);\n        return r;\n      }(e, t);\n      this.tiles = {}, this.tileCoords = [], r && (console.timeEnd(\"preprocess data\"), console.log(\"index: maxZoom: %d, maxPoints: %d\", t.indexMaxZoom, t.indexMaxPoints), console.time(\"generate tiles\"), this.stats = {}, this.total = 0), o = function (e, t) {\n        var r = t.buffer / t.extent,\n          o = e,\n          i = R(e, 1, -1 - r, r, 0, -1, 2, t),\n          n = R(e, 1, 1 - r, 2 + r, 0, -1, 2, t);\n        return (i || n) && (o = R(e, 1, -r, 1 + r, 0, -1, 2, t) || [], i && (o = re(i, 1).concat(o)), n && (o = o.concat(re(n, -1)))), o;\n      }(o, t), o.length && this.splitTile(o, 0, 0, 0), r && (o.length && console.log(\"features: %d, points: %d\", this.tiles[0].numFeatures, this.tiles[0].numPoints), console.timeEnd(\"generate tiles\"), console.log(\"tiles generated:\", this.total, JSON.stringify(this.stats)));\n    }\n    function he(e, t, r) {\n      return 32 * ((1 << e) * r + t) + e;\n    }\n    function ce(t, r) {\n      const o = t.tileID.canonical;\n      if (!this._geoJSONIndex) return r(null, null);\n      const i = this._geoJSONIndex.getTile(o.z, o.x, o.y);\n      if (!i) return r(null, null);\n      const n = new class {\n        constructor(t) {\n          this.layers = {\n            _geojsonTileLayer: this\n          }, this.name = \"_geojsonTileLayer\", this.extent = e.EXTENT, this.length = t.length, this._features = t;\n        }\n        feature(t) {\n          return new class {\n            constructor(t) {\n              this._feature = t, this.extent = e.EXTENT, this.type = t.type, this.properties = t.tags, \"id\" in t && !isNaN(t.id) && (this.id = parseInt(t.id, 10));\n            }\n            loadGeometry() {\n              if (1 === this._feature.type) {\n                const t = [];\n                for (const r of this._feature.geometry) t.push([new e.Point(r[0], r[1])]);\n                return t;\n              }\n              {\n                const t = [];\n                for (const r of this._feature.geometry) {\n                  const o = [];\n                  for (const t of r) o.push(new e.Point(t[0], t[1]));\n                  t.push(o);\n                }\n                return t;\n              }\n            }\n            toGeoJSON(e, t, r) {\n              return l.call(this, e, t, r);\n            }\n          }(this._features[t]);\n        }\n      }(i.features);\n      let s = T(n);\n      0 === s.byteOffset && s.byteLength === s.buffer.byteLength || (s = new Uint8Array(s)), r(null, {\n        vectorTile: n,\n        rawData: s.buffer\n      });\n    }\n    ue.prototype.options = {\n      maxZoom: 14,\n      indexMaxZoom: 5,\n      indexMaxPoints: 1e5,\n      tolerance: 3,\n      extent: 4096,\n      buffer: 64,\n      lineMetrics: !1,\n      promoteId: null,\n      generateId: !1,\n      debug: 0\n    }, ue.prototype.splitTile = function (e, t, r, o, i, n, s) {\n      for (var a = [e, t, r, o], l = this.options, u = l.debug; a.length;) {\n        o = a.pop(), r = a.pop(), t = a.pop(), e = a.pop();\n        var h = 1 << t,\n          c = he(t, r, o),\n          f = this.tiles[c];\n        if (!f && (u > 1 && console.time(\"creation\"), f = this.tiles[c] = se(e, t, r, o, l), this.tileCoords.push({\n          z: t,\n          x: r,\n          y: o\n        }), u)) {\n          u > 1 && (console.log(\"tile z%d-%d-%d (features: %d, points: %d, simplified: %d)\", t, r, o, f.numFeatures, f.numPoints, f.numSimplified), console.timeEnd(\"creation\"));\n          var p = \"z\" + t;\n          this.stats[p] = (this.stats[p] || 0) + 1, this.total++;\n        }\n        if (f.source = e, i) {\n          if (t === l.maxZoom || t === i) continue;\n          var g = 1 << i - t;\n          if (r !== Math.floor(n / g) || o !== Math.floor(s / g)) continue;\n        } else if (t === l.indexMaxZoom || f.numPoints <= l.indexMaxPoints) continue;\n        if (f.source = null, 0 !== e.length) {\n          u > 1 && console.time(\"clipping\");\n          var d,\n            m,\n            y,\n            v,\n            x,\n            w,\n            S = .5 * l.buffer / l.extent,\n            M = .5 - S,\n            P = .5 + S,\n            b = 1 + S;\n          d = m = y = v = null, x = R(e, h, r - S, r + P, 0, f.minX, f.maxX, l), w = R(e, h, r + M, r + b, 0, f.minX, f.maxX, l), e = null, x && (d = R(x, h, o - S, o + P, 1, f.minY, f.maxY, l), m = R(x, h, o + M, o + b, 1, f.minY, f.maxY, l), x = null), w && (y = R(w, h, o - S, o + P, 1, f.minY, f.maxY, l), v = R(w, h, o + M, o + b, 1, f.minY, f.maxY, l), w = null), u > 1 && console.timeEnd(\"clipping\"), a.push(d || [], t + 1, 2 * r, 2 * o), a.push(m || [], t + 1, 2 * r, 2 * o + 1), a.push(y || [], t + 1, 2 * r + 1, 2 * o), a.push(v || [], t + 1, 2 * r + 1, 2 * o + 1);\n        }\n      }\n    }, ue.prototype.getTile = function (e, t, r) {\n      var o = this.options,\n        i = o.extent,\n        n = o.debug;\n      if (e < 0 || e > 24) return null;\n      var s = 1 << e,\n        a = he(e, t = (t % s + s) % s, r);\n      if (this.tiles[a]) return ie(this.tiles[a], i);\n      n > 1 && console.log(\"drilling down to z%d-%d-%d\", e, t, r);\n      for (var l, u = e, h = t, c = r; !l && u > 0;) u--, h = Math.floor(h / 2), c = Math.floor(c / 2), l = this.tiles[he(u, h, c)];\n      return l && l.source ? (n > 1 && console.log(\"found parent tile z%d-%d-%d\", u, h, c), n > 1 && console.time(\"drilling down\"), this.splitTile(l.source, u, h, c, e, t, r), n > 1 && console.timeEnd(\"drilling down\"), this.tiles[a] ? ie(this.tiles[a], i) : null) : null;\n    };\n    class fe extends e.VectorTileWorkerSource {\n      constructor(e, t, r, o, i) {\n        super(e, t, r, o, ce), i && (this.loadGeoJSON = i);\n      }\n      loadData(t, r) {\n        const o = t && t.request,\n          i = o && o.collectResourceTiming;\n        this.loadGeoJSON(t, (n, s) => {\n          if (n || !s) return r(n);\n          if (\"object\" != typeof s) return r(new Error(`Input data given to '${t.source}' is not a valid GeoJSON object.`));\n          {\n            a(s, !0);\n            try {\n              if (t.filter) {\n                const r = e.createExpression(t.filter, {\n                  type: \"boolean\",\n                  \"property-type\": \"data-driven\",\n                  overridable: !1,\n                  transition: !1\n                });\n                if (\"error\" === r.result) throw new Error(r.value.map(e => `${e.key}: ${e.message}`).join(\", \"));\n                const o = s.features.filter(e => r.value.evaluate({\n                  zoom: 0\n                }, e));\n                s = {\n                  type: \"FeatureCollection\",\n                  features: o\n                };\n              }\n              this._geoJSONIndex = t.cluster ? new E(function ({\n                superclusterOptions: t,\n                clusterProperties: r\n              }) {\n                if (!r || !t) return t;\n                const o = {},\n                  i = {},\n                  n = {\n                    accumulated: null,\n                    zoom: 0\n                  },\n                  s = {\n                    properties: null\n                  },\n                  a = Object.keys(r);\n                for (const t of a) {\n                  const [n, s] = r[t],\n                    a = e.createExpression(s),\n                    l = e.createExpression(\"string\" == typeof n ? [n, [\"accumulated\"], [\"get\", t]] : n);\n                  o[t] = a.value, i[t] = l.value;\n                }\n                return t.map = e => {\n                  s.properties = e;\n                  const t = {};\n                  for (const e of a) t[e] = o[e].evaluate(n, s);\n                  return t;\n                }, t.reduce = (e, t) => {\n                  s.properties = t;\n                  for (const t of a) n.accumulated = e[t], e[t] = i[t].evaluate(n, s);\n                }, t;\n              }(t)).load(s.features) : function (e, t) {\n                return new ue(e, t);\n              }(s, t.geojsonVtOptions);\n            } catch (n) {\n              return r(n);\n            }\n            this.loaded = {};\n            const l = {};\n            if (i) {\n              const r = e.getPerformanceMeasurement(o);\n              r && (l.resourceTiming = {}, l.resourceTiming[t.source] = JSON.parse(JSON.stringify(r)));\n            }\n            r(null, l);\n          }\n        });\n      }\n      reloadTile(e, t) {\n        const r = this.loaded;\n        return r && r[e.uid] ? super.reloadTile(e, t) : this.loadTile(e, t);\n      }\n      loadGeoJSON(t, r) {\n        if (t.request) e.getJSON(t.request, r);else {\n          if (\"string\" != typeof t.data) return r(new Error(`Input data given to '${t.source}' is not a valid GeoJSON object.`));\n          try {\n            return r(null, JSON.parse(t.data));\n          } catch (e) {\n            return r(new Error(`Input data given to '${t.source}' is not a valid GeoJSON object.`));\n          }\n        }\n      }\n      getClusterExpansionZoom(e, t) {\n        try {\n          t(null, this._geoJSONIndex.getClusterExpansionZoom(e.clusterId));\n        } catch (e) {\n          t(e);\n        }\n      }\n      getClusterChildren(e, t) {\n        try {\n          t(null, this._geoJSONIndex.getChildren(e.clusterId));\n        } catch (e) {\n          t(e);\n        }\n      }\n      getClusterLeaves(e, t) {\n        try {\n          t(null, this._geoJSONIndex.getLeaves(e.clusterId, e.limit, e.offset));\n        } catch (e) {\n          t(e);\n        }\n      }\n    }\n    class pe {\n      constructor(t) {\n        this.self = t, this.actor = new e.Actor(t, this), this.layerIndexes = {}, this.availableImages = {}, this.isSpriteLoaded = {}, this.projections = {}, this.defaultProjection = e.getProjection({\n          name: \"mercator\"\n        }), this.workerSourceTypes = {\n          vector: e.VectorTileWorkerSource,\n          geojson: fe\n        }, this.workerSources = {}, this.demWorkerSources = {}, this.self.registerWorkerSource = (e, t) => {\n          if (this.workerSourceTypes[e]) throw new Error(`Worker source with name \"${e}\" already registered.`);\n          this.workerSourceTypes[e] = t;\n        }, this.self.registerRTLTextPlugin = t => {\n          if (e.plugin.isParsed()) throw new Error(\"RTL text plugin already registered.\");\n          e.plugin.applyArabicShaping = t.applyArabicShaping, e.plugin.processBidirectionalText = t.processBidirectionalText, e.plugin.processStyledBidirectionalText = t.processStyledBidirectionalText;\n        };\n      }\n      clearCaches(e, t, r) {\n        delete this.layerIndexes[e], delete this.availableImages[e], delete this.workerSources[e], delete this.demWorkerSources[e], r();\n      }\n      checkIfReady(e, t, r) {\n        r();\n      }\n      setReferrer(e, t) {\n        this.referrer = t;\n      }\n      spriteLoaded(t, r) {\n        this.isSpriteLoaded[t] = r;\n        for (const o in this.workerSources[t]) {\n          const i = this.workerSources[t][o];\n          for (const t in i) i[t] instanceof e.VectorTileWorkerSource && (i[t].isSpriteLoaded = r, i[t].fire(new e.Event(\"isSpriteLoaded\")));\n        }\n      }\n      setImages(e, t, r) {\n        this.availableImages[e] = t;\n        for (const r in this.workerSources[e]) {\n          const o = this.workerSources[e][r];\n          for (const e in o) o[e].availableImages = t;\n        }\n        r();\n      }\n      enableTerrain(e, t, r) {\n        this.terrain = t, r();\n      }\n      setProjection(t, r) {\n        this.projections[t] = e.getProjection(r);\n      }\n      setLayers(e, t, r) {\n        this.getLayerIndex(e).replace(t), r();\n      }\n      updateLayers(e, t, r) {\n        this.getLayerIndex(e).update(t.layers, t.removedIds), r();\n      }\n      loadTile(t, r, o) {\n        const i = this.enableTerrain ? e.extend({\n          enableTerrain: this.terrain\n        }, r) : r;\n        i.projection = this.projections[t] || this.defaultProjection, this.getWorkerSource(t, r.type, r.source).loadTile(i, o);\n      }\n      loadDEMTile(t, r, o) {\n        const i = this.enableTerrain ? e.extend({\n          buildQuadTree: this.terrain\n        }, r) : r;\n        this.getDEMWorkerSource(t, r.source).loadTile(i, o);\n      }\n      reloadTile(t, r, o) {\n        const i = this.enableTerrain ? e.extend({\n          enableTerrain: this.terrain\n        }, r) : r;\n        i.projection = this.projections[t] || this.defaultProjection, this.getWorkerSource(t, r.type, r.source).reloadTile(i, o);\n      }\n      abortTile(e, t, r) {\n        this.getWorkerSource(e, t.type, t.source).abortTile(t, r);\n      }\n      removeTile(e, t, r) {\n        this.getWorkerSource(e, t.type, t.source).removeTile(t, r);\n      }\n      removeSource(e, t, r) {\n        if (!this.workerSources[e] || !this.workerSources[e][t.type] || !this.workerSources[e][t.type][t.source]) return;\n        const o = this.workerSources[e][t.type][t.source];\n        delete this.workerSources[e][t.type][t.source], void 0 !== o.removeSource ? o.removeSource(t, r) : r();\n      }\n      loadWorkerSource(e, t, r) {\n        try {\n          this.self.importScripts(t.url), r();\n        } catch (e) {\n          r(e.toString());\n        }\n      }\n      syncRTLPluginState(t, r, o) {\n        try {\n          e.plugin.setState(r);\n          const t = e.plugin.getPluginURL();\n          if (e.plugin.isLoaded() && !e.plugin.isParsed() && null != t) {\n            this.self.importScripts(t);\n            const r = e.plugin.isParsed();\n            o(r ? void 0 : new Error(`RTL Text Plugin failed to import scripts from ${t}`), r);\n          }\n        } catch (e) {\n          o(e.toString());\n        }\n      }\n      getAvailableImages(e) {\n        let t = this.availableImages[e];\n        return t || (t = []), t;\n      }\n      getLayerIndex(e) {\n        let t = this.layerIndexes[e];\n        return t || (t = this.layerIndexes[e] = new o()), t;\n      }\n      getWorkerSource(e, t, r) {\n        if (this.workerSources[e] || (this.workerSources[e] = {}), this.workerSources[e][t] || (this.workerSources[e][t] = {}), !this.workerSources[e][t][r]) {\n          const o = {\n            send: (t, r, o, i, n, s) => {\n              this.actor.send(t, r, o, e, n, s);\n            },\n            scheduler: this.actor.scheduler\n          };\n          this.workerSources[e][t][r] = new this.workerSourceTypes[t](o, this.getLayerIndex(e), this.getAvailableImages(e), this.isSpriteLoaded[e]);\n        }\n        return this.workerSources[e][t][r];\n      }\n      getDEMWorkerSource(e, t) {\n        return this.demWorkerSources[e] || (this.demWorkerSources[e] = {}), this.demWorkerSources[e][t] || (this.demWorkerSources[e][t] = new i()), this.demWorkerSources[e][t];\n      }\n      enforceCacheSizeLimit(t, r) {\n        e.enforceCacheSizeLimit(r);\n      }\n      getWorkerPerformanceMetrics(e, t, r) {\n        r(void 0, void 0);\n      }\n    }\n    return \"undefined\" != typeof WorkerGlobalScope && \"undefined\" != typeof self && self instanceof WorkerGlobalScope && (self.worker = new pe(self)), pe;\n  });\n  define([\"./shared\"], function (e) {\n    \"use strict\";\n\n    function t(e, i) {\n      if (Array.isArray(e)) {\n        if (!Array.isArray(i) || e.length !== i.length) return !1;\n        for (let o = 0; o < e.length; o++) if (!t(e[o], i[o])) return !1;\n        return !0;\n      }\n      if (\"object\" == typeof e && null !== e && null !== i) {\n        if (\"object\" != typeof i) return !1;\n        if (Object.keys(e).length !== Object.keys(i).length) return !1;\n        for (const o in e) if (!t(e[o], i[o])) return !1;\n        return !0;\n      }\n      return e === i;\n    }\n    var i = o;\n    function o(e) {\n      return !function (e) {\n        return \"undefined\" == typeof window || \"undefined\" == typeof document ? \"not a browser\" : Array.prototype && Array.prototype.every && Array.prototype.filter && Array.prototype.forEach && Array.prototype.indexOf && Array.prototype.lastIndexOf && Array.prototype.map && Array.prototype.some && Array.prototype.reduce && Array.prototype.reduceRight && Array.isArray ? Function.prototype && Function.prototype.bind ? Object.keys && Object.create && Object.getPrototypeOf && Object.getOwnPropertyNames && Object.isSealed && Object.isFrozen && Object.isExtensible && Object.getOwnPropertyDescriptor && Object.defineProperty && Object.defineProperties && Object.seal && Object.freeze && Object.preventExtensions ? \"JSON\" in window && \"parse\" in JSON && \"stringify\" in JSON ? function () {\n          if (!(\"Worker\" in window && \"Blob\" in window && \"URL\" in window)) return !1;\n          var e,\n            t,\n            i = new Blob([\"\"], {\n              type: \"text/javascript\"\n            }),\n            o = URL.createObjectURL(i);\n          try {\n            t = new Worker(o), e = !0;\n          } catch (t) {\n            e = !1;\n          }\n          return t && t.terminate(), URL.revokeObjectURL(o), e;\n        }() ? \"Uint8ClampedArray\" in window ? ArrayBuffer.isView ? function () {\n          var e = document.createElement(\"canvas\");\n          e.width = e.height = 1;\n          var t = e.getContext(\"2d\");\n          if (!t) return !1;\n          var i = t.getImageData(0, 0, 1, 1);\n          return i && i.width === e.width;\n        }() ? (void 0 === r[t = e && e.failIfMajorPerformanceCaveat] && (r[t] = function (e) {\n          var t,\n            i = function (e) {\n              var t = document.createElement(\"canvas\"),\n                i = Object.create(o.webGLContextAttributes);\n              return i.failIfMajorPerformanceCaveat = e, t.getContext(\"webgl\", i) || t.getContext(\"experimental-webgl\", i);\n            }(e);\n          if (!i) return !1;\n          try {\n            t = i.createShader(i.VERTEX_SHADER);\n          } catch (e) {\n            return !1;\n          }\n          return !(!t || i.isContextLost()) && (i.shaderSource(t, \"void main() {}\"), i.compileShader(t), !0 === i.getShaderParameter(t, i.COMPILE_STATUS));\n        }(t)), r[t] ? document.documentMode ? \"insufficient ECMAScript 6 support\" : void 0 : \"insufficient WebGL support\") : \"insufficient Canvas/getImageData support\" : \"insufficient ArrayBuffer support\" : \"insufficient Uint8ClampedArray support\" : \"insufficient worker support\" : \"insufficient JSON support\" : \"insufficient Object support\" : \"insufficient Function support\" : \"insufficent Array support\";\n        var t;\n      }(e);\n    }\n    var r = {};\n    function n(t, i, o) {\n      const r = e.window.document.createElement(t);\n      return void 0 !== i && (r.className = i), o && o.appendChild(r), r;\n    }\n    function s(t, i, o) {\n      const r = e.window.document.createElementNS(\"http://www.w3.org/2000/svg\", t);\n      for (const e of Object.keys(i)) r.setAttributeNS(null, e, i[e]);\n      return o && o.appendChild(r), r;\n    }\n    o.webGLContextAttributes = {\n      antialias: !1,\n      alpha: !0,\n      stencil: !0,\n      depth: !0\n    };\n    const a = e.window.document && e.window.document.documentElement.style,\n      l = a && void 0 !== a.userSelect ? \"userSelect\" : \"WebkitUserSelect\";\n    let c;\n    function h() {\n      a && l && (c = a[l], a[l] = \"none\");\n    }\n    function u() {\n      a && l && (a[l] = c);\n    }\n    function _(t) {\n      t.preventDefault(), t.stopPropagation(), e.window.removeEventListener(\"click\", _, !0);\n    }\n    function d() {\n      e.window.addEventListener(\"click\", _, !0), e.window.setTimeout(() => {\n        e.window.removeEventListener(\"click\", _, !0);\n      }, 0);\n    }\n    function p(e, t) {\n      const i = e.getBoundingClientRect();\n      return g(e, i, t);\n    }\n    function m(e, t) {\n      const i = e.getBoundingClientRect(),\n        o = [];\n      for (let r = 0; r < t.length; r++) o.push(g(e, i, t[r]));\n      return o;\n    }\n    function f(t) {\n      return void 0 !== e.window.InstallTrigger && 2 === t.button && t.ctrlKey && e.window.navigator.platform.toUpperCase().indexOf(\"MAC\") >= 0 ? 0 : t.button;\n    }\n    function g(t, i, o) {\n      const r = t.offsetWidth === i.width ? 1 : t.offsetWidth / i.width;\n      return new e.Point((o.clientX - i.left) * r, (o.clientY - i.top) * r);\n    }\n    function v(e, t) {\n      var i = t[0],\n        o = t[1],\n        r = t[2],\n        n = t[3],\n        s = i * n - r * o;\n      return s ? (e[0] = n * (s = 1 / s), e[1] = -o * s, e[2] = -r * s, e[3] = i * s, e) : null;\n    }\n    function x(e) {\n      const {\n        userImage: t\n      } = e;\n      return !!(t && t.render && t.render()) && (e.data.replace(new Uint8Array(t.data.buffer)), !0);\n    }\n    class y extends e.Evented {\n      constructor() {\n        super(), this.images = {}, this.updatedImages = {}, this.callbackDispatchedThisFrame = {}, this.loaded = !1, this.requestors = [], this.patterns = {}, this.atlasImage = new e.RGBAImage({\n          width: 1,\n          height: 1\n        }), this.dirty = !0;\n      }\n      isLoaded() {\n        return this.loaded;\n      }\n      setLoaded(e) {\n        if (this.loaded !== e && (this.loaded = e, e)) {\n          for (const {\n            ids: e,\n            callback: t\n          } of this.requestors) this._notify(e, t);\n          this.requestors = [];\n        }\n      }\n      hasImage(e) {\n        return !!this.getImage(e);\n      }\n      getImage(e) {\n        return this.images[e];\n      }\n      addImage(e, t) {\n        this._validate(e, t) && (this.images[e] = t);\n      }\n      _validate(t, i) {\n        let o = !0;\n        return this._validateStretch(i.stretchX, i.data && i.data.width) || (this.fire(new e.ErrorEvent(new Error(`Image \"${t}\" has invalid \"stretchX\" value`))), o = !1), this._validateStretch(i.stretchY, i.data && i.data.height) || (this.fire(new e.ErrorEvent(new Error(`Image \"${t}\" has invalid \"stretchY\" value`))), o = !1), this._validateContent(i.content, i) || (this.fire(new e.ErrorEvent(new Error(`Image \"${t}\" has invalid \"content\" value`))), o = !1), o;\n      }\n      _validateStretch(e, t) {\n        if (!e) return !0;\n        let i = 0;\n        for (const o of e) {\n          if (o[0] < i || o[1] < o[0] || t < o[1]) return !1;\n          i = o[1];\n        }\n        return !0;\n      }\n      _validateContent(e, t) {\n        return !(e && (4 !== e.length || e[0] < 0 || t.data.width < e[0] || e[1] < 0 || t.data.height < e[1] || e[2] < 0 || t.data.width < e[2] || e[3] < 0 || t.data.height < e[3] || e[2] < e[0] || e[3] < e[1]));\n      }\n      updateImage(e, t) {\n        t.version = this.images[e].version + 1, this.images[e] = t, this.updatedImages[e] = !0;\n      }\n      removeImage(e) {\n        const t = this.images[e];\n        delete this.images[e], delete this.patterns[e], t.userImage && t.userImage.onRemove && t.userImage.onRemove();\n      }\n      listImages() {\n        return Object.keys(this.images);\n      }\n      getImages(e, t) {\n        let i = !0;\n        if (!this.isLoaded()) for (const t of e) this.images[t] || (i = !1);\n        this.isLoaded() || i ? this._notify(e, t) : this.requestors.push({\n          ids: e,\n          callback: t\n        });\n      }\n      _notify(t, i) {\n        const o = {};\n        for (const i of t) {\n          this.images[i] || this.fire(new e.Event(\"styleimagemissing\", {\n            id: i\n          }));\n          const t = this.images[i];\n          t ? o[i] = {\n            data: t.data.clone(),\n            pixelRatio: t.pixelRatio,\n            sdf: t.sdf,\n            version: t.version,\n            stretchX: t.stretchX,\n            stretchY: t.stretchY,\n            content: t.content,\n            hasRenderCallback: Boolean(t.userImage && t.userImage.render)\n          } : e.warnOnce(`Image \"${i}\" could not be loaded. Please make sure you have added the image with map.addImage() or a \"sprite\" property in your style. You can provide missing images by listening for the \"styleimagemissing\" map event.`);\n        }\n        i(null, o);\n      }\n      getPixelSize() {\n        const {\n          width: e,\n          height: t\n        } = this.atlasImage;\n        return {\n          width: e,\n          height: t\n        };\n      }\n      getPattern(t) {\n        const i = this.patterns[t],\n          o = this.getImage(t);\n        if (!o) return null;\n        if (i && i.position.version === o.version) return i.position;\n        if (i) i.position.version = o.version;else {\n          const i = {\n              w: o.data.width + 2,\n              h: o.data.height + 2,\n              x: 0,\n              y: 0\n            },\n            r = new e.ImagePosition(i, o);\n          this.patterns[t] = {\n            bin: i,\n            position: r\n          };\n        }\n        return this._updatePatternAtlas(), this.patterns[t].position;\n      }\n      bind(t) {\n        const i = t.gl;\n        this.atlasTexture ? this.dirty && (this.atlasTexture.update(this.atlasImage), this.dirty = !1) : this.atlasTexture = new e.Texture(t, this.atlasImage, i.RGBA), this.atlasTexture && this.atlasTexture.bind(i.LINEAR, i.CLAMP_TO_EDGE);\n      }\n      _updatePatternAtlas() {\n        const t = [];\n        for (const e in this.patterns) t.push(this.patterns[e].bin);\n        const {\n            w: i,\n            h: o\n          } = e.potpack(t),\n          r = this.atlasImage;\n        r.resize({\n          width: i || 1,\n          height: o || 1\n        });\n        for (const t in this.patterns) {\n          const {\n              bin: i\n            } = this.patterns[t],\n            o = i.x + 1,\n            n = i.y + 1,\n            s = this.images[t].data,\n            a = s.width,\n            l = s.height;\n          e.RGBAImage.copy(s, r, {\n            x: 0,\n            y: 0\n          }, {\n            x: o,\n            y: n\n          }, {\n            width: a,\n            height: l\n          }), e.RGBAImage.copy(s, r, {\n            x: 0,\n            y: l - 1\n          }, {\n            x: o,\n            y: n - 1\n          }, {\n            width: a,\n            height: 1\n          }), e.RGBAImage.copy(s, r, {\n            x: 0,\n            y: 0\n          }, {\n            x: o,\n            y: n + l\n          }, {\n            width: a,\n            height: 1\n          }), e.RGBAImage.copy(s, r, {\n            x: a - 1,\n            y: 0\n          }, {\n            x: o - 1,\n            y: n\n          }, {\n            width: 1,\n            height: l\n          }), e.RGBAImage.copy(s, r, {\n            x: 0,\n            y: 0\n          }, {\n            x: o + a,\n            y: n\n          }, {\n            width: 1,\n            height: l\n          });\n        }\n        this.dirty = !0;\n      }\n      beginFrame() {\n        this.callbackDispatchedThisFrame = {};\n      }\n      dispatchRenderCallbacks(e) {\n        for (const t of e) {\n          if (this.callbackDispatchedThisFrame[t]) continue;\n          this.callbackDispatchedThisFrame[t] = !0;\n          const e = this.images[t];\n          x(e) && this.updateImage(t, e);\n        }\n      }\n    }\n    const b = new e.Properties({\n      anchor: new e.DataConstantProperty(e.spec.light.anchor),\n      position: new class {\n        constructor() {\n          this.specification = e.spec.light.position;\n        }\n        possiblyEvaluate(t, i) {\n          return function ([t, i, o]) {\n            const r = e.degToRad(i + 90),\n              n = e.degToRad(o);\n            return {\n              x: t * Math.cos(r) * Math.sin(n),\n              y: t * Math.sin(r) * Math.sin(n),\n              z: t * Math.cos(n),\n              azimuthal: i,\n              polar: o\n            };\n          }(t.expression.evaluate(i));\n        }\n        interpolate(t, i, o) {\n          return {\n            x: e.number(t.x, i.x, o),\n            y: e.number(t.y, i.y, o),\n            z: e.number(t.z, i.z, o),\n            azimuthal: e.number(t.azimuthal, i.azimuthal, o),\n            polar: e.number(t.polar, i.polar, o)\n          };\n        }\n      }(),\n      color: new e.DataConstantProperty(e.spec.light.color),\n      intensity: new e.DataConstantProperty(e.spec.light.intensity)\n    });\n    class w extends e.Evented {\n      constructor(t) {\n        super(), this._transitionable = new e.Transitionable(b), this.setLight(t), this._transitioning = this._transitionable.untransitioned();\n      }\n      getLight() {\n        return this._transitionable.serialize();\n      }\n      setLight(t, i = {}) {\n        if (!this._validate(e.validateLight, t, i)) for (const i in t) {\n          const o = t[i];\n          e.endsWith(i, \"-transition\") ? this._transitionable.setTransition(i.slice(0, -11), o) : this._transitionable.setValue(i, o);\n        }\n      }\n      updateTransitions(e) {\n        this._transitioning = this._transitionable.transitioned(e, this._transitioning);\n      }\n      hasTransition() {\n        return this._transitioning.hasTransition();\n      }\n      recalculate(e) {\n        this.properties = this._transitioning.possiblyEvaluate(e);\n      }\n      _validate(t, i, o) {\n        return (!o || !1 !== o.validate) && e.emitValidationErrors(this, t.call(e.validateStyle, e.extend({\n          value: i,\n          style: {\n            glyphs: !0,\n            sprite: !0\n          },\n          styleSpec: e.spec\n        })));\n      }\n    }\n    const T = new e.Properties({\n      source: new e.DataConstantProperty(e.spec.terrain.source),\n      exaggeration: new e.DataConstantProperty(e.spec.terrain.exaggeration)\n    });\n    let E = class extends e.Evented {\n      constructor(t, i) {\n        super(), this._transitionable = new e.Transitionable(T), this.set(t), this._transitioning = this._transitionable.untransitioned(), this.drapeRenderMode = i;\n      }\n      get() {\n        return this._transitionable.serialize();\n      }\n      set(t) {\n        for (const i in t) {\n          const o = t[i];\n          e.endsWith(i, \"-transition\") ? this._transitionable.setTransition(i.slice(0, -11), o) : this._transitionable.setValue(i, o);\n        }\n      }\n      updateTransitions(e) {\n        this._transitioning = this._transitionable.transitioned(e, this._transitioning);\n      }\n      hasTransition() {\n        return this._transitioning.hasTransition();\n      }\n      recalculate(e) {\n        this.properties = this._transitioning.possiblyEvaluate(e);\n      }\n    };\n    function C(t, i, o, r) {\n      const n = e.smoothstep(45, 65, o),\n        [s, a] = M(t, r),\n        l = e.length(i);\n      let c = 1 - Math.min(1, Math.exp((l - s) / (a - s) * -6));\n      return c *= c * c, c = Math.min(1, 1.00747 * c), c * n * t.alpha;\n    }\n    function M(e, t) {\n      const i = .5 / Math.tan(.5 * t);\n      return [e.range[0] + i, e.range[1] + i];\n    }\n    const I = new e.Properties({\n      range: new e.DataConstantProperty(e.spec.fog.range),\n      color: new e.DataConstantProperty(e.spec.fog.color),\n      \"high-color\": new e.DataConstantProperty(e.spec.fog[\"high-color\"]),\n      \"space-color\": new e.DataConstantProperty(e.spec.fog[\"space-color\"]),\n      \"horizon-blend\": new e.DataConstantProperty(e.spec.fog[\"horizon-blend\"]),\n      \"star-intensity\": new e.DataConstantProperty(e.spec.fog[\"star-intensity\"])\n    });\n    class P extends e.Evented {\n      constructor(t, i) {\n        super(), this._transitionable = new e.Transitionable(I), this.set(t), this._transitioning = this._transitionable.untransitioned(), this._transform = i;\n      }\n      get state() {\n        const t = this._transform,\n          i = \"globe\" === t.projection.name,\n          o = e.globeToMercatorTransition(t.zoom),\n          r = this.properties.get(\"range\"),\n          n = [.5, 3];\n        return {\n          range: i ? [e.number(n[0], r[0], o), e.number(n[1], r[1], o)] : r,\n          horizonBlend: this.properties.get(\"horizon-blend\"),\n          alpha: this.properties.get(\"color\").a\n        };\n      }\n      get() {\n        return this._transitionable.serialize();\n      }\n      set(t, i = {}) {\n        if (!this._validate(e.validateFog, t, i)) {\n          for (const i of Object.keys(e.spec.fog)) t && void 0 === t[i] && (t[i] = e.spec.fog[i].default);\n          for (const i in t) {\n            const o = t[i];\n            e.endsWith(i, \"-transition\") ? this._transitionable.setTransition(i.slice(0, -11), o) : this._transitionable.setValue(i, o);\n          }\n        }\n      }\n      getOpacity(t) {\n        if (!this._transform.projection.supportsFog) return 0;\n        const i = this.properties && this.properties.get(\"color\") || 1;\n        return (\"globe\" === this._transform.projection.name ? 1 : e.smoothstep(45, 65, t)) * i.a;\n      }\n      getOpacityAtLatLng(t, i) {\n        return this._transform.projection.supportsFog ? function (t, i, o) {\n          const r = e.MercatorCoordinate.fromLngLat(i),\n            n = o.elevation ? o.elevation.getAtPointOrZero(r) : 0,\n            s = [r.x, r.y, n];\n          return e.transformMat4(s, s, o.mercatorFogMatrix), C(t, s, o.pitch, o._fov);\n        }(this.state, t, i) : 0;\n      }\n      getFovAdjustedRange(e) {\n        return this._transform.projection.supportsFog ? M(this.state, e) : [0, 1];\n      }\n      updateTransitions(e) {\n        this._transitioning = this._transitionable.transitioned(e, this._transitioning);\n      }\n      hasTransition() {\n        return this._transitioning.hasTransition();\n      }\n      recalculate(e) {\n        this.properties = this._transitioning.possiblyEvaluate(e);\n      }\n      _validate(t, i, o) {\n        return (!o || !1 !== o.validate) && e.emitValidationErrors(this, t.call(e.validateStyle, e.extend({\n          value: i,\n          style: {\n            glyphs: !0,\n            sprite: !0\n          },\n          styleSpec: e.spec\n        })));\n      }\n    }\n    class S {\n      constructor(t, i) {\n        this.workerPool = t, this.actors = [], this.currentActor = 0, this.id = e.uniqueId();\n        const o = this.workerPool.acquire(this.id);\n        for (let e = 0; e < o.length; e++) {\n          const t = new S.Actor(o[e], i, this.id);\n          t.name = `Worker ${e}`, this.actors.push(t);\n        }\n        this.ready = !1, this.broadcast(\"checkIfReady\", null, () => {\n          this.ready = !0;\n        });\n      }\n      broadcast(t, i, o) {\n        e.asyncAll(this.actors, (e, o) => {\n          e.send(t, i, o);\n        }, o = o || function () {});\n      }\n      getActor() {\n        return this.currentActor = (this.currentActor + 1) % this.actors.length, this.actors[this.currentActor];\n      }\n      remove() {\n        this.actors.forEach(e => {\n          e.remove();\n        }), this.actors = [], this.workerPool.release(this.id);\n      }\n    }\n    function D(t, i, o) {\n      return i * (e.EXTENT / (t.tileSize * Math.pow(2, o - t.tileID.overscaledZ)));\n    }\n    S.Actor = e.Actor;\n    class L {\n      constructor(e, t, i, o) {\n        this.screenBounds = e, this.cameraPoint = t, this._screenRaycastCache = {}, this._cameraRaycastCache = {}, this.isAboveHorizon = i, this.screenGeometry = this.bufferedScreenGeometry(0), this.screenGeometryMercator = this._bufferedScreenMercator(0, o);\n      }\n      static createFromScreenPoints(t, i) {\n        let o, r;\n        if (t instanceof e.Point || \"number\" == typeof t[0]) {\n          const n = e.Point.convert(t);\n          o = [n], r = i.isPointAboveHorizon(n);\n        } else {\n          const n = e.Point.convert(t[0]),\n            s = e.Point.convert(t[1]);\n          o = [n, s], r = e.polygonizeBounds(n, s).every(e => i.isPointAboveHorizon(e));\n        }\n        return new L(o, i.getCameraPoint(), r, i);\n      }\n      isPointQuery() {\n        return 1 === this.screenBounds.length;\n      }\n      bufferedScreenGeometry(t) {\n        return e.polygonizeBounds(this.screenBounds[0], 1 === this.screenBounds.length ? this.screenBounds[0] : this.screenBounds[1], t);\n      }\n      bufferedCameraGeometry(t) {\n        const i = this.screenBounds[0],\n          o = 1 === this.screenBounds.length ? this.screenBounds[0].add(new e.Point(1, 1)) : this.screenBounds[1],\n          r = e.polygonizeBounds(i, o, 0, !1);\n        return this.cameraPoint.y > o.y && (this.cameraPoint.x > i.x && this.cameraPoint.x < o.x ? r.splice(3, 0, this.cameraPoint) : this.cameraPoint.x >= o.x ? r[2] = this.cameraPoint : this.cameraPoint.x <= i.x && (r[3] = this.cameraPoint)), e.bufferConvexPolygon(r, t);\n      }\n      bufferedCameraGeometryGlobe(t) {\n        const i = this.screenBounds[0],\n          o = 1 === this.screenBounds.length ? this.screenBounds[0].add(new e.Point(1, 1)) : this.screenBounds[1],\n          r = e.polygonizeBounds(i, o, t),\n          n = this.cameraPoint.clone();\n        switch (3 * ((n.y > i.y) + (n.y > o.y)) + ((n.x > i.x) + (n.x > o.x))) {\n          case 0:\n            r[0] = n, r[4] = n.clone();\n            break;\n          case 1:\n            r.splice(1, 0, n);\n            break;\n          case 2:\n            r[1] = n;\n            break;\n          case 3:\n            r.splice(4, 0, n);\n            break;\n          case 5:\n            r.splice(2, 0, n);\n            break;\n          case 6:\n            r[3] = n;\n            break;\n          case 7:\n            r.splice(3, 0, n);\n            break;\n          case 8:\n            r[2] = n;\n        }\n        return r;\n      }\n      containsTile(t, i, o, r = 0) {\n        const n = t.queryPadding / i._pixelsPerMercatorPixel + 1,\n          s = o ? this._bufferedCameraMercator(n, i) : this._bufferedScreenMercator(n, i);\n        let a = t.tileID.wrap + (s.unwrapped ? r : 0);\n        const l = s.polygon.map(i => e.getTilePoint(t.tileTransform, i, a));\n        if (!e.polygonIntersectsBox(l, 0, 0, e.EXTENT, e.EXTENT)) return;\n        a = t.tileID.wrap + (this.screenGeometryMercator.unwrapped ? r : 0);\n        const c = this.screenGeometryMercator.polygon.map(i => e.getTileVec3(t.tileTransform, i, a)),\n          h = c.map(t => new e.Point(t[0], t[1])),\n          u = i.getFreeCameraOptions().position || new e.MercatorCoordinate(0, 0, 0),\n          _ = e.getTileVec3(t.tileTransform, u, a),\n          d = c.map(t => {\n            const i = e.sub(t, t, _);\n            return e.normalize(i, i), new e.Ray(_, i);\n          }),\n          p = D(t, 1, i.zoom) * i._pixelsPerMercatorPixel;\n        return {\n          queryGeometry: this,\n          tilespaceGeometry: h,\n          tilespaceRays: d,\n          bufferedTilespaceGeometry: l,\n          bufferedTilespaceBounds: (m = e.getBounds(l), m.min.x = e.clamp(m.min.x, 0, e.EXTENT), m.min.y = e.clamp(m.min.y, 0, e.EXTENT), m.max.x = e.clamp(m.max.x, 0, e.EXTENT), m.max.y = e.clamp(m.max.y, 0, e.EXTENT), m),\n          tile: t,\n          tileID: t.tileID,\n          pixelToTileUnitsFactor: p\n        };\n        var m;\n      }\n      _bufferedScreenMercator(e, t) {\n        const i = R(e);\n        if (this._screenRaycastCache[i]) return this._screenRaycastCache[i];\n        {\n          let o;\n          return o = \"globe\" === t.projection.name ? this._projectAndResample(this.bufferedScreenGeometry(e), t) : {\n            polygon: this.bufferedScreenGeometry(e).map(e => t.pointCoordinate3D(e)),\n            unwrapped: !0\n          }, this._screenRaycastCache[i] = o, o;\n        }\n      }\n      _bufferedCameraMercator(e, t) {\n        const i = R(e);\n        if (this._cameraRaycastCache[i]) return this._cameraRaycastCache[i];\n        {\n          let o;\n          return o = \"globe\" === t.projection.name ? this._projectAndResample(this.bufferedCameraGeometryGlobe(e), t) : {\n            polygon: this.bufferedCameraGeometry(e).map(e => t.pointCoordinate3D(e)),\n            unwrapped: !0\n          }, this._cameraRaycastCache[i] = o, o;\n        }\n      }\n      _projectAndResample(t, i) {\n        const o = function (t, i) {\n          const o = e.multiply([], i.pixelMatrix, i.globeMatrix),\n            r = [0, -e.GLOBE_RADIUS, 0, 1],\n            n = [0, e.GLOBE_RADIUS, 0, 1],\n            s = [0, 0, 0, 1];\n          e.transformMat4$1(r, r, o), e.transformMat4$1(n, n, o), e.transformMat4$1(s, s, o);\n          const a = new e.Point(r[0] / r[3], r[1] / r[3]),\n            l = new e.Point(n[0] / n[3], n[1] / n[3]),\n            c = e.polygonContainsPoint(t, a) && r[3] < s[3],\n            h = e.polygonContainsPoint(t, l) && n[3] < s[3];\n          if (!c && !h) return null;\n          const u = function (e, t, i) {\n            for (let o = 1; o < e.length; o++) {\n              const r = z(t.pointCoordinate3D(e[o - 1]).x),\n                n = z(t.pointCoordinate3D(e[o]).x);\n              if (i < 0) {\n                if (r < n) return {\n                  idx: o,\n                  t: -r / (n - 1 - r)\n                };\n              } else if (n < r) return {\n                idx: o,\n                t: (1 - r) / (n + 1 - r)\n              };\n            }\n            return null;\n          }(t, i, c ? -1 : 1);\n          if (!u) return null;\n          const {\n            idx: _,\n            t: d\n          } = u;\n          let p = _ > 1 ? A(t.slice(0, _), i) : [],\n            m = _ < t.length ? A(t.slice(_), i) : [];\n          p = p.map(t => new e.Point(z(t.x), t.y)), m = m.map(t => new e.Point(z(t.x), t.y));\n          const f = [...p];\n          0 === f.length && f.push(m[m.length - 1]);\n          const g = e.number(f[f.length - 1].y, (0 === m.length ? p[0] : m[0]).y, d);\n          let v;\n          return v = c ? [new e.Point(0, g), new e.Point(0, 0), new e.Point(1, 0), new e.Point(1, g)] : [new e.Point(1, g), new e.Point(1, 1), new e.Point(0, 1), new e.Point(0, g)], f.push(...v), 0 === m.length ? f.push(p[0]) : f.push(...m), {\n            polygon: f.map(t => new e.MercatorCoordinate(t.x, t.y)),\n            unwrapped: !1\n          };\n        }(t, i);\n        if (o) return o;\n        const r = function (t, i) {\n          let o = !1,\n            r = -1 / 0,\n            n = 0;\n          for (let e = 0; e < t.length - 1; e++) t[e].x > r && (r = t[e].x, n = e);\n          for (let e = 0; e < t.length - 1; e++) {\n            const i = (n + e) % (t.length - 1),\n              r = t[i],\n              s = t[i + 1];\n            Math.abs(r.x - s.x) > .5 && (r.x < s.x ? (r.x += 1, 0 === i && (t[t.length - 1].x += 1)) : (s.x += 1, i + 1 === t.length - 1 && (t[0].x += 1)), o = !0);\n          }\n          const s = e.mercatorXfromLng(i.center.lng);\n          return o && s < Math.abs(s - 1) && t.forEach(e => {\n            e.x -= 1;\n          }), {\n            polygon: t,\n            unwrapped: o\n          };\n        }(A(t, i).map(t => new e.Point(z(t.x), t.y)), i);\n        return {\n          polygon: r.polygon.map(t => new e.MercatorCoordinate(t.x, t.y)),\n          unwrapped: r.unwrapped\n        };\n      }\n    }\n    function A(t, i) {\n      return e.resample(t, e => {\n        const t = i.pointCoordinate3D(e);\n        e.x = t.x, e.y = t.y;\n      }, 1 / 256);\n    }\n    function z(e) {\n      return e < 0 ? 1 + e % 1 : e % 1;\n    }\n    function R(e) {\n      return 100 * e | 0;\n    }\n    function O(t, i, o, r, n) {\n      const s = function (o, r) {\n        if (o) return n(o);\n        if (r) {\n          t.url && r.tiles && t.tiles && delete t.tiles;\n          const o = e.pick(e.extend(r, t), [\"tiles\", \"minzoom\", \"maxzoom\", \"attribution\", \"mapbox_logo\", \"bounds\", \"scheme\", \"tileSize\", \"encoding\"]);\n          r.vector_layers && (o.vectorLayers = r.vector_layers, o.vectorLayerIds = o.vectorLayers.map(e => e.id)), o.tiles = i.canonicalizeTileset(o, t.url), n(null, o);\n        }\n      };\n      return t.url ? e.getJSON(i.transformRequest(i.normalizeSourceURL(t.url, null, o, r), e.ResourceType.Source), s) : e.exported.frame(() => s(null, t));\n    }\n    class B {\n      constructor(t, i, o) {\n        this.bounds = e.LngLatBounds.convert(this.validateBounds(t)), this.minzoom = i || 0, this.maxzoom = o || 24;\n      }\n      validateBounds(e) {\n        return Array.isArray(e) && 4 === e.length ? [Math.max(-180, e[0]), Math.max(-90, e[1]), Math.min(180, e[2]), Math.min(90, e[3])] : [-180, -90, 180, 90];\n      }\n      contains(t) {\n        const i = Math.pow(2, t.z),\n          o = Math.floor(e.mercatorXfromLng(this.bounds.getWest()) * i),\n          r = Math.floor(e.mercatorYfromLat(this.bounds.getNorth()) * i),\n          n = Math.ceil(e.mercatorXfromLng(this.bounds.getEast()) * i),\n          s = Math.ceil(e.mercatorYfromLat(this.bounds.getSouth()) * i);\n        return t.x >= o && t.x < n && t.y >= r && t.y < s;\n      }\n    }\n    class k {\n      constructor(e, t, i) {\n        this.context = e;\n        const o = e.gl;\n        this.buffer = o.createBuffer(), this.dynamicDraw = Boolean(i), this.context.unbindVAO(), e.bindElementBuffer.set(this.buffer), o.bufferData(o.ELEMENT_ARRAY_BUFFER, t.arrayBuffer, this.dynamicDraw ? o.DYNAMIC_DRAW : o.STATIC_DRAW), this.dynamicDraw || t.destroy();\n      }\n      bind() {\n        this.context.bindElementBuffer.set(this.buffer);\n      }\n      updateData(e) {\n        const t = this.context.gl;\n        this.context.unbindVAO(), this.bind(), t.bufferSubData(t.ELEMENT_ARRAY_BUFFER, 0, e.arrayBuffer);\n      }\n      destroy() {\n        this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer);\n      }\n    }\n    const F = {\n      Int8: \"BYTE\",\n      Uint8: \"UNSIGNED_BYTE\",\n      Int16: \"SHORT\",\n      Uint16: \"UNSIGNED_SHORT\",\n      Int32: \"INT\",\n      Uint32: \"UNSIGNED_INT\",\n      Float32: \"FLOAT\"\n    };\n    class U {\n      constructor(e, t, i, o) {\n        this.length = t.length, this.attributes = i, this.itemSize = t.bytesPerElement, this.dynamicDraw = o, this.context = e;\n        const r = e.gl;\n        this.buffer = r.createBuffer(), e.bindVertexBuffer.set(this.buffer), r.bufferData(r.ARRAY_BUFFER, t.arrayBuffer, this.dynamicDraw ? r.DYNAMIC_DRAW : r.STATIC_DRAW), this.dynamicDraw || t.destroy();\n      }\n      bind() {\n        this.context.bindVertexBuffer.set(this.buffer);\n      }\n      updateData(e) {\n        const t = this.context.gl;\n        this.bind(), t.bufferSubData(t.ARRAY_BUFFER, 0, e.arrayBuffer);\n      }\n      enableAttributes(e, t) {\n        for (let i = 0; i < this.attributes.length; i++) {\n          const o = t.attributes[this.attributes[i].name];\n          void 0 !== o && e.enableVertexAttribArray(o);\n        }\n      }\n      setVertexAttribPointers(e, t, i) {\n        for (let o = 0; o < this.attributes.length; o++) {\n          const r = this.attributes[o],\n            n = t.attributes[r.name];\n          void 0 !== n && e.vertexAttribPointer(n, r.components, e[F[r.type]], !1, this.itemSize, r.offset + this.itemSize * (i || 0));\n        }\n      }\n      destroy() {\n        this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer);\n      }\n    }\n    class N {\n      constructor(e) {\n        this.gl = e.gl, this.default = this.getDefault(), this.current = this.default, this.dirty = !1;\n      }\n      get() {\n        return this.current;\n      }\n      set(e) {}\n      getDefault() {\n        return this.default;\n      }\n      setDefault() {\n        this.set(this.default);\n      }\n    }\n    class j extends N {\n      getDefault() {\n        return e.Color.transparent;\n      }\n      set(e) {\n        const t = this.current;\n        (e.r !== t.r || e.g !== t.g || e.b !== t.b || e.a !== t.a || this.dirty) && (this.gl.clearColor(e.r, e.g, e.b, e.a), this.current = e, this.dirty = !1);\n      }\n    }\n    class G extends N {\n      getDefault() {\n        return 1;\n      }\n      set(e) {\n        (e !== this.current || this.dirty) && (this.gl.clearDepth(e), this.current = e, this.dirty = !1);\n      }\n    }\n    class Z extends N {\n      getDefault() {\n        return 0;\n      }\n      set(e) {\n        (e !== this.current || this.dirty) && (this.gl.clearStencil(e), this.current = e, this.dirty = !1);\n      }\n    }\n    class V extends N {\n      getDefault() {\n        return [!0, !0, !0, !0];\n      }\n      set(e) {\n        const t = this.current;\n        (e[0] !== t[0] || e[1] !== t[1] || e[2] !== t[2] || e[3] !== t[3] || this.dirty) && (this.gl.colorMask(e[0], e[1], e[2], e[3]), this.current = e, this.dirty = !1);\n      }\n    }\n    class W extends N {\n      getDefault() {\n        return !0;\n      }\n      set(e) {\n        (e !== this.current || this.dirty) && (this.gl.depthMask(e), this.current = e, this.dirty = !1);\n      }\n    }\n    class X extends N {\n      getDefault() {\n        return 255;\n      }\n      set(e) {\n        (e !== this.current || this.dirty) && (this.gl.stencilMask(e), this.current = e, this.dirty = !1);\n      }\n    }\n    class q extends N {\n      getDefault() {\n        return {\n          func: this.gl.ALWAYS,\n          ref: 0,\n          mask: 255\n        };\n      }\n      set(e) {\n        const t = this.current;\n        (e.func !== t.func || e.ref !== t.ref || e.mask !== t.mask || this.dirty) && (this.gl.stencilFunc(e.func, e.ref, e.mask), this.current = e, this.dirty = !1);\n      }\n    }\n    class $ extends N {\n      getDefault() {\n        const e = this.gl;\n        return [e.KEEP, e.KEEP, e.KEEP];\n      }\n      set(e) {\n        const t = this.current;\n        (e[0] !== t[0] || e[1] !== t[1] || e[2] !== t[2] || this.dirty) && (this.gl.stencilOp(e[0], e[1], e[2]), this.current = e, this.dirty = !1);\n      }\n    }\n    class H extends N {\n      getDefault() {\n        return !1;\n      }\n      set(e) {\n        if (e === this.current && !this.dirty) return;\n        const t = this.gl;\n        e ? t.enable(t.STENCIL_TEST) : t.disable(t.STENCIL_TEST), this.current = e, this.dirty = !1;\n      }\n    }\n    class Y extends N {\n      getDefault() {\n        return [0, 1];\n      }\n      set(e) {\n        const t = this.current;\n        (e[0] !== t[0] || e[1] !== t[1] || this.dirty) && (this.gl.depthRange(e[0], e[1]), this.current = e, this.dirty = !1);\n      }\n    }\n    class K extends N {\n      getDefault() {\n        return !1;\n      }\n      set(e) {\n        if (e === this.current && !this.dirty) return;\n        const t = this.gl;\n        e ? t.enable(t.DEPTH_TEST) : t.disable(t.DEPTH_TEST), this.current = e, this.dirty = !1;\n      }\n    }\n    class J extends N {\n      getDefault() {\n        return this.gl.LESS;\n      }\n      set(e) {\n        (e !== this.current || this.dirty) && (this.gl.depthFunc(e), this.current = e, this.dirty = !1);\n      }\n    }\n    class Q extends N {\n      getDefault() {\n        return !1;\n      }\n      set(e) {\n        if (e === this.current && !this.dirty) return;\n        const t = this.gl;\n        e ? t.enable(t.BLEND) : t.disable(t.BLEND), this.current = e, this.dirty = !1;\n      }\n    }\n    class ee extends N {\n      getDefault() {\n        const e = this.gl;\n        return [e.ONE, e.ZERO];\n      }\n      set(e) {\n        const t = this.current;\n        (e[0] !== t[0] || e[1] !== t[1] || this.dirty) && (this.gl.blendFunc(e[0], e[1]), this.current = e, this.dirty = !1);\n      }\n    }\n    class te extends N {\n      getDefault() {\n        return e.Color.transparent;\n      }\n      set(e) {\n        const t = this.current;\n        (e.r !== t.r || e.g !== t.g || e.b !== t.b || e.a !== t.a || this.dirty) && (this.gl.blendColor(e.r, e.g, e.b, e.a), this.current = e, this.dirty = !1);\n      }\n    }\n    class ie extends N {\n      getDefault() {\n        return this.gl.FUNC_ADD;\n      }\n      set(e) {\n        (e !== this.current || this.dirty) && (this.gl.blendEquation(e), this.current = e, this.dirty = !1);\n      }\n    }\n    class oe extends N {\n      getDefault() {\n        return !1;\n      }\n      set(e) {\n        if (e === this.current && !this.dirty) return;\n        const t = this.gl;\n        e ? t.enable(t.CULL_FACE) : t.disable(t.CULL_FACE), this.current = e, this.dirty = !1;\n      }\n    }\n    class re extends N {\n      getDefault() {\n        return this.gl.BACK;\n      }\n      set(e) {\n        (e !== this.current || this.dirty) && (this.gl.cullFace(e), this.current = e, this.dirty = !1);\n      }\n    }\n    class ne extends N {\n      getDefault() {\n        return this.gl.CCW;\n      }\n      set(e) {\n        (e !== this.current || this.dirty) && (this.gl.frontFace(e), this.current = e, this.dirty = !1);\n      }\n    }\n    let se,\n      ae = class extends N {\n        getDefault() {\n          return null;\n        }\n        set(e) {\n          (e !== this.current || this.dirty) && (this.gl.useProgram(e), this.current = e, this.dirty = !1);\n        }\n      };\n    class le extends N {\n      getDefault() {\n        return this.gl.TEXTURE0;\n      }\n      set(e) {\n        (e !== this.current || this.dirty) && (this.gl.activeTexture(e), this.current = e, this.dirty = !1);\n      }\n    }\n    class ce extends N {\n      getDefault() {\n        const e = this.gl;\n        return [0, 0, e.drawingBufferWidth, e.drawingBufferHeight];\n      }\n      set(e) {\n        const t = this.current;\n        (e[0] !== t[0] || e[1] !== t[1] || e[2] !== t[2] || e[3] !== t[3] || this.dirty) && (this.gl.viewport(e[0], e[1], e[2], e[3]), this.current = e, this.dirty = !1);\n      }\n    }\n    class he extends N {\n      getDefault() {\n        return null;\n      }\n      set(e) {\n        if (e === this.current && !this.dirty) return;\n        const t = this.gl;\n        t.bindFramebuffer(t.FRAMEBUFFER, e), this.current = e, this.dirty = !1;\n      }\n    }\n    class ue extends N {\n      getDefault() {\n        return null;\n      }\n      set(e) {\n        if (e === this.current && !this.dirty) return;\n        const t = this.gl;\n        t.bindRenderbuffer(t.RENDERBUFFER, e), this.current = e, this.dirty = !1;\n      }\n    }\n    class _e extends N {\n      getDefault() {\n        return null;\n      }\n      set(e) {\n        if (e === this.current && !this.dirty) return;\n        const t = this.gl;\n        t.bindTexture(t.TEXTURE_2D, e), this.current = e, this.dirty = !1;\n      }\n    }\n    class de extends N {\n      getDefault() {\n        return null;\n      }\n      set(e) {\n        if (e === this.current && !this.dirty) return;\n        const t = this.gl;\n        t.bindBuffer(t.ARRAY_BUFFER, e), this.current = e, this.dirty = !1;\n      }\n    }\n    class pe extends N {\n      getDefault() {\n        return null;\n      }\n      set(e) {\n        const t = this.gl;\n        t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, e), this.current = e, this.dirty = !1;\n      }\n    }\n    class me extends N {\n      constructor(e) {\n        super(e), this.vao = e.extVertexArrayObject;\n      }\n      getDefault() {\n        return null;\n      }\n      set(e) {\n        this.vao && (e !== this.current || this.dirty) && (this.vao.bindVertexArrayOES(e), this.current = e, this.dirty = !1);\n      }\n    }\n    class fe extends N {\n      getDefault() {\n        return 4;\n      }\n      set(e) {\n        if (e === this.current && !this.dirty) return;\n        const t = this.gl;\n        t.pixelStorei(t.UNPACK_ALIGNMENT, e), this.current = e, this.dirty = !1;\n      }\n    }\n    class ge extends N {\n      getDefault() {\n        return !1;\n      }\n      set(e) {\n        if (e === this.current && !this.dirty) return;\n        const t = this.gl;\n        t.pixelStorei(t.UNPACK_PREMULTIPLY_ALPHA_WEBGL, e), this.current = e, this.dirty = !1;\n      }\n    }\n    class ve extends N {\n      getDefault() {\n        return !1;\n      }\n      set(e) {\n        if (e === this.current && !this.dirty) return;\n        const t = this.gl;\n        t.pixelStorei(t.UNPACK_FLIP_Y_WEBGL, e), this.current = e, this.dirty = !1;\n      }\n    }\n    class xe extends N {\n      constructor(e, t) {\n        super(e), this.context = e, this.parent = t;\n      }\n      getDefault() {\n        return null;\n      }\n    }\n    class ye extends xe {\n      setDirty() {\n        this.dirty = !0;\n      }\n      set(e) {\n        if (e === this.current && !this.dirty) return;\n        this.context.bindFramebuffer.set(this.parent);\n        const t = this.gl;\n        t.framebufferTexture2D(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0, t.TEXTURE_2D, e, 0), this.current = e, this.dirty = !1;\n      }\n    }\n    class be extends xe {\n      attachment() {\n        return this.gl.DEPTH_ATTACHMENT;\n      }\n      set(e) {\n        if (e === this.current && !this.dirty) return;\n        this.context.bindFramebuffer.set(this.parent);\n        const t = this.gl;\n        t.framebufferRenderbuffer(t.FRAMEBUFFER, this.attachment(), t.RENDERBUFFER, e), this.current = e, this.dirty = !1;\n      }\n    }\n    class we extends be {\n      attachment() {\n        return this.gl.DEPTH_STENCIL_ATTACHMENT;\n      }\n    }\n    class Te {\n      constructor(e, t, i, o) {\n        this.context = e, this.width = t, this.height = i;\n        const r = this.framebuffer = e.gl.createFramebuffer();\n        this.colorAttachment = new ye(e, r), o && (this.depthAttachment = new be(e, r));\n      }\n      destroy() {\n        const e = this.context.gl,\n          t = this.colorAttachment.get();\n        if (t && e.deleteTexture(t), this.depthAttachment) {\n          const t = this.depthAttachment.get();\n          t && e.deleteRenderbuffer(t);\n        }\n        e.deleteFramebuffer(this.framebuffer);\n      }\n    }\n    class Ee {\n      constructor(e, t = !1) {\n        if (this.gl = e, this.isWebGL2 = t, this.extVertexArrayObject = this.gl.getExtension(\"OES_vertex_array_object\"), t) {\n          const t = e;\n          this.extVertexArrayObject = {\n            createVertexArrayOES: t.createVertexArray.bind(e),\n            deleteVertexArrayOES: t.deleteVertexArray.bind(e),\n            bindVertexArrayOES: t.bindVertexArray.bind(e)\n          };\n        }\n        this.clearColor = new j(this), this.clearDepth = new G(this), this.clearStencil = new Z(this), this.colorMask = new V(this), this.depthMask = new W(this), this.stencilMask = new X(this), this.stencilFunc = new q(this), this.stencilOp = new $(this), this.stencilTest = new H(this), this.depthRange = new Y(this), this.depthTest = new K(this), this.depthFunc = new J(this), this.blend = new Q(this), this.blendFunc = new ee(this), this.blendColor = new te(this), this.blendEquation = new ie(this), this.cullFace = new oe(this), this.cullFaceSide = new re(this), this.frontFace = new ne(this), this.program = new ae(this), this.activeTexture = new le(this), this.viewport = new ce(this), this.bindFramebuffer = new he(this), this.bindRenderbuffer = new ue(this), this.bindTexture = new _e(this), this.bindVertexBuffer = new de(this), this.bindElementBuffer = new pe(this), this.bindVertexArrayOES = this.extVertexArrayObject && new me(this), this.pixelStoreUnpack = new fe(this), this.pixelStoreUnpackPremultiplyAlpha = new ge(this), this.pixelStoreUnpackFlipY = new ve(this), this.extTextureFilterAnisotropic = e.getExtension(\"EXT_texture_filter_anisotropic\") || e.getExtension(\"MOZ_EXT_texture_filter_anisotropic\") || e.getExtension(\"WEBKIT_EXT_texture_filter_anisotropic\"), this.extTextureFilterAnisotropic && (this.extTextureFilterAnisotropicMax = e.getParameter(this.extTextureFilterAnisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT)), this.extTextureFilterAnisotropicForceOff = !1, this.extStandardDerivativesForceOff = !1, this.extDebugRendererInfo = e.getExtension(\"WEBGL_debug_renderer_info\"), this.extDebugRendererInfo && (this.renderer = e.getParameter(this.extDebugRendererInfo.UNMASKED_RENDERER_WEBGL), this.vendor = e.getParameter(this.extDebugRendererInfo.UNMASKED_VENDOR_WEBGL)), t || (this.extTextureHalfFloat = e.getExtension(\"OES_texture_half_float\")), (t || this.extTextureHalfFloat && e.getExtension(\"OES_texture_half_float_linear\")) && (this.extRenderToTextureHalfFloat = e.getExtension(\"EXT_color_buffer_half_float\")), this.extStandardDerivatives = t || e.getExtension(\"OES_standard_derivatives\"), this.extTimerQuery = e.getExtension(\"EXT_disjoint_timer_query\"), this.maxTextureSize = e.getParameter(e.MAX_TEXTURE_SIZE);\n      }\n      setDefault() {\n        this.unbindVAO(), this.clearColor.setDefault(), this.clearDepth.setDefault(), this.clearStencil.setDefault(), this.colorMask.setDefault(), this.depthMask.setDefault(), this.stencilMask.setDefault(), this.stencilFunc.setDefault(), this.stencilOp.setDefault(), this.stencilTest.setDefault(), this.depthRange.setDefault(), this.depthTest.setDefault(), this.depthFunc.setDefault(), this.blend.setDefault(), this.blendFunc.setDefault(), this.blendColor.setDefault(), this.blendEquation.setDefault(), this.cullFace.setDefault(), this.cullFaceSide.setDefault(), this.frontFace.setDefault(), this.program.setDefault(), this.activeTexture.setDefault(), this.bindFramebuffer.setDefault(), this.pixelStoreUnpack.setDefault(), this.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.pixelStoreUnpackFlipY.setDefault();\n      }\n      setDirty() {\n        this.clearColor.dirty = !0, this.clearDepth.dirty = !0, this.clearStencil.dirty = !0, this.colorMask.dirty = !0, this.depthMask.dirty = !0, this.stencilMask.dirty = !0, this.stencilFunc.dirty = !0, this.stencilOp.dirty = !0, this.stencilTest.dirty = !0, this.depthRange.dirty = !0, this.depthTest.dirty = !0, this.depthFunc.dirty = !0, this.blend.dirty = !0, this.blendFunc.dirty = !0, this.blendColor.dirty = !0, this.blendEquation.dirty = !0, this.cullFace.dirty = !0, this.cullFaceSide.dirty = !0, this.frontFace.dirty = !0, this.program.dirty = !0, this.activeTexture.dirty = !0, this.viewport.dirty = !0, this.bindFramebuffer.dirty = !0, this.bindRenderbuffer.dirty = !0, this.bindTexture.dirty = !0, this.bindVertexBuffer.dirty = !0, this.bindElementBuffer.dirty = !0, this.extVertexArrayObject && (this.bindVertexArrayOES.dirty = !0), this.pixelStoreUnpack.dirty = !0, this.pixelStoreUnpackPremultiplyAlpha.dirty = !0, this.pixelStoreUnpackFlipY.dirty = !0;\n      }\n      createIndexBuffer(e, t) {\n        return new k(this, e, t);\n      }\n      createVertexBuffer(e, t, i) {\n        return new U(this, e, t, i);\n      }\n      createRenderbuffer(e, t, i) {\n        const o = this.gl,\n          r = o.createRenderbuffer();\n        return this.bindRenderbuffer.set(r), o.renderbufferStorage(o.RENDERBUFFER, e, t, i), this.bindRenderbuffer.set(null), r;\n      }\n      createFramebuffer(e, t, i) {\n        return new Te(this, e, t, i);\n      }\n      clear({\n        color: e,\n        depth: t,\n        stencil: i\n      }) {\n        const o = this.gl;\n        let r = 0;\n        e && (r |= o.COLOR_BUFFER_BIT, this.clearColor.set(e), this.colorMask.set([!0, !0, !0, !0])), void 0 !== t && (r |= o.DEPTH_BUFFER_BIT, this.depthRange.set([0, 1]), this.clearDepth.set(t), this.depthMask.set(!0)), void 0 !== i && (r |= o.STENCIL_BUFFER_BIT, this.clearStencil.set(i), this.stencilMask.set(255)), o.clear(r);\n      }\n      setCullFace(e) {\n        !1 === e.enable ? this.cullFace.set(!1) : (this.cullFace.set(!0), this.cullFaceSide.set(e.mode), this.frontFace.set(e.frontFace));\n      }\n      setDepthMode(e) {\n        e.func !== this.gl.ALWAYS || e.mask ? (this.depthTest.set(!0), this.depthFunc.set(e.func), this.depthMask.set(e.mask), this.depthRange.set(e.range)) : this.depthTest.set(!1);\n      }\n      setStencilMode(e) {\n        e.test.func !== this.gl.ALWAYS || e.mask ? (this.stencilTest.set(!0), this.stencilMask.set(e.mask), this.stencilOp.set([e.fail, e.depthFail, e.pass]), this.stencilFunc.set({\n          func: e.test.func,\n          ref: e.ref,\n          mask: e.test.mask\n        })) : this.stencilTest.set(!1);\n      }\n      setColorMode(i) {\n        t(i.blendFunction, e.ColorMode.Replace) ? this.blend.set(!1) : (this.blend.set(!0), this.blendFunc.set(i.blendFunction), this.blendColor.set(i.blendColor)), this.colorMask.set(i.mask);\n      }\n      unbindVAO() {\n        this.extVertexArrayObject && this.bindVertexArrayOES.set(null);\n      }\n    }\n    class Ce extends e.Evented {\n      constructor(t, i, o, r) {\n        if (super(), this.id = t, this.dispatcher = o, this.type = \"vector\", this.minzoom = 0, this.maxzoom = 22, this.scheme = \"xyz\", this.tileSize = 512, this.reparseOverscaled = !0, this.isTileClipped = !0, this._loaded = !1, e.extend(this, e.pick(i, [\"url\", \"scheme\", \"tileSize\", \"promoteId\"])), this._options = e.extend({\n          type: \"vector\"\n        }, i), this._collectResourceTiming = i.collectResourceTiming, 512 !== this.tileSize) throw new Error(\"vector tile sources must have a tileSize of 512\");\n        this.setEventedParent(r), this._tileWorkers = {}, this._deduped = new e.DedupedRequest();\n      }\n      load(t) {\n        this._loaded = !1, this.fire(new e.Event(\"dataloading\", {\n          dataType: \"source\"\n        }));\n        const i = Array.isArray(this.map._language) ? this.map._language.join() : this.map._language,\n          o = this.map._worldview;\n        this._tileJSONRequest = O(this._options, this.map._requestManager, i, o, (r, n) => {\n          this._tileJSONRequest = null, this._loaded = !0, r ? (i && console.warn(`Ensure that your requested language string is a valid BCP-47 code or list of codes. Found: ${i}`), o && 2 !== o.length && console.warn(`Requested worldview strings must be a valid ISO alpha-2 code. Found: ${o}`), this.fire(new e.ErrorEvent(r))) : n && (e.extend(this, n), n.bounds && (this.tileBounds = new B(n.bounds, this.minzoom, this.maxzoom)), e.postTurnstileEvent(n.tiles, this.map._requestManager._customAccessToken), this.fire(new e.Event(\"data\", {\n            dataType: \"source\",\n            sourceDataType: \"metadata\"\n          })), this.fire(new e.Event(\"data\", {\n            dataType: \"source\",\n            sourceDataType: \"content\"\n          }))), t && t(r);\n        });\n      }\n      loaded() {\n        return this._loaded;\n      }\n      hasTile(e) {\n        return !this.tileBounds || this.tileBounds.contains(e.canonical);\n      }\n      onAdd(e) {\n        this.map = e, this.load();\n      }\n      reload() {\n        this.cancelTileJSONRequest(), this.load(() => this.map.style._clearSource(this.id));\n      }\n      setTiles(e) {\n        return this._options.tiles = e, this.reload(), this;\n      }\n      setUrl(e) {\n        return this.url = e, this._options.url = e, this.reload(), this;\n      }\n      onRemove() {\n        this.cancelTileJSONRequest();\n      }\n      serialize() {\n        return e.extend({}, this._options);\n      }\n      loadTile(t, i) {\n        const o = this.map._requestManager.normalizeTileURL(t.tileID.canonical.url(this.tiles, this.scheme)),\n          r = {\n            request: this.map._requestManager.transformRequest(o, e.ResourceType.Tile),\n            data: void 0,\n            uid: t.uid,\n            tileID: t.tileID,\n            tileZoom: t.tileZoom,\n            zoom: t.tileID.overscaledZ,\n            tileSize: this.tileSize * t.tileID.overscaleFactor(),\n            type: this.type,\n            source: this.id,\n            pixelRatio: e.exported.devicePixelRatio,\n            showCollisionBoxes: this.map.showCollisionBoxes,\n            promoteId: this.promoteId,\n            isSymbolTile: t.isSymbolTile\n          };\n        if (r.request.collectResourceTiming = this._collectResourceTiming, t.actor && \"expired\" !== t.state) \"loading\" === t.state ? t.reloadCallback = i : t.request = t.actor.send(\"reloadTile\", r, n.bind(this));else if (t.actor = this._tileWorkers[o] = this._tileWorkers[o] || this.dispatcher.getActor(), this.dispatcher.ready) t.request = t.actor.send(\"loadTile\", r, n.bind(this), void 0, !0);else {\n          const i = e.loadVectorTile.call({\n            deduped: this._deduped\n          }, r, (e, i) => {\n            e || !i ? n.call(this, e) : (r.data = {\n              cacheControl: i.cacheControl,\n              expires: i.expires,\n              rawData: i.rawData.slice(0)\n            }, t.actor && t.actor.send(\"loadTile\", r, n.bind(this), void 0, !0));\n          }, !0);\n          t.request = {\n            cancel: i\n          };\n        }\n        function n(o, r) {\n          return delete t.request, t.aborted ? i(null) : o && 404 !== o.status ? i(o) : (r && r.resourceTiming && (t.resourceTiming = r.resourceTiming), this.map._refreshExpiredTiles && r && t.setExpiryData(r), t.loadVectorData(r, this.map.painter), e.cacheEntryPossiblyAdded(this.dispatcher), i(null), void (t.reloadCallback && (this.loadTile(t, t.reloadCallback), t.reloadCallback = null)));\n        }\n      }\n      abortTile(e) {\n        e.request && (e.request.cancel(), delete e.request), e.actor && e.actor.send(\"abortTile\", {\n          uid: e.uid,\n          type: this.type,\n          source: this.id\n        });\n      }\n      unloadTile(e) {\n        e.unloadVectorData(), e.actor && e.actor.send(\"removeTile\", {\n          uid: e.uid,\n          type: this.type,\n          source: this.id\n        });\n      }\n      hasTransition() {\n        return !1;\n      }\n      afterUpdate() {\n        this._tileWorkers = {};\n      }\n      cancelTileJSONRequest() {\n        this._tileJSONRequest && (this._tileJSONRequest.cancel(), this._tileJSONRequest = null);\n      }\n    }\n    class Me extends e.Evented {\n      constructor(t, i, o, r) {\n        super(), this.id = t, this.dispatcher = o, this.setEventedParent(r), this.type = \"raster\", this.minzoom = 0, this.maxzoom = 22, this.roundZoom = !0, this.scheme = \"xyz\", this.tileSize = 512, this._loaded = !1, this._options = e.extend({\n          type: \"raster\"\n        }, i), e.extend(this, e.pick(i, [\"url\", \"scheme\", \"tileSize\"]));\n      }\n      load(t) {\n        this._loaded = !1, this.fire(new e.Event(\"dataloading\", {\n          dataType: \"source\"\n        })), this._tileJSONRequest = O(this._options, this.map._requestManager, null, null, (i, o) => {\n          this._tileJSONRequest = null, this._loaded = !0, i ? this.fire(new e.ErrorEvent(i)) : o && (e.extend(this, o), o.bounds && (this.tileBounds = new B(o.bounds, this.minzoom, this.maxzoom)), e.postTurnstileEvent(o.tiles), this.fire(new e.Event(\"data\", {\n            dataType: \"source\",\n            sourceDataType: \"metadata\"\n          })), this.fire(new e.Event(\"data\", {\n            dataType: \"source\",\n            sourceDataType: \"content\"\n          }))), t && t(i);\n        });\n      }\n      loaded() {\n        return this._loaded;\n      }\n      onAdd(e) {\n        this.map = e, this.load();\n      }\n      reload() {\n        this.cancelTileJSONRequest(), this.load(() => this.map.style._clearSource(this.id));\n      }\n      setTiles(e) {\n        return this._options.tiles = e, this.reload(), this;\n      }\n      setUrl(e) {\n        return this.url = e, this._options.url = e, this.reload(), this;\n      }\n      onRemove() {\n        this.cancelTileJSONRequest();\n      }\n      serialize() {\n        return e.extend({}, this._options);\n      }\n      hasTile(e) {\n        return !this.tileBounds || this.tileBounds.contains(e.canonical);\n      }\n      loadTile(t, i) {\n        const o = e.exported.devicePixelRatio >= 2,\n          r = this.map._requestManager.normalizeTileURL(t.tileID.canonical.url(this.tiles, this.scheme), o, this.tileSize);\n        t.request = e.getImage(this.map._requestManager.transformRequest(r, e.ResourceType.Tile), (o, r, n, s) => (delete t.request, t.aborted ? (t.state = \"unloaded\", i(null)) : o ? (t.state = \"errored\", i(o)) : r ? (this.map._refreshExpiredTiles && t.setExpiryData({\n          cacheControl: n,\n          expires: s\n        }), t.setTexture(r, this.map.painter), t.state = \"loaded\", e.cacheEntryPossiblyAdded(this.dispatcher), void i(null)) : i(null)));\n      }\n      static loadTileData(e, t, i) {\n        e.setTexture(t, i);\n      }\n      static unloadTileData(e, t) {\n        e.texture && t.saveTileTexture(e.texture);\n      }\n      abortTile(e, t) {\n        e.request && (e.request.cancel(), delete e.request), t();\n      }\n      unloadTile(e, t) {\n        e.texture && this.map.painter.saveTileTexture(e.texture), t();\n      }\n      hasTransition() {\n        return !1;\n      }\n      cancelTileJSONRequest() {\n        this._tileJSONRequest && (this._tileJSONRequest.cancel(), this._tileJSONRequest = null);\n      }\n    }\n    function Ie(t, i, o, r, n, s, a, l) {\n      const c = [t, o, n, i, r, s, 1, 1, 1],\n        h = [a, l, 1],\n        u = e.adjoint([], c),\n        [_, d, p] = e.transformMat3(h, h, e.transpose(u, u));\n      return e.multiply$1(c, [_, 0, 0, 0, d, 0, 0, 0, p], c);\n    }\n    class Pe extends e.Evented {\n      constructor(e, t, i, o) {\n        super(), this.id = e, this.dispatcher = i, this.coordinates = t.coordinates, this.type = \"image\", this.minzoom = 0, this.maxzoom = 22, this.tileSize = 512, this.tiles = {}, this._loaded = !1, this.setEventedParent(o), this.options = t, this._dirty = !1;\n      }\n      load(t, i) {\n        this._loaded = i || !1, this.fire(new e.Event(\"dataloading\", {\n          dataType: \"source\"\n        })), this.url = this.options.url, this._imageRequest = e.getImage(this.map._requestManager.transformRequest(this.url, e.ResourceType.Image), (i, o) => {\n          if (this._imageRequest = null, this._loaded = !0, i) this.fire(new e.ErrorEvent(i));else if (o) {\n            const {\n              HTMLImageElement: i\n            } = e.window;\n            this.image = o instanceof i ? e.exported.getImageData(o) : o, this._dirty = !0, this.width = this.image.width, this.height = this.image.height, t && (this.coordinates = t), this._finishLoading();\n          }\n        });\n      }\n      loaded() {\n        return this._loaded;\n      }\n      updateImage(e) {\n        return this.image && e.url ? (this._imageRequest && e.url !== this.options.url && (this._imageRequest.cancel(), this._imageRequest = null), this.options.url = e.url, this.load(e.coordinates, this._loaded), this) : this;\n      }\n      _finishLoading() {\n        this.map && (this.setCoordinates(this.coordinates), this.fire(new e.Event(\"data\", {\n          dataType: \"source\",\n          sourceDataType: \"metadata\"\n        })));\n      }\n      onAdd(e) {\n        this.map = e, this.load();\n      }\n      onRemove() {\n        this._imageRequest && (this._imageRequest.cancel(), this._imageRequest = null), this.texture && this.texture.destroy();\n      }\n      setCoordinates(t) {\n        this.coordinates = t, this._boundsArray = void 0;\n        const i = t.map(e.MercatorCoordinate.fromLngLat);\n        return this.tileID = function (t) {\n          let i = 1 / 0,\n            o = 1 / 0,\n            r = -1 / 0,\n            n = -1 / 0;\n          for (const e of t) i = Math.min(i, e.x), o = Math.min(o, e.y), r = Math.max(r, e.x), n = Math.max(n, e.y);\n          const s = Math.max(r - i, n - o),\n            a = Math.max(0, Math.floor(-Math.log(s) / Math.LN2)),\n            l = Math.pow(2, a);\n          return new e.CanonicalTileID(a, Math.floor((i + r) / 2 * l), Math.floor((o + n) / 2 * l));\n        }(i), this.minzoom = this.maxzoom = this.tileID.z, this.fire(new e.Event(\"data\", {\n          dataType: \"source\",\n          sourceDataType: \"content\"\n        })), this;\n      }\n      _clear() {\n        this._boundsArray = void 0;\n      }\n      _prepareData(t) {\n        for (const e in this.tiles) {\n          const t = this.tiles[e];\n          \"loaded\" !== t.state && (t.state = \"loaded\", t.texture = this.texture);\n        }\n        if (this._boundsArray) return;\n        const i = e.tileTransform(this.tileID, this.map.transform.projection),\n          [o, r, n, s] = this.coordinates.map(t => {\n            const o = i.projection.project(t[0], t[1]);\n            return e.getTilePoint(i, o)._round();\n          });\n        this.perspectiveTransform = function (t, i, o, r, n, s, a, l, c, h) {\n          const u = Ie(0, 0, t, 0, 0, i, t, i),\n            _ = Ie(o, r, n, s, a, l, c, h);\n          return e.multiply$1(_, e.adjoint(u, u), _), [_[6] / _[8] * t / e.EXTENT, _[7] / _[8] * i / e.EXTENT];\n        }(this.width, this.height, o.x, o.y, r.x, r.y, s.x, s.y, n.x, n.y);\n        const a = this._boundsArray = new e.StructArrayLayout4i8();\n        a.emplaceBack(o.x, o.y, 0, 0), a.emplaceBack(r.x, r.y, e.EXTENT, 0), a.emplaceBack(s.x, s.y, 0, e.EXTENT), a.emplaceBack(n.x, n.y, e.EXTENT, e.EXTENT), this.boundsBuffer && this.boundsBuffer.destroy(), this.boundsBuffer = t.createVertexBuffer(a, e.boundsAttributes.members), this.boundsSegments = e.SegmentVector.simpleSegment(0, 0, 4, 2);\n      }\n      prepare() {\n        if (0 === Object.keys(this.tiles).length || !this.image) return;\n        const t = this.map.painter.context,\n          i = t.gl;\n        this._dirty && (this.texture ? this.texture.update(this.image) : (this.texture = new e.Texture(t, this.image, i.RGBA), this.texture.bind(i.LINEAR, i.CLAMP_TO_EDGE)), this._dirty = !1), this._prepareData(t);\n      }\n      loadTile(e, t) {\n        this.tileID && this.tileID.equals(e.tileID.canonical) ? (this.tiles[String(e.tileID.wrap)] = e, e.buckets = {}, t(null)) : (e.state = \"errored\", t(null));\n      }\n      serialize() {\n        return {\n          type: \"image\",\n          url: this.options.url,\n          coordinates: this.coordinates\n        };\n      }\n      hasTransition() {\n        return !1;\n      }\n    }\n    const Se = {\n        vector: Ce,\n        raster: Me,\n        \"raster-dem\": class extends Me {\n          constructor(t, i, o, r) {\n            super(t, i, o, r), this.type = \"raster-dem\", this.maxzoom = 22, this._options = e.extend({\n              type: \"raster-dem\"\n            }, i), this.encoding = i.encoding || \"mapbox\";\n          }\n          loadTile(t, i) {\n            const o = this.map._requestManager.normalizeTileURL(t.tileID.canonical.url(this.tiles, this.scheme), !1, this.tileSize);\n            function r(e, o) {\n              e && (t.state = \"errored\", i(e)), o && (t.dem = o, t.dem.onDeserialize(), t.needsHillshadePrepare = !0, t.needsDEMTextureUpload = !0, t.state = \"loaded\", i(null));\n            }\n            t.request = e.getImage(this.map._requestManager.transformRequest(o, e.ResourceType.Tile), function (o, n, s, a) {\n              if (delete t.request, t.aborted) t.state = \"unloaded\", i(null);else if (o) t.state = \"errored\", i(o);else if (n) {\n                this.map._refreshExpiredTiles && t.setExpiryData({\n                  cacheControl: s,\n                  expires: a\n                });\n                const i = e.window.ImageBitmap && n instanceof e.window.ImageBitmap && (null == se && (se = e.window.OffscreenCanvas && new e.window.OffscreenCanvas(1, 1).getContext(\"2d\") && \"function\" == typeof e.window.createImageBitmap), se),\n                  o = 1 - (n.width - e.prevPowerOfTwo(n.width)) / 2;\n                o < 1 || t.neighboringTiles || (t.neighboringTiles = this._getNeighboringTiles(t.tileID));\n                const l = i ? n : e.exported.getImageData(n, o),\n                  c = {\n                    uid: t.uid,\n                    coord: t.tileID,\n                    source: this.id,\n                    rawImageData: l,\n                    encoding: this.encoding,\n                    padding: o\n                  };\n                t.actor && \"expired\" !== t.state || (t.actor = this.dispatcher.getActor(), t.actor.send(\"loadDEMTile\", c, r.bind(this), void 0, !0));\n              }\n            }.bind(this));\n          }\n          _getNeighboringTiles(t) {\n            const i = t.canonical,\n              o = Math.pow(2, i.z),\n              r = (i.x - 1 + o) % o,\n              n = 0 === i.x ? t.wrap - 1 : t.wrap,\n              s = (i.x + 1 + o) % o,\n              a = i.x + 1 === o ? t.wrap + 1 : t.wrap,\n              l = {};\n            return l[new e.OverscaledTileID(t.overscaledZ, n, i.z, r, i.y).key] = {\n              backfilled: !1\n            }, l[new e.OverscaledTileID(t.overscaledZ, a, i.z, s, i.y).key] = {\n              backfilled: !1\n            }, i.y > 0 && (l[new e.OverscaledTileID(t.overscaledZ, n, i.z, r, i.y - 1).key] = {\n              backfilled: !1\n            }, l[new e.OverscaledTileID(t.overscaledZ, t.wrap, i.z, i.x, i.y - 1).key] = {\n              backfilled: !1\n            }, l[new e.OverscaledTileID(t.overscaledZ, a, i.z, s, i.y - 1).key] = {\n              backfilled: !1\n            }), i.y + 1 < o && (l[new e.OverscaledTileID(t.overscaledZ, n, i.z, r, i.y + 1).key] = {\n              backfilled: !1\n            }, l[new e.OverscaledTileID(t.overscaledZ, t.wrap, i.z, i.x, i.y + 1).key] = {\n              backfilled: !1\n            }, l[new e.OverscaledTileID(t.overscaledZ, a, i.z, s, i.y + 1).key] = {\n              backfilled: !1\n            }), l;\n          }\n          unloadTile(e) {\n            e.demTexture && this.map.painter.saveTileTexture(e.demTexture), e.fbo && (e.fbo.destroy(), delete e.fbo), e.dem && delete e.dem, delete e.neighboringTiles, e.state = \"unloaded\";\n          }\n        },\n        geojson: class extends e.Evented {\n          constructor(t, i, o, r) {\n            super(), this.id = t, this.type = \"geojson\", this.minzoom = 0, this.maxzoom = 18, this.tileSize = 512, this.isTileClipped = !0, this.reparseOverscaled = !0, this._loaded = !1, this.actor = o.getActor(), this.setEventedParent(r), this._data = i.data, this._options = e.extend({}, i), this._collectResourceTiming = i.collectResourceTiming, void 0 !== i.maxzoom && (this.maxzoom = i.maxzoom), i.type && (this.type = i.type), i.attribution && (this.attribution = i.attribution), this.promoteId = i.promoteId;\n            const n = e.EXTENT / this.tileSize;\n            this.workerOptions = e.extend({\n              source: this.id,\n              cluster: i.cluster || !1,\n              geojsonVtOptions: {\n                buffer: (void 0 !== i.buffer ? i.buffer : 128) * n,\n                tolerance: (void 0 !== i.tolerance ? i.tolerance : .375) * n,\n                extent: e.EXTENT,\n                maxZoom: this.maxzoom,\n                lineMetrics: i.lineMetrics || !1,\n                generateId: i.generateId || !1\n              },\n              superclusterOptions: {\n                maxZoom: void 0 !== i.clusterMaxZoom ? i.clusterMaxZoom : this.maxzoom - 1,\n                minPoints: Math.max(2, i.clusterMinPoints || 2),\n                extent: e.EXTENT,\n                radius: (void 0 !== i.clusterRadius ? i.clusterRadius : 50) * n,\n                log: !1,\n                generateId: i.generateId || !1\n              },\n              clusterProperties: i.clusterProperties,\n              filter: i.filter\n            }, i.workerOptions);\n          }\n          onAdd(e) {\n            this.map = e, this.setData(this._data);\n          }\n          setData(e) {\n            return this._data = e, this._updateWorkerData(), this;\n          }\n          getClusterExpansionZoom(e, t) {\n            return this.actor.send(\"geojson.getClusterExpansionZoom\", {\n              clusterId: e,\n              source: this.id\n            }, t), this;\n          }\n          getClusterChildren(e, t) {\n            return this.actor.send(\"geojson.getClusterChildren\", {\n              clusterId: e,\n              source: this.id\n            }, t), this;\n          }\n          getClusterLeaves(e, t, i, o) {\n            return this.actor.send(\"geojson.getClusterLeaves\", {\n              source: this.id,\n              clusterId: e,\n              limit: t,\n              offset: i\n            }, o), this;\n          }\n          _updateWorkerData() {\n            if (this._pendingLoad) return void (this._coalesce = !0);\n            this.fire(new e.Event(\"dataloading\", {\n              dataType: \"source\"\n            })), this._loaded = !1;\n            const t = e.extend({}, this.workerOptions),\n              i = this._data;\n            \"string\" == typeof i ? (t.request = this.map._requestManager.transformRequest(e.exported.resolveURL(i), e.ResourceType.Source), t.request.collectResourceTiming = this._collectResourceTiming) : t.data = JSON.stringify(i), this._pendingLoad = this.actor.send(`${this.type}.loadData`, t, (t, i) => {\n              if (this._loaded = !0, this._pendingLoad = null, t) this.fire(new e.ErrorEvent(t));else {\n                const t = {\n                  dataType: \"source\",\n                  sourceDataType: this._metadataFired ? \"content\" : \"metadata\"\n                };\n                this._collectResourceTiming && i && i.resourceTiming && i.resourceTiming[this.id] && (t.resourceTiming = i.resourceTiming[this.id]), this.fire(new e.Event(\"data\", t)), this._metadataFired = !0;\n              }\n              this._coalesce && (this._updateWorkerData(), this._coalesce = !1);\n            });\n          }\n          loaded() {\n            return this._loaded;\n          }\n          loadTile(t, i) {\n            const o = t.actor ? \"reloadTile\" : \"loadTile\";\n            t.actor = this.actor, t.request = this.actor.send(o, {\n              type: this.type,\n              uid: t.uid,\n              tileID: t.tileID,\n              tileZoom: t.tileZoom,\n              zoom: t.tileID.overscaledZ,\n              maxZoom: this.maxzoom,\n              tileSize: this.tileSize,\n              source: this.id,\n              pixelRatio: e.exported.devicePixelRatio,\n              showCollisionBoxes: this.map.showCollisionBoxes,\n              promoteId: this.promoteId\n            }, (e, r) => (delete t.request, t.unloadVectorData(), t.aborted ? i(null) : e ? i(e) : (t.loadVectorData(r, this.map.painter, \"reloadTile\" === o), i(null))), void 0, \"loadTile\" === o);\n          }\n          abortTile(e) {\n            e.request && (e.request.cancel(), delete e.request), e.aborted = !0;\n          }\n          unloadTile(e) {\n            e.unloadVectorData(), this.actor.send(\"removeTile\", {\n              uid: e.uid,\n              type: this.type,\n              source: this.id\n            });\n          }\n          onRemove() {\n            this._pendingLoad && this._pendingLoad.cancel();\n          }\n          serialize() {\n            return e.extend({}, this._options, {\n              type: this.type,\n              data: this._data\n            });\n          }\n          hasTransition() {\n            return !1;\n          }\n        },\n        video: class extends Pe {\n          constructor(e, t, i, o) {\n            super(e, t, i, o), this.roundZoom = !0, this.type = \"video\", this.options = t;\n          }\n          load() {\n            this._loaded = !1;\n            const t = this.options;\n            this.urls = [];\n            for (const i of t.urls) this.urls.push(this.map._requestManager.transformRequest(i, e.ResourceType.Source).url);\n            e.getVideo(this.urls, (t, i) => {\n              this._loaded = !0, t ? this.fire(new e.ErrorEvent(t)) : i && (this.video = i, this.video.loop = !0, this.video.setAttribute(\"playsinline\", \"\"), this.video.addEventListener(\"playing\", () => {\n                this.map.triggerRepaint();\n              }), this.map && this.video.play(), this._finishLoading());\n            });\n          }\n          pause() {\n            this.video && this.video.pause();\n          }\n          play() {\n            this.video && this.video.play();\n          }\n          seek(t) {\n            if (this.video) {\n              const i = this.video.seekable;\n              t < i.start(0) || t > i.end(0) ? this.fire(new e.ErrorEvent(new e.ValidationError(`sources.${this.id}`, null, `Playback for this video can be set only between the ${i.start(0)} and ${i.end(0)}-second mark.`))) : this.video.currentTime = t;\n            }\n          }\n          getVideo() {\n            return this.video;\n          }\n          onAdd(e) {\n            this.map || (this.map = e, this.load(), this.video && (this.video.play(), this.setCoordinates(this.coordinates)));\n          }\n          prepare() {\n            if (0 === Object.keys(this.tiles).length || this.video.readyState < 2) return;\n            const t = this.map.painter.context,\n              i = t.gl;\n            this.texture ? this.video.paused || (this.texture.bind(i.LINEAR, i.CLAMP_TO_EDGE), i.texSubImage2D(i.TEXTURE_2D, 0, 0, 0, i.RGBA, i.UNSIGNED_BYTE, this.video)) : (this.texture = new e.Texture(t, this.video, i.RGBA), this.texture.bind(i.LINEAR, i.CLAMP_TO_EDGE), this.width = this.video.videoWidth, this.height = this.video.videoHeight), this._prepareData(t);\n          }\n          serialize() {\n            return {\n              type: \"video\",\n              urls: this.urls,\n              coordinates: this.coordinates\n            };\n          }\n          hasTransition() {\n            return this.video && !this.video.paused;\n          }\n        },\n        image: Pe,\n        canvas: class extends Pe {\n          constructor(t, i, o, r) {\n            super(t, i, o, r), i.coordinates ? Array.isArray(i.coordinates) && 4 === i.coordinates.length && !i.coordinates.some(e => !Array.isArray(e) || 2 !== e.length || e.some(e => \"number\" != typeof e)) || this.fire(new e.ErrorEvent(new e.ValidationError(`sources.${t}`, null, '\"coordinates\" property must be an array of 4 longitude/latitude array pairs'))) : this.fire(new e.ErrorEvent(new e.ValidationError(`sources.${t}`, null, 'missing required property \"coordinates\"'))), i.animate && \"boolean\" != typeof i.animate && this.fire(new e.ErrorEvent(new e.ValidationError(`sources.${t}`, null, 'optional \"animate\" property must be a boolean value'))), i.canvas ? \"string\" == typeof i.canvas || i.canvas instanceof e.window.HTMLCanvasElement || this.fire(new e.ErrorEvent(new e.ValidationError(`sources.${t}`, null, '\"canvas\" must be either a string representing the ID of the canvas element from which to read, or an HTMLCanvasElement instance'))) : this.fire(new e.ErrorEvent(new e.ValidationError(`sources.${t}`, null, 'missing required property \"canvas\"'))), this.options = i, this.animate = void 0 === i.animate || i.animate;\n          }\n          load() {\n            this._loaded = !0, this.canvas || (this.canvas = this.options.canvas instanceof e.window.HTMLCanvasElement ? this.options.canvas : e.window.document.getElementById(this.options.canvas)), this.width = this.canvas.width, this.height = this.canvas.height, this._hasInvalidDimensions() ? this.fire(new e.ErrorEvent(new Error(\"Canvas dimensions cannot be less than or equal to zero.\"))) : (this.play = function () {\n              this._playing = !0, this.map.triggerRepaint();\n            }, this.pause = function () {\n              this._playing && (this.prepare(), this._playing = !1);\n            }, this._finishLoading());\n          }\n          getCanvas() {\n            return this.canvas;\n          }\n          onAdd(e) {\n            this.map = e, this.load(), this.canvas && this.animate && this.play();\n          }\n          onRemove() {\n            this.pause();\n          }\n          prepare() {\n            let t = !1;\n            if (this.canvas.width !== this.width && (this.width = this.canvas.width, t = !0), this.canvas.height !== this.height && (this.height = this.canvas.height, t = !0), this._hasInvalidDimensions()) return;\n            if (0 === Object.keys(this.tiles).length) return;\n            const i = this.map.painter.context;\n            this.texture ? (t || this._playing) && this.texture.update(this.canvas, {\n              premultiply: !0\n            }) : this.texture = new e.Texture(i, this.canvas, i.gl.RGBA, {\n              premultiply: !0\n            }), this._prepareData(i);\n          }\n          serialize() {\n            return {\n              type: \"canvas\",\n              coordinates: this.coordinates\n            };\n          }\n          hasTransition() {\n            return this._playing;\n          }\n          _hasInvalidDimensions() {\n            for (const e of [this.canvas.width, this.canvas.height]) if (isNaN(e) || e <= 0) return !0;\n            return !1;\n          }\n        },\n        custom: class extends e.Evented {\n          constructor(t, i, o, r) {\n            super(), this.id = t, this.type = \"custom\", this._dataType = \"raster\", this._dispatcher = o, this._implementation = i, this.setEventedParent(r), this.scheme = \"xyz\", this.minzoom = 0, this.maxzoom = 22, this.tileSize = 512, this._loaded = !1, this.roundZoom = !0, this._implementation || this.fire(new e.ErrorEvent(new Error(`Missing implementation for ${this.id} custom source`))), this._implementation.loadTile || this.fire(new e.ErrorEvent(new Error(`Missing loadTile implementation for ${this.id} custom source`))), this._implementation.bounds && (this.tileBounds = new B(this._implementation.bounds, this.minzoom, this.maxzoom)), i.update = this._update.bind(this), i.clearTiles = this._clearTiles.bind(this), i.coveringTiles = this._coveringTiles.bind(this), e.extend(this, e.pick(i, [\"dataType\", \"scheme\", \"minzoom\", \"maxzoom\", \"tileSize\", \"attribution\", \"minTileCacheSize\", \"maxTileCacheSize\"]));\n          }\n          serialize() {\n            return e.pick(this, [\"type\", \"scheme\", \"minzoom\", \"maxzoom\", \"tileSize\", \"attribution\"]);\n          }\n          load() {\n            this._loaded = !0, this.fire(new e.Event(\"data\", {\n              dataType: \"source\",\n              sourceDataType: \"metadata\"\n            })), this.fire(new e.Event(\"data\", {\n              dataType: \"source\",\n              sourceDataType: \"content\"\n            }));\n          }\n          loaded() {\n            return this._loaded;\n          }\n          onAdd(t) {\n            this._map = t, this._loaded = !1, this.fire(new e.Event(\"dataloading\", {\n              dataType: \"source\"\n            })), this._implementation.onAdd && this._implementation.onAdd(t), this.load();\n          }\n          onRemove(e) {\n            this._implementation.onRemove && this._implementation.onRemove(e);\n          }\n          hasTile(e) {\n            if (this._implementation.hasTile) {\n              const {\n                x: t,\n                y: i,\n                z: o\n              } = e.canonical;\n              return this._implementation.hasTile({\n                x: t,\n                y: i,\n                z: o\n              });\n            }\n            return !this.tileBounds || this.tileBounds.contains(e.canonical);\n          }\n          loadTile(t, i) {\n            const {\n                x: o,\n                y: r,\n                z: n\n              } = t.tileID.canonical,\n              s = new e.window.AbortController();\n            t.request = Promise.resolve(this._implementation.loadTile({\n              x: o,\n              y: r,\n              z: n\n            }, {\n              signal: s.signal\n            })).then(function (o) {\n              return delete t.request, t.aborted ? (t.state = \"unloaded\", i(null)) : void 0 === o ? (t.state = \"errored\", i(null)) : null === o ? (this.loadTileData(t, {\n                width: this.tileSize,\n                height: this.tileSize,\n                data: null\n              }), t.state = \"loaded\", i(null)) : function (t) {\n                return t instanceof e.window.ImageData || t instanceof e.window.HTMLCanvasElement || t instanceof e.window.ImageBitmap || t instanceof e.window.HTMLImageElement;\n              }(o) ? (this.loadTileData(t, o), t.state = \"loaded\", void i(null)) : (t.state = \"errored\", i(new Error(`Can't infer data type for ${this.id}, only raster data supported at the moment`)));\n            }.bind(this)).catch(e => {\n              20 !== e.code && (t.state = \"errored\", i(e));\n            }), t.request.cancel = () => s.abort();\n          }\n          loadTileData(e, t) {\n            Me.loadTileData(e, t, this._map.painter);\n          }\n          unloadTileData(e) {\n            Me.unloadTileData(e, this._map.painter);\n          }\n          unloadTile(e, t) {\n            if (this.unloadTileData(e), this._implementation.unloadTile) {\n              const {\n                x: t,\n                y: i,\n                z: o\n              } = e.tileID.canonical;\n              this._implementation.unloadTile({\n                x: t,\n                y: i,\n                z: o\n              });\n            }\n            t();\n          }\n          abortTile(e, t) {\n            e.request && e.request.cancel && (e.request.cancel(), delete e.request), t();\n          }\n          hasTransition() {\n            return !1;\n          }\n          _coveringTiles() {\n            return this._map.transform.coveringTiles({\n              tileSize: this.tileSize,\n              minzoom: this.minzoom,\n              maxzoom: this.maxzoom,\n              roundZoom: this.roundZoom\n            }).map(e => ({\n              x: e.canonical.x,\n              y: e.canonical.y,\n              z: e.canonical.z\n            }));\n          }\n          _clearTiles() {\n            this._map.style._clearSource(this.id);\n          }\n          _update() {\n            this.fire(new e.Event(\"data\", {\n              dataType: \"source\",\n              sourceDataType: \"content\"\n            }));\n          }\n        }\n      },\n      De = function (t, i, o, r) {\n        const n = new Se[i.type](t, i, o, r);\n        if (n.id !== t) throw new Error(`Expected Source id to be ${t} instead of ${n.id}`);\n        return e.bindAll([\"load\", \"abort\", \"unload\", \"serialize\", \"prepare\"], n), n;\n      };\n    function Le(t, i) {\n      const o = e.identity([]);\n      return e.scale(o, o, [.5 * t.width, .5 * -t.height, 1]), e.translate(o, o, [1, -1, 0]), e.multiply(o, o, t.calculateProjMatrix(i.toUnwrapped())), Float32Array.from(o);\n    }\n    function Ae(e, t, i, o, r, n, s, a = !1) {\n      const l = e.tilesIn(o, s, a);\n      l.sort(Re);\n      const c = [];\n      for (const o of l) c.push({\n        wrappedTileID: o.tile.tileID.wrapped().key,\n        queryResults: o.tile.queryRenderedFeatures(t, i, e._state, o, r, n, Le(e.transform, o.tile.tileID), a)\n      });\n      const h = function (e) {\n        const t = {},\n          i = {};\n        for (const o of e) {\n          const e = o.queryResults,\n            r = o.wrappedTileID,\n            n = i[r] = i[r] || {};\n          for (const i in e) {\n            const o = e[i],\n              r = n[i] = n[i] || {},\n              s = t[i] = t[i] || [];\n            for (const e of o) r[e.featureIndex] || (r[e.featureIndex] = !0, s.push(e));\n          }\n        }\n        return t;\n      }(c);\n      for (const t in h) h[t].forEach(t => {\n        const i = t.feature,\n          o = i.layer;\n        o && \"background\" !== o.type && \"sky\" !== o.type && (i.source = o.source, o[\"source-layer\"] && (i.sourceLayer = o[\"source-layer\"]), i.state = void 0 !== i.id ? e.getFeatureState(o[\"source-layer\"], i.id) : {});\n      });\n      return h;\n    }\n    function ze(e, t) {\n      const i = e.getRenderableIds().map(t => e.getTileByID(t)),\n        o = [],\n        r = {};\n      for (let e = 0; e < i.length; e++) {\n        const n = i[e],\n          s = n.tileID.canonical.key;\n        r[s] || (r[s] = !0, n.querySourceFeatures(o, t));\n      }\n      return o;\n    }\n    function Re(e, t) {\n      const i = e.tileID,\n        o = t.tileID;\n      return i.overscaledZ - o.overscaledZ || i.canonical.y - o.canonical.y || i.wrap - o.wrap || i.canonical.x - o.canonical.x;\n    }\n    function Oe() {\n      return null != dn.workerClass ? new dn.workerClass() : new e.window.Worker(dn.workerUrl);\n    }\n    const Be = \"mapboxgl_preloaded_worker_pool\";\n    class ke {\n      constructor() {\n        this.active = {};\n      }\n      acquire(e) {\n        if (!this.workers) for (this.workers = []; this.workers.length < ke.workerCount;) this.workers.push(new Oe());\n        return this.active[e] = !0, this.workers.slice();\n      }\n      release(e) {\n        delete this.active[e], 0 === this.numActive() && (this.workers.forEach(e => {\n          e.terminate();\n        }), this.workers = null);\n      }\n      isPreloaded() {\n        return !!this.active[Be];\n      }\n      numActive() {\n        return Object.keys(this.active).length;\n      }\n    }\n    let Fe;\n    function Ue() {\n      return Fe || (Fe = new ke()), Fe;\n    }\n    function Ne(t, i) {\n      const o = {};\n      for (const e in t) \"ref\" !== e && (o[e] = t[e]);\n      return e.refProperties.forEach(e => {\n        e in i && (o[e] = i[e]);\n      }), o;\n    }\n    function je(e) {\n      e = e.slice();\n      const t = Object.create(null);\n      for (let i = 0; i < e.length; i++) t[e[i].id] = e[i];\n      for (let i = 0; i < e.length; i++) \"ref\" in e[i] && (e[i] = Ne(e[i], t[e[i].ref]));\n      return e;\n    }\n    ke.workerCount = 2;\n    const Ge = {\n      setStyle: \"setStyle\",\n      addLayer: \"addLayer\",\n      removeLayer: \"removeLayer\",\n      setPaintProperty: \"setPaintProperty\",\n      setLayoutProperty: \"setLayoutProperty\",\n      setFilter: \"setFilter\",\n      addSource: \"addSource\",\n      removeSource: \"removeSource\",\n      setGeoJSONSourceData: \"setGeoJSONSourceData\",\n      setLayerZoomRange: \"setLayerZoomRange\",\n      setLayerProperty: \"setLayerProperty\",\n      setCenter: \"setCenter\",\n      setZoom: \"setZoom\",\n      setBearing: \"setBearing\",\n      setPitch: \"setPitch\",\n      setSprite: \"setSprite\",\n      setGlyphs: \"setGlyphs\",\n      setTransition: \"setTransition\",\n      setLight: \"setLight\",\n      setTerrain: \"setTerrain\",\n      setFog: \"setFog\",\n      setProjection: \"setProjection\"\n    };\n    function Ze(e, t, i) {\n      i.push({\n        command: Ge.addSource,\n        args: [e, t[e]]\n      });\n    }\n    function Ve(e, t, i) {\n      t.push({\n        command: Ge.removeSource,\n        args: [e]\n      }), i[e] = !0;\n    }\n    function We(e, t, i, o) {\n      Ve(e, i, o), Ze(e, t, i);\n    }\n    function Xe(e, i, o) {\n      let r;\n      for (r in e[o]) if (e[o].hasOwnProperty(r) && \"data\" !== r && !t(e[o][r], i[o][r])) return !1;\n      for (r in i[o]) if (i[o].hasOwnProperty(r) && \"data\" !== r && !t(e[o][r], i[o][r])) return !1;\n      return !0;\n    }\n    function qe(e, i, o, r, n, s) {\n      let a;\n      for (a in i = i || {}, e = e || {}) e.hasOwnProperty(a) && (t(e[a], i[a]) || o.push({\n        command: s,\n        args: [r, a, i[a], n]\n      }));\n      for (a in i) i.hasOwnProperty(a) && !e.hasOwnProperty(a) && (t(e[a], i[a]) || o.push({\n        command: s,\n        args: [r, a, i[a], n]\n      }));\n    }\n    function $e(e) {\n      return e.id;\n    }\n    function He(e, t) {\n      return e[t.id] = t, e;\n    }\n    class Ye {\n      constructor(e, t) {\n        this.reset(e, t);\n      }\n      reset(e, t) {\n        this.points = e || [], this._distances = [0];\n        for (let e = 1; e < this.points.length; e++) this._distances[e] = this._distances[e - 1] + this.points[e].dist(this.points[e - 1]);\n        this.length = this._distances[this._distances.length - 1], this.padding = Math.min(t || 0, .5 * this.length), this.paddedLength = this.length - 2 * this.padding;\n      }\n      lerp(t) {\n        if (1 === this.points.length) return this.points[0];\n        t = e.clamp(t, 0, 1);\n        let i = 1,\n          o = this._distances[i];\n        const r = t * this.paddedLength + this.padding;\n        for (; o < r && i < this._distances.length;) o = this._distances[++i];\n        const n = i - 1,\n          s = this._distances[n],\n          a = o - s,\n          l = a > 0 ? (r - s) / a : 0;\n        return this.points[n].mult(1 - l).add(this.points[i].mult(l));\n      }\n    }\n    class Ke {\n      constructor(e, t, i) {\n        const o = this.boxCells = [],\n          r = this.circleCells = [];\n        this.xCellCount = Math.ceil(e / i), this.yCellCount = Math.ceil(t / i);\n        for (let e = 0; e < this.xCellCount * this.yCellCount; e++) o.push([]), r.push([]);\n        this.circleKeys = [], this.boxKeys = [], this.bboxes = [], this.circles = [], this.width = e, this.height = t, this.xScale = this.xCellCount / e, this.yScale = this.yCellCount / t, this.boxUid = 0, this.circleUid = 0;\n      }\n      keysLength() {\n        return this.boxKeys.length + this.circleKeys.length;\n      }\n      insert(e, t, i, o, r) {\n        this._forEachCell(t, i, o, r, this._insertBoxCell, this.boxUid++), this.boxKeys.push(e), this.bboxes.push(t), this.bboxes.push(i), this.bboxes.push(o), this.bboxes.push(r);\n      }\n      insertCircle(e, t, i, o) {\n        this._forEachCell(t - o, i - o, t + o, i + o, this._insertCircleCell, this.circleUid++), this.circleKeys.push(e), this.circles.push(t), this.circles.push(i), this.circles.push(o);\n      }\n      _insertBoxCell(e, t, i, o, r, n) {\n        this.boxCells[r].push(n);\n      }\n      _insertCircleCell(e, t, i, o, r, n) {\n        this.circleCells[r].push(n);\n      }\n      _query(e, t, i, o, r, n) {\n        if (i < 0 || e > this.width || o < 0 || t > this.height) return !r && [];\n        const s = [];\n        if (e <= 0 && t <= 0 && this.width <= i && this.height <= o) {\n          if (r) return !0;\n          for (let e = 0; e < this.boxKeys.length; e++) s.push({\n            key: this.boxKeys[e],\n            x1: this.bboxes[4 * e],\n            y1: this.bboxes[4 * e + 1],\n            x2: this.bboxes[4 * e + 2],\n            y2: this.bboxes[4 * e + 3]\n          });\n          for (let e = 0; e < this.circleKeys.length; e++) {\n            const t = this.circles[3 * e],\n              i = this.circles[3 * e + 1],\n              o = this.circles[3 * e + 2];\n            s.push({\n              key: this.circleKeys[e],\n              x1: t - o,\n              y1: i - o,\n              x2: t + o,\n              y2: i + o\n            });\n          }\n          return n ? s.filter(n) : s;\n        }\n        return this._forEachCell(e, t, i, o, this._queryCell, s, {\n          hitTest: r,\n          seenUids: {\n            box: {},\n            circle: {}\n          }\n        }, n), r ? s.length > 0 : s;\n      }\n      _queryCircle(e, t, i, o, r) {\n        const n = e - i,\n          s = e + i,\n          a = t - i,\n          l = t + i;\n        if (s < 0 || n > this.width || l < 0 || a > this.height) return !o && [];\n        const c = [];\n        return this._forEachCell(n, a, s, l, this._queryCellCircle, c, {\n          hitTest: o,\n          circle: {\n            x: e,\n            y: t,\n            radius: i\n          },\n          seenUids: {\n            box: {},\n            circle: {}\n          }\n        }, r), o ? c.length > 0 : c;\n      }\n      query(e, t, i, o, r) {\n        return this._query(e, t, i, o, !1, r);\n      }\n      hitTest(e, t, i, o, r) {\n        return this._query(e, t, i, o, !0, r);\n      }\n      hitTestCircle(e, t, i, o) {\n        return this._queryCircle(e, t, i, !0, o);\n      }\n      _queryCell(e, t, i, o, r, n, s, a) {\n        const l = s.seenUids,\n          c = this.boxCells[r];\n        if (null !== c) {\n          const r = this.bboxes;\n          for (const h of c) if (!l.box[h]) {\n            l.box[h] = !0;\n            const c = 4 * h;\n            if (e <= r[c + 2] && t <= r[c + 3] && i >= r[c + 0] && o >= r[c + 1] && (!a || a(this.boxKeys[h]))) {\n              if (s.hitTest) return n.push(!0), !0;\n              n.push({\n                key: this.boxKeys[h],\n                x1: r[c],\n                y1: r[c + 1],\n                x2: r[c + 2],\n                y2: r[c + 3]\n              });\n            }\n          }\n        }\n        const h = this.circleCells[r];\n        if (null !== h) {\n          const r = this.circles;\n          for (const c of h) if (!l.circle[c]) {\n            l.circle[c] = !0;\n            const h = 3 * c;\n            if (this._circleAndRectCollide(r[h], r[h + 1], r[h + 2], e, t, i, o) && (!a || a(this.circleKeys[c]))) {\n              if (s.hitTest) return n.push(!0), !0;\n              {\n                const e = r[h],\n                  t = r[h + 1],\n                  i = r[h + 2];\n                n.push({\n                  key: this.circleKeys[c],\n                  x1: e - i,\n                  y1: t - i,\n                  x2: e + i,\n                  y2: t + i\n                });\n              }\n            }\n          }\n        }\n      }\n      _queryCellCircle(e, t, i, o, r, n, s, a) {\n        const l = s.circle,\n          c = s.seenUids,\n          h = this.boxCells[r];\n        if (null !== h) {\n          const e = this.bboxes;\n          for (const t of h) if (!c.box[t]) {\n            c.box[t] = !0;\n            const i = 4 * t;\n            if (this._circleAndRectCollide(l.x, l.y, l.radius, e[i + 0], e[i + 1], e[i + 2], e[i + 3]) && (!a || a(this.boxKeys[t]))) return n.push(!0), !0;\n          }\n        }\n        const u = this.circleCells[r];\n        if (null !== u) {\n          const e = this.circles;\n          for (const t of u) if (!c.circle[t]) {\n            c.circle[t] = !0;\n            const i = 3 * t;\n            if (this._circlesCollide(e[i], e[i + 1], e[i + 2], l.x, l.y, l.radius) && (!a || a(this.circleKeys[t]))) return n.push(!0), !0;\n          }\n        }\n      }\n      _forEachCell(e, t, i, o, r, n, s, a) {\n        const l = this._convertToXCellCoord(e),\n          c = this._convertToYCellCoord(t),\n          h = this._convertToXCellCoord(i),\n          u = this._convertToYCellCoord(o);\n        for (let _ = l; _ <= h; _++) for (let l = c; l <= u; l++) if (r.call(this, e, t, i, o, this.xCellCount * l + _, n, s, a)) return;\n      }\n      _convertToXCellCoord(e) {\n        return Math.max(0, Math.min(this.xCellCount - 1, Math.floor(e * this.xScale)));\n      }\n      _convertToYCellCoord(e) {\n        return Math.max(0, Math.min(this.yCellCount - 1, Math.floor(e * this.yScale)));\n      }\n      _circlesCollide(e, t, i, o, r, n) {\n        const s = o - e,\n          a = r - t,\n          l = i + n;\n        return l * l > s * s + a * a;\n      }\n      _circleAndRectCollide(e, t, i, o, r, n, s) {\n        const a = (n - o) / 2,\n          l = Math.abs(e - (o + a));\n        if (l > a + i) return !1;\n        const c = (s - r) / 2,\n          h = Math.abs(t - (r + c));\n        if (h > c + i) return !1;\n        if (l <= a || h <= c) return !0;\n        const u = l - a,\n          _ = h - c;\n        return u * u + _ * _ <= i * i;\n      }\n    }\n    const Je = {\n        unknown: 0,\n        flipRequired: 1,\n        flipNotRequired: 2\n      },\n      Qe = Math.tan(85 * Math.PI / 180);\n    function et(t, i, o, r, n, s, a) {\n      const l = e.create();\n      if (o) {\n        if (\"globe\" === s.name) {\n          const t = e.calculateGlobeLabelMatrix(n, i);\n          e.multiply(l, l, t);\n        } else {\n          const t = v([], a);\n          l[0] = t[0], l[1] = t[1], l[4] = t[2], l[5] = t[3], r || e.rotateZ(l, l, n.angle);\n        }\n      } else e.multiply(l, n.labelPlaneMatrix, t);\n      return l;\n    }\n    function tt(e, t, i, o, r, n, s) {\n      const a = et(e, t, i, o, r, n, s);\n      return \"globe\" === n.name && i || (a[2] = a[6] = a[10] = a[14] = 0), a;\n    }\n    function it(t, i, o, r, n, s, a) {\n      if (o) {\n        if (\"globe\" === s.name) {\n          const l = et(t, i, o, r, n, s, a);\n          return e.invert(l, l), e.multiply(l, t, l), l;\n        }\n        {\n          const i = e.clone(t),\n            o = e.identity([]);\n          return o[0] = a[0], o[1] = a[1], o[4] = a[2], o[5] = a[3], e.multiply(i, i, o), r || e.rotateZ(i, i, -n.angle), i;\n        }\n      }\n      return n.glCoordMatrix;\n    }\n    function ot(t, i, o, r) {\n      const n = [t, i, o, 1];\n      o ? e.transformMat4$1(n, n, r) : pt(n, n, r);\n      const s = n[3];\n      return n[0] /= s, n[1] /= s, n[2] /= s, n;\n    }\n    function rt(e, t) {\n      return Math.min(.5 + e / t * .5, 1.5);\n    }\n    function nt(e, t) {\n      const i = e[0] / e[3],\n        o = e[1] / e[3];\n      return i >= -t[0] && i <= t[0] && o >= -t[1] && o <= t[1];\n    }\n    function st(t, i, o, r, n, s, a, l, c, h) {\n      const u = o.transform,\n        _ = r ? t.textSizeData : t.iconSizeData,\n        d = e.evaluateSizeForZoom(_, o.transform.zoom),\n        p = \"globe\" === u.projection.name,\n        m = [256 / o.width * 2 + 1, 256 / o.height * 2 + 1],\n        f = r ? t.text.dynamicLayoutVertexArray : t.icon.dynamicLayoutVertexArray;\n      f.clear();\n      let g = null;\n      p && (g = r ? t.text.globeExtVertexArray : t.icon.globeExtVertexArray);\n      const v = t.lineVertexArray,\n        x = r ? t.text.placedSymbolArray : t.icon.placedSymbolArray,\n        y = o.transform.width / o.transform.height;\n      let b,\n        w = !1;\n      for (let r = 0; r < x.length; r++) {\n        const p = x.get(r),\n          {\n            numGlyphs: T,\n            writingMode: E\n          } = p;\n        if (E !== e.WritingMode.vertical || w || b === e.WritingMode.horizontal || (w = !0), b = E, (p.hidden || E === e.WritingMode.vertical) && !w) {\n          dt(T, f);\n          continue;\n        }\n        w = !1;\n        const C = new e.Point(p.tileAnchorX, p.tileAnchorY);\n        let {\n          x: M,\n          y: I,\n          z: P\n        } = u.projection.projectTilePoint(C.x, C.y, h.canonical);\n        if (c) {\n          const [e, t, i] = c(C);\n          M += e, I += t, P += i;\n        }\n        const S = [M, I, P, 1];\n        if (e.transformMat4$1(S, S, i), !nt(S, m)) {\n          dt(T, f);\n          continue;\n        }\n        const D = rt(o.transform.cameraToCenterDistance, S[3]),\n          L = e.evaluateSizeForFeature(_, d, p),\n          A = a ? L / D : L * D,\n          z = ot(M, I, P, n);\n        if (z[3] <= 0) {\n          dt(T, f);\n          continue;\n        }\n        let R = {};\n        const O = a ? null : c,\n          B = ct(p, A, !1, l, i, n, s, t.glyphOffsetArray, v, f, g, z, C, R, y, O, u.projection, h, a);\n        w = B.useVertical, O && B.needsFlipping && (R = {}), (B.notEnoughRoom || w || B.needsFlipping && ct(p, A, !0, l, i, n, s, t.glyphOffsetArray, v, f, g, z, C, R, y, O, u.projection, h, a).notEnoughRoom) && dt(T, f);\n      }\n      r ? (t.text.dynamicLayoutVertexBuffer.updateData(f), g && t.text.globeExtVertexBuffer.updateData(g)) : (t.icon.dynamicLayoutVertexBuffer.updateData(f), g && t.icon.globeExtVertexBuffer.updateData(g));\n    }\n    function at(e, t, i, o, r, n, s, a, l, c, h, u, _, d, p, m) {\n      const {\n          lineStartIndex: f,\n          glyphStartIndex: g,\n          segment: v\n        } = a,\n        x = g + a.numGlyphs,\n        y = f + a.lineLength,\n        b = t.getoffsetX(g),\n        w = t.getoffsetX(x - 1),\n        T = _t(e * b, i, o, r, n, s, v, f, y, l, c, h, u, _, !0, d, p, m);\n      if (!T) return null;\n      const E = _t(e * w, i, o, r, n, s, v, f, y, l, c, h, u, _, !0, d, p, m);\n      return E ? {\n        first: T,\n        last: E\n      } : null;\n    }\n    function lt(t, i, o, r) {\n      return t === e.WritingMode.horizontal && Math.abs(r) > Math.abs(o) ? {\n        useVertical: !0\n      } : t === e.WritingMode.vertical ? r > 0 ? {\n        needsFlipping: !0\n      } : null : i !== Je.unknown && function (e, t) {\n        return 0 === e || Math.abs(t / e) > Qe;\n      }(o, r) ? i === Je.flipRequired ? {\n        needsFlipping: !0\n      } : null : o < 0 ? {\n        needsFlipping: !0\n      } : null;\n    }\n    function ct(t, i, o, r, n, s, a, l, c, h, u, _, d, p, m, f, g, v, x) {\n      const y = i / 24,\n        b = t.lineOffsetX * y,\n        w = t.lineOffsetY * y,\n        {\n          lineStartIndex: T,\n          glyphStartIndex: E,\n          numGlyphs: C,\n          segment: M,\n          writingMode: I,\n          flipState: P\n        } = t,\n        S = T + t.lineLength,\n        D = t => {\n          if (u) {\n            const [i, o, r] = t.up,\n              n = h.length;\n            e.updateGlobeVertexNormal(u, n + 0, i, o, r), e.updateGlobeVertexNormal(u, n + 1, i, o, r), e.updateGlobeVertexNormal(u, n + 2, i, o, r), e.updateGlobeVertexNormal(u, n + 3, i, o, r);\n          }\n          const [i, o, r] = t.point;\n          e.addDynamicAttributes(h, i, o, r, t.angle);\n        };\n      if (C > 1) {\n        const e = at(y, l, b, w, o, _, d, t, c, s, p, f, !1, g, v, x);\n        if (!e) return {\n          notEnoughRoom: !0\n        };\n        if (r && !o) {\n          let [i, o, r] = e.first.point,\n            [n, s, l] = e.last.point;\n          [i, o] = ot(i, o, r, a), [n, s] = ot(n, s, l, a);\n          const c = lt(I, P, (n - i) * m, s - o);\n          if (t.flipState = c && c.needsFlipping ? Je.flipRequired : Je.flipNotRequired, c) return c;\n        }\n        D(e.first);\n        for (let e = E + 1; e < E + C - 1; e++) {\n          const t = _t(y * l.getoffsetX(e), b, w, o, _, d, M, T, S, c, s, p, f, !1, !1, g, v, x);\n          if (!t) return h.length -= 4 * (e - E), {\n            notEnoughRoom: !0\n          };\n          D(t);\n        }\n        D(e.last);\n      } else {\n        if (r && !o) {\n          const i = ot(d.x, d.y, 0, n),\n            o = T + M + 1,\n            r = new e.Point(c.getx(o), c.gety(o)),\n            s = ot(r.x, r.y, 0, n),\n            a = s[3] > 0 ? s : ut(d, r, i, 1, n, void 0, g, v.canonical),\n            l = lt(I, P, (a[0] - i[0]) * m, a[1] - i[1]);\n          if (t.flipState = l && l.needsFlipping ? Je.flipRequired : Je.flipNotRequired, l) return l;\n        }\n        const i = _t(y * l.getoffsetX(E), b, w, o, _, d, M, T, S, c, s, p, f, !1, !1, g, v, x);\n        if (!i) return {\n          notEnoughRoom: !0\n        };\n        D(i);\n      }\n      return {};\n    }\n    function ht(e, t, i, o, r) {\n      const {\n        x: n,\n        y: s,\n        z: a\n      } = o.projectTilePoint(e.x, e.y, t);\n      if (!r) return ot(n, s, a, i);\n      const [l, c, h] = r(e);\n      return ot(n + l, s + c, a + h, i);\n    }\n    function ut(t, i, o, r, n, s, a, l) {\n      const c = ht(t.sub(i)._unit()._add(t), l, n, a, s);\n      return e.sub(c, o, c), e.normalize(c, c), e.scaleAndAdd(c, o, c, r);\n    }\n    function _t(t, i, o, r, n, s, a, l, c, h, u, _, d, p, m, f, g, v) {\n      const x = r ? t - i : t + i;\n      let y = x > 0 ? 1 : -1,\n        b = 0;\n      r && (y *= -1, b = Math.PI), y < 0 && (b += Math.PI);\n      let w = l + a + (y > 0 ? 0 : 1) | 0,\n        T = n,\n        E = n,\n        C = 0,\n        M = 0;\n      const I = Math.abs(x),\n        P = [],\n        S = [];\n      let D = s,\n        L = D;\n      const A = () => ut(L, D, E, I - C + 1, u, d, f, g.canonical);\n      for (; C + M <= I;) {\n        if (w += y, w < l || w >= c) return null;\n        if (E = T, L = D, P.push(E), p && S.push(L), D = new e.Point(h.getx(w), h.gety(w)), T = _[w], !T) {\n          const e = ht(D, g.canonical, u, f, d);\n          T = e[3] > 0 ? _[w] = e : A();\n        }\n        C += M, M = e.distance(E, T);\n      }\n      m && d && (_[w] && (T = A(), M = e.distance(E, T)), _[w] = T);\n      const z = (I - C) / M,\n        R = D.sub(L)._mult(z)._add(L),\n        O = e.sub([], T, E),\n        B = e.scaleAndAdd([], E, O, z);\n      let k = [0, 0, 1],\n        F = O[0],\n        U = O[1];\n      if (v && (k = f.upVector(g.canonical, R.x, R.y), 0 !== k[0] || 0 !== k[1] || 1 !== k[2])) {\n        const t = [k[2], 0, -k[0]],\n          i = e.cross([], k, t);\n        e.normalize(t, t), e.normalize(i, i), F = e.dot(O, t), U = e.dot(O, i);\n      }\n      if (o) {\n        const t = e.cross([], k, O);\n        e.normalize(t, t), e.scaleAndAdd(B, B, t, o * y);\n      }\n      const N = b + Math.atan2(U, F);\n      return P.push(B), p && S.push(R), {\n        point: B,\n        angle: N,\n        path: P,\n        tilePath: S,\n        up: k\n      };\n    }\n    function dt(e, t) {\n      const i = t.length,\n        o = i + 4 * e;\n      t.resize(o), t.float32.fill(-1 / 0, 4 * i, 4 * o);\n    }\n    function pt(e, t, i) {\n      const o = t[0],\n        r = t[1];\n      return e[0] = i[0] * o + i[4] * r + i[12], e[1] = i[1] * o + i[5] * r + i[13], e[3] = i[3] * o + i[7] * r + i[15], e;\n    }\n    const mt = 100;\n    class ft {\n      constructor(e, t, i = new Ke(e.width + 200, e.height + 200, 25), o = new Ke(e.width + 200, e.height + 200, 25)) {\n        this.transform = e, this.grid = i, this.ignoredGrid = o, this.pitchfactor = Math.cos(e._pitch) * e.cameraToCenterDistance, this.screenRightBoundary = e.width + mt, this.screenBottomBoundary = e.height + mt, this.gridRightBoundary = e.width + 200, this.gridBottomBoundary = e.height + 200, this.fogState = t;\n      }\n      placeCollisionBox(e, t, i, o, r, n, s, a) {\n        let l = i.projectedAnchorX,\n          c = i.projectedAnchorY,\n          h = i.projectedAnchorZ;\n        const u = i.elevation,\n          _ = i.tileID,\n          d = e.getProjection();\n        if (u && _) {\n          const [e, t, o] = d.upVector(_.canonical, i.tileAnchorX, i.tileAnchorY),\n            r = d.upVectorScale(_.canonical, this.transform.center.lat, this.transform.worldSize).metersToTile;\n          l += e * u * r, c += t * u * r, h += o * u * r;\n        }\n        const p = this.projectAndGetPerspectiveRatio(s, l, c, h, i.tileID, \"globe\" === d.name || !!u || this.transform.pitch > 0, d),\n          m = n * p.perspectiveRatio,\n          f = (i.x1 * t + o.x - i.padding) * m + p.point.x,\n          g = (i.y1 * t + o.y - i.padding) * m + p.point.y,\n          v = (i.x2 * t + o.x + i.padding) * m + p.point.x,\n          x = (i.y2 * t + o.y + i.padding) * m + p.point.y,\n          y = p.perspectiveRatio <= .55 || p.occluded;\n        return !this.isInsideGrid(f, g, v, x) || !r && this.grid.hitTest(f, g, v, x, a) || y ? {\n          box: [],\n          offscreen: !1,\n          occluded: p.occluded\n        } : {\n          box: [f, g, v, x],\n          offscreen: this.isOffscreen(f, g, v, x),\n          occluded: !1\n        };\n      }\n      placeCollisionCircles(t, i, o, r, n, s, a, l, c, h, u, _, d, p, m) {\n        const f = [],\n          g = this.transform.elevation,\n          v = t.getProjection(),\n          x = g ? g.getAtTileOffsetFunc(m, this.transform.center.lat, this.transform.worldSize, v) : null,\n          y = new e.Point(o.tileAnchorX, o.tileAnchorY);\n        let {\n          x: b,\n          y: w,\n          z: T\n        } = v.projectTilePoint(y.x, y.y, m.canonical);\n        if (x) {\n          const [e, t, i] = x(y);\n          b += e, w += t, T += i;\n        }\n        const E = \"globe\" === v.name,\n          C = this.projectAndGetPerspectiveRatio(a, b, w, T, m, E || !!g || this.transform.pitch > 0, v),\n          {\n            perspectiveRatio: M\n          } = C,\n          I = (u ? s / M : s * M) / e.ONE_EM,\n          P = ot(b, w, T, l),\n          S = C.signedDistanceFromCamera > 0 ? at(I, n, o.lineOffsetX * I, o.lineOffsetY * I, !1, P, y, o, r, l, {}, g && !u ? x : null, u && !!g, v, m, u) : null;\n        let D = !1,\n          L = !1,\n          A = !0;\n        if (S && !C.occluded) {\n          const t = .5 * d * M + p,\n            o = new e.Point(-100, -100),\n            r = new e.Point(this.screenRightBoundary, this.screenBottomBoundary),\n            n = new Ye(),\n            {\n              first: s,\n              last: a\n            } = S,\n            l = s.path.length;\n          let u = [];\n          for (let e = l - 1; e >= 1; e--) u.push(s.path[e]);\n          for (let e = 1; e < a.path.length; e++) u.push(a.path[e]);\n          const m = 2.5 * t;\n          c && (u = u.map(([e, t, i], o) => (x && !E && (i = x(o < l - 1 ? s.tilePath[l - 1 - o] : a.tilePath[o - l + 2])[2]), ot(e, t, i, c))), u.some(e => e[3] <= 0) && (u = []));\n          let g = [];\n          if (u.length > 0) {\n            let t = 1 / 0,\n              i = -1 / 0,\n              n = 1 / 0,\n              s = -1 / 0;\n            for (const e of u) t = Math.min(t, e[0]), n = Math.min(n, e[1]), i = Math.max(i, e[0]), s = Math.max(s, e[1]);\n            i >= o.x && t <= r.x && s >= o.y && n <= r.y && (g = [u.map(t => new e.Point(t[0], t[1]))], (t < o.x || i > r.x || n < o.y || s > r.y) && (g = e.clipLine(g, o.x, o.y, r.x, r.y)));\n          }\n          for (const e of g) {\n            n.reset(e, .25 * t);\n            let o = 0;\n            o = n.length <= .5 * t ? 1 : Math.ceil(n.paddedLength / m) + 1;\n            for (let e = 0; e < o; e++) {\n              const r = e / Math.max(o - 1, 1),\n                s = n.lerp(r),\n                a = s.x + mt,\n                l = s.y + mt;\n              f.push(a, l, t, 0);\n              const c = a - t,\n                u = l - t,\n                d = a + t,\n                p = l + t;\n              if (A = A && this.isOffscreen(c, u, d, p), L = L || this.isInsideGrid(c, u, d, p), !i && this.grid.hitTestCircle(a, l, t, _) && (D = !0, !h)) return {\n                circles: [],\n                offscreen: !1,\n                collisionDetected: D,\n                occluded: !1\n              };\n            }\n          }\n        }\n        return {\n          circles: !h && D || !L ? [] : f,\n          offscreen: A,\n          collisionDetected: D,\n          occluded: C.occluded\n        };\n      }\n      queryRenderedSymbols(t) {\n        if (0 === t.length || 0 === this.grid.keysLength() && 0 === this.ignoredGrid.keysLength()) return {};\n        const i = [];\n        let o = 1 / 0,\n          r = 1 / 0,\n          n = -1 / 0,\n          s = -1 / 0;\n        for (const a of t) {\n          const t = new e.Point(a.x + mt, a.y + mt);\n          o = Math.min(o, t.x), r = Math.min(r, t.y), n = Math.max(n, t.x), s = Math.max(s, t.y), i.push(t);\n        }\n        const a = this.grid.query(o, r, n, s).concat(this.ignoredGrid.query(o, r, n, s)),\n          l = {},\n          c = {};\n        for (const t of a) {\n          const o = t.key;\n          if (void 0 === l[o.bucketInstanceId] && (l[o.bucketInstanceId] = {}), l[o.bucketInstanceId][o.featureIndex]) continue;\n          const r = [new e.Point(t.x1, t.y1), new e.Point(t.x2, t.y1), new e.Point(t.x2, t.y2), new e.Point(t.x1, t.y2)];\n          e.polygonIntersectsPolygon(i, r) && (l[o.bucketInstanceId][o.featureIndex] = !0, void 0 === c[o.bucketInstanceId] && (c[o.bucketInstanceId] = []), c[o.bucketInstanceId].push(o.featureIndex));\n        }\n        return c;\n      }\n      insertCollisionBox(e, t, i, o, r) {\n        (t ? this.ignoredGrid : this.grid).insert({\n          bucketInstanceId: i,\n          featureIndex: o,\n          collisionGroupID: r\n        }, e[0], e[1], e[2], e[3]);\n      }\n      insertCollisionCircles(e, t, i, o, r) {\n        const n = t ? this.ignoredGrid : this.grid,\n          s = {\n            bucketInstanceId: i,\n            featureIndex: o,\n            collisionGroupID: r\n          };\n        for (let t = 0; t < e.length; t += 4) n.insertCircle(s, e[t], e[t + 1], e[t + 2]);\n      }\n      projectAndGetPerspectiveRatio(t, i, o, r, n, s, a) {\n        const l = [i, o, r, 1];\n        let c = !1;\n        if (r || this.transform.pitch > 0) {\n          if (e.transformMat4$1(l, l, t), this.fogState && n && \"globe\" !== a.name) {\n            const t = function (t, i, o, r, n, s) {\n              const a = s.calculateFogTileMatrix(n),\n                l = [i, o, r];\n              return e.transformMat4(l, l, a), C(t, l, s.pitch, s._fov);\n            }(this.fogState, i, o, r, n.toUnwrapped(), this.transform);\n            c = t > .9;\n          }\n        } else pt(l, l, t);\n        const h = l[3];\n        return {\n          point: new e.Point((l[0] / h + 1) / 2 * this.transform.width + mt, (-l[1] / h + 1) / 2 * this.transform.height + mt),\n          perspectiveRatio: Math.min(.5 + this.transform.getCameraToCenterDistance(a) / h * .5, 1.5),\n          signedDistanceFromCamera: h,\n          occluded: s && l[2] > h || c\n        };\n      }\n      isOffscreen(e, t, i, o) {\n        return i < mt || e >= this.screenRightBoundary || o < mt || t > this.screenBottomBoundary;\n      }\n      isInsideGrid(e, t, i, o) {\n        return i >= 0 && e < this.gridRightBoundary && o >= 0 && t < this.gridBottomBoundary;\n      }\n      getViewportMatrix() {\n        const t = e.identity([]);\n        return e.translate(t, t, [-100, -100, 0]), t;\n      }\n    }\n    function gt(t, i, o) {\n      const r = i.createTileMatrix(t, t.worldSize, o.toUnwrapped());\n      return e.multiply(new Float32Array(16), t.projMatrix, r);\n    }\n    function vt(e, t, i) {\n      if (t.projection.name === i.projection.name) return e.projMatrix;\n      const o = i.clone();\n      return o.setProjection(t.projection), gt(o, t.getProjection(), e);\n    }\n    function xt(e, t, i) {\n      return t.name === i.projection.name ? e.projMatrix : gt(i, t, e);\n    }\n    class yt {\n      constructor(e, t, i, o) {\n        this.opacity = e ? Math.max(0, Math.min(1, e.opacity + (e.placed ? t : -t))) : o && i ? 1 : 0, this.placed = i;\n      }\n      isHidden() {\n        return 0 === this.opacity && !this.placed;\n      }\n    }\n    class bt {\n      constructor(e, t, i, o, r, n = !1) {\n        this.text = new yt(e ? e.text : null, t, i, r), this.icon = new yt(e ? e.icon : null, t, o, r), this.clipped = n;\n      }\n      isHidden() {\n        return this.text.isHidden() && this.icon.isHidden();\n      }\n    }\n    class wt {\n      constructor(e, t, i, o = !1) {\n        this.text = e, this.icon = t, this.skipFade = i, this.clipped = o;\n      }\n    }\n    class Tt {\n      constructor() {\n        this.invProjMatrix = e.create(), this.viewportMatrix = e.create(), this.circles = [];\n      }\n    }\n    class Et {\n      constructor(e, t, i, o, r) {\n        this.bucketInstanceId = e, this.featureIndex = t, this.sourceLayerIndex = i, this.bucketIndex = o, this.tileID = r;\n      }\n    }\n    class Ct {\n      constructor(e) {\n        this.crossSourceCollisions = e, this.maxGroupID = 0, this.collisionGroups = {};\n      }\n      get(e) {\n        if (this.crossSourceCollisions) return {\n          ID: 0,\n          predicate: null\n        };\n        if (!this.collisionGroups[e]) {\n          const t = ++this.maxGroupID;\n          this.collisionGroups[e] = {\n            ID: t,\n            predicate: e => e.collisionGroupID === t\n          };\n        }\n        return this.collisionGroups[e];\n      }\n    }\n    function Mt(t, i, o, r, n) {\n      const {\n          horizontalAlign: s,\n          verticalAlign: a\n        } = e.getAnchorAlignment(t),\n        l = -(s - .5) * i,\n        c = -(a - .5) * o,\n        h = e.evaluateVariableOffset(t, r);\n      return new e.Point(l + h[0] * n, c + h[1] * n);\n    }\n    function It(t, i, o, r, n) {\n      const s = new e.Point(t, i);\n      return o && s._rotate(r ? n : -n), s;\n    }\n    class Pt {\n      constructor(e, t, i, o, r) {\n        this.transform = e.clone(), this.projection = e.projection.name, this.collisionIndex = new ft(this.transform, r), this.placements = {}, this.opacities = {}, this.variableOffsets = {}, this.stale = !1, this.commitTime = 0, this.fadeDuration = t, this.retainedQueryData = {}, this.collisionGroups = new Ct(i), this.collisionCircleArrays = {}, this.prevPlacement = o, o && (o.prevPlacement = void 0), this.placedOrientations = {};\n      }\n      getBucketParts(t, i, o, r) {\n        const n = o.getBucket(i),\n          s = o.latestFeatureIndex;\n        if (!n || !s || i.id !== n.layerIds[0]) return;\n        const a = n.layers[0].layout,\n          l = o.collisionBoxArray,\n          c = Math.pow(2, this.transform.zoom - o.tileID.overscaledZ),\n          h = o.tileSize / e.EXTENT,\n          u = o.tileID.toUnwrapped();\n        this.transform.setProjection(n.projection);\n        const _ = (d = o.tileID, p = n.getProjection(), m = this.transform, p.name === this.projection ? m.calculateProjMatrix(d.toUnwrapped()) : gt(m, p, d));\n        var d, p, m;\n        const f = \"map\" === a.get(\"text-pitch-alignment\"),\n          g = \"map\" === a.get(\"text-rotation-alignment\");\n        i.compileFilter();\n        const v = i.dynamicFilter(),\n          x = i.dynamicFilterNeedsFeature(),\n          y = this.transform.calculatePixelsToTileUnitsMatrix(o),\n          b = tt(_, o.tileID.canonical, f, g, this.transform, n.getProjection(), y);\n        let w = null;\n        if (f) {\n          const t = it(_, o.tileID.canonical, f, g, this.transform, n.getProjection(), y);\n          w = e.multiply([], this.transform.labelPlaneMatrix, t);\n        }\n        let T = null;\n        v && o.latestFeatureIndex && (T = {\n          unwrappedTileID: u,\n          dynamicFilter: v,\n          dynamicFilterNeedsFeature: x,\n          featureIndex: o.latestFeatureIndex\n        }), this.retainedQueryData[n.bucketInstanceId] = new Et(n.bucketInstanceId, s, n.sourceLayerIndex, n.index, o.tileID);\n        const E = {\n          bucket: n,\n          layout: a,\n          posMatrix: _,\n          textLabelPlaneMatrix: b,\n          labelToScreenMatrix: w,\n          clippingData: T,\n          scale: c,\n          textPixelRatio: h,\n          holdingForFade: o.holdingForFade(),\n          collisionBoxArray: l,\n          partiallyEvaluatedTextSize: e.evaluateSizeForZoom(n.textSizeData, this.transform.zoom),\n          partiallyEvaluatedIconSize: e.evaluateSizeForZoom(n.iconSizeData, this.transform.zoom),\n          collisionGroup: this.collisionGroups.get(n.sourceID)\n        };\n        if (r) for (const e of n.sortKeyRanges) {\n          const {\n            sortKey: i,\n            symbolInstanceStart: o,\n            symbolInstanceEnd: r\n          } = e;\n          t.push({\n            sortKey: i,\n            symbolInstanceStart: o,\n            symbolInstanceEnd: r,\n            parameters: E\n          });\n        } else t.push({\n          symbolInstanceStart: 0,\n          symbolInstanceEnd: n.symbolInstances.length,\n          parameters: E\n        });\n      }\n      attemptAnchorPlacement(e, t, i, o, r, n, s, a, l, c, h, u, _, d, p, m, f, g) {\n        const {\n            textOffset0: v,\n            textOffset1: x,\n            crossTileID: y\n          } = u,\n          b = [v, x],\n          w = Mt(e, i, o, b, r),\n          T = this.collisionIndex.placeCollisionBox(d, r, t, It(w.x, w.y, n, s, this.transform.angle), h, a, l, c.predicate);\n        if (m) {\n          const e = d.getSymbolInstanceIconSize(g, this.transform.zoom, u.placedIconSymbolIndex);\n          if (0 === this.collisionIndex.placeCollisionBox(d, e, m, It(w.x, w.y, n, s, this.transform.angle), h, a, l, c.predicate).box.length) return;\n        }\n        if (T.box.length > 0) {\n          let t;\n          return this.prevPlacement && this.prevPlacement.variableOffsets[y] && this.prevPlacement.placements[y] && this.prevPlacement.placements[y].text && (t = this.prevPlacement.variableOffsets[y].anchor), this.variableOffsets[y] = {\n            textOffset: b,\n            width: i,\n            height: o,\n            anchor: e,\n            textScale: r,\n            prevAnchor: t\n          }, this.markUsedJustification(d, e, u, p), d.allowVerticalPlacement && (this.markUsedOrientation(d, p, u), this.placedOrientations[y] = p), {\n            shift: w,\n            placedGlyphBoxes: T\n          };\n        }\n      }\n      placeLayerBucketPart(t, i, o, r) {\n        const {\n            bucket: n,\n            layout: s,\n            posMatrix: a,\n            textLabelPlaneMatrix: l,\n            labelToScreenMatrix: c,\n            clippingData: h,\n            textPixelRatio: u,\n            holdingForFade: _,\n            collisionBoxArray: d,\n            partiallyEvaluatedTextSize: p,\n            partiallyEvaluatedIconSize: m,\n            collisionGroup: f\n          } = t.parameters,\n          g = s.get(\"text-optional\"),\n          v = s.get(\"icon-optional\"),\n          x = s.get(\"text-allow-overlap\"),\n          y = s.get(\"icon-allow-overlap\"),\n          b = \"map\" === s.get(\"text-rotation-alignment\"),\n          w = \"map\" === s.get(\"text-pitch-alignment\"),\n          T = \"none\" !== s.get(\"icon-text-fit\"),\n          E = \"viewport-y\" === s.get(\"symbol-z-order\");\n        this.transform.setProjection(n.projection);\n        let C = x && (y || !n.hasIconData() || v),\n          M = y && (x || !n.hasTextData() || g);\n        !n.collisionArrays && d && n.deserializeCollisionBoxes(d), o && r && n.updateCollisionDebugBuffers(this.transform.zoom, d);\n        const I = (t, r, d) => {\n          const {\n            crossTileID: E,\n            numVerticalGlyphVertices: I\n          } = t;\n          if (h) {\n            const o = {\n              zoom: this.transform.zoom,\n              pitch: this.transform.pitch\n            };\n            let r = null;\n            if (h.dynamicFilterNeedsFeature) {\n              const e = this.retainedQueryData[n.bucketInstanceId];\n              r = h.featureIndex.loadFeature({\n                featureIndex: t.featureIndex,\n                bucketIndex: e.bucketIndex,\n                sourceLayerIndex: e.sourceLayerIndex,\n                layoutVertexArrayOffset: 0\n              });\n            }\n            if (!(0, h.dynamicFilter)(o, r, this.retainedQueryData[n.bucketInstanceId].tileID.canonical, new e.Point(t.tileAnchorX, t.tileAnchorY), this.transform.calculateDistanceTileData(h.unwrappedTileID))) return this.placements[E] = new wt(!1, !1, !1, !0), void i.add(E);\n          }\n          if (i.has(E)) return;\n          if (_) return void (this.placements[E] = new wt(!1, !1, !1));\n          let P = !1,\n            S = !1,\n            D = !0,\n            L = !1,\n            A = !1,\n            z = null,\n            R = {\n              box: null,\n              offscreen: null,\n              occluded: null\n            },\n            O = {\n              box: null,\n              offscreen: null,\n              occluded: null\n            },\n            B = null,\n            k = null,\n            F = null,\n            U = 0,\n            N = 0,\n            j = 0;\n          d.textFeatureIndex ? U = d.textFeatureIndex : t.useRuntimeCollisionCircles && (U = t.featureIndex), d.verticalTextFeatureIndex && (N = d.verticalTextFeatureIndex);\n          const G = e => {\n              e.tileID = this.retainedQueryData[n.bucketInstanceId].tileID;\n              const t = this.transform.elevation;\n              (t || e.elevation) && (e.elevation = t ? t.getAtTileOffset(e.tileID, e.tileAnchorX, e.tileAnchorY) : 0);\n            },\n            Z = d.textBox;\n          if (Z) {\n            G(Z);\n            const i = i => {\n                let o = e.WritingMode.horizontal;\n                if (n.allowVerticalPlacement && !i && this.prevPlacement) {\n                  const e = this.prevPlacement.placedOrientations[E];\n                  e && (this.placedOrientations[E] = e, o = e, this.markUsedOrientation(n, o, t));\n                }\n                return o;\n              },\n              o = (t, i) => {\n                if (n.allowVerticalPlacement && I > 0 && d.verticalTextBox) {\n                  for (const o of n.writingModes) if (o === e.WritingMode.vertical ? (R = i(), O = R) : R = t(), R && R.box && R.box.length) break;\n                } else R = t();\n              };\n            if (s.get(\"text-variable-anchor\")) {\n              let l = s.get(\"text-variable-anchor\");\n              if (this.prevPlacement && this.prevPlacement.variableOffsets[E]) {\n                const e = this.prevPlacement.variableOffsets[E];\n                l.indexOf(e.anchor) > 0 && (l = l.filter(t => t !== e.anchor), l.unshift(e.anchor));\n              }\n              const c = (e, i, o) => {\n                const s = n.getSymbolInstanceTextSize(p, t, this.transform.zoom, r),\n                  c = (e.x2 - e.x1) * s + 2 * e.padding,\n                  h = (e.y2 - e.y1) * s + 2 * e.padding,\n                  _ = T && !y ? i : null;\n                _ && G(_);\n                let d = {\n                  box: [],\n                  offscreen: !1,\n                  occluded: !1\n                };\n                const g = x ? 2 * l.length : l.length;\n                for (let i = 0; i < g; ++i) {\n                  const g = this.attemptAnchorPlacement(l[i % l.length], e, c, h, s, b, w, u, a, f, i >= l.length, t, r, n, o, _, p, m);\n                  if (g && (d = g.placedGlyphBoxes, d && d.box && d.box.length)) {\n                    P = !0, z = g.shift;\n                    break;\n                  }\n                }\n                return d;\n              };\n              o(() => c(Z, d.iconBox, e.WritingMode.horizontal), () => {\n                const t = d.verticalTextBox;\n                return t && G(t), n.allowVerticalPlacement && !(R && R.box && R.box.length) && I > 0 && t ? c(t, d.verticalIconBox, e.WritingMode.vertical) : {\n                  box: null,\n                  offscreen: null,\n                  occluded: null\n                };\n              }), R && (P = R.box, D = R.offscreen, L = R.occluded);\n              const h = i(!(!R || !R.box));\n              if (!P && this.prevPlacement) {\n                const e = this.prevPlacement.variableOffsets[E];\n                e && (this.variableOffsets[E] = e, this.markUsedJustification(n, e.anchor, t, h));\n              }\n            } else {\n              const s = (i, o) => {\n                const s = n.getSymbolInstanceTextSize(p, t, this.transform.zoom, r),\n                  l = this.collisionIndex.placeCollisionBox(n, s, i, new e.Point(0, 0), x, u, a, f.predicate);\n                return l && l.box && l.box.length && (this.markUsedOrientation(n, o, t), this.placedOrientations[E] = o), l;\n              };\n              o(() => s(Z, e.WritingMode.horizontal), () => {\n                const t = d.verticalTextBox;\n                return n.allowVerticalPlacement && I > 0 && t ? (G(t), s(t, e.WritingMode.vertical)) : {\n                  box: null,\n                  offscreen: null,\n                  occluded: null\n                };\n              }), i(!!(R && R.box && R.box.length));\n            }\n          }\n          if (B = R, P = B && B.box && B.box.length > 0, D = B && B.offscreen, L = B && B.occluded, t.useRuntimeCollisionCircles) {\n            const i = n.text.placedSymbolArray.get(t.centerJustifiedTextSymbolIndex >= 0 ? t.centerJustifiedTextSymbolIndex : t.verticalPlacedTextSymbolIndex),\n              r = e.evaluateSizeForFeature(n.textSizeData, p, i),\n              h = s.get(\"text-padding\");\n            k = this.collisionIndex.placeCollisionCircles(n, x, i, n.lineVertexArray, n.glyphOffsetArray, r, a, l, c, o, w, f.predicate, t.collisionCircleDiameter * r / e.ONE_EM, h, this.retainedQueryData[n.bucketInstanceId].tileID), P = x || k.circles.length > 0 && !k.collisionDetected, D = D && k.offscreen, L = k.occluded;\n          }\n          if (d.iconFeatureIndex && (j = d.iconFeatureIndex), d.iconBox) {\n            const i = i => {\n              G(i);\n              const o = T && z ? It(z.x, z.y, b, w, this.transform.angle) : new e.Point(0, 0),\n                r = n.getSymbolInstanceIconSize(m, this.transform.zoom, t.placedIconSymbolIndex);\n              return this.collisionIndex.placeCollisionBox(n, r, i, o, y, u, a, f.predicate);\n            };\n            O && O.box && O.box.length && d.verticalIconBox ? (F = i(d.verticalIconBox), S = F.box.length > 0) : (F = i(d.iconBox), S = F.box.length > 0), D = D && F.offscreen, A = F.occluded;\n          }\n          const V = g || 0 === t.numHorizontalGlyphVertices && 0 === I,\n            W = v || 0 === t.numIconVertices;\n          if (V || W ? W ? V || (S = S && P) : P = S && P : S = P = S && P, P && B && B.box && this.collisionIndex.insertCollisionBox(B.box, s.get(\"text-ignore-placement\"), n.bucketInstanceId, O && O.box && N ? N : U, f.ID), S && F && this.collisionIndex.insertCollisionBox(F.box, s.get(\"icon-ignore-placement\"), n.bucketInstanceId, j, f.ID), k && (P && this.collisionIndex.insertCollisionCircles(k.circles, s.get(\"text-ignore-placement\"), n.bucketInstanceId, U, f.ID), o)) {\n            const e = n.bucketInstanceId;\n            let t = this.collisionCircleArrays[e];\n            void 0 === t && (t = this.collisionCircleArrays[e] = new Tt());\n            for (let e = 0; e < k.circles.length; e += 4) t.circles.push(k.circles[e + 0]), t.circles.push(k.circles[e + 1]), t.circles.push(k.circles[e + 2]), t.circles.push(k.collisionDetected ? 1 : 0);\n          }\n          const X = \"globe\" !== n.projection.name;\n          C = C && (X || !L), M = M && (X || !A), this.placements[E] = new wt(P || C, S || M, D || n.justReloaded), i.add(E);\n        };\n        if (E) {\n          const e = n.getSortedSymbolIndexes(this.transform.angle);\n          for (let t = e.length - 1; t >= 0; --t) {\n            const i = e[t];\n            I(n.symbolInstances.get(i), i, n.collisionArrays[i]);\n          }\n        } else for (let e = t.symbolInstanceStart; e < t.symbolInstanceEnd; e++) I(n.symbolInstances.get(e), e, n.collisionArrays[e]);\n        if (o && n.bucketInstanceId in this.collisionCircleArrays) {\n          const t = this.collisionCircleArrays[n.bucketInstanceId];\n          e.invert(t.invProjMatrix, a), t.viewportMatrix = this.collisionIndex.getViewportMatrix();\n        }\n        n.justReloaded = !1;\n      }\n      markUsedJustification(t, i, o, r) {\n        const {\n            leftJustifiedTextSymbolIndex: n,\n            centerJustifiedTextSymbolIndex: s,\n            rightJustifiedTextSymbolIndex: a,\n            verticalPlacedTextSymbolIndex: l,\n            crossTileID: c\n          } = o,\n          h = e.getAnchorJustification(i),\n          u = r === e.WritingMode.vertical ? l : \"left\" === h ? n : \"center\" === h ? s : \"right\" === h ? a : -1;\n        n >= 0 && (t.text.placedSymbolArray.get(n).crossTileID = u >= 0 && n !== u ? 0 : c), s >= 0 && (t.text.placedSymbolArray.get(s).crossTileID = u >= 0 && s !== u ? 0 : c), a >= 0 && (t.text.placedSymbolArray.get(a).crossTileID = u >= 0 && a !== u ? 0 : c), l >= 0 && (t.text.placedSymbolArray.get(l).crossTileID = u >= 0 && l !== u ? 0 : c);\n      }\n      markUsedOrientation(t, i, o) {\n        const r = i === e.WritingMode.horizontal || i === e.WritingMode.horizontalOnly ? i : 0,\n          n = i === e.WritingMode.vertical ? i : 0,\n          {\n            leftJustifiedTextSymbolIndex: s,\n            centerJustifiedTextSymbolIndex: a,\n            rightJustifiedTextSymbolIndex: l,\n            verticalPlacedTextSymbolIndex: c\n          } = o,\n          h = t.text.placedSymbolArray;\n        s >= 0 && (h.get(s).placedOrientation = r), a >= 0 && (h.get(a).placedOrientation = r), l >= 0 && (h.get(l).placedOrientation = r), c >= 0 && (h.get(c).placedOrientation = n);\n      }\n      commit(e) {\n        this.commitTime = e, this.zoomAtLastRecencyCheck = this.transform.zoom;\n        const t = this.prevPlacement;\n        let i = !1;\n        this.prevZoomAdjustment = t ? t.zoomAdjustment(this.transform.zoom) : 0;\n        const o = t ? t.symbolFadeChange(e) : 1,\n          r = t ? t.opacities : {},\n          n = t ? t.variableOffsets : {},\n          s = t ? t.placedOrientations : {};\n        for (const e in this.placements) {\n          const t = this.placements[e],\n            n = r[e];\n          n ? (this.opacities[e] = new bt(n, o, t.text, t.icon, null, t.clipped), i = i || t.text !== n.text.placed || t.icon !== n.icon.placed) : (this.opacities[e] = new bt(null, o, t.text, t.icon, t.skipFade, t.clipped), i = i || t.text || t.icon);\n        }\n        for (const e in r) {\n          const t = r[e];\n          if (!this.opacities[e]) {\n            const r = new bt(t, o, !1, !1);\n            r.isHidden() || (this.opacities[e] = r, i = i || t.text.placed || t.icon.placed);\n          }\n        }\n        for (const e in n) this.variableOffsets[e] || !this.opacities[e] || this.opacities[e].isHidden() || (this.variableOffsets[e] = n[e]);\n        for (const e in s) this.placedOrientations[e] || !this.opacities[e] || this.opacities[e].isHidden() || (this.placedOrientations[e] = s[e]);\n        i ? this.lastPlacementChangeTime = e : \"number\" != typeof this.lastPlacementChangeTime && (this.lastPlacementChangeTime = t ? t.lastPlacementChangeTime : e);\n      }\n      updateLayerOpacities(e, t) {\n        const i = new Set();\n        for (const o of t) {\n          const t = o.getBucket(e);\n          t && o.latestFeatureIndex && e.id === t.layerIds[0] && this.updateBucketOpacities(t, i, o.collisionBoxArray);\n        }\n      }\n      updateBucketOpacities(t, i, o) {\n        t.hasTextData() && t.text.opacityVertexArray.clear(), t.hasIconData() && t.icon.opacityVertexArray.clear(), t.hasIconCollisionBoxData() && t.iconCollisionBox.collisionVertexArray.clear(), t.hasTextCollisionBoxData() && t.textCollisionBox.collisionVertexArray.clear();\n        const r = t.layers[0].layout,\n          n = !!t.layers[0].dynamicFilter(),\n          s = new bt(null, 0, !1, !1, !0),\n          a = r.get(\"text-allow-overlap\"),\n          l = r.get(\"icon-allow-overlap\"),\n          c = r.get(\"text-variable-anchor\"),\n          h = \"map\" === r.get(\"text-rotation-alignment\"),\n          u = \"map\" === r.get(\"text-pitch-alignment\"),\n          _ = \"none\" !== r.get(\"icon-text-fit\"),\n          d = new bt(null, 0, a && (l || !t.hasIconData() || r.get(\"icon-optional\")), l && (a || !t.hasTextData() || r.get(\"text-optional\")), !0);\n        !t.collisionArrays && o && (t.hasIconCollisionBoxData() || t.hasTextCollisionBoxData()) && t.deserializeCollisionBoxes(o);\n        const p = (e, t, i) => {\n          for (let o = 0; o < t / 4; o++) e.opacityVertexArray.emplaceBack(i);\n        };\n        let m = 0;\n        for (let o = 0; o < t.symbolInstances.length; o++) {\n          const r = t.symbolInstances.get(o),\n            {\n              numHorizontalGlyphVertices: a,\n              numVerticalGlyphVertices: l,\n              crossTileID: f,\n              numIconVertices: g\n            } = r,\n            v = i.has(f);\n          let x = this.opacities[f];\n          v ? x = s : x || (x = d, this.opacities[f] = x), i.add(f);\n          const y = a > 0 || l > 0,\n            b = g > 0,\n            w = this.placedOrientations[f],\n            T = w === e.WritingMode.vertical,\n            E = w === e.WritingMode.horizontal || w === e.WritingMode.horizontalOnly;\n          if (!y && !b || x.isHidden() || m++, y) {\n            const e = kt(x.text);\n            p(t.text, a, T ? Ft : e), p(t.text, l, E ? Ft : e);\n            const i = x.text.isHidden(),\n              {\n                leftJustifiedTextSymbolIndex: o,\n                centerJustifiedTextSymbolIndex: n,\n                rightJustifiedTextSymbolIndex: s,\n                verticalPlacedTextSymbolIndex: c\n              } = r,\n              h = t.text.placedSymbolArray,\n              u = i || T ? 1 : 0;\n            o >= 0 && (h.get(o).hidden = u), n >= 0 && (h.get(n).hidden = u), s >= 0 && (h.get(s).hidden = u), c >= 0 && (h.get(c).hidden = i || E ? 1 : 0);\n            const _ = this.variableOffsets[f];\n            _ && this.markUsedJustification(t, _.anchor, r, w);\n            const d = this.placedOrientations[f];\n            d && (this.markUsedJustification(t, \"left\", r, d), this.markUsedOrientation(t, d, r));\n          }\n          if (b) {\n            const e = kt(x.icon),\n              {\n                placedIconSymbolIndex: i,\n                verticalPlacedIconSymbolIndex: o\n              } = r,\n              n = t.icon.placedSymbolArray,\n              s = x.icon.isHidden() ? 1 : 0;\n            i >= 0 && (p(t.icon, g, T ? Ft : e), n.get(i).hidden = s), o >= 0 && (p(t.icon, r.numVerticalIconVertices, E ? Ft : e), n.get(o).hidden = s);\n          }\n          if (t.hasIconCollisionBoxData() || t.hasTextCollisionBoxData()) {\n            const i = t.collisionArrays[o];\n            if (i) {\n              let o = new e.Point(0, 0),\n                r = !0;\n              if (i.textBox || i.verticalTextBox) {\n                if (c) {\n                  const e = this.variableOffsets[f];\n                  e ? (o = Mt(e.anchor, e.width, e.height, e.textOffset, e.textScale), h && o._rotate(u ? this.transform.angle : -this.transform.angle)) : r = !1;\n                }\n                n && (r = !x.clipped), i.textBox && St(t.textCollisionBox.collisionVertexArray, x.text.placed, !r || T, o.x, o.y), i.verticalTextBox && St(t.textCollisionBox.collisionVertexArray, x.text.placed, !r || E, o.x, o.y);\n              }\n              const s = r && Boolean(!E && i.verticalIconBox);\n              i.iconBox && St(t.iconCollisionBox.collisionVertexArray, x.icon.placed, s, _ ? o.x : 0, _ ? o.y : 0), i.verticalIconBox && St(t.iconCollisionBox.collisionVertexArray, x.icon.placed, !s, _ ? o.x : 0, _ ? o.y : 0);\n            }\n          }\n        }\n        if (t.fullyClipped = 0 === m, t.sortFeatures(this.transform.angle), this.retainedQueryData[t.bucketInstanceId] && (this.retainedQueryData[t.bucketInstanceId].featureSortOrder = t.featureSortOrder), t.hasTextData() && t.text.opacityVertexBuffer && t.text.opacityVertexBuffer.updateData(t.text.opacityVertexArray), t.hasIconData() && t.icon.opacityVertexBuffer && t.icon.opacityVertexBuffer.updateData(t.icon.opacityVertexArray), t.hasIconCollisionBoxData() && t.iconCollisionBox.collisionVertexBuffer && t.iconCollisionBox.collisionVertexBuffer.updateData(t.iconCollisionBox.collisionVertexArray), t.hasTextCollisionBoxData() && t.textCollisionBox.collisionVertexBuffer && t.textCollisionBox.collisionVertexBuffer.updateData(t.textCollisionBox.collisionVertexArray), t.bucketInstanceId in this.collisionCircleArrays) {\n          const e = this.collisionCircleArrays[t.bucketInstanceId];\n          t.placementInvProjMatrix = e.invProjMatrix, t.placementViewportMatrix = e.viewportMatrix, t.collisionCircleArray = e.circles, delete this.collisionCircleArrays[t.bucketInstanceId];\n        }\n      }\n      symbolFadeChange(e) {\n        return 0 === this.fadeDuration ? 1 : (e - this.commitTime) / this.fadeDuration + this.prevZoomAdjustment;\n      }\n      zoomAdjustment(e) {\n        return Math.max(0, (this.transform.zoom - e) / 1.5);\n      }\n      hasTransitions(e) {\n        return this.stale || e - this.lastPlacementChangeTime < this.fadeDuration;\n      }\n      stillRecent(e, t) {\n        const i = this.zoomAtLastRecencyCheck === t ? 1 - this.zoomAdjustment(t) : 1;\n        return this.zoomAtLastRecencyCheck = t, this.commitTime + this.fadeDuration * i > e;\n      }\n      setStale() {\n        this.stale = !0;\n      }\n    }\n    function St(e, t, i, o, r) {\n      e.emplaceBack(t ? 1 : 0, i ? 1 : 0, o || 0, r || 0), e.emplaceBack(t ? 1 : 0, i ? 1 : 0, o || 0, r || 0), e.emplaceBack(t ? 1 : 0, i ? 1 : 0, o || 0, r || 0), e.emplaceBack(t ? 1 : 0, i ? 1 : 0, o || 0, r || 0);\n    }\n    const Dt = Math.pow(2, 25),\n      Lt = Math.pow(2, 24),\n      At = Math.pow(2, 17),\n      zt = Math.pow(2, 16),\n      Rt = Math.pow(2, 9),\n      Ot = Math.pow(2, 8),\n      Bt = Math.pow(2, 1);\n    function kt(e) {\n      if (0 === e.opacity && !e.placed) return 0;\n      if (1 === e.opacity && e.placed) return 4294967295;\n      const t = e.placed ? 1 : 0,\n        i = Math.floor(127 * e.opacity);\n      return i * Dt + t * Lt + i * At + t * zt + i * Rt + t * Ot + i * Bt + t;\n    }\n    const Ft = 0;\n    class Ut {\n      constructor(e) {\n        this._sortAcrossTiles = \"viewport-y\" !== e.layout.get(\"symbol-z-order\") && void 0 !== e.layout.get(\"symbol-sort-key\").constantOr(1), this._currentTileIndex = 0, this._currentPartIndex = 0, this._seenCrossTileIDs = new Set(), this._bucketParts = [];\n      }\n      continuePlacement(e, t, i, o, r) {\n        const n = this._bucketParts;\n        for (; this._currentTileIndex < e.length;) if (t.getBucketParts(n, o, e[this._currentTileIndex], this._sortAcrossTiles), this._currentTileIndex++, r()) return !0;\n        for (this._sortAcrossTiles && (this._sortAcrossTiles = !1, n.sort((e, t) => e.sortKey - t.sortKey)); this._currentPartIndex < n.length;) {\n          const e = n[this._currentPartIndex];\n          if (t.placeLayerBucketPart(e, this._seenCrossTileIDs, i, 0 === e.symbolInstanceStart), this._currentPartIndex++, r()) return !0;\n        }\n        return !1;\n      }\n    }\n    class Nt {\n      constructor(e, t, i, o, r, n, s, a) {\n        this.placement = new Pt(e, r, n, s, a), this._currentPlacementIndex = t.length - 1, this._forceFullPlacement = i, this._showCollisionBoxes = o, this._done = !1;\n      }\n      isDone() {\n        return this._done;\n      }\n      continuePlacement(t, i, o) {\n        const r = e.exported.now(),\n          n = () => {\n            const t = e.exported.now() - r;\n            return !this._forceFullPlacement && t > 2;\n          };\n        for (; this._currentPlacementIndex >= 0;) {\n          const e = i[t[this._currentPlacementIndex]],\n            r = this.placement.collisionIndex.transform.zoom;\n          if (\"symbol\" === e.type && (!e.minzoom || e.minzoom <= r) && (!e.maxzoom || e.maxzoom > r)) {\n            if (this._inProgressLayer || (this._inProgressLayer = new Ut(e)), this._inProgressLayer.continuePlacement(o[e.source], this.placement, this._showCollisionBoxes, e, n)) return;\n            delete this._inProgressLayer;\n          }\n          this._currentPlacementIndex--;\n        }\n        this._done = !0;\n      }\n      commit(e) {\n        return this.placement.commit(e), this.placement;\n      }\n    }\n    const jt = 512 / e.EXTENT / 2;\n    class Gt {\n      constructor(t, i, o) {\n        this.tileID = t, this.bucketInstanceId = o, this.index = new e.KDBush(i.length, 16, Int32Array), this.keys = [], this.crossTileIDs = [];\n        const r = t.canonical.x * e.EXTENT,\n          n = t.canonical.y * e.EXTENT;\n        for (let e = 0; e < i.length; e++) {\n          const {\n              key: t,\n              crossTileID: o,\n              tileAnchorX: s,\n              tileAnchorY: a\n            } = i.get(e),\n            l = Math.floor((r + s) * jt),\n            c = Math.floor((n + a) * jt);\n          this.index.add(l, c), this.keys.push(t), this.crossTileIDs.push(o);\n        }\n        this.index.finish();\n      }\n      findMatches(t, i, o) {\n        const r = this.tileID.canonical.z < i.canonical.z ? 1 : Math.pow(2, this.tileID.canonical.z - i.canonical.z),\n          n = jt / Math.pow(2, i.canonical.z - this.tileID.canonical.z),\n          s = i.canonical.x * e.EXTENT,\n          a = i.canonical.y * e.EXTENT;\n        for (let e = 0; e < t.length; e++) {\n          const i = t.get(e);\n          if (i.crossTileID) continue;\n          const {\n              key: l,\n              tileAnchorX: c,\n              tileAnchorY: h\n            } = i,\n            u = Math.floor((s + c) * n),\n            _ = Math.floor((a + h) * n),\n            d = this.index.range(u - r, _ - r, u + r, _ + r);\n          for (const e of d) {\n            const t = this.crossTileIDs[e];\n            if (this.keys[e] === l && !o.has(t)) {\n              o.add(t), i.crossTileID = t;\n              break;\n            }\n          }\n        }\n      }\n    }\n    class Zt {\n      constructor() {\n        this.maxCrossTileID = 0;\n      }\n      generate() {\n        return ++this.maxCrossTileID;\n      }\n    }\n    class Vt {\n      constructor() {\n        this.indexes = {}, this.usedCrossTileIDs = {}, this.lng = 0;\n      }\n      handleWrapJump(e) {\n        const t = Math.round((e - this.lng) / 360);\n        if (0 !== t) for (const e in this.indexes) {\n          const i = this.indexes[e],\n            o = {};\n          for (const e in i) {\n            const r = i[e];\n            r.tileID = r.tileID.unwrapTo(r.tileID.wrap + t), o[r.tileID.key] = r;\n          }\n          this.indexes[e] = o;\n        }\n        this.lng = e;\n      }\n      addBucket(e, t, i) {\n        if (this.indexes[e.overscaledZ] && this.indexes[e.overscaledZ][e.key]) {\n          if (this.indexes[e.overscaledZ][e.key].bucketInstanceId === t.bucketInstanceId) return !1;\n          this.removeBucketCrossTileIDs(e.overscaledZ, this.indexes[e.overscaledZ][e.key]);\n        }\n        for (let e = 0; e < t.symbolInstances.length; e++) t.symbolInstances.get(e).crossTileID = 0;\n        this.usedCrossTileIDs[e.overscaledZ] || (this.usedCrossTileIDs[e.overscaledZ] = new Set());\n        const o = this.usedCrossTileIDs[e.overscaledZ];\n        for (const i in this.indexes) {\n          const r = this.indexes[i];\n          if (Number(i) > e.overscaledZ) for (const i in r) {\n            const n = r[i];\n            n.tileID.isChildOf(e) && n.findMatches(t.symbolInstances, e, o);\n          } else {\n            const n = r[e.scaledTo(Number(i)).key];\n            n && n.findMatches(t.symbolInstances, e, o);\n          }\n        }\n        for (let e = 0; e < t.symbolInstances.length; e++) {\n          const r = t.symbolInstances.get(e);\n          r.crossTileID || (r.crossTileID = i.generate(), o.add(r.crossTileID));\n        }\n        return void 0 === this.indexes[e.overscaledZ] && (this.indexes[e.overscaledZ] = {}), this.indexes[e.overscaledZ][e.key] = new Gt(e, t.symbolInstances, t.bucketInstanceId), !0;\n      }\n      removeBucketCrossTileIDs(e, t) {\n        for (const i of t.crossTileIDs) this.usedCrossTileIDs[e].delete(i);\n      }\n      removeStaleBuckets(e) {\n        let t = !1;\n        for (const i in this.indexes) {\n          const o = this.indexes[i];\n          for (const r in o) e[o[r].bucketInstanceId] || (this.removeBucketCrossTileIDs(i, o[r]), delete o[r], t = !0);\n        }\n        return t;\n      }\n    }\n    class Wt {\n      constructor() {\n        this.layerIndexes = {}, this.crossTileIDs = new Zt(), this.maxBucketInstanceId = 0, this.bucketsInCurrentPlacement = {};\n      }\n      addLayer(e, t, i, o) {\n        let r = this.layerIndexes[e.id];\n        void 0 === r && (r = this.layerIndexes[e.id] = new Vt());\n        let n = !1;\n        const s = {};\n        \"globe\" !== o.name && r.handleWrapJump(i);\n        for (const i of t) {\n          const t = i.getBucket(e);\n          t && e.id === t.layerIds[0] && (t.bucketInstanceId || (t.bucketInstanceId = ++this.maxBucketInstanceId), r.addBucket(i.tileID, t, this.crossTileIDs) && (n = !0), s[t.bucketInstanceId] = !0);\n        }\n        return r.removeStaleBuckets(s) && (n = !0), n;\n      }\n      pruneUnusedLayers(e) {\n        const t = {};\n        e.forEach(e => {\n          t[e] = !0;\n        });\n        for (const e in this.layerIndexes) t[e] || delete this.layerIndexes[e];\n      }\n    }\n    const Xt = (t, i) => e.emitValidationErrors(t, i && i.filter(e => \"source.canvas\" !== e.identifier)),\n      qt = e.pick(Ge, [\"addLayer\", \"removeLayer\", \"setPaintProperty\", \"setLayoutProperty\", \"setFilter\", \"addSource\", \"removeSource\", \"setLayerZoomRange\", \"setLight\", \"setTransition\", \"setGeoJSONSourceData\", \"setTerrain\", \"setFog\", \"setProjection\"]),\n      $t = e.pick(Ge, [\"setCenter\", \"setZoom\", \"setBearing\", \"setPitch\"]),\n      Ht = {\n        version: 8,\n        layers: [],\n        sources: {}\n      },\n      Yt = {\n        fill: !0,\n        line: !0,\n        background: !0,\n        hillshade: !0,\n        raster: !0\n      };\n    class Kt extends e.Evented {\n      constructor(t, i = {}) {\n        super(), this.map = t, this.dispatcher = new S(Ue(), this), this.imageManager = new y(), this.imageManager.setEventedParent(this), this.glyphManager = new e.GlyphManager(t._requestManager, i.localFontFamily ? e.LocalGlyphMode.all : i.localIdeographFontFamily ? e.LocalGlyphMode.ideographs : e.LocalGlyphMode.none, i.localFontFamily || i.localIdeographFontFamily), this.crossTileSymbolIndex = new Wt(), this._layers = {}, this._num3DLayers = 0, this._numSymbolLayers = 0, this._numCircleLayers = 0, this._serializedLayers = {}, this._sourceCaches = {}, this._otherSourceCaches = {}, this._symbolSourceCaches = {}, this._loaded = !1, this._availableImages = [], this._order = [], this._drapedFirstOrder = [], this._markersNeedUpdate = !1, this._resetUpdates(), this.dispatcher.broadcast(\"setReferrer\", e.getReferrer());\n        const o = this;\n        this._rtlTextPluginCallback = Kt.registerForPluginStateChange(t => {\n          o.dispatcher.broadcast(\"syncRTLPluginState\", {\n            pluginStatus: t.pluginStatus,\n            pluginURL: t.pluginURL\n          }, (t, i) => {\n            if (e.triggerPluginCompletionEvent(t), i && i.every(e => e)) for (const e in o._sourceCaches) {\n              const t = o._sourceCaches[e],\n                i = t.getSource().type;\n              \"vector\" !== i && \"geojson\" !== i || t.reload();\n            }\n          });\n        }), this.on(\"data\", e => {\n          if (\"source\" !== e.dataType || \"metadata\" !== e.sourceDataType) return;\n          const t = this.getSource(e.sourceId);\n          if (t && t.vectorLayerIds) for (const e in this._layers) {\n            const i = this._layers[e];\n            i.source === t.id && this._validateLayer(i);\n          }\n        });\n      }\n      loadURL(t, i = {}) {\n        this.fire(new e.Event(\"dataloading\", {\n          dataType: \"style\"\n        }));\n        const o = \"boolean\" == typeof i.validate ? i.validate : !e.isMapboxURL(t);\n        t = this.map._requestManager.normalizeStyleURL(t, i.accessToken);\n        const r = this.map._requestManager.transformRequest(t, e.ResourceType.Style);\n        this._request = e.getJSON(r, (t, i) => {\n          this._request = null, t ? this.fire(new e.ErrorEvent(t)) : i && this._load(i, o);\n        });\n      }\n      loadJSON(t, i = {}) {\n        this.fire(new e.Event(\"dataloading\", {\n          dataType: \"style\"\n        })), this._request = e.exported.frame(() => {\n          this._request = null, this._load(t, !1 !== i.validate);\n        });\n      }\n      loadEmpty() {\n        this.fire(new e.Event(\"dataloading\", {\n          dataType: \"style\"\n        })), this._load(Ht, !1);\n      }\n      _updateLayerCount(e, t) {\n        const i = t ? 1 : -1;\n        e.is3D() && (this._num3DLayers += i), \"circle\" === e.type && (this._numCircleLayers += i), \"symbol\" === e.type && (this._numSymbolLayers += i);\n      }\n      _load(t, i) {\n        if (i && Xt(this, e.validateStyle(t))) return;\n        this._loaded = !0, this.stylesheet = e.clone$1(t), this._updateMapProjection();\n        for (const e in t.sources) this.addSource(e, t.sources[e], {\n          validate: !1\n        });\n        this._changed = !1, t.sprite ? this._loadSprite(t.sprite) : (this.imageManager.setLoaded(!0), this.dispatcher.broadcast(\"spriteLoaded\", !0)), this.glyphManager.setURL(t.glyphs);\n        const o = je(this.stylesheet.layers);\n        this._order = o.map(e => e.id), this._layers = {}, this._serializedLayers = {};\n        for (const t of o) {\n          const i = e.createStyleLayer(t);\n          i.setEventedParent(this, {\n            layer: {\n              id: i.id\n            }\n          }), this._layers[i.id] = i, this._serializedLayers[i.id] = i.serialize(), this._updateLayerCount(i, !0);\n        }\n        this.dispatcher.broadcast(\"setLayers\", this._serializeLayers(this._order)), this.light = new w(this.stylesheet.light), this.stylesheet.terrain && !this.terrainSetForDrapingOnly() && this._createTerrain(this.stylesheet.terrain, 1), this.stylesheet.fog && this._createFog(this.stylesheet.fog), this._updateDrapeFirstLayers(), this.fire(new e.Event(\"data\", {\n          dataType: \"style\"\n        })), this.fire(new e.Event(\"style.load\"));\n      }\n      terrainSetForDrapingOnly() {\n        return !!this.terrain && 0 === this.terrain.drapeRenderMode;\n      }\n      setProjection(e) {\n        e ? this.stylesheet.projection = e : delete this.stylesheet.projection, this._updateMapProjection();\n      }\n      applyProjectionUpdate() {\n        this._loaded && (this.dispatcher.broadcast(\"setProjection\", this.map.transform.projectionOptions), this.map.transform.projection.requiresDraping ? this.getTerrain() || this.stylesheet.terrain || this.setTerrainForDraping() : this.terrainSetForDrapingOnly() && this.setTerrain(null));\n      }\n      _updateMapProjection() {\n        this.map._useExplicitProjection ? this.applyProjectionUpdate() : this.map._prioritizeAndUpdateProjection(null, this.stylesheet.projection);\n      }\n      _loadSprite(t) {\n        this._spriteRequest = function (t, i, o) {\n          let r, n, s;\n          const a = e.exported.devicePixelRatio > 1 ? \"@2x\" : \"\";\n          let l = e.getJSON(i.transformRequest(i.normalizeSpriteURL(t, a, \".json\"), e.ResourceType.SpriteJSON), (e, t) => {\n              l = null, s || (s = e, r = t, h());\n            }),\n            c = e.getImage(i.transformRequest(i.normalizeSpriteURL(t, a, \".png\"), e.ResourceType.SpriteImage), (e, t) => {\n              c = null, s || (s = e, n = t, h());\n            });\n          function h() {\n            if (s) o(s);else if (r && n) {\n              const t = e.exported.getImageData(n),\n                i = {};\n              for (const o in r) {\n                const {\n                    width: n,\n                    height: s,\n                    x: a,\n                    y: l,\n                    sdf: c,\n                    pixelRatio: h,\n                    stretchX: u,\n                    stretchY: _,\n                    content: d\n                  } = r[o],\n                  p = new e.RGBAImage({\n                    width: n,\n                    height: s\n                  });\n                e.RGBAImage.copy(t, p, {\n                  x: a,\n                  y: l\n                }, {\n                  x: 0,\n                  y: 0\n                }, {\n                  width: n,\n                  height: s\n                }), i[o] = {\n                  data: p,\n                  pixelRatio: h,\n                  sdf: c,\n                  stretchX: u,\n                  stretchY: _,\n                  content: d\n                };\n              }\n              o(null, i);\n            }\n          }\n          return {\n            cancel() {\n              l && (l.cancel(), l = null), c && (c.cancel(), c = null);\n            }\n          };\n        }(t, this.map._requestManager, (t, i) => {\n          if (this._spriteRequest = null, t) this.fire(new e.ErrorEvent(t));else if (i) for (const e in i) this.imageManager.addImage(e, i[e]);\n          this.imageManager.setLoaded(!0), this._availableImages = this.imageManager.listImages(), this.dispatcher.broadcast(\"setImages\", this._availableImages), this.dispatcher.broadcast(\"spriteLoaded\", !0), this.fire(new e.Event(\"data\", {\n            dataType: \"style\"\n          }));\n        });\n      }\n      _validateLayer(t) {\n        const i = this.getSource(t.source);\n        if (!i) return;\n        const o = t.sourceLayer;\n        o && (\"geojson\" === i.type || i.vectorLayerIds && -1 === i.vectorLayerIds.indexOf(o)) && this.fire(new e.ErrorEvent(new Error(`Source layer \"${o}\" does not exist on source \"${i.id}\" as specified by style layer \"${t.id}\"`)));\n      }\n      loaded() {\n        if (!this._loaded) return !1;\n        if (Object.keys(this._updatedSources).length) return !1;\n        for (const e in this._sourceCaches) if (!this._sourceCaches[e].loaded()) return !1;\n        return !!this.imageManager.isLoaded();\n      }\n      _serializeLayers(e) {\n        const t = [];\n        for (const i of e) {\n          const e = this._layers[i];\n          \"custom\" !== e.type && t.push(e.serialize());\n        }\n        return t;\n      }\n      hasTransitions() {\n        if (this.light && this.light.hasTransition()) return !0;\n        if (this.fog && this.fog.hasTransition()) return !0;\n        for (const e in this._sourceCaches) if (this._sourceCaches[e].hasTransition()) return !0;\n        for (const e in this._layers) if (this._layers[e].hasTransition()) return !0;\n        return !1;\n      }\n      get order() {\n        return this.map._optimizeForTerrain && this.terrain ? this._drapedFirstOrder : this._order;\n      }\n      isLayerDraped(e) {\n        return !!this.terrain && (\"function\" == typeof e.isLayerDraped ? e.isLayerDraped() : Yt[e.type]);\n      }\n      _checkLoaded() {\n        if (!this._loaded) throw new Error(\"Style is not done loading\");\n      }\n      update(t) {\n        if (!this._loaded) return;\n        const i = this._changed;\n        if (this._changed) {\n          const e = Object.keys(this._updatedLayers),\n            i = Object.keys(this._removedLayers);\n          (e.length || i.length) && this._updateWorkerLayers(e, i);\n          for (const e in this._updatedSources) {\n            const t = this._updatedSources[e];\n            \"reload\" === t ? this._reloadSource(e) : \"clear\" === t && this._clearSource(e);\n          }\n          this._updateTilesForChangedImages();\n          for (const e in this._updatedPaintProps) this._layers[e].updateTransitions(t);\n          this.light.updateTransitions(t), this.fog && this.fog.updateTransitions(t), this._resetUpdates();\n        }\n        const o = {};\n        for (const e in this._sourceCaches) {\n          const t = this._sourceCaches[e];\n          o[e] = t.used, t.used = !1;\n        }\n        for (const e of this._order) {\n          const i = this._layers[e];\n          if (i.recalculate(t, this._availableImages), !i.isHidden(t.zoom)) {\n            const e = this._getLayerSourceCache(i);\n            e && (e.used = !0);\n          }\n          const o = this.map.painter;\n          if (o) {\n            const e = i.getProgramIds();\n            if (!e) continue;\n            const r = i.getProgramConfiguration(t.zoom);\n            for (const t of e) o.useProgram(t, r);\n          }\n        }\n        for (const t in o) {\n          const i = this._sourceCaches[t];\n          o[t] !== i.used && i.getSource().fire(new e.Event(\"data\", {\n            sourceDataType: \"visibility\",\n            dataType: \"source\",\n            sourceId: i.getSource().id\n          }));\n        }\n        this.light.recalculate(t), this.terrain && this.terrain.recalculate(t), this.fog && this.fog.recalculate(t), this.z = t.zoom, this._markersNeedUpdate && (this._updateMarkersOpacity(), this._markersNeedUpdate = !1), i && this.fire(new e.Event(\"data\", {\n          dataType: \"style\"\n        }));\n      }\n      _updateTilesForChangedImages() {\n        const e = Object.keys(this._changedImages);\n        if (e.length) {\n          for (const t in this._sourceCaches) this._sourceCaches[t].reloadTilesForDependencies([\"icons\", \"patterns\"], e);\n          this._changedImages = {};\n        }\n      }\n      _updateWorkerLayers(e, t) {\n        this.dispatcher.broadcast(\"updateLayers\", {\n          layers: this._serializeLayers(e),\n          removedIds: t\n        });\n      }\n      _resetUpdates() {\n        this._changed = !1, this._updatedLayers = {}, this._removedLayers = {}, this._updatedSources = {}, this._updatedPaintProps = {}, this._changedImages = {};\n      }\n      setState(i) {\n        if (this._checkLoaded(), Xt(this, e.validateStyle(i))) return !1;\n        (i = e.clone$1(i)).layers = je(i.layers);\n        const o = function (e, i) {\n          if (!e) return [{\n            command: Ge.setStyle,\n            args: [i]\n          }];\n          let o = [];\n          try {\n            if (!t(e.version, i.version)) return [{\n              command: Ge.setStyle,\n              args: [i]\n            }];\n            t(e.center, i.center) || o.push({\n              command: Ge.setCenter,\n              args: [i.center]\n            }), t(e.zoom, i.zoom) || o.push({\n              command: Ge.setZoom,\n              args: [i.zoom]\n            }), t(e.bearing, i.bearing) || o.push({\n              command: Ge.setBearing,\n              args: [i.bearing]\n            }), t(e.pitch, i.pitch) || o.push({\n              command: Ge.setPitch,\n              args: [i.pitch]\n            }), t(e.sprite, i.sprite) || o.push({\n              command: Ge.setSprite,\n              args: [i.sprite]\n            }), t(e.glyphs, i.glyphs) || o.push({\n              command: Ge.setGlyphs,\n              args: [i.glyphs]\n            }), t(e.transition, i.transition) || o.push({\n              command: Ge.setTransition,\n              args: [i.transition]\n            }), t(e.light, i.light) || o.push({\n              command: Ge.setLight,\n              args: [i.light]\n            }), t(e.fog, i.fog) || o.push({\n              command: Ge.setFog,\n              args: [i.fog]\n            }), t(e.projection, i.projection) || o.push({\n              command: Ge.setProjection,\n              args: [i.projection]\n            });\n            const r = {},\n              n = [];\n            !function (e, i, o, r) {\n              let n;\n              for (n in i = i || {}, e = e || {}) e.hasOwnProperty(n) && (i.hasOwnProperty(n) || Ve(n, o, r));\n              for (n in i) {\n                if (!i.hasOwnProperty(n)) continue;\n                const s = i[n];\n                e.hasOwnProperty(n) ? t(e[n], s) || (\"geojson\" === e[n].type && \"geojson\" === s.type && Xe(e, i, n) ? o.push({\n                  command: Ge.setGeoJSONSourceData,\n                  args: [n, s.data]\n                }) : We(n, i, o, r)) : Ze(n, i, o);\n              }\n            }(e.sources, i.sources, n, r);\n            const s = [];\n            e.layers && e.layers.forEach(e => {\n              e.source && r[e.source] ? o.push({\n                command: Ge.removeLayer,\n                args: [e.id]\n              }) : s.push(e);\n            });\n            let a = e.terrain;\n            a && r[a.source] && (o.push({\n              command: Ge.setTerrain,\n              args: [void 0]\n            }), a = void 0), o = o.concat(n), t(a, i.terrain) || o.push({\n              command: Ge.setTerrain,\n              args: [i.terrain]\n            }), function (e, i, o) {\n              i = i || [];\n              const r = (e = e || []).map($e),\n                n = i.map($e),\n                s = e.reduce(He, {}),\n                a = i.reduce(He, {}),\n                l = r.slice(),\n                c = Object.create(null);\n              let h, u, _, d, p, m, f;\n              for (h = 0, u = 0; h < r.length; h++) _ = r[h], a.hasOwnProperty(_) ? u++ : (o.push({\n                command: Ge.removeLayer,\n                args: [_]\n              }), l.splice(l.indexOf(_, u), 1));\n              for (h = 0, u = 0; h < n.length; h++) _ = n[n.length - 1 - h], l[l.length - 1 - h] !== _ && (s.hasOwnProperty(_) ? (o.push({\n                command: Ge.removeLayer,\n                args: [_]\n              }), l.splice(l.lastIndexOf(_, l.length - u), 1)) : u++, m = l[l.length - h], o.push({\n                command: Ge.addLayer,\n                args: [a[_], m]\n              }), l.splice(l.length - h, 0, _), c[_] = !0);\n              for (h = 0; h < n.length; h++) if (_ = n[h], d = s[_], p = a[_], !c[_] && !t(d, p)) if (t(d.source, p.source) && t(d[\"source-layer\"], p[\"source-layer\"]) && t(d.type, p.type)) {\n                for (f in qe(d.layout, p.layout, o, _, null, Ge.setLayoutProperty), qe(d.paint, p.paint, o, _, null, Ge.setPaintProperty), t(d.filter, p.filter) || o.push({\n                  command: Ge.setFilter,\n                  args: [_, p.filter]\n                }), t(d.minzoom, p.minzoom) && t(d.maxzoom, p.maxzoom) || o.push({\n                  command: Ge.setLayerZoomRange,\n                  args: [_, p.minzoom, p.maxzoom]\n                }), d) d.hasOwnProperty(f) && \"layout\" !== f && \"paint\" !== f && \"filter\" !== f && \"metadata\" !== f && \"minzoom\" !== f && \"maxzoom\" !== f && (0 === f.indexOf(\"paint.\") ? qe(d[f], p[f], o, _, f.slice(6), Ge.setPaintProperty) : t(d[f], p[f]) || o.push({\n                  command: Ge.setLayerProperty,\n                  args: [_, f, p[f]]\n                }));\n                for (f in p) p.hasOwnProperty(f) && !d.hasOwnProperty(f) && \"layout\" !== f && \"paint\" !== f && \"filter\" !== f && \"metadata\" !== f && \"minzoom\" !== f && \"maxzoom\" !== f && (0 === f.indexOf(\"paint.\") ? qe(d[f], p[f], o, _, f.slice(6), Ge.setPaintProperty) : t(d[f], p[f]) || o.push({\n                  command: Ge.setLayerProperty,\n                  args: [_, f, p[f]]\n                }));\n              } else o.push({\n                command: Ge.removeLayer,\n                args: [_]\n              }), m = l[l.lastIndexOf(_) + 1], o.push({\n                command: Ge.addLayer,\n                args: [p, m]\n              });\n            }(s, i.layers, o);\n          } catch (e) {\n            console.warn(\"Unable to compute style diff:\", e), o = [{\n              command: Ge.setStyle,\n              args: [i]\n            }];\n          }\n          return o;\n        }(this.serialize(), i).filter(e => !(e.command in $t));\n        if (0 === o.length) return !1;\n        const r = o.filter(e => !(e.command in qt));\n        if (r.length > 0) throw new Error(`Unimplemented: ${r.map(e => e.command).join(\", \")}.`);\n        return o.forEach(e => {\n          \"setTransition\" !== e.command && \"setProjection\" !== e.command && this[e.command].apply(this, e.args);\n        }), this.stylesheet = i, this._updateMapProjection(), !0;\n      }\n      addImage(t, i) {\n        return this.getImage(t) ? this.fire(new e.ErrorEvent(new Error(\"An image with this name already exists.\"))) : (this.imageManager.addImage(t, i), this._afterImageUpdated(t), this);\n      }\n      updateImage(e, t) {\n        this.imageManager.updateImage(e, t);\n      }\n      getImage(e) {\n        return this.imageManager.getImage(e);\n      }\n      removeImage(t) {\n        return this.getImage(t) ? (this.imageManager.removeImage(t), this._afterImageUpdated(t), this) : this.fire(new e.ErrorEvent(new Error(\"No image with this name exists.\")));\n      }\n      _afterImageUpdated(t) {\n        this._availableImages = this.imageManager.listImages(), this._changedImages[t] = !0, this._changed = !0, this.dispatcher.broadcast(\"setImages\", this._availableImages), this.fire(new e.Event(\"data\", {\n          dataType: \"style\"\n        }));\n      }\n      listImages() {\n        return this._checkLoaded(), this._availableImages.slice();\n      }\n      addSource(t, i, o = {}) {\n        if (this._checkLoaded(), void 0 !== this.getSource(t)) throw new Error(\"There is already a source with this ID\");\n        if (!i.type) throw new Error(`The type property must be defined, but only the following properties were given: ${Object.keys(i).join(\", \")}.`);\n        if ([\"vector\", \"raster\", \"geojson\", \"video\", \"image\"].indexOf(i.type) >= 0 && this._validate(e.validateSource, `sources.${t}`, i, null, o)) return;\n        this.map && this.map._collectResourceTiming && (i.collectResourceTiming = !0);\n        const r = De(t, i, this.dispatcher, this);\n        r.setEventedParent(this, () => ({\n          isSourceLoaded: this._isSourceCacheLoaded(t),\n          source: r.serialize(),\n          sourceId: t\n        }));\n        const n = i => {\n          const o = (i ? \"symbol:\" : \"other:\") + t,\n            n = this._sourceCaches[o] = new e.SourceCache(o, r, i);\n          (i ? this._symbolSourceCaches : this._otherSourceCaches)[t] = n, n.style = this, n.onAdd(this.map);\n        };\n        n(!1), \"vector\" !== i.type && \"geojson\" !== i.type || n(!0), r.onAdd && r.onAdd(this.map), this._changed = !0;\n      }\n      removeSource(t) {\n        this._checkLoaded();\n        const i = this.getSource(t);\n        if (!i) throw new Error(\"There is no source with this ID\");\n        for (const i in this._layers) if (this._layers[i].source === t) return this.fire(new e.ErrorEvent(new Error(`Source \"${t}\" cannot be removed while layer \"${i}\" is using it.`)));\n        if (this.terrain && this.terrain.get().source === t) return this.fire(new e.ErrorEvent(new Error(`Source \"${t}\" cannot be removed while terrain is using it.`)));\n        const o = this._getSourceCaches(t);\n        for (const t of o) delete this._sourceCaches[t.id], delete this._updatedSources[t.id], t.fire(new e.Event(\"data\", {\n          sourceDataType: \"metadata\",\n          dataType: \"source\",\n          sourceId: t.getSource().id\n        })), t.setEventedParent(null), t.clearTiles();\n        return delete this._otherSourceCaches[t], delete this._symbolSourceCaches[t], i.setEventedParent(null), i.onRemove && i.onRemove(this.map), this._changed = !0, this;\n      }\n      setGeoJSONSourceData(e, t) {\n        this._checkLoaded(), this.getSource(e).setData(t), this._changed = !0;\n      }\n      getSource(e) {\n        const t = this._getSourceCache(e);\n        return t && t.getSource();\n      }\n      _getSources() {\n        const e = [];\n        for (const t in this._otherSourceCaches) {\n          const i = this._getSourceCache(t);\n          i && e.push(i.getSource());\n        }\n        return e;\n      }\n      addLayer(t, i, o = {}) {\n        this._checkLoaded();\n        const r = t.id;\n        if (this.getLayer(r)) return void this.fire(new e.ErrorEvent(new Error(`Layer with id \"${r}\" already exists on this map`)));\n        let n;\n        if (\"custom\" === t.type) {\n          if (Xt(this, e.validateCustomStyleLayer(t))) return;\n          n = e.createStyleLayer(t);\n        } else {\n          if (\"object\" == typeof t.source && (this.addSource(r, t.source), t = e.clone$1(t), t = e.extend(t, {\n            source: r\n          })), this._validate(e.validateLayer, `layers.${r}`, t, {\n            arrayIndex: -1\n          }, o)) return;\n          n = e.createStyleLayer(t), this._validateLayer(n), n.setEventedParent(this, {\n            layer: {\n              id: r\n            }\n          }), this._serializedLayers[n.id] = n.serialize(), this._updateLayerCount(n, !0);\n        }\n        const s = i ? this._order.indexOf(i) : this._order.length;\n        if (i && -1 === s) return void this.fire(new e.ErrorEvent(new Error(`Layer with id \"${i}\" does not exist on this map.`)));\n        this._order.splice(s, 0, r), this._layerOrderChanged = !0, this._layers[r] = n;\n        const a = this._getLayerSourceCache(n);\n        if (this._removedLayers[r] && n.source && a && \"custom\" !== n.type) {\n          const e = this._removedLayers[r];\n          delete this._removedLayers[r], e.type !== n.type ? this._updatedSources[n.source] = \"clear\" : (this._updatedSources[n.source] = \"reload\", a.pause());\n        }\n        this._updateLayer(n), n.onAdd && n.onAdd(this.map), this._updateDrapeFirstLayers();\n      }\n      moveLayer(t, i) {\n        if (this._checkLoaded(), this._changed = !0, !this._layers[t]) return void this.fire(new e.ErrorEvent(new Error(`The layer '${t}' does not exist in the map's style and cannot be moved.`)));\n        if (t === i) return;\n        const o = this._order.indexOf(t);\n        this._order.splice(o, 1);\n        const r = i ? this._order.indexOf(i) : this._order.length;\n        i && -1 === r ? this.fire(new e.ErrorEvent(new Error(`Layer with id \"${i}\" does not exist on this map.`))) : (this._order.splice(r, 0, t), this._layerOrderChanged = !0, this._updateDrapeFirstLayers());\n      }\n      removeLayer(t) {\n        this._checkLoaded();\n        const i = this._layers[t];\n        if (!i) return void this.fire(new e.ErrorEvent(new Error(`The layer '${t}' does not exist in the map's style and cannot be removed.`)));\n        i.setEventedParent(null), this._updateLayerCount(i, !1);\n        const o = this._order.indexOf(t);\n        this._order.splice(o, 1), this._layerOrderChanged = !0, this._changed = !0, this._removedLayers[t] = i, delete this._layers[t], delete this._serializedLayers[t], delete this._updatedLayers[t], delete this._updatedPaintProps[t], i.onRemove && i.onRemove(this.map), this._updateDrapeFirstLayers();\n      }\n      getLayer(e) {\n        return this._layers[e];\n      }\n      hasLayer(e) {\n        return e in this._layers;\n      }\n      hasLayerType(e) {\n        for (const t in this._layers) if (this._layers[t].type === e) return !0;\n        return !1;\n      }\n      setLayerZoomRange(t, i, o) {\n        this._checkLoaded();\n        const r = this.getLayer(t);\n        r ? r.minzoom === i && r.maxzoom === o || (null != i && (r.minzoom = i), null != o && (r.maxzoom = o), this._updateLayer(r)) : this.fire(new e.ErrorEvent(new Error(`The layer '${t}' does not exist in the map's style and cannot have zoom extent.`)));\n      }\n      setFilter(i, o, r = {}) {\n        this._checkLoaded();\n        const n = this.getLayer(i);\n        if (n) {\n          if (!t(n.filter, o)) return null == o ? (n.filter = void 0, void this._updateLayer(n)) : void (this._validate(e.validateFilter, `layers.${n.id}.filter`, o, {\n            layerType: n.type\n          }, r) || (n.filter = e.clone$1(o), this._updateLayer(n)));\n        } else this.fire(new e.ErrorEvent(new Error(`The layer '${i}' does not exist in the map's style and cannot be filtered.`)));\n      }\n      getFilter(t) {\n        const i = this.getLayer(t);\n        return i && e.clone$1(i.filter);\n      }\n      setLayoutProperty(i, o, r, n = {}) {\n        this._checkLoaded();\n        const s = this.getLayer(i);\n        s ? t(s.getLayoutProperty(o), r) || (s.setLayoutProperty(o, r, n), this._updateLayer(s)) : this.fire(new e.ErrorEvent(new Error(`The layer '${i}' does not exist in the map's style and cannot be styled.`)));\n      }\n      getLayoutProperty(t, i) {\n        const o = this.getLayer(t);\n        if (o) return o.getLayoutProperty(i);\n        this.fire(new e.ErrorEvent(new Error(`The layer '${t}' does not exist in the map's style.`)));\n      }\n      setPaintProperty(i, o, r, n = {}) {\n        this._checkLoaded();\n        const s = this.getLayer(i);\n        s ? t(s.getPaintProperty(o), r) || (s.setPaintProperty(o, r, n) && this._updateLayer(s), this._changed = !0, this._updatedPaintProps[i] = !0) : this.fire(new e.ErrorEvent(new Error(`The layer '${i}' does not exist in the map's style and cannot be styled.`)));\n      }\n      getPaintProperty(e, t) {\n        const i = this.getLayer(e);\n        return i && i.getPaintProperty(t);\n      }\n      setFeatureState(t, i) {\n        this._checkLoaded();\n        const o = t.source,\n          r = t.sourceLayer,\n          n = this.getSource(o);\n        if (!n) return void this.fire(new e.ErrorEvent(new Error(`The source '${o}' does not exist in the map's style.`)));\n        const s = n.type;\n        if (\"geojson\" === s && r) return void this.fire(new e.ErrorEvent(new Error(\"GeoJSON sources cannot have a sourceLayer parameter.\")));\n        if (\"vector\" === s && !r) return void this.fire(new e.ErrorEvent(new Error(\"The sourceLayer parameter must be provided for vector source types.\")));\n        void 0 === t.id && this.fire(new e.ErrorEvent(new Error(\"The feature id parameter must be provided.\")));\n        const a = this._getSourceCaches(o);\n        for (const e of a) e.setFeatureState(r, t.id, i);\n      }\n      removeFeatureState(t, i) {\n        this._checkLoaded();\n        const o = t.source,\n          r = this.getSource(o);\n        if (!r) return void this.fire(new e.ErrorEvent(new Error(`The source '${o}' does not exist in the map's style.`)));\n        const n = r.type,\n          s = \"vector\" === n ? t.sourceLayer : void 0;\n        if (\"vector\" === n && !s) return void this.fire(new e.ErrorEvent(new Error(\"The sourceLayer parameter must be provided for vector source types.\")));\n        if (i && \"string\" != typeof t.id && \"number\" != typeof t.id) return void this.fire(new e.ErrorEvent(new Error(\"A feature id is required to remove its specific state property.\")));\n        const a = this._getSourceCaches(o);\n        for (const e of a) e.removeFeatureState(s, t.id, i);\n      }\n      getFeatureState(t) {\n        this._checkLoaded();\n        const i = t.source,\n          o = t.sourceLayer,\n          r = this.getSource(i);\n        if (r) {\n          if (\"vector\" !== r.type || o) return void 0 === t.id && this.fire(new e.ErrorEvent(new Error(\"The feature id parameter must be provided.\"))), this._getSourceCaches(i)[0].getFeatureState(o, t.id);\n          this.fire(new e.ErrorEvent(new Error(\"The sourceLayer parameter must be provided for vector source types.\")));\n        } else this.fire(new e.ErrorEvent(new Error(`The source '${i}' does not exist in the map's style.`)));\n      }\n      getTransition() {\n        return e.extend({\n          duration: 300,\n          delay: 0\n        }, this.stylesheet && this.stylesheet.transition);\n      }\n      serialize() {\n        const t = {};\n        for (const e in this._sourceCaches) {\n          const i = this._sourceCaches[e].getSource();\n          t[i.id] || (t[i.id] = i.serialize());\n        }\n        return e.filterObject({\n          version: this.stylesheet.version,\n          name: this.stylesheet.name,\n          metadata: this.stylesheet.metadata,\n          light: this.stylesheet.light,\n          terrain: this.getTerrain() || void 0,\n          fog: this.stylesheet.fog,\n          center: this.stylesheet.center,\n          zoom: this.stylesheet.zoom,\n          bearing: this.stylesheet.bearing,\n          pitch: this.stylesheet.pitch,\n          sprite: this.stylesheet.sprite,\n          glyphs: this.stylesheet.glyphs,\n          transition: this.stylesheet.transition,\n          projection: this.stylesheet.projection,\n          sources: t,\n          layers: this._serializeLayers(this._order)\n        }, e => void 0 !== e);\n      }\n      _updateLayer(e) {\n        this._updatedLayers[e.id] = !0;\n        const t = this._getLayerSourceCache(e);\n        e.source && !this._updatedSources[e.source] && t && \"raster\" !== t.getSource().type && (this._updatedSources[e.source] = \"reload\", t.pause()), this._changed = !0, e.invalidateCompiledFilter();\n      }\n      _flattenAndSortRenderedFeatures(e) {\n        const t = e => \"fill-extrusion\" === this._layers[e].type,\n          i = {},\n          o = [];\n        for (let r = this._order.length - 1; r >= 0; r--) {\n          const n = this._order[r];\n          if (t(n)) {\n            i[n] = r;\n            for (const t of e) {\n              const e = t[n];\n              if (e) for (const t of e) o.push(t);\n            }\n          }\n        }\n        o.sort((e, t) => t.intersectionZ - e.intersectionZ);\n        const r = [];\n        for (let n = this._order.length - 1; n >= 0; n--) {\n          const s = this._order[n];\n          if (t(s)) for (let e = o.length - 1; e >= 0; e--) {\n            const t = o[e].feature;\n            if (i[t.layer.id] < n) break;\n            r.push(t), o.pop();\n          } else for (const t of e) {\n            const e = t[s];\n            if (e) for (const t of e) r.push(t.feature);\n          }\n        }\n        return r;\n      }\n      queryRenderedFeatures(t, i, o) {\n        i && i.filter && this._validate(e.validateFilter, \"queryRenderedFeatures.filter\", i.filter, null, i);\n        const r = {};\n        if (i && i.layers) {\n          if (!Array.isArray(i.layers)) return this.fire(new e.ErrorEvent(new Error(\"parameters.layers must be an Array.\"))), [];\n          for (const t of i.layers) {\n            const i = this._layers[t];\n            if (!i) return this.fire(new e.ErrorEvent(new Error(`The layer '${t}' does not exist in the map's style and cannot be queried for features.`))), [];\n            r[i.source] = !0;\n          }\n        }\n        const n = [];\n        i.availableImages = this._availableImages;\n        const s = i && i.layers ? i.layers.some(e => {\n            const t = this.getLayer(e);\n            return t && t.is3D();\n          }) : this.has3DLayers(),\n          a = L.createFromScreenPoints(t, o);\n        for (const e in this._sourceCaches) {\n          const t = this._sourceCaches[e].getSource().id;\n          i.layers && !r[t] || n.push(Ae(this._sourceCaches[e], this._layers, this._serializedLayers, a, i, o, s, !!this.map._showQueryGeometry));\n        }\n        return this.placement && n.push(function (e, t, i, o, r, n, s) {\n          const a = {},\n            l = n.queryRenderedSymbols(o),\n            c = [];\n          for (const e of Object.keys(l).map(Number)) c.push(s[e]);\n          c.sort(Re);\n          for (const i of c) {\n            const o = i.featureIndex.lookupSymbolFeatures(l[i.bucketInstanceId], t, i.bucketIndex, i.sourceLayerIndex, r.filter, r.layers, r.availableImages, e);\n            for (const e in o) {\n              const t = a[e] = a[e] || [],\n                r = o[e];\n              r.sort((e, t) => {\n                const o = i.featureSortOrder;\n                if (o) {\n                  const i = o.indexOf(e.featureIndex);\n                  return o.indexOf(t.featureIndex) - i;\n                }\n                return t.featureIndex - e.featureIndex;\n              });\n              for (const e of r) t.push(e);\n            }\n          }\n          for (const t in a) a[t].forEach(o => {\n            const r = o.feature,\n              n = i(e[t]);\n            if (!n) return;\n            const s = n.getFeatureState(r.layer[\"source-layer\"], r.id);\n            r.source = r.layer.source, r.layer[\"source-layer\"] && (r.sourceLayer = r.layer[\"source-layer\"]), r.state = s;\n          });\n          return a;\n        }(this._layers, this._serializedLayers, this._getLayerSourceCache.bind(this), a.screenGeometry, i, this.placement.collisionIndex, this.placement.retainedQueryData)), this._flattenAndSortRenderedFeatures(n);\n      }\n      querySourceFeatures(t, i) {\n        i && i.filter && this._validate(e.validateFilter, \"querySourceFeatures.filter\", i.filter, null, i);\n        const o = this._getSourceCaches(t);\n        let r = [];\n        for (const e of o) r = r.concat(ze(e, i));\n        return r;\n      }\n      addSourceType(e, t, i) {\n        return Kt.getSourceType(e) ? i(new Error(`A source type called \"${e}\" already exists.`)) : (Kt.setSourceType(e, t), t.workerSourceURL ? void this.dispatcher.broadcast(\"loadWorkerSource\", {\n          name: e,\n          url: t.workerSourceURL\n        }, i) : i(null, null));\n      }\n      getLight() {\n        return this.light.getLight();\n      }\n      setLight(e, i = {}) {\n        this._checkLoaded();\n        const o = this.light.getLight();\n        let r = !1;\n        for (const i in e) if (!t(e[i], o[i])) {\n          r = !0;\n          break;\n        }\n        if (!r) return;\n        const n = this._setTransitionParameters({\n          duration: 300,\n          delay: 0\n        });\n        this.light.setLight(e, i), this.light.updateTransitions(n);\n      }\n      getTerrain() {\n        return this.terrain && 1 === this.terrain.drapeRenderMode ? this.terrain.get() : null;\n      }\n      setTerrainForDraping() {\n        this.setTerrain({\n          source: \"\",\n          exaggeration: 0\n        }, 0);\n      }\n      setTerrain(i, o = 1) {\n        if (this._checkLoaded(), !i) return delete this.terrain, delete this.stylesheet.terrain, this.dispatcher.broadcast(\"enableTerrain\", !1), this._force3DLayerUpdate(), void (this._markersNeedUpdate = !0);\n        let r = i;\n        if (1 === o) {\n          if (\"object\" == typeof r.source) {\n            const t = \"terrain-dem-src\";\n            this.addSource(t, r.source), r = e.clone$1(r), r = e.extend(r, {\n              source: t\n            });\n          }\n          if (this._validate(e.validateTerrain, \"terrain\", r)) return;\n        }\n        if (!this.terrain || this.terrain && o !== this.terrain.drapeRenderMode) {\n          if (!r) return;\n          this._createTerrain(r, o);\n        } else {\n          const i = this.terrain,\n            o = i.get();\n          for (const t of Object.keys(e.spec.terrain)) !r.hasOwnProperty(t) && e.spec.terrain[t].default && (r[t] = e.spec.terrain[t].default);\n          for (const e in r) if (!t(r[e], o[e])) {\n            i.set(r), this.stylesheet.terrain = r;\n            const e = this._setTransitionParameters({\n              duration: 0\n            });\n            i.updateTransitions(e);\n            break;\n          }\n        }\n        this._updateDrapeFirstLayers(), this._markersNeedUpdate = !0;\n      }\n      _createFog(e) {\n        const t = this.fog = new P(e, this.map.transform);\n        this.stylesheet.fog = e;\n        const i = this._setTransitionParameters({\n          duration: 0\n        });\n        t.updateTransitions(i);\n      }\n      _updateMarkersOpacity() {\n        0 !== this.map._markers.length && this.map._requestDomTask(() => {\n          for (const e of this.map._markers) e._evaluateOpacity();\n        });\n      }\n      getFog() {\n        return this.fog ? this.fog.get() : null;\n      }\n      setFog(e) {\n        if (this._checkLoaded(), !e) return delete this.fog, delete this.stylesheet.fog, void (this._markersNeedUpdate = !0);\n        if (this.fog) {\n          const i = this.fog,\n            o = i.get();\n          0 === Object.keys(e).length && i.set(e);\n          for (const r in e) if (!t(e[r], o[r])) {\n            i.set(e), this.stylesheet.fog = e;\n            const t = this._setTransitionParameters({\n              duration: 0\n            });\n            i.updateTransitions(t);\n            break;\n          }\n        } else this._createFog(e);\n        this._markersNeedUpdate = !0;\n      }\n      _setTransitionParameters(t) {\n        return {\n          now: e.exported.now(),\n          transition: e.extend(t, this.stylesheet.transition)\n        };\n      }\n      _updateDrapeFirstLayers() {\n        if (!this.map._optimizeForTerrain || !this.terrain) return;\n        const e = this._order.filter(e => this.isLayerDraped(this._layers[e])),\n          t = this._order.filter(e => !this.isLayerDraped(this._layers[e]));\n        this._drapedFirstOrder = [], this._drapedFirstOrder.push(...e), this._drapedFirstOrder.push(...t);\n      }\n      _createTerrain(e, t) {\n        const i = this.terrain = new E(e, t);\n        this.stylesheet.terrain = e, this.dispatcher.broadcast(\"enableTerrain\", !this.terrainSetForDrapingOnly()), this._force3DLayerUpdate();\n        const o = this._setTransitionParameters({\n          duration: 0\n        });\n        i.updateTransitions(o);\n      }\n      _force3DLayerUpdate() {\n        for (const e in this._layers) {\n          const t = this._layers[e];\n          \"fill-extrusion\" === t.type && this._updateLayer(t);\n        }\n      }\n      _forceSymbolLayerUpdate() {\n        for (const e in this._layers) {\n          const t = this._layers[e];\n          \"symbol\" === t.type && this._updateLayer(t);\n        }\n      }\n      _validate(t, i, o, r, n = {}) {\n        return (!n || !1 !== n.validate) && Xt(this, t.call(e.validateStyle, e.extend({\n          key: i,\n          style: this.serialize(),\n          value: o,\n          styleSpec: e.spec\n        }, r)));\n      }\n      _remove() {\n        this._request && (this._request.cancel(), this._request = null), this._spriteRequest && (this._spriteRequest.cancel(), this._spriteRequest = null), e.evented.off(\"pluginStateChange\", this._rtlTextPluginCallback);\n        for (const e in this._layers) this._layers[e].setEventedParent(null);\n        for (const e in this._sourceCaches) this._sourceCaches[e].clearTiles(), this._sourceCaches[e].setEventedParent(null);\n        this.imageManager.setEventedParent(null), this.setEventedParent(null), this.dispatcher.remove();\n      }\n      _clearSource(e) {\n        const t = this._getSourceCaches(e);\n        for (const e of t) e.clearTiles();\n      }\n      _reloadSource(e) {\n        const t = this._getSourceCaches(e);\n        for (const e of t) e.resume(), e.reload();\n      }\n      _reloadSources() {\n        for (const e of this._getSources()) e.reload && e.reload();\n      }\n      _updateSources(e) {\n        for (const t in this._sourceCaches) this._sourceCaches[t].update(e);\n      }\n      _generateCollisionBoxes() {\n        for (const e in this._sourceCaches) {\n          const t = this._sourceCaches[e];\n          t.resume(), t.reload();\n        }\n      }\n      _updatePlacement(t, i, o, r, n = !1) {\n        let s = !1,\n          a = !1;\n        const l = {};\n        for (const e of this._order) {\n          const i = this._layers[e];\n          if (\"symbol\" !== i.type) continue;\n          if (!l[i.source]) {\n            const e = this._getLayerSourceCache(i);\n            if (!e) continue;\n            l[i.source] = e.getRenderableIds(!0).map(t => e.getTileByID(t)).sort((e, t) => t.tileID.overscaledZ - e.tileID.overscaledZ || (e.tileID.isLessThan(t.tileID) ? -1 : 1));\n          }\n          const o = this.crossTileSymbolIndex.addLayer(i, l[i.source], t.center.lng, t.projection);\n          s = s || o;\n        }\n        if (this.crossTileSymbolIndex.pruneUnusedLayers(this._order), n = n || this._layerOrderChanged || 0 === o, this._layerOrderChanged && this.fire(new e.Event(\"neworder\")), (n || !this.pauseablePlacement || this.pauseablePlacement.isDone() && !this.placement.stillRecent(e.exported.now(), t.zoom)) && (this.pauseablePlacement = new Nt(t, this._order, n, i, o, r, this.placement, this.fog && t.projection.supportsFog ? this.fog.state : null), this._layerOrderChanged = !1), this.pauseablePlacement.isDone() ? this.placement.setStale() : (this.pauseablePlacement.continuePlacement(this._order, this._layers, l), this.pauseablePlacement.isDone() && (this.placement = this.pauseablePlacement.commit(e.exported.now()), a = !0), s && this.pauseablePlacement.placement.setStale()), a || s) for (const e of this._order) {\n          const t = this._layers[e];\n          \"symbol\" === t.type && this.placement.updateLayerOpacities(t, l[t.source]);\n        }\n        return !this.pauseablePlacement.isDone() || this.placement.hasTransitions(e.exported.now());\n      }\n      _releaseSymbolFadeTiles() {\n        for (const e in this._sourceCaches) this._sourceCaches[e].releaseSymbolFadeTiles();\n      }\n      getImages(e, t, i) {\n        this.imageManager.getImages(t.icons, i), this._updateTilesForChangedImages();\n        const o = e => {\n          e && e.setDependencies(t.tileID.key, t.type, t.icons);\n        };\n        o(this._otherSourceCaches[t.source]), o(this._symbolSourceCaches[t.source]);\n      }\n      getGlyphs(e, t, i) {\n        this.glyphManager.getGlyphs(t.stacks, i);\n      }\n      getResource(t, i, o) {\n        return e.makeRequest(i, o);\n      }\n      _getSourceCache(e) {\n        return this._otherSourceCaches[e];\n      }\n      _getLayerSourceCache(e) {\n        return \"symbol\" === e.type ? this._symbolSourceCaches[e.source] : this._otherSourceCaches[e.source];\n      }\n      _getSourceCaches(e) {\n        const t = [];\n        return this._otherSourceCaches[e] && t.push(this._otherSourceCaches[e]), this._symbolSourceCaches[e] && t.push(this._symbolSourceCaches[e]), t;\n      }\n      _isSourceCacheLoaded(t) {\n        const i = this._getSourceCaches(t);\n        return 0 === i.length ? (this.fire(new e.ErrorEvent(new Error(`There is no source with ID '${t}'`))), !1) : i.every(e => e.loaded());\n      }\n      has3DLayers() {\n        return this._num3DLayers > 0;\n      }\n      hasSymbolLayers() {\n        return this._numSymbolLayers > 0;\n      }\n      hasCircleLayers() {\n        return this._numCircleLayers > 0;\n      }\n      _clearWorkerCaches() {\n        this.dispatcher.broadcast(\"clearCaches\");\n      }\n      destroy() {\n        this._clearWorkerCaches(), this.terrainSetForDrapingOnly() && (delete this.terrain, delete this.stylesheet.terrain);\n      }\n    }\n    Kt.getSourceType = function (e) {\n      return Se[e];\n    }, Kt.setSourceType = function (e, t) {\n      Se[e] = t;\n    }, Kt.registerForPluginStateChange = e.registerForPluginStateChange;\n    var Jt = \"\\n#define EPSILON 0.0000001\\n#define PI 3.141592653589793\\n#define EXTENT 8192.0\\n#define HALF_PI PI/2.0\\n#define QUARTER_PI PI/4.0\\n#define RAD_TO_DEG 180.0/PI\\n#define DEG_TO_RAD PI/180.0\\n#define GLOBE_RADIUS EXTENT/PI/2.0\",\n      Qt = \"attribute highp vec3 a_pos_3f;uniform lowp mat4 u_matrix;varying highp vec3 v_uv;void main() {const mat3 half_neg_pi_around_x=mat3(1.0,0.0, 0.0,0.0,0.0,-1.0,0.0,1.0, 0.0);v_uv=half_neg_pi_around_x*a_pos_3f;vec4 pos=u_matrix*vec4(a_pos_3f,1.0);gl_Position=pos.xyww;}\",\n      ei = \"\\n#define ELEVATION_SCALE 7.0\\n#define ELEVATION_OFFSET 450.0\\n#ifdef PROJECTION_GLOBE_VIEW\\nuniform vec3 u_tile_tl_up;uniform vec3 u_tile_tr_up;uniform vec3 u_tile_br_up;uniform vec3 u_tile_bl_up;uniform float u_tile_up_scale;vec3 elevationVector(vec2 pos) {vec2 uv=pos/EXTENT;vec3 up=normalize(mix(\\nmix(u_tile_tl_up,u_tile_tr_up,uv.xxx),mix(u_tile_bl_up,u_tile_br_up,uv.xxx),uv.yyy));return up*u_tile_up_scale;}\\n#else\\nvec3 elevationVector(vec2 pos) { return vec3(0,0,1); }\\n#endif\\nconst float skirtOffset=24575.0;vec3 decomposeToPosAndSkirt(vec2 posWithComposedSkirt)\\n{float skirt=float(posWithComposedSkirt.x >=skirtOffset);vec2 pos=posWithComposedSkirt-vec2(skirt*skirtOffset,0.0);return vec3(pos,skirt);}\\n#ifdef TERRAIN\\n#ifdef TERRAIN_DEM_FLOAT_FORMAT\\nuniform highp sampler2D u_dem;uniform highp sampler2D u_dem_prev;\\n#else\\nuniform sampler2D u_dem;uniform sampler2D u_dem_prev;\\n#endif\\nuniform vec4 u_dem_unpack;uniform vec2 u_dem_tl;uniform vec2 u_dem_tl_prev;uniform float u_dem_scale;uniform float u_dem_scale_prev;uniform float u_dem_size;uniform float u_dem_lerp;uniform float u_exaggeration;uniform float u_meter_to_dem;uniform mat4 u_label_plane_matrix_inv;uniform sampler2D u_depth;uniform vec2 u_depth_size_inv;vec4 tileUvToDemSample(vec2 uv,float dem_size,float dem_scale,vec2 dem_tl) {vec2 pos=dem_size*(uv*dem_scale+dem_tl)+1.0;vec2 f=fract(pos);return vec4((pos-f+0.5)/(dem_size+2.0),f);}float decodeElevation(vec4 v) {return dot(vec4(v.xyz*255.0,-1.0),u_dem_unpack);}float currentElevation(vec2 apos) {\\n#ifdef TERRAIN_DEM_FLOAT_FORMAT\\nvec2 pos=(u_dem_size*(apos/8192.0*u_dem_scale+u_dem_tl)+1.5)/(u_dem_size+2.0);return u_exaggeration*texture2D(u_dem,pos).a;\\n#else\\nfloat dd=1.0/(u_dem_size+2.0);vec4 r=tileUvToDemSample(apos/8192.0,u_dem_size,u_dem_scale,u_dem_tl);vec2 pos=r.xy;vec2 f=r.zw;float tl=decodeElevation(texture2D(u_dem,pos));\\n#ifdef TERRAIN_DEM_NEAREST_FILTER\\nreturn u_exaggeration*tl;\\n#endif\\nfloat tr=decodeElevation(texture2D(u_dem,pos+vec2(dd,0.0)));float bl=decodeElevation(texture2D(u_dem,pos+vec2(0.0,dd)));float br=decodeElevation(texture2D(u_dem,pos+vec2(dd,dd)));return u_exaggeration*mix(mix(tl,tr,f.x),mix(bl,br,f.x),f.y);\\n#endif\\n}float prevElevation(vec2 apos) {\\n#ifdef TERRAIN_DEM_FLOAT_FORMAT\\nvec2 pos=(u_dem_size*(apos/8192.0*u_dem_scale_prev+u_dem_tl_prev)+1.5)/(u_dem_size+2.0);return u_exaggeration*texture2D(u_dem_prev,pos).a;\\n#else\\nfloat dd=1.0/(u_dem_size+2.0);vec4 r=tileUvToDemSample(apos/8192.0,u_dem_size,u_dem_scale_prev,u_dem_tl_prev);vec2 pos=r.xy;vec2 f=r.zw;float tl=decodeElevation(texture2D(u_dem_prev,pos));float tr=decodeElevation(texture2D(u_dem_prev,pos+vec2(dd,0.0)));float bl=decodeElevation(texture2D(u_dem_prev,pos+vec2(0.0,dd)));float br=decodeElevation(texture2D(u_dem_prev,pos+vec2(dd,dd)));return u_exaggeration*mix(mix(tl,tr,f.x),mix(bl,br,f.x),f.y);\\n#endif\\n}\\n#ifdef TERRAIN_VERTEX_MORPHING\\nfloat elevation(vec2 apos) {\\n#ifdef ZERO_EXAGGERATION\\nreturn 0.0;\\n#endif\\nfloat nextElevation=currentElevation(apos);float prevElevation=prevElevation(apos);return mix(prevElevation,nextElevation,u_dem_lerp);}\\n#else\\nfloat elevation(vec2 apos) {\\n#ifdef ZERO_EXAGGERATION\\nreturn 0.0;\\n#endif\\nreturn currentElevation(apos);}\\n#endif\\nhighp float unpack_depth(highp vec4 rgba_depth)\\n{const highp vec4 bit_shift=vec4(1.0/(255.0*255.0*255.0),1.0/(255.0*255.0),1.0/255.0,1.0);return dot(rgba_depth,bit_shift)*2.0-1.0;}bool isOccluded(vec4 frag) {vec3 coord=frag.xyz/frag.w;float depth=unpack_depth(texture2D(u_depth,(coord.xy+1.0)*0.5));return coord.z > depth+0.0005;}float occlusionFade(vec4 frag) {vec3 coord=frag.xyz/frag.w;vec3 df=vec3(5.0*u_depth_size_inv,0.0);vec2 uv=0.5*coord.xy+0.5;vec4 depth=vec4(\\nunpack_depth(texture2D(u_depth,uv-df.xz)),unpack_depth(texture2D(u_depth,uv+df.xz)),unpack_depth(texture2D(u_depth,uv-df.zy)),unpack_depth(texture2D(u_depth,uv+df.zy))\\n);return dot(vec4(0.25),vec4(1.0)-clamp(300.0*(vec4(coord.z-0.001)-depth),0.0,1.0));}vec4 fourSample(vec2 pos,vec2 off) {\\n#ifdef TERRAIN_DEM_FLOAT_FORMAT\\nfloat tl=texture2D(u_dem,pos).a;float tr=texture2D(u_dem,pos+vec2(off.x,0.0)).a;float bl=texture2D(u_dem,pos+vec2(0.0,off.y)).a;float br=texture2D(u_dem,pos+off).a;\\n#else\\nvec4 demtl=vec4(texture2D(u_dem,pos).xyz*255.0,-1.0);float tl=dot(demtl,u_dem_unpack);vec4 demtr=vec4(texture2D(u_dem,pos+vec2(off.x,0.0)).xyz*255.0,-1.0);float tr=dot(demtr,u_dem_unpack);vec4 dembl=vec4(texture2D(u_dem,pos+vec2(0.0,off.y)).xyz*255.0,-1.0);float bl=dot(dembl,u_dem_unpack);vec4 dembr=vec4(texture2D(u_dem,pos+off).xyz*255.0,-1.0);float br=dot(dembr,u_dem_unpack);\\n#endif\\nreturn vec4(tl,tr,bl,br);}float flatElevation(vec2 pack) {vec2 apos=floor(pack/8.0);vec2 span=10.0*(pack-apos*8.0);vec2 uvTex=(apos-vec2(1.0,1.0))/8190.0;float size=u_dem_size+2.0;float dd=1.0/size;vec2 pos=u_dem_size*(uvTex*u_dem_scale+u_dem_tl)+1.0;vec2 f=fract(pos);pos=(pos-f+0.5)*dd;vec4 h=fourSample(pos,vec2(dd));float z=mix(mix(h.x,h.y,f.x),mix(h.z,h.w,f.x),f.y);vec2 w=floor(0.5*(span*u_meter_to_dem-1.0));vec2 d=dd*w;h=fourSample(pos-d,2.0*d+vec2(dd));vec4 diff=abs(h.xzxy-h.ywzw);vec2 slope=min(vec2(0.25),u_meter_to_dem*0.5*(diff.xz+diff.yw)/(2.0*w+vec2(1.0)));vec2 fix=slope*span;float base=z+max(fix.x,fix.y);return u_exaggeration*base;}float elevationFromUint16(float word) {return u_exaggeration*(word/ELEVATION_SCALE-ELEVATION_OFFSET);}\\n#else\\nfloat elevation(vec2 pos) { return 0.0; }bool isOccluded(vec4 frag) { return false; }float occlusionFade(vec4 frag) { return 1.0; }\\n#endif\",\n      ti = \"#ifdef FOG\\nuniform mediump vec4 u_fog_color;uniform mediump vec2 u_fog_range;uniform mediump float u_fog_horizon_blend;uniform mediump mat4 u_fog_matrix;varying vec3 v_fog_pos;float fog_range(float depth) {return (depth-u_fog_range[0])/(u_fog_range[1]-u_fog_range[0]);}float fog_horizon_blending(vec3 camera_dir) {float t=max(0.0,camera_dir.z/u_fog_horizon_blend);return u_fog_color.a*exp(-3.0*t*t);}float fog_opacity(float t) {const float decay=6.0;float falloff=1.0-min(1.0,exp(-decay*t));falloff*=falloff*falloff;return u_fog_color.a*min(1.0,1.00747*falloff);}vec3 fog_position(vec3 pos) {return (u_fog_matrix*vec4(pos,1.0)).xyz;}vec3 fog_position(vec2 pos) {return fog_position(vec3(pos,0.0));}float fog(vec3 pos) {float depth=length(pos);float opacity=fog_opacity(fog_range(depth));return opacity*fog_horizon_blending(pos/depth);}\\n#endif\",\n      ii = \"#ifdef FOG\\nuniform mediump vec4 u_fog_color;uniform mediump vec2 u_fog_range;uniform mediump float u_fog_horizon_blend;uniform mediump float u_fog_temporal_offset;varying vec3 v_fog_pos;uniform highp vec3 u_frustum_tl;uniform highp vec3 u_frustum_tr;uniform highp vec3 u_frustum_br;uniform highp vec3 u_frustum_bl;uniform highp vec3 u_globe_pos;uniform highp float u_globe_radius;uniform highp vec2 u_viewport;uniform float u_globe_transition;uniform int u_is_globe;float fog_range(float depth) {return (depth-u_fog_range[0])/(u_fog_range[1]-u_fog_range[0]);}float fog_horizon_blending(vec3 camera_dir) {float t=max(0.0,camera_dir.z/u_fog_horizon_blend);return u_fog_color.a*exp(-3.0*t*t);}float fog_opacity(float t) {const float decay=6.0;float falloff=1.0-min(1.0,exp(-decay*t));falloff*=falloff*falloff;return u_fog_color.a*min(1.0,1.00747*falloff);}float globe_glow_progress() {highp vec2 uv=gl_FragCoord.xy/u_viewport;highp vec3 ray_dir=mix(\\nmix(u_frustum_tl,u_frustum_tr,uv.x),mix(u_frustum_bl,u_frustum_br,uv.x),1.0-uv.y);highp vec3 dir=normalize(ray_dir);highp vec3 closest_point=dot(u_globe_pos,dir)*dir;highp float sdf=length(closest_point-u_globe_pos)/u_globe_radius;return sdf+PI*0.5;}float fog_opacity(vec3 pos) {float depth=length(pos);return fog_opacity(fog_range(depth));}vec3 fog_apply(vec3 color,vec3 pos) {float depth=length(pos);float opacity;if (u_is_globe==1) {float glow_progress=globe_glow_progress();float t=mix(glow_progress,depth,u_globe_transition);opacity=fog_opacity(fog_range(t));} else {opacity=fog_opacity(fog_range(depth));opacity*=fog_horizon_blending(pos/depth);}return mix(color,u_fog_color.rgb,opacity);}vec4 fog_apply_from_vert(vec4 color,float fog_opac) {float alpha=EPSILON+color.a;color.rgb=mix(color.rgb/alpha,u_fog_color.rgb,fog_opac)*alpha;return color;}vec3 fog_apply_sky_gradient(vec3 camera_ray,vec3 sky_color) {float horizon_blend=fog_horizon_blending(normalize(camera_ray));return mix(sky_color,u_fog_color.rgb,horizon_blend);}vec4 fog_apply_premultiplied(vec4 color,vec3 pos) {float alpha=EPSILON+color.a;color.rgb=fog_apply(color.rgb/alpha,pos)*alpha;return color;}vec3 fog_dither(vec3 color) {vec2 dither_seed=gl_FragCoord.xy+u_fog_temporal_offset;return dither(color,dither_seed);}vec4 fog_dither(vec4 color) {return vec4(fog_dither(color.rgb),color.a);}\\n#endif\";\n    let oi = {},\n      ri = {};\n    const ni = [];\n    hi(Jt, ni), hi(ei, ni), hi(ti, ni), hi(ii, ni), oi = ui(\"\", ei), ri = ui(ii, ti);\n    const si = ui(\"\\n#if __VERSION__ >=300\\n#define varying in\\n#define gl_FragColor glFragColor\\n#define texture2D texture\\n#define textureCube texture\\nout vec4 glFragColor;\\n#endif\\nhighp vec3 hash(highp vec2 p) {highp vec3 p3=fract(p.xyx*vec3(443.8975,397.2973,491.1871));p3+=dot(p3,p3.yxz+19.19);return fract((p3.xxy+p3.yzz)*p3.zyx);}vec3 dither(vec3 color,highp vec2 seed) {vec3 rnd=hash(seed)+hash(seed+0.59374)-0.5;return color+rnd/255.0;}highp float unpack_depth(highp vec4 rgba_depth)\\n{const highp vec4 bit_shift=vec4(1.0/(255.0*255.0*255.0),1.0/(255.0*255.0),1.0/255.0,1.0);return dot(rgba_depth,bit_shift)*2.0-1.0;}highp vec4 pack_depth(highp float ndc_z) {highp float depth=ndc_z*0.5+0.5;const highp vec4 bit_shift=vec4(255.0*255.0*255.0,255.0*255.0,255.0,1.0);const highp vec4 bit_mask =vec4(0.0,1.0/255.0,1.0/255.0,1.0/255.0);highp vec4 res=fract(depth*bit_shift);res-=res.xxyz*bit_mask;return res;}\", \"\\n#if __VERSION__ >=300\\n#define attribute in\\n#define varying out\\n#define texture2D texture\\n#endif\\nfloat wrap(float n,float min,float max) {float d=max-min;float w=mod(mod(n-min,d)+d,d)+min;return (w==min) ? max : w;}\\n#ifdef PROJECTION_GLOBE_VIEW\\nvec3 mercator_tile_position(mat4 matrix,vec2 tile_anchor,vec3 tile_id,vec2 mercator_center) {\\n#ifndef PROJECTED_POS_ON_VIEWPORT\\nfloat tiles=tile_id.z;vec2 mercator=(tile_anchor/EXTENT+tile_id.xy)/tiles;mercator-=mercator_center;mercator.x=wrap(mercator.x,-0.5,0.5);vec4 mercator_tile=vec4(mercator.xy*EXTENT,EXTENT/(2.0*PI),1.0);mercator_tile=matrix*mercator_tile;return mercator_tile.xyz;\\n#else\\nreturn vec3(0.0);\\n#endif\\n}vec3 mix_globe_mercator(vec3 globe,vec3 mercator,float t) {return mix(globe,mercator,t);}mat3 globe_mercator_surface_vectors(vec3 pos_normal,vec3 up_dir,float zoom_transition) {vec3 normal=zoom_transition==0.0 ? pos_normal : normalize(mix(pos_normal,up_dir,zoom_transition));vec3 xAxis=normalize(vec3(normal.z,0.0,-normal.x));vec3 yAxis=normalize(cross(normal,xAxis));return mat3(xAxis,yAxis,normal);}\\n#endif\\nvec2 unpack_float(const float packedValue) {int packedIntValue=int(packedValue);int v0=packedIntValue/256;return vec2(v0,packedIntValue-v0*256);}vec2 unpack_opacity(const float packedOpacity) {int intOpacity=int(packedOpacity)/2;return vec2(float(intOpacity)/127.0,mod(packedOpacity,2.0));}vec4 decode_color(const vec2 encodedColor) {return vec4(\\nunpack_float(encodedColor[0])/255.0,unpack_float(encodedColor[1])/255.0\\n);}float unpack_mix_vec2(const vec2 packedValue,const float t) {return mix(packedValue[0],packedValue[1],t);}vec4 unpack_mix_color(const vec4 packedColors,const float t) {vec4 minColor=decode_color(vec2(packedColors[0],packedColors[1]));vec4 maxColor=decode_color(vec2(packedColors[2],packedColors[3]));return mix(minColor,maxColor,t);}vec2 get_pattern_pos(const vec2 pixel_coord_upper,const vec2 pixel_coord_lower,const vec2 pattern_size,const float tile_units_to_pixels,const vec2 pos) {vec2 offset=mod(mod(mod(pixel_coord_upper,pattern_size)*256.0,pattern_size)*256.0+pixel_coord_lower,pattern_size);return (tile_units_to_pixels*pos+offset)/pattern_size;}const vec4 AWAY=vec4(-1000.0,-1000.0,-1000.0,1);//Normalized device coordinate that is not rendered.\"),\n      ai = Jt,\n      li = \"\\n#ifdef GL_ES\\nprecision mediump float;\\n#else\\n\\n#if !defined(lowp)\\n#define lowp\\n#endif\\n\\n#if !defined(mediump)\\n#define mediump\\n#endif\\n\\n#if !defined(highp)\\n#define highp\\n#endif\\n\\n#endif\";\n    var ci = {\n      background: ui(\"uniform vec4 u_color;uniform float u_opacity;\\n#ifdef LIGHTING_3D_MODE\\nvarying vec4 v_color;\\n#endif\\nvoid main() {vec4 out_color;\\n#ifdef LIGHTING_3D_MODE\\nout_color=v_color;\\n#else\\nout_color=u_color;\\n#endif\\n#ifdef FOG\\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\\n#endif\\ngl_FragColor=out_color*u_opacity;\\n#ifdef OVERDRAW_INSPECTOR\\ngl_FragColor=vec4(1.0);\\n#endif\\n}\", \"attribute vec2 a_pos;uniform mat4 u_matrix;\\n#ifdef LIGHTING_3D_MODE\\nuniform vec4 u_color;varying vec4 v_color;\\n#endif\\nvoid main() {gl_Position=u_matrix*vec4(a_pos,0,1);\\n#ifdef LIGHTING_3D_MODE\\nv_color=apply_lighting(u_color);\\n#endif\\n#ifdef FOG\\nv_fog_pos=fog_position(a_pos);\\n#endif\\n}\"),\n      backgroundPattern: ui(\"uniform vec2 u_pattern_tl;uniform vec2 u_pattern_br;uniform vec2 u_texsize;uniform float u_opacity;uniform sampler2D u_image;varying vec2 v_pos;void main() {vec2 imagecoord=mod(v_pos,1.0);vec2 pos=mix(u_pattern_tl/u_texsize,u_pattern_br/u_texsize,imagecoord);vec4 out_color=texture2D(u_image,pos);\\n#ifdef LIGHTING_3D_MODE\\nout_color=apply_lighting(out_color);\\n#endif\\n#ifdef FOG\\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\\n#endif\\ngl_FragColor=out_color*u_opacity;\\n#ifdef OVERDRAW_INSPECTOR\\ngl_FragColor=vec4(1.0);\\n#endif\\n}\", \"uniform mat4 u_matrix;uniform vec2 u_pattern_size;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_tile_units_to_pixels;attribute vec2 a_pos;varying vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_pattern_size,u_tile_units_to_pixels,a_pos);\\n#ifdef FOG\\nv_fog_pos=fog_position(a_pos);\\n#endif\\n}\"),\n      circle: ui(\"varying vec3 v_data;varying float v_visibility;\\n#pragma mapbox: define highp vec4 color\\n#pragma mapbox: define mediump float radius\\n#pragma mapbox: define lowp float blur\\n#pragma mapbox: define lowp float opacity\\n#pragma mapbox: define highp vec4 stroke_color\\n#pragma mapbox: define mediump float stroke_width\\n#pragma mapbox: define lowp float stroke_opacity\\nvoid main() {\\n#pragma mapbox: initialize highp vec4 color\\n#pragma mapbox: initialize mediump float radius\\n#pragma mapbox: initialize lowp float blur\\n#pragma mapbox: initialize lowp float opacity\\n#pragma mapbox: initialize highp vec4 stroke_color\\n#pragma mapbox: initialize mediump float stroke_width\\n#pragma mapbox: initialize lowp float stroke_opacity\\nvec2 extrude=v_data.xy;float extrude_length=length(extrude);lowp float antialiasblur=v_data.z;float antialiased_blur=-max(blur,antialiasblur);float opacity_t=smoothstep(0.0,antialiased_blur,extrude_length-1.0);float color_t=stroke_width < 0.01 ? 0.0 : smoothstep(\\nantialiased_blur,0.0,extrude_length-radius/(radius+stroke_width)\\n);vec4 out_color=mix(color*opacity,stroke_color*stroke_opacity,color_t);\\n#ifdef LIGHTING_3D_MODE\\nout_color=apply_lighting(out_color);\\n#endif\\n#ifdef FOG\\nout_color=fog_apply_premultiplied(out_color,v_fog_pos);\\n#endif\\ngl_FragColor=out_color*(v_visibility*opacity_t);\\n#ifdef OVERDRAW_INSPECTOR\\ngl_FragColor=vec4(1.0);\\n#endif\\n}\", \"#define NUM_VISIBILITY_RINGS 2\\n#define INV_SQRT2 0.70710678\\n#define ELEVATION_BIAS 0.0001\\n#define NUM_SAMPLES_PER_RING 16\\nuniform mat4 u_matrix;uniform mat2 u_extrude_scale;uniform lowp float u_device_pixel_ratio;uniform highp float u_camera_to_center_distance;attribute vec2 a_pos;\\n#ifdef PROJECTION_GLOBE_VIEW\\nattribute vec3 a_pos_3;attribute vec3 a_pos_normal_3;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_tile_id;uniform float u_zoom_transition;uniform vec3 u_up_dir;\\n#endif\\nvarying vec3 v_data;varying float v_visibility;\\n#pragma mapbox: define highp vec4 color\\n#pragma mapbox: define mediump float radius\\n#pragma mapbox: define lowp float blur\\n#pragma mapbox: define lowp float opacity\\n#pragma mapbox: define highp vec4 stroke_color\\n#pragma mapbox: define mediump float stroke_width\\n#pragma mapbox: define lowp float stroke_opacity\\nvec2 calc_offset(vec2 extrusion,float radius,float stroke_width, float view_scale) {return extrusion*(radius+stroke_width)*u_extrude_scale*view_scale;}float cantilevered_elevation(vec2 pos,float radius,float stroke_width,float view_scale) {vec2 c1=pos+calc_offset(vec2(-1,-1),radius,stroke_width,view_scale);vec2 c2=pos+calc_offset(vec2(1,-1),radius,stroke_width,view_scale);vec2 c3=pos+calc_offset(vec2(1,1),radius,stroke_width,view_scale);vec2 c4=pos+calc_offset(vec2(-1,1),radius,stroke_width,view_scale);float h1=elevation(c1)+ELEVATION_BIAS;float h2=elevation(c2)+ELEVATION_BIAS;float h3=elevation(c3)+ELEVATION_BIAS;float h4=elevation(c4)+ELEVATION_BIAS;return max(h4,max(h3,max(h1,h2)));}float circle_elevation(vec2 pos) {\\n#if defined(TERRAIN)\\nreturn elevation(pos)+ELEVATION_BIAS;\\n#else\\nreturn 0.0;\\n#endif\\n}vec4 project_vertex(vec2 extrusion,vec4 world_center,vec4 projected_center,float radius,float stroke_width, float view_scale,mat3 surface_vectors) {vec2 sample_offset=calc_offset(extrusion,radius,stroke_width,view_scale);\\n#ifdef PITCH_WITH_MAP\\n#ifdef PROJECTION_GLOBE_VIEW\\nreturn u_matrix*( world_center+vec4(sample_offset.x*surface_vectors[0]+sample_offset.y*surface_vectors[1],0) );\\n#else\\nreturn u_matrix*( world_center+vec4(sample_offset,0,0) );\\n#endif\\n#else\\nreturn projected_center+vec4(sample_offset,0,0);\\n#endif\\n}float get_sample_step() {\\n#ifdef PITCH_WITH_MAP\\nreturn 2.0*PI/float(NUM_SAMPLES_PER_RING);\\n#else\\nreturn PI/float(NUM_SAMPLES_PER_RING);\\n#endif\\n}void main(void) {\\n#pragma mapbox: initialize highp vec4 color\\n#pragma mapbox: initialize mediump float radius\\n#pragma mapbox: initialize lowp float blur\\n#pragma mapbox: initialize lowp float opacity\\n#pragma mapbox: initialize highp vec4 stroke_color\\n#pragma mapbox: initialize mediump float stroke_width\\n#pragma mapbox: initialize lowp float stroke_opacity\\nvec2 extrude=vec2(mod(a_pos,2.0)*2.0-1.0);vec2 circle_center=floor(a_pos*0.5);vec4 world_center;mat3 surface_vectors;\\n#ifdef PROJECTION_GLOBE_VIEW\\nvec3 pos_normal_3=a_pos_normal_3/16384.0;surface_vectors=globe_mercator_surface_vectors(pos_normal_3,u_up_dir,u_zoom_transition);vec3 surface_extrusion=extrude.x*surface_vectors[0]+extrude.y*surface_vectors[1];vec3 globe_elevation=elevationVector(circle_center)*circle_elevation(circle_center);vec3 globe_pos=a_pos_3+surface_extrusion+globe_elevation;vec3 mercator_elevation=u_up_dir*u_tile_up_scale*circle_elevation(circle_center);vec3 merc_pos=mercator_tile_position(u_inv_rot_matrix,circle_center,u_tile_id,u_merc_center)+surface_extrusion+mercator_elevation;vec3 pos=mix_globe_mercator(globe_pos,merc_pos,u_zoom_transition);world_center=vec4(pos,1);\\n#else \\nsurface_vectors=mat3(1.0);float height=circle_elevation(circle_center);world_center=vec4(circle_center,height,1);\\n#endif\\nvec4 projected_center=u_matrix*world_center;float view_scale=0.0;\\n#ifdef PITCH_WITH_MAP\\n#ifdef SCALE_WITH_MAP\\nview_scale=1.0;\\n#else\\nview_scale=projected_center.w/u_camera_to_center_distance;\\n#endif\\n#else\\n#ifdef SCALE_WITH_MAP\\nview_scale=u_camera_to_center_distance;\\n#else\\nview_scale=projected_center.w;\\n#endif\\n#endif\\ngl_Position=project_vertex(extrude,world_center,projected_center,radius,stroke_width,view_scale,surface_vectors);float visibility=0.0;\\n#ifdef TERRAIN\\nfloat step=get_sample_step();vec4 occlusion_world_center;vec4 occlusion_projected_center;\\n#ifdef PITCH_WITH_MAP\\nfloat cantilevered_height=cantilevered_elevation(circle_center,radius,stroke_width,view_scale);occlusion_world_center=vec4(circle_center,cantilevered_height,1);occlusion_projected_center=u_matrix*occlusion_world_center;\\n#else\\nocclusion_world_center=world_center;occlusion_projected_center=projected_center;\\n#endif\\nfor(int ring=0; ring < NUM_VISIBILITY_RINGS; ring++) {float scale=(float(ring)+1.0)/float(NUM_VISIBILITY_RINGS);for(int i=0; i < NUM_SAMPLES_PER_RING; i++) {vec2 extrusion=vec2(cos(step*float(i)),-sin(step*float(i)))*scale;vec4 frag_pos=project_vertex(extrusion,occlusion_world_center,occlusion_projected_center,radius,stroke_width,view_scale,surface_vectors);visibility+=float(!isOccluded(frag_pos));}}visibility/=float(NUM_VISIBILITY_RINGS)*float(NUM_SAMPLES_PER_RING);\\n#else\\nvisibility=1.0;\\n#endif\\n#ifdef PROJECTION_GLOBE_VIEW\\nvisibility=1.0;\\n#endif\\nv_visibility=visibility;lowp float antialiasblur=1.0/u_device_pixel_ratio/(radius+stroke_width);v_data=vec3(extrude.x,extrude.y,antialiasblur);\\n#ifdef FOG\\nv_fog_pos=fog_position(world_center.xyz);\\n#endif\\n}\"),\n      clippingMask: ui(\"void main() {gl_FragColor=vec4(1.0);}\", \"attribute vec2 a_pos;uniform mat4 u_matrix;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);}\"),\n      heatmap: ui(\"uniform highp float u_intensity;varying vec2 v_extrude;\\n#pragma mapbox: define highp float weight\\n#define GAUSS_COEF 0.3989422804014327\\nvoid main() {\\n#pragma mapbox: initialize highp float weight\\nfloat d=-0.5*3.0*3.0*dot(v_extrude,v_extrude);float val=weight*u_intensity*GAUSS_COEF*exp(d);gl_FragColor=vec4(val,1.0,1.0,1.0);\\n#ifdef FOG\\nif (u_is_globe==0) {gl_FragColor.r*=pow(1.0-fog_opacity(v_fog_pos),2.0);}\\n#endif\\n#ifdef OVERDRAW_INSPECTOR\\ngl_FragColor=vec4(1.0);\\n#endif\\n}\", \"uniform mat4 u_matrix;uniform float u_extrude_scale;uniform float u_opacity;uniform float u_intensity;attribute vec2 a_pos;\\n#ifdef PROJECTION_GLOBE_VIEW\\nattribute vec3 a_pos_3;attribute vec3 a_pos_normal_3;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_tile_id;uniform float u_zoom_transition;uniform vec3 u_up_dir;\\n#endif\\nvarying vec2 v_extrude;\\n#pragma mapbox: define highp float weight\\n#pragma mapbox: define mediump float radius\\nconst highp float ZERO=1.0/255.0/16.0;\\n#define GAUSS_COEF 0.3989422804014327\\nvoid main(void) {\\n#pragma mapbox: initialize highp float weight\\n#pragma mapbox: initialize mediump float radius\\nvec2 unscaled_extrude=vec2(mod(a_pos,2.0)*2.0-1.0);float S=sqrt(-2.0*log(ZERO/weight/u_intensity/GAUSS_COEF))/3.0;v_extrude=S*unscaled_extrude;vec2 extrude=v_extrude*radius*u_extrude_scale;vec2 tilePos=floor(a_pos*0.5);vec3 pos;\\n#ifdef PROJECTION_GLOBE_VIEW\\nvec3 pos_normal_3=a_pos_normal_3/16384.0;mat3 surface_vectors=globe_mercator_surface_vectors(pos_normal_3,u_up_dir,u_zoom_transition);vec3 surface_extrusion=extrude.x*surface_vectors[0]+extrude.y*surface_vectors[1];vec3 globe_elevation=elevationVector(tilePos)*elevation(tilePos);vec3 globe_pos=a_pos_3+surface_extrusion+globe_elevation;vec3 mercator_elevation=u_up_dir*u_tile_up_scale*elevation(tilePos);vec3 merc_pos=mercator_tile_position(u_inv_rot_matrix,tilePos,u_tile_id,u_merc_center)+surface_extrusion+mercator_elevation;pos=mix_globe_mercator(globe_pos,merc_pos,u_zoom_transition);\\n#else\\npos=vec3(tilePos+extrude,elevation(tilePos));\\n#endif\\ngl_Position=u_matrix*vec4(pos,1);\\n#ifdef FOG\\nv_fog_pos=fog_position(pos);\\n#endif\\n}\"),\n      heatmapTexture: ui(\"uniform sampler2D u_image;uniform sampler2D u_color_ramp;uniform float u_opacity;varying vec2 v_pos;void main() {float t=texture2D(u_image,v_pos).r;vec4 color=texture2D(u_color_ramp,vec2(t,0.5));gl_FragColor=color*u_opacity;\\n#ifdef OVERDRAW_INSPECTOR\\ngl_FragColor=vec4(0.0);\\n#endif\\n}\", \"attribute vec2 a_pos;varying vec2 v_pos;void main() {gl_Position=vec4(a_pos,0,1);v_pos=a_pos*0.5+0.5;}\"),\n      collisionBox: ui(\"varying float v_placed;varying float v_notUsed;void main() {vec4 red =vec4(1.0,0.0,0.0,1.0);vec4 blue=vec4(0.0,0.0,1.0,0.5);gl_FragColor =mix(red,blue,step(0.5,v_placed))*0.5;gl_FragColor*=mix(1.0,0.1,step(0.5,v_notUsed));}\", \"attribute vec3 a_pos;attribute vec2 a_anchor_pos;attribute vec2 a_extrude;attribute vec2 a_placed;attribute vec2 a_shift;attribute float a_size_scale;attribute vec2 a_padding;uniform mat4 u_matrix;uniform vec2 u_extrude_scale;uniform float u_camera_to_center_distance;varying float v_placed;varying float v_notUsed;void main() {vec4 projectedPoint=u_matrix*vec4(a_pos+elevationVector(a_anchor_pos)*elevation(a_anchor_pos),1);highp float camera_to_anchor_distance=projectedPoint.w;highp float collision_perspective_ratio=clamp(\\n0.5+0.5*(u_camera_to_center_distance/camera_to_anchor_distance),0.0,1.5);gl_Position=projectedPoint;gl_Position.xy+=(a_extrude*a_size_scale+a_shift+a_padding)*u_extrude_scale*gl_Position.w*collision_perspective_ratio;v_placed=a_placed.x;v_notUsed=a_placed.y;}\"),\n      collisionCircle: ui(\"varying float v_radius;varying vec2 v_extrude;varying float v_perspective_ratio;varying float v_collision;void main() {float alpha=0.5*min(v_perspective_ratio,1.0);float stroke_radius=0.9*max(v_perspective_ratio,1.0);float distance_to_center=length(v_extrude);float distance_to_edge=abs(distance_to_center-v_radius);float opacity_t=smoothstep(-stroke_radius,0.0,-distance_to_edge);vec4 color=mix(vec4(0.0,0.0,1.0,0.5),vec4(1.0,0.0,0.0,1.0),v_collision);gl_FragColor=color*alpha*opacity_t;}\", \"attribute vec2 a_pos_2f;attribute float a_radius;attribute vec2 a_flags;uniform mat4 u_matrix;uniform mat4 u_inv_matrix;uniform vec2 u_viewport_size;uniform float u_camera_to_center_distance;varying float v_radius;varying vec2 v_extrude;varying float v_perspective_ratio;varying float v_collision;vec3 toTilePosition(vec2 screenPos) {vec4 rayStart=u_inv_matrix*vec4(screenPos,-1.0,1.0);vec4 rayEnd  =u_inv_matrix*vec4(screenPos, 1.0,1.0);rayStart.xyz/=rayStart.w;rayEnd.xyz  /=rayEnd.w;highp float t=(0.0-rayStart.z)/(rayEnd.z-rayStart.z);return mix(rayStart.xyz,rayEnd.xyz,t);}void main() {vec2 quadCenterPos=a_pos_2f;float radius=a_radius;float collision=a_flags.x;float vertexIdx=a_flags.y;vec2 quadVertexOffset=vec2(\\nmix(-1.0,1.0,float(vertexIdx >=2.0)),mix(-1.0,1.0,float(vertexIdx >=1.0 && vertexIdx <=2.0)));vec2 quadVertexExtent=quadVertexOffset*radius;vec3 tilePos=toTilePosition(quadCenterPos);vec4 clipPos=u_matrix*vec4(tilePos,1.0);highp float camera_to_anchor_distance=clipPos.w;highp float collision_perspective_ratio=clamp(\\n0.5+0.5*(u_camera_to_center_distance/camera_to_anchor_distance),0.0,4.0);float padding_factor=1.2;v_radius=radius;v_extrude=quadVertexExtent*padding_factor;v_perspective_ratio=collision_perspective_ratio;v_collision=collision;gl_Position=vec4(clipPos.xyz/clipPos.w,1.0)+vec4(quadVertexExtent*padding_factor/u_viewport_size*2.0,0.0,0.0);}\"),\n      debug: ui(\"uniform highp vec4 u_color;uniform sampler2D u_overlay;varying vec2 v_uv;void main() {vec4 overlay_color=texture2D(u_overlay,v_uv);gl_FragColor=mix(u_color,overlay_color,overlay_color.a);}\", \"attribute vec2 a_pos;\\n#ifdef PROJECTION_GLOBE_VIEW\\nattribute vec3 a_pos_3;\\n#endif\\nvarying vec2 v_uv;uniform mat4 u_matrix;uniform float u_overlay_scale;void main() {float h=elevation(a_pos);v_uv=a_pos/8192.0;\\n#ifdef PROJECTION_GLOBE_VIEW\\ngl_Position=u_matrix*vec4(a_pos_3+elevationVector(a_pos)*h,1);\\n#else\\ngl_Position=u_matrix*vec4(a_pos*u_overlay_scale,h,1);\\n#endif\\n}\"),\n      fill: ui(\"#pragma mapbox: define highp vec4 color\\n#pragma mapbox: define lowp float opacity\\nvoid main() {\\n#pragma mapbox: initialize highp vec4 color\\n#pragma mapbox: initialize lowp float opacity\\nvec4 out_color=color;\\n#ifdef LIGHTING_3D_MODE\\nout_color=apply_lighting(out_color);\\n#endif\\n#ifdef FOG\\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\\n#endif\\ngl_FragColor=out_color*opacity;\\n#ifdef OVERDRAW_INSPECTOR\\ngl_FragColor=vec4(1.0);\\n#endif\\n}\", \"attribute vec2 a_pos;uniform mat4 u_matrix;\\n#pragma mapbox: define highp vec4 color\\n#pragma mapbox: define lowp float opacity\\nvoid main() {\\n#pragma mapbox: initialize highp vec4 color\\n#pragma mapbox: initialize lowp float opacity\\ngl_Position=u_matrix*vec4(a_pos,0,1);\\n#ifdef FOG\\nv_fog_pos=fog_position(a_pos);\\n#endif\\n}\"),\n      fillOutline: ui(\"varying vec2 v_pos;\\n#pragma mapbox: define highp vec4 outline_color\\n#pragma mapbox: define lowp float opacity\\nvoid main() {\\n#pragma mapbox: initialize highp vec4 outline_color\\n#pragma mapbox: initialize lowp float opacity\\nfloat dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);vec4 out_color=outline_color;\\n#ifdef LIGHTING_3D_MODE\\nout_color=apply_lighting(out_color);\\n#endif\\n#ifdef FOG\\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\\n#endif\\ngl_FragColor=out_color*(alpha*opacity);\\n#ifdef OVERDRAW_INSPECTOR\\ngl_FragColor=vec4(1.0);\\n#endif\\n}\", \"attribute vec2 a_pos;uniform mat4 u_matrix;uniform vec2 u_world;varying vec2 v_pos;\\n#pragma mapbox: define highp vec4 outline_color\\n#pragma mapbox: define lowp float opacity\\nvoid main() {\\n#pragma mapbox: initialize highp vec4 outline_color\\n#pragma mapbox: initialize lowp float opacity\\ngl_Position=u_matrix*vec4(a_pos,0,1);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;\\n#ifdef FOG\\nv_fog_pos=fog_position(a_pos);\\n#endif\\n}\"),\n      fillOutlinePattern: ui(\"uniform vec2 u_texsize;uniform sampler2D u_image;varying vec2 v_pos;varying vec2 v_pos_world;\\n#pragma mapbox: define lowp float opacity\\n#pragma mapbox: define lowp vec4 pattern\\nvoid main() {\\n#pragma mapbox: initialize lowp float opacity\\n#pragma mapbox: initialize mediump vec4 pattern\\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;vec2 imagecoord=mod(v_pos,1.0);vec2 pos=mix(pattern_tl/u_texsize,pattern_br/u_texsize,imagecoord);float dist=length(v_pos_world-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);vec4 out_color=texture2D(u_image,pos);\\n#ifdef LIGHTING_3D_MODE\\nout_color=apply_lighting(out_color);\\n#endif\\n#ifdef FOG\\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\\n#endif\\ngl_FragColor=out_color*(alpha*opacity);\\n#ifdef OVERDRAW_INSPECTOR\\ngl_FragColor=vec4(1.0);\\n#endif\\n}\", \"uniform mat4 u_matrix;uniform vec2 u_world;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_tile_units_to_pixels;attribute vec2 a_pos;varying vec2 v_pos;varying vec2 v_pos_world;\\n#pragma mapbox: define lowp float opacity\\n#pragma mapbox: define lowp vec4 pattern\\n#pragma mapbox: define lowp float pixel_ratio\\nvoid main() {\\n#pragma mapbox: initialize lowp float opacity\\n#pragma mapbox: initialize mediump vec4 pattern\\n#pragma mapbox: initialize lowp float pixel_ratio\\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;gl_Position=u_matrix*vec4(a_pos,0,1);vec2 display_size=(pattern_br-pattern_tl)/pixel_ratio;v_pos=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,display_size,u_tile_units_to_pixels,a_pos);v_pos_world=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;\\n#ifdef FOG\\nv_fog_pos=fog_position(a_pos);\\n#endif\\n}\"),\n      fillPattern: ui(\"uniform vec2 u_texsize;uniform sampler2D u_image;varying vec2 v_pos;\\n#pragma mapbox: define lowp float opacity\\n#pragma mapbox: define lowp vec4 pattern\\nvoid main() {\\n#pragma mapbox: initialize lowp float opacity\\n#pragma mapbox: initialize mediump vec4 pattern\\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;vec2 imagecoord=mod(v_pos,1.0);vec2 pos=mix(pattern_tl/u_texsize,pattern_br/u_texsize,imagecoord);vec4 out_color=texture2D(u_image,pos);\\n#ifdef LIGHTING_3D_MODE\\nout_color=apply_lighting(out_color);\\n#endif\\n#ifdef FOG\\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\\n#endif\\ngl_FragColor=out_color*opacity;\\n#ifdef OVERDRAW_INSPECTOR\\ngl_FragColor=vec4(1.0);\\n#endif\\n}\", \"uniform mat4 u_matrix;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_tile_units_to_pixels;attribute vec2 a_pos;varying vec2 v_pos;\\n#pragma mapbox: define lowp float opacity\\n#pragma mapbox: define lowp vec4 pattern\\n#pragma mapbox: define lowp float pixel_ratio\\nvoid main() {\\n#pragma mapbox: initialize lowp float opacity\\n#pragma mapbox: initialize mediump vec4 pattern\\n#pragma mapbox: initialize lowp float pixel_ratio\\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;vec2 display_size=(pattern_br-pattern_tl)/pixel_ratio;gl_Position=u_matrix*vec4(a_pos,0,1);v_pos=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,display_size,u_tile_units_to_pixels,a_pos);\\n#ifdef FOG\\nv_fog_pos=fog_position(a_pos);\\n#endif\\n}\"),\n      fillExtrusion: ui(\"varying vec4 v_color;\\n#ifdef RENDER_SHADOWS\\nvarying highp vec4 v_pos_light_view_0;varying highp vec4 v_pos_light_view_1;varying float v_depth;\\n#endif\\n#ifdef FAUX_AO\\nuniform lowp vec2 u_ao;varying vec3 v_ao;\\n#endif\\n#ifdef ZERO_ROOF_RADIUS\\nvarying vec4 v_roof_color;\\n#endif\\n#if defined(ZERO_ROOF_RADIUS) || defined(RENDER_SHADOWS)\\nvarying highp vec3 v_normal;\\n#endif\\nvoid main() {\\n#if defined(ZERO_ROOF_RADIUS) || defined(RENDER_SHADOWS)\\nvec3 normal=v_normal;\\n#endif\\nfloat z;vec4 color;\\n#ifdef ZERO_ROOF_RADIUS\\nz=float(normal.z > 0.00001);color=mix(v_color,v_roof_color,z);\\n#else\\ncolor=v_color;\\n#endif\\n#ifdef FAUX_AO\\nfloat intensity=u_ao[0];float h=max(0.0,v_ao.z);float h_floors=h/u_ao[1];float y_shade=1.0-0.9*intensity*min(v_ao.y,1.0);float shade=(1.0-0.08*intensity)*(y_shade+(1.0-y_shade)*(1.0-pow(1.0-min(h_floors/16.0,1.0),16.0)))+0.08*intensity*min(h_floors/160.0,1.0);float concave=v_ao.x*v_ao.x;\\n#ifdef ZERO_ROOF_RADIUS\\nconcave*=(1.0-z);\\n#endif\\nfloat x_shade=mix(1.0,mix(0.6,0.75,min(h_floors/30.0,1.0)),intensity)+0.1*intensity*min(h,1.0);shade*=mix(1.0,x_shade*x_shade*x_shade,concave);color.rgb=color.rgb*shade;\\n#endif\\n#ifdef RENDER_SHADOWS\\n#ifdef ZERO_ROOF_RADIUS\\nnormal=mix(normal,vec3(0.0,0.0,1.0),z);\\n#endif\\ncolor.xyz=shadowed_color_normal(color.xyz,normalize(normal),v_pos_light_view_0,v_pos_light_view_1,v_depth);\\n#endif\\n#ifdef FOG\\ncolor=fog_dither(fog_apply_premultiplied(color,v_fog_pos));\\n#endif\\ngl_FragColor=color;\\n#ifdef OVERDRAW_INSPECTOR\\ngl_FragColor=vec4(1.0);\\n#endif\\n}\", \"uniform mat4 u_matrix;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp float u_lightintensity;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform float u_edge_radius;attribute vec4 a_pos_normal_ed;attribute vec2 a_centroid_pos;\\n#ifdef PROJECTION_GLOBE_VIEW\\nattribute vec3 a_pos_3;attribute vec3 a_pos_normal_3;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_tile_id;uniform float u_zoom_transition;uniform vec3 u_up_dir;uniform float u_height_lift;\\n#endif\\nvarying vec4 v_color;\\n#ifdef RENDER_SHADOWS\\nuniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;varying highp vec4 v_pos_light_view_0;varying highp vec4 v_pos_light_view_1;varying float v_depth;\\n#endif\\n#ifdef ZERO_ROOF_RADIUS\\nvarying vec4 v_roof_color;\\n#endif\\n#if defined(ZERO_ROOF_RADIUS) || defined(RENDER_SHADOWS)\\nvarying highp vec3 v_normal;\\n#endif\\n#ifdef FAUX_AO\\nuniform lowp vec2 u_ao;varying vec3 v_ao;\\n#endif\\n#pragma mapbox: define highp float base\\n#pragma mapbox: define highp float height\\n#pragma mapbox: define highp vec4 color\\nvoid main() {\\n#pragma mapbox: initialize highp float base\\n#pragma mapbox: initialize highp float height\\n#pragma mapbox: initialize highp vec4 color\\nvec4 pos_nx=floor(a_pos_normal_ed*0.5);vec4 top_up_ny_start=a_pos_normal_ed-2.0*pos_nx;vec3 top_up_ny=top_up_ny_start.xyz;float x_normal=pos_nx.z/8192.0;vec3 normal=top_up_ny.y==1.0 ? vec3(0.0,0.0,1.0) : normalize(vec3(x_normal,(2.0*top_up_ny.z-1.0)*(1.0-abs(x_normal)),0.0));\\n#if defined(ZERO_ROOF_RADIUS) || defined(RENDER_SHADOWS)\\nv_normal=normal;\\n#endif\\nbase=max(0.0,base);height=max(0.0,top_up_ny.y==0.0 && top_up_ny.x==1.0 ? height-u_edge_radius : height);float t=top_up_ny.x;vec2 centroid_pos=vec2(0.0);\\n#if defined(HAS_CENTROID) || defined(TERRAIN)\\ncentroid_pos=a_centroid_pos;\\n#endif\\nfloat ele=0.0;float h=0.0;float c_ele;vec3 pos;\\n#ifdef TERRAIN\\nbool flat_roof=centroid_pos.x !=0.0 && t > 0.0;ele=elevation(pos_nx.xy);c_ele=flat_roof ? centroid_pos.y==0.0 ? elevationFromUint16(centroid_pos.x) : flatElevation(centroid_pos) : ele;h=flat_roof ? max(c_ele+height,ele+base+2.0) : ele+(t > 0.0 ? height : base==0.0 ?-5.0 : base);pos=vec3(pos_nx.xy,h);\\n#else\\nh=t > 0.0 ? height : base;pos=vec3(pos_nx.xy,h);\\n#endif\\n#ifdef PROJECTION_GLOBE_VIEW\\nfloat lift=float((t+base) > 0.0)*u_height_lift;h+=lift;vec3 globe_normal=normalize(mix(a_pos_normal_3/16384.0,u_up_dir,u_zoom_transition));vec3 globe_pos=a_pos_3+globe_normal*(u_tile_up_scale*h);vec3 merc_pos=mercator_tile_position(u_inv_rot_matrix,pos.xy,u_tile_id,u_merc_center)+u_up_dir*u_tile_up_scale*pos.z;pos=mix_globe_mercator(globe_pos,merc_pos,u_zoom_transition);\\n#endif\\nfloat hidden=float(centroid_pos.x==0.0 && centroid_pos.y==1.0);gl_Position=mix(u_matrix*vec4(pos,1),AWAY,hidden);\\n#ifdef RENDER_SHADOWS\\nv_pos_light_view_0=u_light_matrix_0*vec4(pos,1);v_pos_light_view_1=u_light_matrix_1*vec4(pos,1);v_depth=gl_Position.w;\\n#endif\\nfloat NdotL=0.0;float colorvalue=0.0;\\n#ifdef LIGHTING_3D_MODE\\nNdotL=calculate_NdotL(normal);\\n#else\\ncolorvalue=color.r*0.2126+color.g*0.7152+color.b*0.0722;vec4 ambientlight=vec4(0.03,0.03,0.03,1.0);color+=ambientlight;NdotL=clamp(dot(normal,u_lightpos),0.0,1.0);NdotL=mix((1.0-u_lightintensity),max((1.0-colorvalue+u_lightintensity),1.0),NdotL);\\n#endif\\nif (normal.y !=0.0) {float r=0.84;\\n#ifndef LIGHTING_3D_MODE\\nr=mix(0.7,0.98,1.0-u_lightintensity);\\n#endif\\nNdotL*=(\\n(1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),r,1.0)));}v_color=vec4(0.0,0.0,0.0,1.0);\\n#ifdef FAUX_AO\\nfloat concave=pos_nx.w-floor(pos_nx.w*0.5)*2.0;float start=top_up_ny_start.w;float y_ground=1.0-clamp(t+base,0.0,1.0);float top_height=height;\\n#ifdef TERRAIN\\ntop_height=mix(max(c_ele+height,ele+base+2.0),ele+height,float(centroid_pos.x==0.0))-ele;y_ground+=y_ground*5.0/max(3.0,top_height);\\n#endif\\nv_ao=vec3(mix(concave,-concave,start),y_ground,h-ele);NdotL*=(1.0+0.05*(1.0-top_up_ny.y)*u_ao[0]);\\n#ifdef PROJECTION_GLOBE_VIEW\\ntop_height+=u_height_lift;\\n#endif\\ngl_Position.z-=(0.0000006*(min(top_height,500.)+2.0*min(base,500.0)+60.0*concave+3.0*start))*gl_Position.w;\\n#endif\\n#ifdef LIGHTING_3D_MODE\\nv_color=apply_lighting(color,NdotL);\\n#else\\nv_color.rgb+=clamp(color.rgb*NdotL*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));\\n#endif\\nv_color*=u_opacity;\\n#ifdef ZERO_ROOF_RADIUS\\nv_roof_color=vec4(0.0,0.0,0.0,1.0);\\n#ifdef LIGHTING_3D_MODE\\nv_roof_color=apply_lighting(color,calculate_NdotL(vec3(0.0,0.0,1.0)));\\n#else\\nfloat roofNdotL=clamp(u_lightpos.z,0.0,1.0);roofNdotL=mix((1.0-u_lightintensity),max((1.0-colorvalue+u_lightintensity),1.0),roofNdotL);v_roof_color.rgb+=clamp(color.rgb*roofNdotL*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));\\n#endif\\nv_roof_color*=u_opacity;\\n#endif\\n#ifdef FOG\\nv_fog_pos=fog_position(pos);\\n#endif\\n}\"),\n      fillExtrusionPattern: ui(\"uniform vec2 u_texsize;uniform sampler2D u_image;\\n#ifdef FAUX_AO\\nuniform lowp vec2 u_ao;varying vec3 v_ao;\\n#endif\\n#ifdef LIGHTING_3D_MODE\\nvarying float v_NdotL;\\n#endif\\nvarying vec2 v_pos;varying vec4 v_lighting;uniform lowp float u_opacity;\\n#pragma mapbox: define lowp float base\\n#pragma mapbox: define lowp float height\\n#pragma mapbox: define lowp vec4 pattern\\n#pragma mapbox: define lowp float pixel_ratio\\nvoid main() {\\n#pragma mapbox: initialize lowp float base\\n#pragma mapbox: initialize lowp float height\\n#pragma mapbox: initialize mediump vec4 pattern\\n#pragma mapbox: initialize lowp float pixel_ratio\\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;vec2 imagecoord=mod(v_pos,1.0);vec2 pos=mix(pattern_tl/u_texsize,pattern_br/u_texsize,imagecoord);vec4 out_color=texture2D(u_image,pos);\\n#ifdef LIGHTING_3D_MODE\\nout_color=apply_lighting(out_color,v_NdotL)*u_opacity;\\n#else\\nout_color=out_color*v_lighting;\\n#endif\\n#ifdef FAUX_AO\\nfloat intensity=u_ao[0];float h=max(0.0,v_ao.z);float h_floors=h/u_ao[1];float y_shade=1.0-0.9*intensity*min(v_ao.y,1.0);float shade=(1.0-0.08*intensity)*(y_shade+(1.0-y_shade)*(1.0-pow(1.0-min(h_floors/16.0,1.0),16.0)))+0.08*intensity*min(h_floors/160.0,1.0);float concave=v_ao.x*v_ao.x;float x_shade=mix(1.0,mix(0.6,0.75,min(h_floors/30.0,1.0)),intensity)+0.1*intensity*min(h,1.0);shade*=mix(1.0,x_shade*x_shade*x_shade,concave);out_color.rgb=out_color.rgb*shade;\\n#endif\\n#ifdef FOG\\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\\n#endif\\ngl_FragColor=out_color;\\n#ifdef OVERDRAW_INSPECTOR\\ngl_FragColor=vec4(1.0);\\n#endif\\n}\", \"uniform mat4 u_matrix;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_height_factor;uniform float u_tile_units_to_pixels;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp float u_lightintensity;attribute vec4 a_pos_normal_ed;attribute vec2 a_centroid_pos;\\n#ifdef PROJECTION_GLOBE_VIEW\\nattribute vec3 a_pos_3;attribute vec3 a_pos_normal_3;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_tile_id;uniform float u_zoom_transition;uniform vec3 u_up_dir;uniform float u_height_lift;\\n#endif\\nvarying vec2 v_pos;varying vec4 v_lighting;\\n#ifdef FAUX_AO\\nuniform lowp vec2 u_ao;varying vec3 v_ao;\\n#endif\\n#ifdef LIGHTING_3D_MODE\\nvarying float v_NdotL;\\n#endif\\n#pragma mapbox: define lowp float base\\n#pragma mapbox: define lowp float height\\n#pragma mapbox: define lowp vec4 pattern\\n#pragma mapbox: define lowp float pixel_ratio\\nvoid main() {\\n#pragma mapbox: initialize lowp float base\\n#pragma mapbox: initialize lowp float height\\n#pragma mapbox: initialize mediump vec4 pattern\\n#pragma mapbox: initialize lowp float pixel_ratio\\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;vec4 pos_nx=floor(a_pos_normal_ed*0.5);mediump vec4 top_up_ny_start=a_pos_normal_ed-2.0*pos_nx;mediump vec3 top_up_ny=top_up_ny_start.xyz;float x_normal=pos_nx.z/8192.0;vec3 normal=top_up_ny.y==1.0 ? vec3(0.0,0.0,1.0) : normalize(vec3(x_normal,(2.0*top_up_ny.z-1.0)*(1.0-abs(x_normal)),0.0));float edgedistance=a_pos_normal_ed.w;vec2 display_size=(pattern_br-pattern_tl)/pixel_ratio;base=max(0.0,base);height=max(0.0,height);float t=top_up_ny.x;float z=t > 0.0 ? height : base;vec2 centroid_pos=vec2(0.0);\\n#if defined(HAS_CENTROID) || defined(TERRAIN)\\ncentroid_pos=a_centroid_pos;\\n#endif\\nfloat ele=0.0;float h=z;vec3 p;float c_ele;\\n#ifdef TERRAIN\\nbool flat_roof=centroid_pos.x !=0.0 && t > 0.0;ele=elevation(pos_nx.xy);c_ele=flat_roof ? centroid_pos.y==0.0 ? elevationFromUint16(centroid_pos.x) : flatElevation(centroid_pos) : ele;h=flat_roof ? max(c_ele+height,ele+base+2.0) : ele+(t > 0.0 ? height : base==0.0 ?-5.0 : base);p=vec3(pos_nx.xy,h);\\n#else\\np=vec3(pos_nx.xy,z);\\n#endif\\n#ifdef PROJECTION_GLOBE_VIEW\\nfloat lift=float((t+base) > 0.0)*u_height_lift;h+=lift;vec3 globe_normal=normalize(mix(a_pos_normal_3/16384.0,u_up_dir,u_zoom_transition));vec3 globe_pos=a_pos_3+globe_normal*(u_tile_up_scale*(p.z+lift));vec3 merc_pos=mercator_tile_position(u_inv_rot_matrix,p.xy,u_tile_id,u_merc_center)+u_up_dir*u_tile_up_scale*p.z;p=mix_globe_mercator(globe_pos,merc_pos,u_zoom_transition);\\n#endif\\nfloat hidden=float(centroid_pos.x==0.0 && centroid_pos.y==1.0);gl_Position=mix(u_matrix*vec4(p,1),AWAY,hidden);vec2 pos=normal.z==1.0\\n? pos_nx.xy\\n: vec2(edgedistance,z*u_height_factor);v_pos=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,display_size,u_tile_units_to_pixels,pos);v_lighting=vec4(0.0,0.0,0.0,1.0);float NdotL=0.0;\\n#ifdef LIGHTING_3D_MODE\\nNdotL=calculate_NdotL(normal);\\n#else\\nNdotL=clamp(dot(normal,u_lightpos),0.0,1.0);NdotL=mix((1.0-u_lightintensity),max((0.5+u_lightintensity),1.0),NdotL);\\n#endif\\nif (normal.y !=0.0) {float r=0.84;\\n#ifndef LIGHTING_3D_MODE\\nr=mix(0.7,0.98,1.0-u_lightintensity);\\n#endif\\nNdotL*=(\\n(1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),r,1.0)));}\\n#ifdef FAUX_AO\\nfloat concave=pos_nx.w-floor(pos_nx.w*0.5)*2.0;float start=top_up_ny_start.w;float y_ground=1.0-clamp(t+base,0.0,1.0);float top_height=height;\\n#ifdef TERRAIN\\ntop_height=mix(max(c_ele+height,ele+base+2.0),ele+height,float(centroid_pos.x==0.0))-ele;y_ground+=y_ground*5.0/max(3.0,top_height);\\n#endif\\nv_ao=vec3(mix(concave,-concave,start),y_ground,h-ele);NdotL*=(1.0+0.05*(1.0-top_up_ny.y)*u_ao[0]);\\n#ifdef PROJECTION_GLOBE_VIEW\\ntop_height+=u_height_lift;\\n#endif\\ngl_Position.z-=(0.0000006*(min(top_height,500.)+2.0*min(base,500.0)+60.0*concave+3.0*start))*gl_Position.w;\\n#endif\\n#ifdef LIGHTING_3D_MODE\\nv_NdotL=NdotL;\\n#else\\nv_lighting.rgb+=clamp(NdotL*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));v_lighting*=u_opacity;\\n#endif \\n#ifdef FOG\\nv_fog_pos=fog_position(p);\\n#endif\\n}\"),\n      hillshadePrepare: ui(\"#ifdef GL_ES\\nprecision highp float;\\n#endif\\nuniform sampler2D u_image;varying vec2 v_pos;uniform vec2 u_dimension;uniform float u_zoom;uniform vec4 u_unpack;float getElevation(vec2 coord) {\\n#ifdef TERRAIN_DEM_FLOAT_FORMAT\\nreturn texture2D(u_image,coord).a/4.0;\\n#else\\nvec4 data=texture2D(u_image,coord)*255.0;data.a=-1.0;return dot(data,u_unpack)/4.0;\\n#endif\\n}void main() {vec2 epsilon=1.0/u_dimension;float a=getElevation(v_pos+vec2(-epsilon.x,-epsilon.y));float b=getElevation(v_pos+vec2(0,-epsilon.y));float c=getElevation(v_pos+vec2(epsilon.x,-epsilon.y));float d=getElevation(v_pos+vec2(-epsilon.x,0));float e=getElevation(v_pos+vec2(epsilon.x,0));float f=getElevation(v_pos+vec2(-epsilon.x,epsilon.y));float g=getElevation(v_pos+vec2(0,epsilon.y));float h=getElevation(v_pos+vec2(epsilon.x,epsilon.y));float exaggerationFactor=u_zoom < 2.0 ? 0.4 : u_zoom < 4.5 ? 0.35 : 0.3;float exaggeration=u_zoom < 15.0 ? (u_zoom-15.0)*exaggerationFactor : 0.0;vec2 deriv=vec2(\\n(c+e+e+h)-(a+d+d+f),(f+g+g+h)-(a+b+b+c)\\n)/pow(2.0,exaggeration+(19.2562-u_zoom));gl_FragColor=clamp(vec4(\\nderiv.x/2.0+0.5,deriv.y/2.0+0.5,1.0,1.0),0.0,1.0);\\n#ifdef OVERDRAW_INSPECTOR\\ngl_FragColor=vec4(1.0);\\n#endif\\n}\", \"uniform mat4 u_matrix;uniform vec2 u_dimension;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);highp vec2 epsilon=1.0/u_dimension;float scale=(u_dimension.x-2.0)/u_dimension.x;v_pos=(a_texture_pos/8192.0)*scale+epsilon;}\"),\n      hillshade: ui(\"uniform sampler2D u_image;varying vec2 v_pos;uniform vec2 u_latrange;uniform vec2 u_light;uniform vec4 u_shadow;uniform vec4 u_highlight;uniform vec4 u_accent;void main() {vec4 pixel=texture2D(u_image,v_pos);vec2 deriv=((pixel.rg*2.0)-1.0);float scaleFactor=cos(radians((u_latrange[0]-u_latrange[1])*(1.0-v_pos.y)+u_latrange[1]));float slope=atan(1.25*length(deriv)/scaleFactor);float aspect=deriv.x !=0.0 ? atan(deriv.y,-deriv.x) : PI/2.0*(deriv.y > 0.0 ? 1.0 :-1.0);float intensity=u_light.x;float azimuth=u_light.y+PI;float base=1.875-intensity*1.75;float maxValue=0.5*PI;float scaledSlope=intensity !=0.5 ? ((pow(base,slope)-1.0)/(pow(base,maxValue)-1.0))*maxValue : slope;float accent=cos(scaledSlope);vec4 accent_color=(1.0-accent)*u_accent*clamp(intensity*2.0,0.0,1.0);float shade=abs(mod((aspect+azimuth)/PI+0.5,2.0)-1.0);vec4 shade_color=mix(u_shadow,u_highlight,shade)*sin(scaledSlope)*clamp(intensity*2.0,0.0,1.0);gl_FragColor=accent_color*(1.0-shade_color.a)+shade_color;\\n#ifdef LIGHTING_3D_MODE\\ngl_FragColor=apply_lighting(gl_FragColor);\\n#endif\\n#ifdef FOG\\ngl_FragColor=fog_dither(fog_apply_premultiplied(gl_FragColor,v_fog_pos));\\n#endif\\n#ifdef OVERDRAW_INSPECTOR\\ngl_FragColor=vec4(1.0);\\n#endif\\n}\", \"uniform mat4 u_matrix;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos=a_texture_pos/8192.0;\\n#ifdef FOG\\nv_fog_pos=fog_position(a_pos);\\n#endif\\n}\"),\n      line: ui(\"uniform lowp float u_device_pixel_ratio;uniform float u_alpha_discard_threshold;uniform highp vec2 u_trim_offset;varying vec2 v_width2;varying vec2 v_normal;varying float v_gamma_scale;varying highp vec4 v_uv;\\n#ifdef RENDER_LINE_DASH\\nuniform sampler2D u_dash_image;varying vec2 v_tex;\\n#endif\\n#ifdef RENDER_LINE_GRADIENT\\nuniform sampler2D u_gradient_image;\\n#endif\\nuniform float u_border_width;uniform vec4 u_border_color;float luminance(vec3 c) {return (c.r+c.r+c.b+c.g+c.g+c.g)*0.1667;}\\n#pragma mapbox: define highp vec4 color\\n#pragma mapbox: define lowp float floorwidth\\n#pragma mapbox: define lowp vec4 dash\\n#pragma mapbox: define lowp float blur\\n#pragma mapbox: define lowp float opacity\\nfloat linearstep(float edge0,float edge1,float x) {return  clamp((x-edge0)/(edge1-edge0),0.0,1.0);}void main() {\\n#pragma mapbox: initialize highp vec4 color\\n#pragma mapbox: initialize lowp float floorwidth\\n#pragma mapbox: initialize lowp vec4 dash\\n#pragma mapbox: initialize lowp float blur\\n#pragma mapbox: initialize lowp float opacity\\nfloat dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);\\n#ifdef RENDER_LINE_DASH\\nfloat sdfdist=texture2D(u_dash_image,v_tex).a;float sdfgamma=1.0/(2.0*u_device_pixel_ratio)/dash.z;alpha*=linearstep(0.5-sdfgamma/floorwidth,0.5+sdfgamma/floorwidth,sdfdist);\\n#endif\\nhighp vec4 out_color;\\n#ifdef RENDER_LINE_GRADIENT\\nout_color=texture2D(u_gradient_image,v_uv.xy);\\n#else\\nout_color=color;\\n#endif\\nfloat trimmed=1.0;\\n#ifdef RENDER_LINE_TRIM_OFFSET\\nhighp float start=v_uv[2];highp float end=v_uv[3];highp float trim_start=u_trim_offset[0];highp float trim_end=u_trim_offset[1];highp float line_progress=(start+(v_uv.x)*(end-start));if (trim_end > trim_start) {if (line_progress <=trim_end && line_progress >=trim_start) {out_color=vec4(0,0,0,0);trimmed=0.0;}}\\n#endif\\n#ifdef LIGHTING_3D_MODE\\nout_color=apply_lighting(out_color);\\n#endif\\n#ifdef FOG\\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\\n#endif\\n#ifdef RENDER_LINE_ALPHA_DISCARD\\nif (alpha < u_alpha_discard_threshold) {discard;}\\n#endif\\n#ifdef RENDER_LINE_BORDER\\nfloat edgeBlur=(u_border_width+1.0/u_device_pixel_ratio);float alpha2=clamp(min(dist-(v_width2.t-edgeBlur),v_width2.s-dist)/edgeBlur,0.0,1.0);if (alpha2 < 1.) {float smoothAlpha=smoothstep(0.6,1.0,alpha2);\\n#ifdef RENDER_LINE_BORDER_AUTO\\nfloat Y=(out_color.a > 0.01) ? luminance(out_color.rgb/out_color.a) : 1.;float adjustment=(Y > 0.) ? 0.5/Y : 0.45;if (out_color.a > 0.25 && Y < 0.25) {vec3 borderColor=(Y > 0.) ? out_color.rgb : vec3(1,1,1)*out_color.a;out_color.rgb=out_color.rgb+borderColor*(adjustment*(1.0-smoothAlpha));} else {out_color.rgb*=(0.6 +0.4*smoothAlpha);}\\n#else\\nout_color.rgb=mix(u_border_color.rgb*u_border_color.a*trimmed,out_color.rgb,smoothAlpha);\\n#endif\\n}\\n#endif\\ngl_FragColor=out_color*(alpha*opacity);\\n#ifdef OVERDRAW_INSPECTOR\\ngl_FragColor=vec4(1.0);\\n#endif\\n}\", \"\\n#define EXTRUDE_SCALE 0.015873016\\nattribute vec2 a_pos_normal;attribute vec4 a_data;\\n#if defined(RENDER_LINE_GRADIENT) || defined(RENDER_LINE_TRIM_OFFSET)\\nattribute highp vec4 a_packed;\\n#endif\\n#ifdef RENDER_LINE_DASH\\nattribute float a_linesofar;\\n#endif\\nuniform mat4 u_matrix;uniform mat2 u_pixels_to_tile_units;uniform vec2 u_units_to_pixels;uniform lowp float u_device_pixel_ratio;varying vec2 v_normal;varying vec2 v_width2;varying float v_gamma_scale;varying highp vec4 v_uv;\\n#ifdef RENDER_LINE_DASH\\nuniform vec2 u_texsize;uniform float u_tile_units_to_pixels;varying vec2 v_tex;\\n#endif\\n#ifdef RENDER_LINE_GRADIENT\\nuniform float u_image_height;\\n#endif\\n#pragma mapbox: define highp vec4 color\\n#pragma mapbox: define lowp float floorwidth\\n#pragma mapbox: define lowp vec4 dash\\n#pragma mapbox: define lowp float blur\\n#pragma mapbox: define lowp float opacity\\n#pragma mapbox: define mediump float gapwidth\\n#pragma mapbox: define lowp float offset\\n#pragma mapbox: define mediump float width\\nvoid main() {\\n#pragma mapbox: initialize highp vec4 color\\n#pragma mapbox: initialize lowp float floorwidth\\n#pragma mapbox: initialize lowp vec4 dash\\n#pragma mapbox: initialize lowp float blur\\n#pragma mapbox: initialize lowp float opacity\\n#pragma mapbox: initialize mediump float gapwidth\\n#pragma mapbox: initialize lowp float offset\\n#pragma mapbox: initialize mediump float width\\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*EXTRUDE_SCALE;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*EXTRUDE_SCALE*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist*u_pixels_to_tile_units,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2*u_pixels_to_tile_units,0.0,1.0)+projected_extrude;\\n#ifndef RENDER_TO_TEXTURE\\nfloat extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;\\n#else\\nv_gamma_scale=1.0;\\n#endif\\n#if defined(RENDER_LINE_GRADIENT) || defined(RENDER_LINE_TRIM_OFFSET)\\nfloat a_uv_x=a_packed[0];float a_split_index=a_packed[1];highp float a_clip_start=a_packed[2];highp float a_clip_end=a_packed[3];\\n#ifdef RENDER_LINE_GRADIENT\\nhighp float texel_height=1.0/u_image_height;highp float half_texel_height=0.5*texel_height;v_uv=vec4(a_uv_x,a_split_index*texel_height-half_texel_height,a_clip_start,a_clip_end);\\n#else\\nv_uv=vec4(a_uv_x,0.0,a_clip_start,a_clip_end);\\n#endif\\n#endif\\n#ifdef RENDER_LINE_DASH\\nfloat scale=dash.z==0.0 ? 0.0 : u_tile_units_to_pixels/dash.z;float height=dash.y;v_tex=vec2(a_linesofar*scale/floorwidth,(-normal.y*height+dash.x+0.5)/u_texsize.y);\\n#endif\\nv_width2=vec2(outset,inset);\\n#ifdef FOG\\nv_fog_pos=fog_position(pos);\\n#endif\\n}\"),\n      linePattern: ui(\"uniform lowp float u_device_pixel_ratio;uniform vec2 u_texsize;uniform float u_tile_units_to_pixels;uniform sampler2D u_image;varying vec2 v_normal;varying vec2 v_width2;varying float v_linesofar;varying float v_gamma_scale;varying float v_width;\\n#pragma mapbox: define lowp vec4 pattern\\n#pragma mapbox: define lowp float pixel_ratio\\n#pragma mapbox: define lowp float blur\\n#pragma mapbox: define lowp float opacity\\nvoid main() {\\n#pragma mapbox: initialize mediump vec4 pattern\\n#pragma mapbox: initialize lowp float pixel_ratio\\n#pragma mapbox: initialize lowp float blur\\n#pragma mapbox: initialize lowp float opacity\\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;vec2 display_size=(pattern_br-pattern_tl)/pixel_ratio;vec2 pattern_size=vec2(display_size.x/u_tile_units_to_pixels,display_size.y);float aspect=display_size.y/v_width;float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float x=mod(v_linesofar/pattern_size.x*aspect,1.0);float y=0.5*v_normal.y+0.5;vec2 texel_size=1.0/u_texsize;vec2 pos=mix(pattern_tl*texel_size-texel_size,pattern_br*texel_size+texel_size,vec2(x,y));vec4 color=texture2D(u_image,pos);\\n#ifdef LIGHTING_3D_MODE\\ncolor=apply_lighting(color);\\n#endif\\n#ifdef FOG\\ncolor=fog_dither(fog_apply_premultiplied(color,v_fog_pos));\\n#endif\\ngl_FragColor=color*(alpha*opacity);\\n#ifdef OVERDRAW_INSPECTOR\\ngl_FragColor=vec4(1.0);\\n#endif\\n}\", \"\\n#define scale 0.015873016\\nattribute vec2 a_pos_normal;attribute vec4 a_data;attribute float a_linesofar;uniform mat4 u_matrix;uniform vec2 u_units_to_pixels;uniform mat2 u_pixels_to_tile_units;uniform lowp float u_device_pixel_ratio;varying vec2 v_normal;varying vec2 v_width2;varying float v_linesofar;varying float v_gamma_scale;varying float v_width;\\n#pragma mapbox: define lowp float blur\\n#pragma mapbox: define lowp float opacity\\n#pragma mapbox: define lowp float offset\\n#pragma mapbox: define mediump float gapwidth\\n#pragma mapbox: define mediump float width\\n#pragma mapbox: define lowp float floorwidth\\n#pragma mapbox: define lowp vec4 pattern\\n#pragma mapbox: define lowp float pixel_ratio\\nvoid main() {\\n#pragma mapbox: initialize lowp float blur\\n#pragma mapbox: initialize lowp float opacity\\n#pragma mapbox: initialize lowp float offset\\n#pragma mapbox: initialize mediump float gapwidth\\n#pragma mapbox: initialize mediump float width\\n#pragma mapbox: initialize lowp float floorwidth\\n#pragma mapbox: initialize mediump vec4 pattern\\n#pragma mapbox: initialize lowp float pixel_ratio\\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist*u_pixels_to_tile_units,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2*u_pixels_to_tile_units,0.0,1.0)+projected_extrude;\\n#ifndef RENDER_TO_TEXTURE\\nfloat extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;\\n#else\\nv_gamma_scale=1.0;\\n#endif\\nv_linesofar=a_linesofar;v_width2=vec2(outset,inset);v_width=floorwidth;\\n#ifdef FOG\\nv_fog_pos=fog_position(pos);\\n#endif\\n}\"),\n      raster: ui(\"uniform float u_fade_t;uniform float u_opacity;uniform sampler2D u_image0;uniform sampler2D u_image1;varying vec2 v_pos0;varying vec2 v_pos1;uniform float u_brightness_low;uniform float u_brightness_high;uniform float u_saturation_factor;uniform float u_contrast_factor;uniform vec3 u_spin_weights;void main() {vec4 color0=texture2D(u_image0,v_pos0);vec4 color1=texture2D(u_image1,v_pos1);if (color0.a > 0.0) {color0.rgb=color0.rgb/color0.a;}if (color1.a > 0.0) {color1.rgb=color1.rgb/color1.a;}vec4 color=mix(color0,color1,u_fade_t);color.a*=u_opacity;vec3 rgb=color.rgb;rgb=vec3(\\ndot(rgb,u_spin_weights.xyz),dot(rgb,u_spin_weights.zxy),dot(rgb,u_spin_weights.yzx));float average=(color.r+color.g+color.b)/3.0;rgb+=(average-rgb)*u_saturation_factor;rgb=(rgb-0.5)*u_contrast_factor+0.5;vec3 u_high_vec=vec3(u_brightness_low,u_brightness_low,u_brightness_low);vec3 u_low_vec=vec3(u_brightness_high,u_brightness_high,u_brightness_high);vec3 out_color=mix(u_high_vec,u_low_vec,rgb);\\n#ifdef LIGHTING_3D_MODE\\nout_color=apply_lighting(out_color);\\n#endif\\n#ifdef FOG\\nout_color=fog_dither(fog_apply(out_color,v_fog_pos));\\n#endif\\ngl_FragColor=vec4(out_color*color.a,color.a);\\n#ifdef OVERDRAW_INSPECTOR\\ngl_FragColor=vec4(1.0);\\n#endif\\n}\", \"uniform mat4 u_matrix;uniform vec2 u_tl_parent;uniform float u_scale_parent;uniform vec2 u_perspective_transform;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos0;varying vec2 v_pos1;void main() {float w=1.0+dot(a_texture_pos,u_perspective_transform);gl_Position=u_matrix*vec4(a_pos*w,0,w);v_pos0=a_texture_pos/8192.0;v_pos1=(v_pos0*u_scale_parent)+u_tl_parent;\\n#ifdef FOG\\nv_fog_pos=fog_position(a_pos);\\n#endif\\n}\"),\n      symbolIcon: ui(\"uniform sampler2D u_texture;varying vec2 v_tex;varying float v_fade_opacity;\\n#pragma mapbox: define lowp float opacity\\nvoid main() {\\n#pragma mapbox: initialize lowp float opacity\\nlowp float alpha=opacity*v_fade_opacity;gl_FragColor=texture2D(u_texture,v_tex)*alpha;\\n#ifdef OVERDRAW_INSPECTOR\\ngl_FragColor=vec4(1.0);\\n#endif\\n}\", \"attribute vec4 a_pos_offset;attribute vec4 a_tex_size;attribute vec4 a_pixeloffset;attribute vec4 a_projected_pos;attribute float a_fade_opacity;\\n#ifdef PROJECTION_GLOBE_VIEW\\nattribute vec3 a_globe_anchor;attribute vec3 a_globe_normal;\\n#endif\\nuniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform highp float u_camera_to_center_distance;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform float u_fade_change;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform vec2 u_texsize;uniform vec3 u_up_vector;\\n#ifdef PROJECTION_GLOBE_VIEW\\nuniform vec3 u_tile_id;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_camera_forward;uniform float u_zoom_transition;uniform vec3 u_ecef_origin;uniform mat4 u_tile_matrix;\\n#endif\\nvarying vec2 v_tex;varying float v_fade_opacity;\\n#pragma mapbox: define lowp float opacity\\nvoid main() {\\n#pragma mapbox: initialize lowp float opacity\\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_tex_size.xy;vec2 a_size=a_tex_size.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;vec2 a_min_font_scale=a_pixeloffset.zw/256.0;highp float segment_angle=-a_projected_pos[3];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 tile_anchor=a_pos;vec3 h=elevationVector(tile_anchor)*elevation(tile_anchor);float globe_occlusion_fade;vec3 world_pos;vec3 mercator_pos;\\n#ifdef PROJECTION_GLOBE_VIEW\\nmercator_pos=mercator_tile_position(u_inv_rot_matrix,tile_anchor,u_tile_id,u_merc_center);world_pos=mix_globe_mercator(a_globe_anchor+h,mercator_pos,u_zoom_transition);vec4 ecef_point=u_tile_matrix*vec4(world_pos,1.0);vec3 origin_to_point=ecef_point.xyz-u_ecef_origin;globe_occlusion_fade=dot(origin_to_point,u_camera_forward) >=0.0 ? 0.0 : 1.0;\\n#else\\nworld_pos=vec3(tile_anchor,0)+h;globe_occlusion_fade=1.0;\\n#endif\\nvec4 projected_point=u_matrix*vec4(world_pos,1);highp float camera_to_anchor_distance=projected_point.w;highp float distance_ratio=u_pitch_with_map ?\\ncamera_to_anchor_distance/u_camera_to_center_distance :\\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(\\n0.5+0.5*distance_ratio,0.0,1.5);size*=perspective_ratio;float font_scale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjected_point;\\n#ifdef PROJECTION_GLOBE_VIEW\\nvec3 displacement=vec3(a_globe_normal.z,0,-a_globe_normal.x);offsetProjected_point=u_matrix*vec4(a_globe_anchor+displacement,1);\\n#else\\noffsetProjected_point=u_matrix*vec4(tile_anchor+vec2(1,0),0,1);\\n#endif\\nvec2 a=projected_point.xy/projected_point.w;vec2 b=offsetProjected_point.xy/offsetProjected_point.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}vec4 projected_pos;\\n#ifdef PROJECTION_GLOBE_VIEW\\nvec3 proj_pos=mix_globe_mercator(a_projected_pos.xyz+h,mercator_pos,u_zoom_transition);projected_pos=u_label_plane_matrix*vec4(proj_pos,1.0);\\n#else\\nprojected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,h.z,1.0);\\n#endif\\nhighp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);float z=0.0;vec2 offset=rotation_matrix*(a_offset/32.0*max(a_min_font_scale,font_scale)+a_pxoffset/16.0);\\n#ifdef TERRAIN\\n#ifdef PITCH_WITH_MAP_TERRAIN\\nvec4 tile_pos=u_label_plane_matrix_inv*vec4(a_projected_pos.xy+offset,0.0,1.0);z=elevation(tile_pos.xy);\\n#endif\\n#endif\\nfloat occlusion_fade=occlusionFade(projected_point)*globe_occlusion_fade;\\n#ifdef PROJECTION_GLOBE_VIEW\\nvec3 xAxis=u_pitch_with_map ? normalize(cross(a_globe_normal,u_up_vector)) : vec3(1,0,0);vec3 yAxis=u_pitch_with_map ? normalize(cross(a_globe_normal,xAxis)) : vec3(0,1,0);gl_Position=mix(u_coord_matrix*vec4(projected_pos.xyz/projected_pos.w+xAxis*offset.x+yAxis*offset.y,1.0),AWAY,float(projected_point.w <=0.0 || occlusion_fade==0.0));\\n#else\\ngl_Position=mix(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+offset,z,1.0),AWAY,float(projected_point.w <=0.0 || occlusion_fade==0.0));\\n#endif\\nfloat projection_transition_fade=1.0;\\n#if defined(PROJECTED_POS_ON_VIEWPORT) && defined(PROJECTION_GLOBE_VIEW)\\nprojection_transition_fade=1.0-step(EPSILON,u_zoom_transition);\\n#endif\\nv_tex=a_tex/u_texsize;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;v_fade_opacity=max(0.0,min(occlusion_fade,fade_opacity[0]+fade_change))*projection_transition_fade;}\"),\n      symbolSDF: ui(\"#define SDF_PX 8.0\\nuniform bool u_is_halo;uniform sampler2D u_texture;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;uniform bool u_is_text;varying vec2 v_data0;varying vec3 v_data1;\\n#pragma mapbox: define highp vec4 fill_color\\n#pragma mapbox: define highp vec4 halo_color\\n#pragma mapbox: define lowp float opacity\\n#pragma mapbox: define lowp float halo_width\\n#pragma mapbox: define lowp float halo_blur\\nvoid main() {\\n#pragma mapbox: initialize highp vec4 fill_color\\n#pragma mapbox: initialize highp vec4 halo_color\\n#pragma mapbox: initialize lowp float opacity\\n#pragma mapbox: initialize lowp float halo_width\\n#pragma mapbox: initialize lowp float halo_blur\\nfloat EDGE_GAMMA=0.105/u_device_pixel_ratio;vec2 tex=v_data0.xy;float gamma_scale=v_data1.x;float size=v_data1.y;float fade_opacity=v_data1[2];float fontScale=u_is_text ? size/24.0 : size;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float buff=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);buff=(6.0-halo_width/fontScale)/SDF_PX;}lowp float dist=texture2D(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(buff-gamma_scaled,buff+gamma_scaled,dist);gl_FragColor=color*(alpha*opacity*fade_opacity);\\n#ifdef OVERDRAW_INSPECTOR\\ngl_FragColor=vec4(1.0);\\n#endif\\n}\", \"attribute vec4 a_pos_offset;attribute vec4 a_tex_size;attribute vec4 a_pixeloffset;attribute vec4 a_projected_pos;attribute float a_fade_opacity;\\n#ifdef PROJECTION_GLOBE_VIEW\\nattribute vec3 a_globe_anchor;attribute vec3 a_globe_normal;\\n#endif\\nuniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec3 u_up_vector;\\n#ifdef PROJECTION_GLOBE_VIEW\\nuniform vec3 u_tile_id;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_camera_forward;uniform float u_zoom_transition;uniform vec3 u_ecef_origin;uniform mat4 u_tile_matrix;\\n#endif\\nvarying vec2 v_data0;varying vec3 v_data1;\\n#pragma mapbox: define highp vec4 fill_color\\n#pragma mapbox: define highp vec4 halo_color\\n#pragma mapbox: define lowp float opacity\\n#pragma mapbox: define lowp float halo_width\\n#pragma mapbox: define lowp float halo_blur\\nvoid main() {\\n#pragma mapbox: initialize highp vec4 fill_color\\n#pragma mapbox: initialize highp vec4 halo_color\\n#pragma mapbox: initialize lowp float opacity\\n#pragma mapbox: initialize lowp float halo_width\\n#pragma mapbox: initialize lowp float halo_blur\\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_tex_size.xy;vec2 a_size=a_tex_size.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;highp float segment_angle=-a_projected_pos[3];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 tile_anchor=a_pos;vec3 h=elevationVector(tile_anchor)*elevation(tile_anchor);float globe_occlusion_fade;vec3 world_pos;vec3 mercator_pos;\\n#ifdef PROJECTION_GLOBE_VIEW\\nmercator_pos=mercator_tile_position(u_inv_rot_matrix,tile_anchor,u_tile_id,u_merc_center);world_pos=mix_globe_mercator(a_globe_anchor+h,mercator_pos,u_zoom_transition);vec4 ecef_point=u_tile_matrix*vec4(world_pos,1.0);vec3 origin_to_point=ecef_point.xyz-u_ecef_origin;globe_occlusion_fade=dot(origin_to_point,u_camera_forward) >=0.0 ? 0.0 : 1.0;\\n#else\\nworld_pos=vec3(tile_anchor,0)+h;globe_occlusion_fade=1.0;\\n#endif\\nvec4 projected_point=u_matrix*vec4(world_pos,1);highp float camera_to_anchor_distance=projected_point.w;highp float distance_ratio=u_pitch_with_map ?\\ncamera_to_anchor_distance/u_camera_to_center_distance :\\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(\\n0.5+0.5*distance_ratio,0.0,1.5);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetprojected_point;\\n#ifdef PROJECTION_GLOBE_VIEW\\nvec3 displacement=vec3(a_globe_normal.z,0,-a_globe_normal.x);offsetprojected_point=u_matrix*vec4(a_globe_anchor+displacement,1);\\n#else\\noffsetprojected_point=u_matrix*vec4(tile_anchor+vec2(1,0),0,1);\\n#endif\\nvec2 a=projected_point.xy/projected_point.w;vec2 b=offsetprojected_point.xy/offsetprojected_point.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}vec4 projected_pos;\\n#ifdef PROJECTION_GLOBE_VIEW\\nvec3 proj_pos=mix_globe_mercator(a_projected_pos.xyz+h,mercator_pos,u_zoom_transition);projected_pos=u_label_plane_matrix*vec4(proj_pos,1.0);\\n#else\\nprojected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,h.z,1.0);\\n#endif\\nhighp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);float z=0.0;vec2 offset=rotation_matrix*(a_offset/32.0*fontScale+a_pxoffset);\\n#ifdef TERRAIN\\n#ifdef PITCH_WITH_MAP_TERRAIN\\nvec4 tile_pos=u_label_plane_matrix_inv*vec4(a_projected_pos.xy+offset,0.0,1.0);z=elevation(tile_pos.xy);\\n#endif\\n#endif\\nfloat occlusion_fade=occlusionFade(projected_point)*globe_occlusion_fade;\\n#ifdef PROJECTION_GLOBE_VIEW\\nvec3 xAxis=u_pitch_with_map ? normalize(cross(a_globe_normal,u_up_vector)) : vec3(1,0,0);vec3 yAxis=u_pitch_with_map ? normalize(cross(a_globe_normal,xAxis)) : vec3(0,1,0);gl_Position=mix(u_coord_matrix*vec4(projected_pos.xyz/projected_pos.w+xAxis*offset.x+yAxis*offset.y,1.0),AWAY,float(projected_point.w <=0.0 || occlusion_fade==0.0));\\n#else\\ngl_Position=mix(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+offset,z,1.0),AWAY,float(projected_point.w <=0.0 || occlusion_fade==0.0));\\n#endif\\nfloat gamma_scale=gl_Position.w;float projection_transition_fade=1.0;\\n#if defined(PROJECTED_POS_ON_VIEWPORT) && defined(PROJECTION_GLOBE_VIEW)\\nprojection_transition_fade=1.0-step(EPSILON,u_zoom_transition);\\n#endif\\nvec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(occlusion_fade,fade_opacity[0]+fade_change));v_data0=a_tex/u_texsize;v_data1=vec3(gamma_scale,size,interpolated_fade_opacity*projection_transition_fade);}\"),\n      symbolTextAndIcon: ui(\"#define SDF_PX 8.0\\n#define SDF 1.0\\n#define ICON 0.0\\nuniform bool u_is_halo;uniform sampler2D u_texture;uniform sampler2D u_texture_icon;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;varying vec4 v_data0;varying vec4 v_data1;\\n#pragma mapbox: define highp vec4 fill_color\\n#pragma mapbox: define highp vec4 halo_color\\n#pragma mapbox: define lowp float opacity\\n#pragma mapbox: define lowp float halo_width\\n#pragma mapbox: define lowp float halo_blur\\nvoid main() {\\n#pragma mapbox: initialize highp vec4 fill_color\\n#pragma mapbox: initialize highp vec4 halo_color\\n#pragma mapbox: initialize lowp float opacity\\n#pragma mapbox: initialize lowp float halo_width\\n#pragma mapbox: initialize lowp float halo_blur\\nfloat fade_opacity=v_data1[2];if (v_data1.w==ICON) {vec2 tex_icon=v_data0.zw;lowp float alpha=opacity*fade_opacity;gl_FragColor=texture2D(u_texture_icon,tex_icon)*alpha;\\n#ifdef OVERDRAW_INSPECTOR\\ngl_FragColor=vec4(1.0);\\n#endif\\nreturn;}vec2 tex=v_data0.xy;float EDGE_GAMMA=0.105/u_device_pixel_ratio;float gamma_scale=v_data1.x;float size=v_data1.y;float fontScale=size/24.0;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float buff=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);buff=(6.0-halo_width/fontScale)/SDF_PX;}lowp float dist=texture2D(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(buff-gamma_scaled,buff+gamma_scaled,dist);gl_FragColor=color*(alpha*opacity*fade_opacity);\\n#ifdef OVERDRAW_INSPECTOR\\ngl_FragColor=vec4(1.0);\\n#endif\\n}\", \"attribute vec4 a_pos_offset;attribute vec4 a_tex_size;attribute vec4 a_projected_pos;attribute float a_fade_opacity;\\n#ifdef PROJECTION_GLOBE_VIEW\\nattribute vec3 a_globe_anchor;attribute vec3 a_globe_normal;\\n#endif\\nuniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec3 u_up_vector;uniform vec2 u_texsize_icon;\\n#ifdef PROJECTION_GLOBE_VIEW\\nuniform vec3 u_tile_id;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_camera_forward;uniform float u_zoom_transition;uniform vec3 u_ecef_origin;uniform mat4 u_tile_matrix;\\n#endif\\nvarying vec4 v_data0;varying vec4 v_data1;\\n#pragma mapbox: define highp vec4 fill_color\\n#pragma mapbox: define highp vec4 halo_color\\n#pragma mapbox: define lowp float opacity\\n#pragma mapbox: define lowp float halo_width\\n#pragma mapbox: define lowp float halo_blur\\nvoid main() {\\n#pragma mapbox: initialize highp vec4 fill_color\\n#pragma mapbox: initialize highp vec4 halo_color\\n#pragma mapbox: initialize lowp float opacity\\n#pragma mapbox: initialize lowp float halo_width\\n#pragma mapbox: initialize lowp float halo_blur\\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_tex_size.xy;vec2 a_size=a_tex_size.zw;float a_size_min=floor(a_size[0]*0.5);float is_sdf=a_size[0]-2.0*a_size_min;highp float segment_angle=-a_projected_pos[3];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 tile_anchor=a_pos;vec3 h=elevationVector(tile_anchor)*elevation(tile_anchor);float globe_occlusion_fade;vec3 world_pos;vec3 mercator_pos;\\n#ifdef PROJECTION_GLOBE_VIEW\\nmercator_pos=mercator_tile_position(u_inv_rot_matrix,tile_anchor,u_tile_id,u_merc_center);world_pos=mix_globe_mercator(a_globe_anchor+h,mercator_pos,u_zoom_transition);vec4 ecef_point=u_tile_matrix*vec4(world_pos,1.0);vec3 origin_to_point=ecef_point.xyz-u_ecef_origin;globe_occlusion_fade=dot(origin_to_point,u_camera_forward) >=0.0 ? 0.0 : 1.0;\\n#else\\nworld_pos=vec3(tile_anchor,0)+h;globe_occlusion_fade=1.0;\\n#endif\\nvec4 projected_point=u_matrix*vec4(world_pos,1);highp float camera_to_anchor_distance=projected_point.w;highp float distance_ratio=u_pitch_with_map ?\\ncamera_to_anchor_distance/u_camera_to_center_distance :\\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(\\n0.5+0.5*distance_ratio,0.0,1.5);size*=perspective_ratio;float font_scale=size/24.0;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offset_projected_point=u_matrix*vec4(a_pos+vec2(1,0),0,1);vec2 a=projected_point.xy/projected_point.w;vec2 b=offset_projected_point.xy/offset_projected_point.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}vec4 projected_pos;\\n#ifdef PROJECTION_GLOBE_VIEW\\nvec3 proj_pos=mix_globe_mercator(a_projected_pos.xyz+h,mercator_pos,u_zoom_transition);projected_pos=u_label_plane_matrix*vec4(proj_pos,1.0);\\n#else\\nprojected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,h.z,1.0);\\n#endif\\nhighp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);float z=0.0;vec2 offset=rotation_matrix*(a_offset/32.0*font_scale);\\n#ifdef TERRAIN\\n#ifdef PITCH_WITH_MAP_TERRAIN\\nvec4 tile_pos=u_label_plane_matrix_inv*vec4(a_projected_pos.xy+offset,0.0,1.0);z=elevation(tile_pos.xy);\\n#endif\\n#endif\\nfloat occlusion_fade=occlusionFade(projected_point)*globe_occlusion_fade;\\n#ifdef PROJECTION_GLOBE_VIEW\\nvec3 xAxis=u_pitch_with_map ? normalize(cross(a_globe_normal,u_up_vector)) : vec3(1,0,0);vec3 yAxis=u_pitch_with_map ? normalize(cross(a_globe_normal,xAxis)) : vec3(0,1,0);gl_Position=mix(u_coord_matrix*vec4(projected_pos.xyz/projected_pos.w+xAxis*offset.x+yAxis*offset.y,1.0),AWAY,float(projected_point.w <=0.0 || occlusion_fade==0.0));\\n#else\\ngl_Position=mix(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+offset,z,1.0),AWAY,float(projected_point.w <=0.0 || occlusion_fade==0.0));\\n#endif\\nfloat gamma_scale=gl_Position.w;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(occlusion_fade,fade_opacity[0]+fade_change));float projection_transition_fade=1.0;\\n#if defined(PROJECTED_POS_ON_VIEWPORT) && defined(PROJECTION_GLOBE_VIEW)\\nprojection_transition_fade=1.0-step(EPSILON,u_zoom_transition);\\n#endif\\nv_data0.xy=a_tex/u_texsize;v_data0.zw=a_tex/u_texsize_icon;v_data1=vec4(gamma_scale,size,interpolated_fade_opacity*projection_transition_fade,is_sdf);}\"),\n      terrainRaster: ui(\"uniform sampler2D u_image0;varying vec2 v_pos0;\\n#ifdef FOG\\nvarying float v_fog_opacity;\\n#endif\\n#ifdef RENDER_SHADOWS\\nvarying vec4 v_pos_light_view_0;varying vec4 v_pos_light_view_1;varying float v_depth;\\n#endif\\nvoid main() {vec4 color=texture2D(u_image0,v_pos0);\\n#ifdef RENDER_SHADOWS\\ncolor.xyz=shadowed_color(color.xyz,v_pos_light_view_0,v_pos_light_view_1,v_depth);\\n#endif\\n#ifdef FOG\\n#ifdef ZERO_EXAGGERATION\\ncolor=fog_dither(fog_apply_premultiplied(color,v_fog_pos));\\n#else\\ncolor=fog_dither(fog_apply_from_vert(color,v_fog_opacity));\\n#endif\\n#endif\\ngl_FragColor=color;\\n#ifdef TERRAIN_WIREFRAME\\ngl_FragColor=vec4(1.0,0.0,0.0,0.8);\\n#endif\\n#ifdef OVERDRAW_INSPECTOR\\ngl_FragColor=vec4(1.0);\\n#endif\\n}\", \"uniform mat4 u_matrix;uniform float u_skirt_height;attribute vec2 a_pos;varying vec2 v_pos0;\\n#ifdef FOG\\nvarying float v_fog_opacity;\\n#endif\\n#ifdef RENDER_SHADOWS\\nuniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;varying vec4 v_pos_light_view_0;varying vec4 v_pos_light_view_1;varying float v_depth;\\n#endif\\nconst float wireframeOffset=0.00015;void main() {vec3 decomposedPosAndSkirt=decomposeToPosAndSkirt(a_pos);float skirt=decomposedPosAndSkirt.z;vec2 decodedPos=decomposedPosAndSkirt.xy;float elevation=elevation(decodedPos)-skirt*u_skirt_height;\\n#ifdef TERRAIN_WIREFRAME\\nelevation+=wireframeOffset;\\n#endif\\nv_pos0=decodedPos/8192.0;gl_Position=u_matrix*vec4(decodedPos,elevation,1.0);\\n#ifdef FOG\\n#ifdef ZERO_EXAGGERATION\\nv_fog_pos=fog_position(decodedPos);\\n#else\\nv_fog_opacity=fog(fog_position(vec3(decodedPos,elevation)));\\n#endif\\n#endif\\n#ifdef RENDER_SHADOWS\\nvec3 pos=vec3(decodedPos,elevation);v_pos_light_view_0=u_light_matrix_0*vec4(pos,1.);v_pos_light_view_1=u_light_matrix_1*vec4(pos,1.);v_depth=gl_Position.w;\\n#endif\\n}\"),\n      terrainDepth: ui(\"#ifdef GL_ES\\nprecision highp float;\\n#endif\\nvarying float v_depth;void main() {gl_FragColor=pack_depth(v_depth);}\", \"uniform mat4 u_matrix;attribute vec2 a_pos;varying float v_depth;void main() {float elevation=elevation(a_pos);gl_Position=u_matrix*vec4(a_pos,elevation,1.0);v_depth=gl_Position.z/gl_Position.w;}\"),\n      skybox: ui(\"\\nvarying lowp vec3 v_uv;uniform lowp samplerCube u_cubemap;uniform lowp float u_opacity;uniform highp float u_temporal_offset;uniform highp vec3 u_sun_direction;float sun_disk(highp vec3 ray_direction,highp vec3 sun_direction) {highp float cos_angle=dot(normalize(ray_direction),sun_direction);const highp float cos_sun_angular_diameter=0.99996192306;const highp float smoothstep_delta=1e-5;return smoothstep(\\ncos_sun_angular_diameter-smoothstep_delta,cos_sun_angular_diameter+smoothstep_delta,cos_angle);}float map(float value,float start,float end,float new_start,float new_end) {return ((value-start)*(new_end-new_start))/(end-start)+new_start;}void main() {vec3 uv=v_uv;const float y_bias=0.015;uv.y+=y_bias;uv.y=pow(abs(uv.y),1.0/5.0);uv.y=map(uv.y,0.0,1.0,-1.0,1.0);vec3 sky_color=textureCube(u_cubemap,uv).rgb;\\n#ifdef FOG\\nsky_color=fog_apply_sky_gradient(v_uv.xzy,sky_color);\\n#endif\\nsky_color.rgb=dither(sky_color.rgb,gl_FragCoord.xy+u_temporal_offset);sky_color+=0.1*sun_disk(v_uv,u_sun_direction);gl_FragColor=vec4(sky_color*u_opacity,u_opacity);\\n#ifdef OVERDRAW_INSPECTOR\\ngl_FragColor=vec4(1.0);\\n#endif\\n}\", Qt),\n      skyboxGradient: ui(\"varying highp vec3 v_uv;uniform lowp sampler2D u_color_ramp;uniform highp vec3 u_center_direction;uniform lowp float u_radius;uniform lowp float u_opacity;uniform highp float u_temporal_offset;void main() {float progress=acos(dot(normalize(v_uv),u_center_direction))/u_radius;vec4 color=texture2D(u_color_ramp,vec2(progress,0.5));\\n#ifdef FOG\\ncolor.rgb=fog_apply_sky_gradient(v_uv.xzy,color.rgb/color.a)*color.a;\\n#endif\\ncolor*=u_opacity;color.rgb=dither(color.rgb,gl_FragCoord.xy+u_temporal_offset);gl_FragColor=color;\\n#ifdef OVERDRAW_INSPECTOR\\ngl_FragColor=vec4(1.0);\\n#endif\\n}\", Qt),\n      skyboxCapture: ui(\"\\nvarying highp vec3 v_position;uniform highp float u_sun_intensity;uniform highp float u_luminance;uniform lowp vec3 u_sun_direction;uniform highp vec4 u_color_tint_r;uniform highp vec4 u_color_tint_m;\\n#ifdef GL_ES\\nprecision highp float;\\n#endif\\n#define BETA_R                  vec3(5.5e-6,13.0e-6,22.4e-6)\\n#define BETA_M                  vec3(21e-6,21e-6,21e-6)\\n#define MIE_G                   0.76\\n#define DENSITY_HEIGHT_SCALE_R  8000.0\\n#define DENSITY_HEIGHT_SCALE_M  1200.0\\n#define PLANET_RADIUS           6360e3\\n#define ATMOSPHERE_RADIUS       6420e3\\n#define SAMPLE_STEPS            10\\n#define DENSITY_STEPS           4\\nfloat ray_sphere_exit(vec3 orig,vec3 dir,float radius) {float a=dot(dir,dir);float b=2.0*dot(dir,orig);float c=dot(orig,orig)-radius*radius;float d=sqrt(b*b-4.0*a*c);return (-b+d)/(2.0*a);}vec3 extinction(vec2 density) {return exp(-vec3(BETA_R*u_color_tint_r.a*density.x+BETA_M*u_color_tint_m.a*density.y));}vec2 local_density(vec3 point) {float height=max(length(point)-PLANET_RADIUS,0.0);float exp_r=exp(-height/DENSITY_HEIGHT_SCALE_R);float exp_m=exp(-height/DENSITY_HEIGHT_SCALE_M);return vec2(exp_r,exp_m);}float phase_ray(float cos_angle) {return (3.0/(16.0*PI))*(1.0+cos_angle*cos_angle);}float phase_mie(float cos_angle) {return (3.0/(8.0*PI))*((1.0-MIE_G*MIE_G)*(1.0+cos_angle*cos_angle))/((2.0+MIE_G*MIE_G)*pow(1.0+MIE_G*MIE_G-2.0*MIE_G*cos_angle,1.5));}vec2 density_to_atmosphere(vec3 point,vec3 light_dir) {float ray_len=ray_sphere_exit(point,light_dir,ATMOSPHERE_RADIUS);float step_len=ray_len/float(DENSITY_STEPS);vec2 density_point_to_atmosphere=vec2(0.0);for (int i=0; i < DENSITY_STEPS;++i) {vec3 point_on_ray=point+light_dir*((float(i)+0.5)*step_len);density_point_to_atmosphere+=local_density(point_on_ray)*step_len;;}return density_point_to_atmosphere;}vec3 atmosphere(vec3 ray_dir,vec3 sun_direction,float sun_intensity) {vec2 density_orig_to_point=vec2(0.0);vec3 scatter_r=vec3(0.0);vec3 scatter_m=vec3(0.0);vec3 origin=vec3(0.0,PLANET_RADIUS,0.0);float ray_len=ray_sphere_exit(origin,ray_dir,ATMOSPHERE_RADIUS);float step_len=ray_len/float(SAMPLE_STEPS);for (int i=0; i < SAMPLE_STEPS;++i) {vec3 point_on_ray=origin+ray_dir*((float(i)+0.5)*step_len);vec2 density=local_density(point_on_ray)*step_len;density_orig_to_point+=density;vec2 density_point_to_atmosphere=density_to_atmosphere(point_on_ray,sun_direction);vec2 density_orig_to_atmosphere=density_orig_to_point+density_point_to_atmosphere;vec3 extinction=extinction(density_orig_to_atmosphere);scatter_r+=density.x*extinction;scatter_m+=density.y*extinction;}float cos_angle=dot(ray_dir,sun_direction);float phase_r=phase_ray(cos_angle);float phase_m=phase_mie(cos_angle);vec3 beta_r=BETA_R*u_color_tint_r.rgb*u_color_tint_r.a;vec3 beta_m=BETA_M*u_color_tint_m.rgb*u_color_tint_m.a;return (scatter_r*phase_r*beta_r+scatter_m*phase_m*beta_m)*sun_intensity;}const float A=0.15;const float B=0.50;const float C=0.10;const float D=0.20;const float E=0.02;const float F=0.30;vec3 uncharted2_tonemap(vec3 x) {return ((x*(A*x+C*B)+D*E)/(x*(A*x+B)+D*F))-E/F;}void main() {vec3 ray_direction=v_position;ray_direction.y=pow(ray_direction.y,5.0);const float y_bias=0.015;ray_direction.y+=y_bias;vec3 color=atmosphere(normalize(ray_direction),u_sun_direction,u_sun_intensity);float white_scale=1.0748724675633854;color=uncharted2_tonemap((log2(2.0/pow(u_luminance,4.0)))*color)*white_scale;gl_FragColor=vec4(color,1.0);}\", \"attribute highp vec3 a_pos_3f;uniform mat3 u_matrix_3f;varying highp vec3 v_position;float map(float value,float start,float end,float new_start,float new_end) {return ((value-start)*(new_end-new_start))/(end-start)+new_start;}void main() {vec4 pos=vec4(u_matrix_3f*a_pos_3f,1.0);v_position=pos.xyz;v_position.y*=-1.0;v_position.y=map(v_position.y,-1.0,1.0,0.0,1.0);gl_Position=vec4(a_pos_3f.xy,0.0,1.0);}\"),\n      globeRaster: ui(\"uniform sampler2D u_image0;varying vec2 v_pos0;\\n#ifndef FOG\\nuniform highp vec3 u_frustum_tl;uniform highp vec3 u_frustum_tr;uniform highp vec3 u_frustum_br;uniform highp vec3 u_frustum_bl;uniform highp vec3 u_globe_pos;uniform highp float u_globe_radius;uniform vec2 u_viewport;\\n#endif\\nvoid main() {vec4 color;\\n#ifdef CUSTOM_ANTIALIASING\\nvec2 uv=gl_FragCoord.xy/u_viewport;highp vec3 ray_dir=mix(\\nmix(u_frustum_tl,u_frustum_tr,uv.x),mix(u_frustum_bl,u_frustum_br,uv.x),1.0-uv.y);vec3 dir=normalize(ray_dir);vec3 closest_point=dot(u_globe_pos,dir)*dir;float norm_dist_from_center=1.0-length(closest_point-u_globe_pos)/u_globe_radius;const float antialias_pixel=2.0;float antialias_factor=antialias_pixel*fwidth(norm_dist_from_center);float antialias=smoothstep(0.0,antialias_factor,norm_dist_from_center);vec4 raster=texture2D(u_image0,v_pos0);color=vec4(raster.rgb*antialias,raster.a*antialias);\\n#else\\ncolor=texture2D(u_image0,v_pos0);\\n#endif\\n#ifdef FOG\\ncolor=fog_dither(fog_apply_premultiplied(color,v_fog_pos));\\n#endif\\ngl_FragColor=color;\\n#ifdef TERRAIN_WIREFRAME\\ngl_FragColor=vec4(1.0,0.0,0.0,0.8);\\n#endif\\n#ifdef OVERDRAW_INSPECTOR\\ngl_FragColor=vec4(1.0);\\n#endif\\n}\", \"uniform mat4 u_proj_matrix;uniform mat4 u_normalize_matrix;uniform mat4 u_globe_matrix;uniform mat4 u_merc_matrix;uniform float u_zoom_transition;uniform vec2 u_merc_center;uniform mat3 u_grid_matrix;uniform float u_skirt_height;\\n#ifdef GLOBE_POLES\\nattribute vec3 a_globe_pos;attribute vec2 a_uv;\\n#else\\nattribute vec2 a_pos;\\n#endif\\nvarying vec2 v_pos0;const float wireframeOffset=1e3;float mercatorXfromLng(float lng) {return (180.0+lng)/360.0;}float mercatorYfromLat(float lat) {return (180.0-(RAD_TO_DEG*log(tan(QUARTER_PI+lat/2.0*DEG_TO_RAD))))/360.0;}vec3 latLngToECEF(vec2 latLng) {latLng=DEG_TO_RAD*latLng;float cosLat=cos(latLng[0]);float sinLat=sin(latLng[0]);float cosLng=cos(latLng[1]);float sinLng=sin(latLng[1]);float sx=cosLat*sinLng*GLOBE_RADIUS;float sy=-sinLat*GLOBE_RADIUS;float sz=cosLat*cosLng*GLOBE_RADIUS;return vec3(sx,sy,sz);}void main() {\\n#ifdef GLOBE_POLES\\nvec3 globe_pos=a_globe_pos;vec2 uv=a_uv;\\n#else\\nfloat tiles=u_grid_matrix[0][2];float idx=u_grid_matrix[1][2];float idy=u_grid_matrix[2][2];vec3 decomposed_pos_and_skirt=decomposeToPosAndSkirt(a_pos);vec3 latLng=u_grid_matrix*vec3(decomposed_pos_and_skirt.xy,1.0);float mercatorY=mercatorYfromLat(latLng[0]);float uvY=mercatorY*tiles-idy;float mercatorX=mercatorXfromLng(latLng[1]);float uvX=mercatorX*tiles-idx;vec3 globe_pos=latLngToECEF(latLng.xy);vec2 merc_pos=vec2(mercatorX,mercatorY);vec2 uv=vec2(uvX,uvY);\\n#endif\\nv_pos0=uv;vec2 tile_pos=uv*EXTENT;vec3 globe_derived_up_vector=normalize(globe_pos)*u_tile_up_scale;\\n#ifdef GLOBE_POLES\\nvec3 up_vector=globe_derived_up_vector;\\n#else\\nvec3 up_vector=elevationVector(tile_pos);\\n#endif\\nfloat height=elevation(tile_pos);\\n#ifdef TERRAIN_WIREFRAME\\nheight+=wireframeOffset;\\n#endif\\nglobe_pos+=up_vector*height;\\n#ifndef GLOBE_POLES\\nglobe_pos-=globe_derived_up_vector*u_skirt_height*decomposed_pos_and_skirt.z;\\n#endif\\n#ifdef GLOBE_POLES\\nvec4 interpolated_pos=u_globe_matrix*vec4(globe_pos,1.0);\\n#else\\nvec4 globe_world_pos=u_globe_matrix*vec4(globe_pos,1.0);vec4 merc_world_pos=vec4(0.0);if (u_zoom_transition > 0.0) {merc_world_pos=vec4(merc_pos,height-u_skirt_height*decomposed_pos_and_skirt.z,1.0);merc_world_pos.xy-=u_merc_center;merc_world_pos.x=wrap(merc_world_pos.x,-0.5,0.5);merc_world_pos=u_merc_matrix*merc_world_pos;}vec4 interpolated_pos=vec4(mix(globe_world_pos.xyz,merc_world_pos.xyz,u_zoom_transition),1.0);\\n#endif\\ngl_Position=u_proj_matrix*interpolated_pos;\\n#ifdef FOG\\nv_fog_pos=fog_position((u_normalize_matrix*vec4(globe_pos,1.0)).xyz);\\n#endif\\n}\"),\n      globeAtmosphere: ui(\"uniform float u_transition;uniform highp float u_fadeout_range;uniform highp float u_temporal_offset;uniform vec3 u_start_color;uniform vec4 u_color;uniform vec4 u_space_color;uniform vec4 u_high_color;uniform float u_star_intensity;uniform float u_star_size;uniform float u_star_density;uniform float u_horizon_angle;uniform mat4 u_rotation_matrix;varying highp vec3 v_ray_dir;varying highp vec3 v_horizon_dir;highp float random(highp vec3 p) {p=fract(p*vec3(23.2342,97.1231,91.2342));p+=dot(p.zxy,p.yxz+123.1234);return fract(p.x*p.y);}float stars(vec3 p,float scale,vec2 offset) {vec2 uv_scale=(u_viewport/u_star_size)*scale;vec3 position=vec3(p.xy*uv_scale+offset*u_viewport,p.z);vec3 q=fract(position)-0.5;vec3 id=floor(position);float random_visibility=step(random(id),u_star_density);float circle=smoothstep(0.5+u_star_intensity,0.5,length(q));return circle*random_visibility;}void main() {highp vec3 dir=normalize(v_ray_dir);float globe_pos_dot_dir;\\n#ifdef PROJECTION_GLOBE_VIEW\\nglobe_pos_dot_dir=dot(u_globe_pos,dir);highp vec3 closest_point_forward=abs(globe_pos_dot_dir)*dir;float norm_dist_from_center=length(closest_point_forward-u_globe_pos)/u_globe_radius;if (norm_dist_from_center < 0.98) {discard;return;}\\n#endif\\nhighp vec3 horizon_dir=normalize(v_horizon_dir);float horizon_angle_mercator=dir.y < horizon_dir.y ?\\n0.0 : max(acos(dot(dir,horizon_dir)),0.0);float horizon_angle;\\n#ifdef PROJECTION_GLOBE_VIEW\\nhighp vec3 closest_point=globe_pos_dot_dir*dir;float closest_point_to_center=length(closest_point-u_globe_pos);float theta=asin(clamp(closest_point_to_center/length(u_globe_pos),-1.0,1.0));horizon_angle=globe_pos_dot_dir < 0.0 ?\\nPI-theta-u_horizon_angle : theta-u_horizon_angle;float angle_t=pow(u_transition,10.0);horizon_angle=mix(horizon_angle,horizon_angle_mercator,angle_t);\\n#else\\nhorizon_angle=horizon_angle_mercator;\\n#endif\\nhorizon_angle/=PI;float t=exp(-horizon_angle/u_fadeout_range);float alpha_0=u_color.a;float alpha_1=u_high_color.a;float alpha_2=u_space_color.a;vec3 color_stop_0=u_color.rgb;vec3 color_stop_1=u_high_color.rgb;vec3 color_stop_2=u_space_color.rgb;vec3 c0=mix(color_stop_2,color_stop_1,alpha_1);vec3 c1=mix(c0,color_stop_0,alpha_0);vec3 c2=mix(c0,c1,t);vec3 c =mix(color_stop_2,c2,t);float a0=mix(alpha_2,1.0,alpha_1);float a1=mix(a0,1.0,alpha_0);float a2=mix(a0,a1,t);float a =mix(alpha_2,a2,t);vec2 uv=gl_FragCoord.xy/u_viewport-0.5;float aspect_ratio=u_viewport.x/u_viewport.y;vec4 uv_dir=vec4(normalize(vec3(uv.x*aspect_ratio,uv.y,1.0)),1.0);uv_dir=u_rotation_matrix*uv_dir;vec3 n=abs(uv_dir.xyz);vec2 uv_remap=(n.x > n.y && n.x > n.z) ? uv_dir.yz/uv_dir.x:\\n(n.y > n.x && n.y > n.z) ? uv_dir.zx/uv_dir.y:\\nuv_dir.xy/uv_dir.z;uv_remap.x/=aspect_ratio;vec3 D=vec3(uv_remap,1.0);highp float star_field=0.0;if (u_star_intensity > 0.0) {star_field+=stars(D,1.2,vec2(0.0,0.0));star_field+=stars(D,1.0,vec2(1.0,0.0));star_field+=stars(D,0.8,vec2(0.0,1.0));star_field+=stars(D,0.6,vec2(1.0,1.0));star_field*=(1.0-pow(t,0.25+(1.0-u_high_color.a)*0.75));c+=star_field*alpha_2;}c=dither(c,gl_FragCoord.xy+u_temporal_offset);gl_FragColor=vec4(c,a);}\", \"attribute vec3 a_pos;attribute vec2 a_uv;uniform vec3 u_frustum_tl;uniform vec3 u_frustum_tr;uniform vec3 u_frustum_br;uniform vec3 u_frustum_bl;uniform float u_horizon;varying highp vec3 v_ray_dir;varying highp vec3 v_horizon_dir;void main() {v_ray_dir=mix(\\nmix(u_frustum_tl,u_frustum_tr,a_uv.x),mix(u_frustum_bl,u_frustum_br,a_uv.x),a_uv.y);v_horizon_dir=mix(\\nmix(u_frustum_tl,u_frustum_bl,u_horizon),mix(u_frustum_tr,u_frustum_br,u_horizon),a_uv.x);gl_Position=vec4(a_pos,1.0);}\")\n    };\n    function hi(e, t) {\n      const i = e.replace(/\\s*\\/\\/[^\\n]*\\n/g, \"\\n\").split(\"\\n\");\n      for (let e of i) if (e = e.trim(), \"#\" === e[0] && e.includes(\"if\") && !e.includes(\"endif\")) {\n        e = e.replace(\"#\", \"\").replace(/ifdef|ifndef|elif|if/g, \"\").replace(/!|defined|\\(|\\)|\\|\\||&&/g, \"\").replace(/\\s+/g, \" \").trim();\n        const i = e.split(\" \");\n        for (const e of i) t.includes(e) || t.push(e);\n      }\n    }\n    function ui(e, t) {\n      const i = /#pragma mapbox: ([\\w]+) ([\\w]+) ([\\w]+) ([\\w]+)/g,\n        o = t.match(/attribute (highp |mediump |lowp )?([\\w]+) ([\\w]+)/g),\n        r = {},\n        n = [...ni];\n      return hi(e, n), hi(t, n), {\n        fragmentSource: e = e.replace(i, (e, t, i, o, n) => (r[n] = !0, \"define\" === t ? `\\n#ifndef HAS_UNIFORM_u_${n}\\nvarying ${i} ${o} ${n};\\n#else\\nuniform ${i} ${o} u_${n};\\n#endif\\n` : `\\n#ifdef HAS_UNIFORM_u_${n}\\n    ${i} ${o} ${n} = u_${n};\\n#endif\\n`)),\n        vertexSource: t = t.replace(i, (e, t, i, o, n) => {\n          const s = \"float\" === o ? \"vec2\" : \"vec4\",\n            a = n.match(/color/) ? \"color\" : s;\n          return r[n] ? \"define\" === t ? `\\n#ifndef HAS_UNIFORM_u_${n}\\nuniform lowp float u_${n}_t;\\nattribute ${i} ${s} a_${n};\\nvarying ${i} ${o} ${n};\\n#else\\nuniform ${i} ${o} u_${n};\\n#endif\\n` : \"vec4\" === a ? `\\n#ifndef HAS_UNIFORM_u_${n}\\n    ${n} = a_${n};\\n#else\\n    ${i} ${o} ${n} = u_${n};\\n#endif\\n` : `\\n#ifndef HAS_UNIFORM_u_${n}\\n    ${n} = unpack_mix_${a}(a_${n}, u_${n}_t);\\n#else\\n    ${i} ${o} ${n} = u_${n};\\n#endif\\n` : \"define\" === t ? `\\n#ifndef HAS_UNIFORM_u_${n}\\nuniform lowp float u_${n}_t;\\nattribute ${i} ${s} a_${n};\\n#else\\nuniform ${i} ${o} u_${n};\\n#endif\\n` : \"vec4\" === a ? `\\n#ifndef HAS_UNIFORM_u_${n}\\n    ${i} ${o} ${n} = a_${n};\\n#else\\n    ${i} ${o} ${n} = u_${n};\\n#endif\\n` : `\\n#ifndef HAS_UNIFORM_u_${n}\\n    ${i} ${o} ${n} = unpack_mix_${a}(a_${n}, u_${n}_t);\\n#else\\n    ${i} ${o} ${n} = u_${n};\\n#endif\\n`;\n        }),\n        staticAttributes: o,\n        usedDefines: n\n      };\n    }\n    class _i {\n      constructor() {\n        this.boundProgram = null, this.boundLayoutVertexBuffer = null, this.boundPaintVertexBuffers = [], this.boundIndexBuffer = null, this.boundVertexOffset = null, this.boundDynamicVertexBuffers = [], this.vao = null;\n      }\n      bind(e, t, i, o, r, n, s) {\n        this.context = e;\n        let a = this.boundPaintVertexBuffers.length !== o.length;\n        for (let e = 0; !a && e < o.length; e++) this.boundPaintVertexBuffers[e] !== o[e] && (a = !0);\n        let l = this.boundDynamicVertexBuffers.length !== s.length;\n        for (let e = 0; !l && e < s.length; e++) this.boundDynamicVertexBuffers[e] !== s[e] && (l = !0);\n        if (!e.extVertexArrayObject || !this.vao || this.boundProgram !== t || this.boundLayoutVertexBuffer !== i || a || l || this.boundIndexBuffer !== r || this.boundVertexOffset !== n) this.freshBind(t, i, o, r, n, s);else {\n          e.bindVertexArrayOES.set(this.vao);\n          for (const e of s) e && e.bind();\n          r && r.dynamicDraw && r.bind();\n        }\n      }\n      freshBind(e, t, i, o, r, n) {\n        let s;\n        const a = e.numAttributes,\n          l = this.context,\n          c = l.gl;\n        if (l.extVertexArrayObject) this.vao && this.destroy(), this.vao = l.extVertexArrayObject.createVertexArrayOES(), l.bindVertexArrayOES.set(this.vao), s = 0, this.boundProgram = e, this.boundLayoutVertexBuffer = t, this.boundPaintVertexBuffers = i, this.boundIndexBuffer = o, this.boundVertexOffset = r, this.boundDynamicVertexBuffers = n;else {\n          s = l.currentNumAttributes || 0;\n          for (let e = a; e < s; e++) c.disableVertexAttribArray(e);\n        }\n        t.enableAttributes(c, e), t.bind(), t.setVertexAttribPointers(c, e, r);\n        for (const t of i) t.enableAttributes(c, e), t.bind(), t.setVertexAttribPointers(c, e, r);\n        for (const t of n) t && (t.enableAttributes(c, e), t.bind(), t.setVertexAttribPointers(c, e, r));\n        o && o.bind(), l.currentNumAttributes = a;\n      }\n      destroy() {\n        this.vao && (this.context.extVertexArrayObject.deleteVertexArrayOES(this.vao), this.vao = null);\n      }\n    }\n    function di(t, i) {\n      const o = Math.pow(2, i.canonical.z),\n        r = i.canonical.y;\n      return [new e.MercatorCoordinate(0, r / o).toLngLat().lat, new e.MercatorCoordinate(0, (r + 1) / o).toLngLat().lat];\n    }\n    function pi(t, i, o, r, n, s, a) {\n      const l = t.context,\n        c = l.gl,\n        h = o.fbo;\n      if (!h) return;\n      t.prepareDrawTile();\n      const u = t.useProgram(\"hillshade\");\n      l.activeTexture.set(c.TEXTURE0), c.bindTexture(c.TEXTURE_2D, h.colorAttachment.get());\n      const _ = ((e, t, i, o) => {\n        const r = i.paint.get(\"hillshade-shadow-color\"),\n          n = i.paint.get(\"hillshade-highlight-color\"),\n          s = i.paint.get(\"hillshade-accent-color\");\n        let a = i.paint.get(\"hillshade-illumination-direction\") * (Math.PI / 180);\n        \"viewport\" === i.paint.get(\"hillshade-illumination-anchor\") && (a -= e.transform.angle);\n        const l = !e.options.moving;\n        return {\n          u_matrix: o || e.transform.calculateProjMatrix(t.tileID.toUnwrapped(), l),\n          u_image: 0,\n          u_latrange: di(0, t.tileID),\n          u_light: [i.paint.get(\"hillshade-exaggeration\"), a],\n          u_shadow: r,\n          u_highlight: n,\n          u_accent: s\n        };\n      })(t, o, r, t.terrain ? i.projMatrix : null);\n      t.prepareDrawProgram(l, u, i.toUnwrapped());\n      const {\n        tileBoundsBuffer: d,\n        tileBoundsIndexBuffer: p,\n        tileBoundsSegments: m\n      } = t.getTileBoundsBuffers(o);\n      u.draw(l, c.TRIANGLES, n, s, a, e.CullFaceMode.disabled, _, r.id, d, p, m);\n    }\n    function mi(t, i, o) {\n      if (!i.needsDEMTextureUpload) return;\n      const r = t.context,\n        n = r.gl;\n      r.pixelStoreUnpackPremultiplyAlpha.set(!1), i.demTexture = i.demTexture || t.getTileTexture(o.stride);\n      const s = o.getPixels();\n      i.demTexture ? i.demTexture.update(s, {\n        premultiply: !1\n      }) : i.demTexture = new e.Texture(r, s, n.RGBA, {\n        premultiply: !1\n      }), i.needsDEMTextureUpload = !1;\n    }\n    function fi(t, i, o, r, n, s) {\n      const a = t.context,\n        l = a.gl;\n      if (!i.dem) return;\n      const c = i.dem;\n      if (a.activeTexture.set(l.TEXTURE1), mi(t, i, c), !i.demTexture) return;\n      i.demTexture.bind(l.NEAREST, l.CLAMP_TO_EDGE);\n      const h = c.dim;\n      a.activeTexture.set(l.TEXTURE0);\n      let u = i.fbo;\n      if (!u) {\n        const t = new e.Texture(a, {\n          width: h,\n          height: h,\n          data: null\n        }, l.RGBA);\n        t.bind(l.LINEAR, l.CLAMP_TO_EDGE), u = i.fbo = a.createFramebuffer(h, h, !0), u.colorAttachment.set(t.texture);\n      }\n      a.bindFramebuffer.set(u.framebuffer), a.viewport.set([0, 0, h, h]);\n      const {\n        tileBoundsBuffer: _,\n        tileBoundsIndexBuffer: d,\n        tileBoundsSegments: p\n      } = t.getMercatorTileBoundsBuffers();\n      t.useProgram(\"hillshadePrepare\").draw(a, l.TRIANGLES, r, n, s, e.CullFaceMode.disabled, ((t, i) => {\n        const o = i.stride,\n          r = e.create();\n        return e.ortho(r, 0, e.EXTENT, -e.EXTENT, 0, 0, 1), e.translate(r, r, [0, -e.EXTENT, 0]), {\n          u_matrix: r,\n          u_image: 1,\n          u_dimension: [o, o],\n          u_zoom: t.overscaledZ,\n          u_unpack: i.unpackVector\n        };\n      })(i.tileID, c), o.id, _, d, p), i.needsHillshadePrepare = !1;\n    }\n    const gi = t => ({\n        u_matrix: new e.UniformMatrix4f(t),\n        u_image0: new e.Uniform1i(t),\n        u_skirt_height: new e.Uniform1f(t)\n      }),\n      vi = (e, t) => ({\n        u_matrix: e,\n        u_image0: 0,\n        u_skirt_height: t\n      }),\n      xi = (e, t, i, o, r, n, s, a, l, c, h, u, _, d, p) => ({\n        u_proj_matrix: Float32Array.from(e),\n        u_globe_matrix: t,\n        u_normalize_matrix: Float32Array.from(o),\n        u_merc_matrix: i,\n        u_zoom_transition: r,\n        u_merc_center: n,\n        u_image0: 0,\n        u_frustum_tl: s,\n        u_frustum_tr: a,\n        u_frustum_br: l,\n        u_frustum_bl: c,\n        u_globe_pos: h,\n        u_globe_radius: u,\n        u_viewport: _,\n        u_grid_matrix: p ? Float32Array.from(p) : new Float32Array(9),\n        u_skirt_height: d\n      });\n    function yi(e, t) {\n      return null != e && null != t && !(!e.hasData() || !t.hasData()) && null != e.demTexture && null != t.demTexture && e.tileID.key !== t.tileID.key;\n    }\n    const bi = new class {\n        constructor() {\n          this.operations = {};\n        }\n        newMorphing(e, t, i, o, r) {\n          if (e in this.operations) {\n            const t = this.operations[e];\n            t.to.tileID.key !== i.tileID.key && (t.queued = i);\n          } else this.operations[e] = {\n            startTime: o,\n            phase: 0,\n            duration: r,\n            from: t,\n            to: i,\n            queued: null\n          };\n        }\n        getMorphValuesForProxy(e) {\n          if (!(e in this.operations)) return null;\n          const t = this.operations[e];\n          return {\n            from: t.from,\n            to: t.to,\n            phase: t.phase\n          };\n        }\n        update(e) {\n          for (const t in this.operations) {\n            const i = this.operations[t];\n            for (i.phase = (e - i.startTime) / i.duration; i.phase >= 1 || !this._validOp(i);) if (!this._nextOp(i, e)) {\n              delete this.operations[t];\n              break;\n            }\n          }\n        }\n        _nextOp(e, t) {\n          return !!e.queued && (e.from = e.to, e.to = e.queued, e.queued = null, e.phase = 0, e.startTime = t, !0);\n        }\n        _validOp(e) {\n          return e.from.hasData() && e.to.hasData();\n        }\n      }(),\n      wi = {\n        0: null,\n        1: \"TERRAIN_VERTEX_MORPHING\",\n        2: \"TERRAIN_WIREFRAME\"\n      };\n    function Ti(e) {\n      return 6 * Math.pow(1.5, 22 - e);\n    }\n    function Ei(e, t) {\n      const i = 1 << e.z;\n      return !t && (0 === e.x || e.x === i - 1) || 0 === e.y || e.y === i - 1;\n    }\n    const Ci = e => ({\n      u_matrix: e\n    });\n    function Mi(t, i, o, r, n) {\n      if (n > 0) {\n        const s = e.exported.now(),\n          a = (s - t.timeAdded) / n,\n          l = i ? (s - i.timeAdded) / n : -1,\n          c = o.getSource(),\n          h = r.coveringZoomLevel({\n            tileSize: c.tileSize,\n            roundZoom: c.roundZoom\n          }),\n          u = !i || Math.abs(i.tileID.overscaledZ - h) > Math.abs(t.tileID.overscaledZ - h),\n          _ = u && t.refreshedUponExpiration ? 1 : e.clamp(u ? a : 1 - l, 0, 1);\n        return t.refreshedUponExpiration && a >= 1 && (t.refreshedUponExpiration = !1), i ? {\n          opacity: 1,\n          mix: 1 - _\n        } : {\n          opacity: _,\n          mix: 0\n        };\n      }\n      return {\n        opacity: 1,\n        mix: 0\n      };\n    }\n    class Ii extends e.SourceCache {\n      constructor(e) {\n        const t = {\n            type: \"raster-dem\",\n            maxzoom: e.transform.maxZoom\n          },\n          i = new S(Ue(), null),\n          o = De(\"mock-dem\", t, i, e.style);\n        super(\"mock-dem\", o, !1), o.setEventedParent(this), this._sourceLoaded = !0;\n      }\n      _loadTile(e, t) {\n        e.state = \"loaded\", t(null);\n      }\n    }\n    class Pi extends e.SourceCache {\n      constructor(e) {\n        const t = De(\"proxy\", {\n          type: \"geojson\",\n          maxzoom: e.transform.maxZoom\n        }, new S(Ue(), null), e.style);\n        super(\"proxy\", t, !1), t.setEventedParent(this), this.map = this.getSource().map = e, this.used = this._sourceLoaded = !0, this.renderCache = [], this.renderCachePool = [], this.proxyCachedFBO = {};\n      }\n      update(t, i, o) {\n        if (t.freezeTileCoverage) return;\n        this.transform = t;\n        const r = t.coveringTiles({\n          tileSize: this._source.tileSize,\n          minzoom: this._source.minzoom,\n          maxzoom: this._source.maxzoom,\n          roundZoom: this._source.roundZoom,\n          reparseOverscaled: this._source.reparseOverscaled\n        }).reduce((i, o) => {\n          if (i[o.key] = \"\", !this._tiles[o.key]) {\n            const i = new e.Tile(o, this._source.tileSize * o.overscaleFactor(), t.tileZoom);\n            i.state = \"loaded\", this._tiles[o.key] = i;\n          }\n          return i;\n        }, {});\n        for (const e in this._tiles) e in r || (this.freeFBO(e), this._tiles[e].unloadVectorData(), delete this._tiles[e]);\n      }\n      freeFBO(e) {\n        const t = this.proxyCachedFBO[e];\n        if (void 0 !== t) {\n          const i = Object.values(t);\n          this.renderCachePool.push(...i), delete this.proxyCachedFBO[e];\n        }\n      }\n      deallocRenderCache() {\n        this.renderCache.forEach(e => e.fb.destroy()), this.renderCache = [], this.renderCachePool = [], this.proxyCachedFBO = {};\n      }\n    }\n    class Si extends e.OverscaledTileID {\n      constructor(e, t, i) {\n        super(e.overscaledZ, e.wrap, e.canonical.z, e.canonical.x, e.canonical.y), this.proxyTileKey = t, this.projMatrix = i;\n      }\n    }\n    class Di extends e.Elevation {\n      constructor(t, i) {\n        super(), this.painter = t, this.terrainTileForTile = {}, this.prevTerrainTileForTile = {};\n        const [o, r, n] = function (t) {\n            const i = new e.StructArrayLayout2i4(),\n              o = new e.StructArrayLayout3ui6(),\n              r = 131;\n            i.reserve(17161), o.reserve(33800);\n            const n = e.EXTENT / 128,\n              s = e.EXTENT + n / 2,\n              a = s + n;\n            for (let t = -n; t < a; t += n) for (let o = -n; o < a; o += n) {\n              const r = o < 0 || o > s || t < 0 || t > s ? 24575 : 0,\n                n = e.clamp(Math.round(o), 0, e.EXTENT),\n                a = e.clamp(Math.round(t), 0, e.EXTENT);\n              i.emplaceBack(n + r, a);\n            }\n            const l = (e, t) => {\n              const i = t * r + e;\n              o.emplaceBack(i + 1, i, i + r), o.emplaceBack(i + r, i + r + 1, i + 1);\n            };\n            for (let e = 1; e < 129; e++) for (let t = 1; t < 129; t++) l(t, e);\n            return [0, 129].forEach(e => {\n              for (let t = 0; t < 130; t++) l(t, e), l(e, t);\n            }), [i, o, 32768];\n          }(),\n          s = t.context;\n        this.gridBuffer = s.createVertexBuffer(o, e.posAttributes.members), this.gridIndexBuffer = s.createIndexBuffer(r), this.gridSegments = e.SegmentVector.simpleSegment(0, 0, o.length, r.length), this.gridNoSkirtSegments = e.SegmentVector.simpleSegment(0, 0, o.length, n), this.proxyCoords = [], this.proxiedCoords = {}, this._visibleDemTiles = [], this._drapedRenderBatches = [], this._sourceTilesOverlap = {}, this.proxySourceCache = new Pi(i.map), this.orthoMatrix = e.create(), e.ortho(this.orthoMatrix, \"globe\" === this.painter.transform.projection.name ? .015 : 0, e.EXTENT, 0, e.EXTENT, 0, 1);\n        const a = s.gl;\n        this._overlapStencilMode = new e.StencilMode({\n          func: a.GEQUAL,\n          mask: 255\n        }, 0, 255, a.KEEP, a.KEEP, a.REPLACE), this._previousZoom = t.transform.zoom, this.pool = [], this._findCoveringTileCache = {}, this._tilesDirty = {}, this.style = i, this._useVertexMorphing = !0, this._exaggeration = 1, this._mockSourceCache = new Ii(i.map);\n      }\n      set style(e) {\n        e.on(\"data\", this._onStyleDataEvent.bind(this)), e.on(\"neworder\", this._checkRenderCacheEfficiency.bind(this)), this._style = e, this._checkRenderCacheEfficiency(), this._style.map.on(\"moveend\", () => {\n          this._clearLineLayersFromRenderCache();\n        });\n      }\n      update(t, i, o) {\n        if (t && t.terrain) {\n          this._style !== t && (this.style = t), this.enabled = !0;\n          const r = t.terrain.properties;\n          this.sourceCache = 0 === t.terrain.drapeRenderMode ? this._mockSourceCache : t._getSourceCache(r.get(\"source\")), this._exaggeration = r.get(\"exaggeration\");\n          const n = () => {\n            this.sourceCache.used && e.warnOnce(`Raster DEM source '${this.sourceCache.id}' is used both for terrain and as layer source.\\nThis leads to lower resolution of hillshade. For full hillshade resolution but higher memory consumption, define another raster DEM source.`);\n            const t = this.getScaledDemTileSize();\n            this.sourceCache.update(i, t, !0), this.resetTileLookupCache(this.sourceCache.id);\n          };\n          this.sourceCache.usedForTerrain || (this.resetTileLookupCache(this.sourceCache.id), this.sourceCache.usedForTerrain = !0, n(), this._initializing = !0), n(), i.updateElevation(!0, o), this.resetTileLookupCache(this.proxySourceCache.id), this.proxySourceCache.update(i), this._emptyDEMTextureDirty = !0;\n        } else this._disable();\n      }\n      resetTileLookupCache(e) {\n        this._findCoveringTileCache[e] = {};\n      }\n      getScaledDemTileSize() {\n        return this.sourceCache.getSource().tileSize / 128 * this.proxySourceCache.getSource().tileSize;\n      }\n      _checkRenderCacheEfficiency() {\n        const t = this.renderCacheEfficiency(this._style);\n        this._style.map._optimizeForTerrain || 100 !== t.efficiency && e.warnOnce(`Terrain render cache efficiency is not optimal (${t.efficiency}%) and performance\\n                may be affected negatively, consider placing all background, fill and line layers before layer\\n                with id '${t.firstUndrapedLayer}' or create a map using optimizeForTerrain: true option.`);\n      }\n      _onStyleDataEvent(e) {\n        e.coord && \"source\" === e.dataType ? this._clearRenderCacheForTile(e.sourceCacheId, e.coord) : \"style\" === e.dataType && (this._invalidateRenderCache = !0);\n      }\n      _disable() {\n        if (this.enabled && (this.enabled = !1, this._sharedDepthStencil = void 0, this.proxySourceCache.deallocRenderCache(), this._style)) for (const e in this._style._sourceCaches) this._style._sourceCaches[e].usedForTerrain = !1;\n      }\n      destroy() {\n        this._disable(), this._emptyDEMTexture && this._emptyDEMTexture.destroy(), this._emptyDepthBufferTexture && this._emptyDepthBufferTexture.destroy(), this.pool.forEach(e => e.fb.destroy()), this.pool = [], this._depthFBO && (this._depthFBO.destroy(), this._depthFBO = void 0, this._depthTexture = void 0);\n      }\n      _source() {\n        return this.enabled ? this.sourceCache : null;\n      }\n      isUsingMockSource() {\n        return this.sourceCache === this._mockSourceCache;\n      }\n      exaggeration() {\n        return this._exaggeration;\n      }\n      get visibleDemTiles() {\n        return this._visibleDemTiles;\n      }\n      get drapeBufferSize() {\n        const e = 2 * this.proxySourceCache.getSource().tileSize;\n        return [e, e];\n      }\n      set useVertexMorphing(e) {\n        this._useVertexMorphing = e;\n      }\n      updateTileBinding(t) {\n        if (!this.enabled) return;\n        this.prevTerrainTileForTile = this.terrainTileForTile;\n        const i = this.proxySourceCache,\n          o = this.painter.transform;\n        this._initializing && (this._initializing = 0 === o._centerAltitude && -1 === this.getAtPointOrZero(e.MercatorCoordinate.fromLngLat(o.center), -1), this._emptyDEMTextureDirty = !this._initializing);\n        const r = this.proxyCoords = i.getIds().map(e => {\n          const t = i.getTileByID(e).tileID;\n          return t.projMatrix = o.calculateProjMatrix(t.toUnwrapped()), t;\n        });\n        !function (t, i) {\n          const o = i.transform.pointCoordinate(i.transform.getCameraPoint()),\n            r = new e.Point(o.x, o.y);\n          t.sort((t, i) => {\n            if (i.overscaledZ - t.overscaledZ) return i.overscaledZ - t.overscaledZ;\n            const o = new e.Point(t.canonical.x + (1 << t.canonical.z) * t.wrap, t.canonical.y),\n              n = new e.Point(i.canonical.x + (1 << i.canonical.z) * i.wrap, i.canonical.y),\n              s = r.mult(1 << t.canonical.z);\n            return s.x -= .5, s.y -= .5, s.distSqr(o) - s.distSqr(n);\n          });\n        }(r, this.painter), this._previousZoom = o.zoom;\n        const n = this.proxyToSource || {};\n        this.proxyToSource = {}, r.forEach(e => {\n          this.proxyToSource[e.key] = {};\n        }), this.terrainTileForTile = {};\n        const s = this._style._sourceCaches;\n        for (const e in s) {\n          const i = s[e];\n          if (!i.used) continue;\n          if (i !== this.sourceCache && this.resetTileLookupCache(i.id), this._setupProxiedCoordsForOrtho(i, t[e], n), i.usedForTerrain) continue;\n          const o = t[e];\n          i.getSource().reparseOverscaled && this._assignTerrainTiles(o);\n        }\n        this.proxiedCoords[i.id] = r.map(e => new Si(e, e.key, this.orthoMatrix)), this._assignTerrainTiles(r), this._prepareDEMTextures(), this._setupDrapedRenderBatches(), this._initFBOPool(), this._setupRenderCache(n), this.renderingToTexture = !1, this._updateTimestamp = e.exported.now();\n        const a = {};\n        this._visibleDemTiles = [];\n        for (const e of this.proxyCoords) {\n          const t = this.terrainTileForTile[e.key];\n          if (!t) continue;\n          const i = t.tileID.key;\n          i in a || (this._visibleDemTiles.push(t), a[i] = i);\n        }\n      }\n      _assignTerrainTiles(e) {\n        this._initializing || e.forEach(e => {\n          if (this.terrainTileForTile[e.key]) return;\n          const t = this._findTileCoveringTileID(e, this.sourceCache);\n          t && (this.terrainTileForTile[e.key] = t);\n        });\n      }\n      _prepareDEMTextures() {\n        const e = this.painter.context,\n          t = e.gl;\n        for (const i in this.terrainTileForTile) {\n          const o = this.terrainTileForTile[i],\n            r = o.dem;\n          !r || o.demTexture && !o.needsDEMTextureUpload || (e.activeTexture.set(t.TEXTURE1), mi(this.painter, o, r));\n        }\n      }\n      _prepareDemTileUniforms(e, t, i, o) {\n        if (!t || null == t.demTexture) return !1;\n        const r = e.tileID.canonical,\n          n = Math.pow(2, t.tileID.canonical.z - r.z),\n          s = o || \"\";\n        return i[`u_dem_tl${s}`] = [r.x * n % 1, r.y * n % 1], i[`u_dem_scale${s}`] = n, !0;\n      }\n      get emptyDEMTexture() {\n        return !this._emptyDEMTextureDirty && this._emptyDEMTexture ? this._emptyDEMTexture : this._updateEmptyDEMTexture();\n      }\n      get emptyDepthBufferTexture() {\n        const t = this.painter.context,\n          i = t.gl;\n        if (!this._emptyDepthBufferTexture) {\n          const o = new e.RGBAImage({\n            width: 1,\n            height: 1\n          }, Uint8Array.of(255, 255, 255, 255));\n          this._emptyDepthBufferTexture = new e.Texture(t, o, i.RGBA, {\n            premultiply: !1\n          });\n        }\n        return this._emptyDepthBufferTexture;\n      }\n      _getLoadedAreaMinimum() {\n        let e = 0;\n        const t = this._visibleDemTiles.reduce((t, i) => {\n          if (!i.dem) return t;\n          const o = i.dem.tree.minimums[0];\n          return o > 0 && e++, t + o;\n        }, 0);\n        return e ? t / e : 0;\n      }\n      _updateEmptyDEMTexture() {\n        const t = this.painter.context,\n          i = t.gl;\n        t.activeTexture.set(i.TEXTURE2);\n        const o = this._getLoadedAreaMinimum(),\n          r = new e.RGBAImage({\n            width: 1,\n            height: 1\n          }, new Uint8Array(e.DEMData.pack(o, this.sourceCache.getSource().encoding)));\n        this._emptyDEMTextureDirty = !1;\n        let n = this._emptyDEMTexture;\n        return n ? n.update(r, {\n          premultiply: !1\n        }) : n = this._emptyDEMTexture = new e.Texture(t, r, i.RGBA, {\n          premultiply: !1\n        }), n;\n      }\n      setupElevationDraw(t, i, o) {\n        const r = this.painter.context,\n          n = r.gl,\n          s = (a = this.sourceCache.getSource().encoding, {\n            u_dem: 2,\n            u_dem_prev: 4,\n            u_dem_unpack: e.DEMData.getUnpackVector(a),\n            u_dem_tl: [0, 0],\n            u_dem_tl_prev: [0, 0],\n            u_dem_scale: 0,\n            u_dem_scale_prev: 0,\n            u_dem_size: 0,\n            u_dem_lerp: 1,\n            u_depth: 3,\n            u_depth_size_inv: [0, 0],\n            u_exaggeration: 0\n          });\n        var a;\n        s.u_dem_size = this.sourceCache.getSource().tileSize, s.u_exaggeration = this.exaggeration();\n        let l = null,\n          c = null,\n          h = 1;\n        if (o && o.morphing && this._useVertexMorphing) {\n          const e = o.morphing.srcDemTile,\n            i = o.morphing.dstDemTile;\n          h = o.morphing.phase, e && i && (this._prepareDemTileUniforms(t, e, s, \"_prev\") && (c = e), this._prepareDemTileUniforms(t, i, s) && (l = i));\n        }\n        if (c && l ? (r.activeTexture.set(n.TEXTURE2), l.demTexture.bind(n.NEAREST, n.CLAMP_TO_EDGE, n.NEAREST), r.activeTexture.set(n.TEXTURE4), c.demTexture.bind(n.NEAREST, n.CLAMP_TO_EDGE, n.NEAREST), s.u_dem_lerp = h) : (l = this.terrainTileForTile[t.tileID.key], r.activeTexture.set(n.TEXTURE2), (this._prepareDemTileUniforms(t, l, s) ? l.demTexture : this.emptyDEMTexture).bind(n.NEAREST, n.CLAMP_TO_EDGE)), r.activeTexture.set(n.TEXTURE3), o && o.useDepthForOcclusion ? (this._depthTexture && this._depthTexture.bind(n.NEAREST, n.CLAMP_TO_EDGE), this._depthFBO && (s.u_depth_size_inv = [1 / this._depthFBO.width, 1 / this._depthFBO.height])) : (this.emptyDepthBufferTexture.bind(n.NEAREST, n.CLAMP_TO_EDGE), s.u_depth_size_inv = [1, 1]), o && o.useMeterToDem && l) {\n          const t = (1 << l.tileID.canonical.z) * e.mercatorZfromAltitude(1, this.painter.transform.center.lat) * this.sourceCache.getSource().tileSize;\n          s.u_meter_to_dem = t;\n        }\n        if (o && o.labelPlaneMatrixInv && (s.u_label_plane_matrix_inv = o.labelPlaneMatrixInv), i.setTerrainUniformValues(r, s), \"globe\" === this.painter.transform.projection.name) {\n          const e = this.globeUniformValues(this.painter.transform, t.tileID.canonical, o && o.useDenormalizedUpVectorScale);\n          i.setGlobeUniformValues(r, e);\n        }\n      }\n      globeUniformValues(t, i, o) {\n        const r = t.projection;\n        return {\n          u_tile_tl_up: r.upVector(i, 0, 0),\n          u_tile_tr_up: r.upVector(i, e.EXTENT, 0),\n          u_tile_br_up: r.upVector(i, e.EXTENT, e.EXTENT),\n          u_tile_bl_up: r.upVector(i, 0, e.EXTENT),\n          u_tile_up_scale: o ? e.globeMetersToEcef(1) : r.upVectorScale(i, t.center.lat, t.worldSize).metersToTile\n        };\n      }\n      renderToBackBuffer(t) {\n        const i = this.painter,\n          o = this.painter.context;\n        0 !== t.length && (o.bindFramebuffer.set(null), o.viewport.set([0, 0, i.width, i.height]), i.gpuTimingDeferredRenderStart(), this.renderingToTexture = !1, function (t, i, o, r, n) {\n          if (\"globe\" === t.transform.projection.name) !function (t, i, o, r, n) {\n            const s = t.context,\n              a = s.gl;\n            let l, c;\n            const h = t.options.showTerrainWireframe ? 2 : 0,\n              u = t.transform,\n              _ = e.globeUseCustomAntiAliasing(t, s, u),\n              d = (e, i) => {\n                if (c === e) return;\n                const o = [wi[e], \"PROJECTION_GLOBE_VIEW\"];\n                _ && o.push(\"CUSTOM_ANTIALIASING\"), i && o.push(wi[h]), l = t.useProgram(\"globeRaster\", null, o), c = e;\n              },\n              p = t.colorModeForRenderPass(),\n              m = new e.DepthMode(a.LEQUAL, e.DepthMode.ReadWrite, t.depthRangeFor3D);\n            bi.update(n);\n            const f = e.calculateGlobeMercatorMatrix(u),\n              g = [e.mercatorXfromLng(u.center.lng), e.mercatorYfromLat(u.center.lat)],\n              v = h ? [!1, !0] : [!1],\n              x = t.globeSharedBuffers,\n              y = [u.width * e.exported.devicePixelRatio, u.height * e.exported.devicePixelRatio],\n              b = Float32Array.from(u.globeMatrix),\n              w = {\n                useDenormalizedUpVectorScale: !0\n              };\n            if (v.forEach(h => {\n              const u = t.transform,\n                _ = Ti(u.zoom) * i.exaggeration();\n              c = -1;\n              const v = h ? a.LINES : a.TRIANGLES;\n              for (const c of r) {\n                const r = o.getTile(c),\n                  T = e.StencilMode.disabled,\n                  E = i.prevTerrainTileForTile[c.key],\n                  C = i.terrainTileForTile[c.key];\n                yi(E, C) && bi.newMorphing(c.key, E, C, n, 250), s.activeTexture.set(a.TEXTURE0), r.texture.bind(a.LINEAR, a.CLAMP_TO_EDGE);\n                const M = bi.getMorphValuesForProxy(c.key),\n                  I = M ? 1 : 0;\n                M && e.extend$1(w, {\n                  morphing: {\n                    srcDemTile: M.from,\n                    dstDemTile: M.to,\n                    phase: e.easeCubicInOut(M.phase)\n                  }\n                });\n                const P = e.tileCornersToBounds(c.canonical),\n                  S = e.getLatitudinalLod(P.getCenter().lat),\n                  D = e.getGridMatrix(c.canonical, P, S, u.worldSize / u._pixelsPerMercatorPixel),\n                  L = e.globeNormalizeECEF(e.globeTileBounds(c.canonical)),\n                  A = xi(u.projMatrix, b, f, L, e.globeToMercatorTransition(u.zoom), g, u.frustumCorners.TL, u.frustumCorners.TR, u.frustumCorners.BR, u.frustumCorners.BL, u.globeCenterInViewSpace, u.globeRadius, y, _, D);\n                if (d(I, h), i.setupElevationDraw(r, l, w), t.prepareDrawProgram(s, l, c.toUnwrapped()), x) {\n                  const [i, o, r] = h ? x.getWirefameBuffers(t.context, S) : x.getGridBuffers(S, 0 !== _);\n                  l.draw(s, v, m, T, p, e.CullFaceMode.backCCW, A, \"globe_raster\", i, o, r);\n                }\n              }\n            }), x) {\n              const n = [\"GLOBE_POLES\", \"PROJECTION_GLOBE_VIEW\"];\n              _ && n.push(\"CUSTOM_ANTIALIASING\"), l = t.useProgram(\"globeRaster\", null, n);\n              for (const n of r) {\n                const {\n                    x: r,\n                    y: c,\n                    z: h\n                  } = n.canonical,\n                  _ = 0 === c,\n                  d = c === (1 << h) - 1,\n                  [f, v, b, T] = x.getPoleBuffers(h);\n                if (T && (_ || d)) {\n                  const c = o.getTile(n);\n                  s.activeTexture.set(a.TEXTURE0), c.texture.bind(a.LINEAR, a.CLAMP_TO_EDGE);\n                  let x = e.globePoleMatrixForTile(h, r, u);\n                  const E = e.globeNormalizeECEF(e.globeTileBounds(n.canonical)),\n                    C = (t, i) => t.draw(s, a.TRIANGLES, m, e.StencilMode.disabled, p, e.CullFaceMode.disabled, xi(u.projMatrix, x, x, E, 0, g, u.frustumCorners.TL, u.frustumCorners.TR, u.frustumCorners.BR, u.frustumCorners.BL, u.globeCenterInViewSpace, u.globeRadius, y, 0), \"globe_pole_raster\", i, b, T);\n                  i.setupElevationDraw(c, l, w), t.prepareDrawProgram(s, l, n.toUnwrapped()), _ && C(l, f), d && (x = e.scale(e.create(), x, [1, -1, 1]), C(l, v));\n                }\n              }\n            }\n          }(t, i, o, r, n);else {\n            const s = t.context,\n              a = s.gl;\n            let l, c;\n            const h = t.options.showTerrainWireframe ? 2 : 0,\n              u = (e, i) => {\n                if (c === e) return;\n                const o = [wi[e]];\n                i && o.push(wi[h]), l = t.useProgram(\"terrainRaster\", null, o), c = e;\n              },\n              _ = t.colorModeForRenderPass(),\n              d = new e.DepthMode(a.LEQUAL, e.DepthMode.ReadWrite, t.depthRangeFor3D);\n            bi.update(n);\n            const p = t.transform,\n              m = Ti(p.zoom) * i.exaggeration();\n            (h ? [!1, !0] : [!1]).forEach(h => {\n              c = -1;\n              const f = h ? a.LINES : a.TRIANGLES,\n                [g, v] = h ? i.getWirefameBuffer() : [i.gridIndexBuffer, i.gridSegments];\n              for (const c of r) {\n                const r = o.getTile(c),\n                  x = e.StencilMode.disabled,\n                  y = i.prevTerrainTileForTile[c.key],\n                  b = i.terrainTileForTile[c.key];\n                yi(y, b) && bi.newMorphing(c.key, y, b, n, 250), s.activeTexture.set(a.TEXTURE0), r.texture.bind(a.LINEAR, a.CLAMP_TO_EDGE, a.LINEAR_MIPMAP_NEAREST);\n                const w = bi.getMorphValuesForProxy(c.key),\n                  T = w ? 1 : 0;\n                let E;\n                w && (E = {\n                  morphing: {\n                    srcDemTile: w.from,\n                    dstDemTile: w.to,\n                    phase: e.easeCubicInOut(w.phase)\n                  }\n                });\n                const C = vi(c.projMatrix, Ei(c.canonical, p.renderWorldCopies) ? m / 10 : m);\n                u(T, h), i.setupElevationDraw(r, l, E), t.prepareDrawProgram(s, l, c.toUnwrapped()), l.draw(s, f, d, x, _, e.CullFaceMode.backCCW, C, \"terrain_raster\", i.gridBuffer, g, v);\n              }\n            });\n          }\n        }(i, this, this.proxySourceCache, t, this._updateTimestamp), this.renderingToTexture = !0, i.gpuTimingDeferredRenderEnd(), t.splice(0, t.length));\n      }\n      renderBatch(t) {\n        if (0 === this._drapedRenderBatches.length) return t + 1;\n        this.renderingToTexture = !0;\n        const i = this.painter,\n          o = this.painter.context,\n          r = this.proxySourceCache,\n          n = this.proxiedCoords[r.id],\n          s = this._drapedRenderBatches.shift(),\n          a = [],\n          l = i.style.order;\n        let c = 0;\n        for (const h of n) {\n          const n = r.getTileByID(h.proxyTileKey),\n            u = r.proxyCachedFBO[h.key] ? r.proxyCachedFBO[h.key][t] : void 0,\n            _ = void 0 !== u ? r.renderCache[u] : this.pool[c++],\n            d = void 0 !== u;\n          if (n.texture = _.tex, d && !_.dirty) {\n            a.push(n.tileID);\n            continue;\n          }\n          let p;\n          o.bindFramebuffer.set(_.fb.framebuffer), this.renderedToTile = !1, _.dirty && (o.clear({\n            color: e.Color.transparent,\n            stencil: 0\n          }), _.dirty = !1);\n          for (let e = s.start; e <= s.end; ++e) {\n            const t = i.style._layers[l[e]];\n            if (t.isHidden(i.transform.zoom)) continue;\n            const r = i.style._getLayerSourceCache(t),\n              n = r ? this.proxyToSource[h.key][r.id] : [h];\n            if (!n) continue;\n            const s = n;\n            o.viewport.set([0, 0, _.fb.width, _.fb.height]), p !== (r ? r.id : null) && (this._setupStencil(_, n, t, r), p = r ? r.id : null), i.renderLayer(i, r, t, s);\n          }\n          this.renderedToTile ? (_.dirty = !0, a.push(n.tileID)) : d || --c, 5 === c && (c = 0, this.renderToBackBuffer(a));\n        }\n        return this.renderToBackBuffer(a), this.renderingToTexture = !1, o.bindFramebuffer.set(null), o.viewport.set([0, 0, i.width, i.height]), s.end + 1;\n      }\n      postRender() {}\n      renderCacheEfficiency(e) {\n        const t = e.order.length;\n        if (0 === t) return {\n          efficiency: 100\n        };\n        let i,\n          o = 0,\n          r = 0,\n          n = !1;\n        for (let s = 0; s < t; ++s) {\n          const t = e._layers[e.order[s]];\n          this._style.isLayerDraped(t) ? (n && ++o, ++r) : n || (n = !0, i = t.id);\n        }\n        return 0 === r ? {\n          efficiency: 100\n        } : {\n          efficiency: 100 * (1 - o / r),\n          firstUndrapedLayer: i\n        };\n      }\n      getMinElevationBelowMSL() {\n        let e = 0;\n        return this._visibleDemTiles.filter(e => e.dem).forEach(t => {\n          e = Math.min(e, t.dem.tree.minimums[0]);\n        }), 0 === e ? e : (e - 30) * this._exaggeration;\n      }\n      raycast(e, t, i) {\n        if (!this._visibleDemTiles) return null;\n        const o = this._visibleDemTiles.filter(e => e.dem).map(o => {\n          const r = o.tileID,\n            n = 1 << r.overscaledZ,\n            {\n              x: s,\n              y: a\n            } = r.canonical,\n            l = s / n,\n            c = (s + 1) / n,\n            h = a / n,\n            u = (a + 1) / n;\n          return {\n            minx: l,\n            miny: h,\n            maxx: c,\n            maxy: u,\n            t: o.dem.tree.raycastRoot(l, h, c, u, e, t, i),\n            tile: o\n          };\n        });\n        o.sort((e, t) => (null !== e.t ? e.t : Number.MAX_VALUE) - (null !== t.t ? t.t : Number.MAX_VALUE));\n        for (const r of o) {\n          if (null == r.t) return null;\n          const o = r.tile.dem.tree.raycast(r.minx, r.miny, r.maxx, r.maxy, e, t, i);\n          if (null != o) return o;\n        }\n        return null;\n      }\n      _createFBO() {\n        const t = this.painter.context,\n          i = t.gl,\n          o = this.drapeBufferSize;\n        t.activeTexture.set(i.TEXTURE0);\n        const r = new e.Texture(t, {\n          width: o[0],\n          height: o[1],\n          data: null\n        }, i.RGBA);\n        r.bind(i.LINEAR, i.CLAMP_TO_EDGE);\n        const n = t.createFramebuffer(o[0], o[1], !1);\n        return n.colorAttachment.set(r.texture), n.depthAttachment = new we(t, n.framebuffer), void 0 === this._sharedDepthStencil ? (this._sharedDepthStencil = t.createRenderbuffer(t.gl.DEPTH_STENCIL, o[0], o[1]), this._stencilRef = 0, n.depthAttachment.set(this._sharedDepthStencil), t.clear({\n          stencil: 0\n        })) : n.depthAttachment.set(this._sharedDepthStencil), t.extTextureFilterAnisotropic && !t.extTextureFilterAnisotropicForceOff && i.texParameterf(i.TEXTURE_2D, t.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, t.extTextureFilterAnisotropicMax), {\n          fb: n,\n          tex: r,\n          dirty: !1\n        };\n      }\n      _initFBOPool() {\n        for (; this.pool.length < Math.min(5, this.proxyCoords.length);) this.pool.push(this._createFBO());\n      }\n      _shouldDisableRenderCache() {\n        if (this._style.light && this._style.light.hasTransition()) return !0;\n        for (const e in this._style._sourceCaches) if (this._style._sourceCaches[e].hasTransition()) return !0;\n        return this._style.order.some(e => {\n          const t = this._style._layers[e],\n            i = t.isHidden(this.painter.transform.zoom);\n          return \"custom\" === t.type ? !i && t.shouldRedrape() : !i && t.hasTransition();\n        });\n      }\n      _clearLineLayersFromRenderCache() {\n        let t = !1;\n        for (const e of this._style._getSources()) if (e instanceof Ce) {\n          t = !0;\n          break;\n        }\n        if (!t) return;\n        const i = {};\n        for (let t = 0; t < this._style.order.length; ++t) {\n          const o = this._style._layers[this._style.order[t]],\n            r = this._style._getLayerSourceCache(o);\n          if (r && !i[r.id] && !o.isHidden(this.painter.transform.zoom) && \"line\" === o.type && o.widthExpression() instanceof e.ZoomDependentExpression) {\n            i[r.id] = !0;\n            for (const e of this.proxyCoords) {\n              const t = this.proxyToSource[e.key][r.id];\n              if (t) for (const e of t) this._clearRenderCacheForTile(r.id, e);\n            }\n          }\n        }\n      }\n      _clearRasterLayersFromRenderCache() {\n        let e = !1;\n        for (const t in this._style._sourceCaches) if (this._style._sourceCaches[t]._source instanceof Me) {\n          e = !0;\n          break;\n        }\n        if (!e) return;\n        const t = {};\n        for (let e = 0; e < this._style.order.length; ++e) {\n          const i = this._style._layers[this._style.order[e]],\n            o = this._style._getLayerSourceCache(i);\n          if (!o || t[o.id]) continue;\n          if (i.isHidden(this.painter.transform.zoom) || \"raster\" !== i.type) continue;\n          const r = i.paint.get(\"raster-fade-duration\");\n          for (const e of this.proxyCoords) {\n            const t = this.proxyToSource[e.key][o.id];\n            if (t) for (const e of t) {\n              const t = Mi(o.getTile(e), o.findLoadedParent(e, 0), o, this.painter.transform, r);\n              (1 !== t.opacity || 0 !== t.mix) && this._clearRenderCacheForTile(o.id, e);\n            }\n          }\n        }\n      }\n      _setupDrapedRenderBatches() {\n        const e = this._style.order,\n          t = e.length;\n        if (0 === t) return;\n        const i = [];\n        let o,\n          r = 0,\n          n = this._style._layers[e[r]];\n        for (; !this._style.isLayerDraped(n) && n.isHidden(this.painter.transform.zoom) && ++r < t;) n = this._style._layers[e[r]];\n        for (; r < t; ++r) {\n          const t = this._style._layers[e[r]];\n          t.isHidden(this.painter.transform.zoom) || (this._style.isLayerDraped(t) ? void 0 === o && (o = r) : void 0 !== o && (i.push({\n            start: o,\n            end: r - 1\n          }), o = void 0));\n        }\n        void 0 !== o && i.push({\n          start: o,\n          end: r - 1\n        }), this._drapedRenderBatches = i;\n      }\n      _setupRenderCache(e) {\n        const t = this.proxySourceCache;\n        if (this._shouldDisableRenderCache() || this._invalidateRenderCache) {\n          if (this._invalidateRenderCache = !1, t.renderCache.length > t.renderCachePool.length) {\n            const e = Object.values(t.proxyCachedFBO);\n            t.proxyCachedFBO = {};\n            for (let i = 0; i < e.length; ++i) {\n              const o = Object.values(e[i]);\n              t.renderCachePool.push(...o);\n            }\n          }\n          return;\n        }\n        this._clearRasterLayersFromRenderCache();\n        const i = this.proxyCoords,\n          o = this._tilesDirty;\n        for (let r = i.length - 1; r >= 0; r--) {\n          const n = i[r];\n          if (t.getTileByID(n.key), void 0 !== t.proxyCachedFBO[n.key]) {\n            const i = e[n.key],\n              r = this.proxyToSource[n.key];\n            let s = 0;\n            for (const e in r) {\n              const t = r[e],\n                n = i[e];\n              if (!n || n.length !== t.length || t.some((t, i) => t !== n[i] || o[e] && o[e].hasOwnProperty(t.key))) {\n                s = -1;\n                break;\n              }\n              ++s;\n            }\n            for (const e in t.proxyCachedFBO[n.key]) t.renderCache[t.proxyCachedFBO[n.key][e]].dirty = s < 0 || s !== Object.values(i).length;\n          }\n        }\n        const r = [...this._drapedRenderBatches];\n        r.sort((e, t) => t.end - t.start - (e.end - e.start));\n        for (const e of r) for (const o of i) {\n          if (t.proxyCachedFBO[o.key]) continue;\n          let i = t.renderCachePool.pop();\n          void 0 === i && t.renderCache.length < 50 && (i = t.renderCache.length, t.renderCache.push(this._createFBO())), void 0 !== i && (t.proxyCachedFBO[o.key] = {}, t.proxyCachedFBO[o.key][e.start] = i, t.renderCache[i].dirty = !0);\n        }\n        this._tilesDirty = {};\n      }\n      _setupStencil(e, t, i, o) {\n        if (!o || !this._sourceTilesOverlap[o.id]) return void (this._overlapStencilType && (this._overlapStencilType = !1));\n        const r = this.painter.context,\n          n = r.gl;\n        if (t.length <= 1) return void (this._overlapStencilType = !1);\n        let s;\n        if (i.isTileClipped()) s = t.length, this._overlapStencilMode.test = {\n          func: n.EQUAL,\n          mask: 255\n        }, this._overlapStencilType = \"Clip\";else {\n          if (!(t[0].overscaledZ > t[t.length - 1].overscaledZ)) return void (this._overlapStencilType = !1);\n          s = 1, this._overlapStencilMode.test = {\n            func: n.GREATER,\n            mask: 255\n          }, this._overlapStencilType = \"Mask\";\n        }\n        this._stencilRef + s > 255 && (r.clear({\n          stencil: 0\n        }), this._stencilRef = 0), this._stencilRef += s, this._overlapStencilMode.ref = this._stencilRef, i.isTileClipped() && this._renderTileClippingMasks(t, this._overlapStencilMode.ref);\n      }\n      clipOrMaskOverlapStencilType() {\n        return \"Clip\" === this._overlapStencilType || \"Mask\" === this._overlapStencilType;\n      }\n      stencilModeForRTTOverlap(t) {\n        return this.renderingToTexture && this._overlapStencilType ? (\"Clip\" === this._overlapStencilType && (this._overlapStencilMode.ref = this.painter._tileClippingMaskIDs[t.key]), this._overlapStencilMode) : e.StencilMode.disabled;\n      }\n      _renderTileClippingMasks(t, i) {\n        const o = this.painter,\n          r = this.painter.context,\n          n = r.gl;\n        o._tileClippingMaskIDs = {}, r.setColorMode(e.ColorMode.disabled), r.setDepthMode(e.DepthMode.disabled);\n        const s = o.useProgram(\"clippingMask\");\n        for (const a of t) {\n          const t = o._tileClippingMaskIDs[a.key] = --i;\n          s.draw(r, n.TRIANGLES, e.DepthMode.disabled, new e.StencilMode({\n            func: n.ALWAYS,\n            mask: 0\n          }, t, 255, n.KEEP, n.KEEP, n.REPLACE), e.ColorMode.disabled, e.CullFaceMode.disabled, Ci(a.projMatrix), \"$clipping\", o.tileExtentBuffer, o.quadTriangleIndexBuffer, o.tileExtentSegments);\n        }\n      }\n      pointCoordinate(t) {\n        const i = this.painter.transform;\n        if (t.x < 0 || t.x > i.width || t.y < 0 || t.y > i.height) return null;\n        const o = [t.x, t.y, 1, 1];\n        e.transformMat4$1(o, o, i.pixelMatrixInverse), e.scale$1(o, o, 1 / o[3]), o[0] /= i.worldSize, o[1] /= i.worldSize;\n        const r = i._camera.position,\n          n = e.mercatorZfromAltitude(1, i.center.lat),\n          s = [r[0], r[1], r[2] / n, 0],\n          a = e.subtract([], o.slice(0, 3), s);\n        e.normalize(a, a);\n        const l = this.raycast(s, a, this._exaggeration);\n        return null !== l && l ? (e.scaleAndAdd(s, s, a, l), s[3] = s[2], s[2] *= n, s) : null;\n      }\n      drawDepth() {\n        const t = this.painter,\n          i = t.context,\n          o = this.proxySourceCache,\n          r = Math.ceil(t.width),\n          n = Math.ceil(t.height);\n        if (!this._depthFBO || this._depthFBO.width === r && this._depthFBO.height === n || (this._depthFBO.destroy(), this._depthFBO = void 0, this._depthTexture = void 0), !this._depthFBO) {\n          const t = i.gl,\n            o = i.createFramebuffer(r, n, !0);\n          i.activeTexture.set(t.TEXTURE0);\n          const s = new e.Texture(i, {\n            width: r,\n            height: n,\n            data: null\n          }, t.RGBA);\n          s.bind(t.NEAREST, t.CLAMP_TO_EDGE), o.colorAttachment.set(s.texture);\n          const a = i.createRenderbuffer(i.gl.DEPTH_COMPONENT16, r, n);\n          o.depthAttachment.set(a), this._depthFBO = o, this._depthTexture = s;\n        }\n        i.bindFramebuffer.set(this._depthFBO.framebuffer), i.viewport.set([0, 0, r, n]), function (t, i, o, r) {\n          if (\"globe\" === t.transform.projection.name) return;\n          const n = t.context,\n            s = n.gl;\n          n.clear({\n            depth: 1\n          });\n          const a = t.useProgram(\"terrainDepth\"),\n            l = new e.DepthMode(s.LESS, e.DepthMode.ReadWrite, t.depthRangeFor3D);\n          for (const t of r) {\n            const r = o.getTile(t),\n              c = vi(t.projMatrix, 0);\n            i.setupElevationDraw(r, a), a.draw(n, s.TRIANGLES, l, e.StencilMode.disabled, e.ColorMode.unblended, e.CullFaceMode.backCCW, c, \"terrain_depth\", i.gridBuffer, i.gridIndexBuffer, i.gridNoSkirtSegments);\n          }\n        }(t, this, o, this.proxyCoords);\n      }\n      _setupProxiedCoordsForOrtho(e, t, i) {\n        if (e.getSource() instanceof Pe) return this._setupProxiedCoordsForImageSource(e, t, i);\n        this._findCoveringTileCache[e.id] = this._findCoveringTileCache[e.id] || {};\n        const o = this.proxiedCoords[e.id] = [],\n          r = this.proxyCoords;\n        for (let t = 0; t < r.length; t++) {\n          const n = r[t],\n            s = this._findTileCoveringTileID(n, e);\n          if (s) {\n            const t = this._createProxiedId(n, s, i[n.key] && i[n.key][e.id]);\n            o.push(t), this.proxyToSource[n.key][e.id] = [t];\n          }\n        }\n        let n = !1;\n        for (let r = 0; r < t.length; r++) {\n          const s = e.getTile(t[r]);\n          if (!s || !s.hasData()) continue;\n          const a = this._findTileCoveringTileID(s.tileID, this.proxySourceCache);\n          if (a && a.tileID.canonical.z !== s.tileID.canonical.z) {\n            const t = this.proxyToSource[a.tileID.key][e.id],\n              r = this._createProxiedId(a.tileID, s, i[a.tileID.key] && i[a.tileID.key][e.id]);\n            t ? t.splice(t.length - 1, 0, r) : this.proxyToSource[a.tileID.key][e.id] = [r], o.push(r), n = !0;\n          }\n        }\n        this._sourceTilesOverlap[e.id] = n;\n      }\n      _setupProxiedCoordsForImageSource(t, i, o) {\n        if (!t.getSource().loaded()) return;\n        const r = this.proxiedCoords[t.id] = [],\n          n = this.proxyCoords,\n          s = t.getSource(),\n          a = new e.Point(s.tileID.x, s.tileID.y)._div(1 << s.tileID.z),\n          l = s.coordinates.map(e.MercatorCoordinate.fromLngLat).reduce((e, t) => (e.min.x = Math.min(e.min.x, t.x - a.x), e.min.y = Math.min(e.min.y, t.y - a.y), e.max.x = Math.max(e.max.x, t.x - a.x), e.max.y = Math.max(e.max.y, t.y - a.y), e), {\n            min: new e.Point(Number.MAX_VALUE, Number.MAX_VALUE),\n            max: new e.Point(-Number.MAX_VALUE, -Number.MAX_VALUE)\n          }),\n          c = (t, i) => {\n            const o = t.wrap + t.canonical.x / (1 << t.canonical.z),\n              r = t.canonical.y / (1 << t.canonical.z),\n              n = e.EXTENT / (1 << t.canonical.z),\n              s = i.wrap + i.canonical.x / (1 << i.canonical.z),\n              a = i.canonical.y / (1 << i.canonical.z);\n            return o + n < s + l.min.x || o > s + l.max.x || r + n < a + l.min.y || r > a + l.max.y;\n          };\n        for (let e = 0; e < n.length; e++) {\n          const s = n[e];\n          for (let e = 0; e < i.length; e++) {\n            const n = t.getTile(i[e]);\n            if (!n || !n.hasData()) continue;\n            if (c(s, n.tileID)) continue;\n            const a = this._createProxiedId(s, n, o[s.key] && o[s.key][t.id]),\n              l = this.proxyToSource[s.key][t.id];\n            l ? l.push(a) : this.proxyToSource[s.key][t.id] = [a], r.push(a);\n          }\n        }\n      }\n      _createProxiedId(t, i, o) {\n        let r = this.orthoMatrix;\n        if (o) {\n          const e = o.find(e => e.key === i.tileID.key);\n          if (e) return e;\n        }\n        if (i.tileID.key !== t.key) {\n          const o = t.canonical.z - i.tileID.canonical.z;\n          let n, s, a;\n          r = e.create();\n          const l = i.tileID.wrap - t.wrap << t.overscaledZ;\n          o > 0 ? (n = e.EXTENT >> o, s = n * ((i.tileID.canonical.x << o) - t.canonical.x + l), a = n * ((i.tileID.canonical.y << o) - t.canonical.y)) : (n = e.EXTENT << -o, s = e.EXTENT * (i.tileID.canonical.x - (t.canonical.x + l << -o)), a = e.EXTENT * (i.tileID.canonical.y - (t.canonical.y << -o))), e.ortho(r, 0, n, 0, n, 0, 1), e.translate(r, r, [s, a, 0]);\n        }\n        return new Si(i.tileID, t.key, r);\n      }\n      _findTileCoveringTileID(t, i) {\n        let o = i.getTile(t);\n        if (o && o.hasData()) return o;\n        const r = this._findCoveringTileCache[i.id],\n          n = r[t.key];\n        if (o = n ? i.getTileByID(n) : null, o && o.hasData() || null === n) return o;\n        let s = o ? o.tileID : t,\n          a = s.overscaledZ;\n        const l = i.getSource().minzoom,\n          c = [];\n        if (!n) {\n          const r = i.getSource().maxzoom;\n          if (t.canonical.z >= r) {\n            const o = t.canonical.z - r;\n            i.getSource().reparseOverscaled ? (a = Math.max(t.canonical.z + 2, i.transform.tileZoom), s = new e.OverscaledTileID(a, t.wrap, r, t.canonical.x >> o, t.canonical.y >> o)) : 0 !== o && (a = r, s = new e.OverscaledTileID(a, t.wrap, r, t.canonical.x >> o, t.canonical.y >> o));\n          }\n          s.key !== t.key && (c.push(s.key), o = i.getTile(s));\n        }\n        const h = e => {\n          c.forEach(t => {\n            r[t] = e;\n          }), c.length = 0;\n        };\n        for (a -= 1; a >= l && (!o || !o.hasData()); a--) {\n          o && h(o.tileID.key);\n          const e = s.calculateScaledKey(a);\n          if (o = i.getTileByID(e), o && o.hasData()) break;\n          const t = r[e];\n          if (null === t) break;\n          void 0 === t ? c.push(e) : o = i.getTileByID(t);\n        }\n        return h(o ? o.tileID.key : null), o && o.hasData() ? o : null;\n      }\n      findDEMTileFor(e) {\n        return this.enabled ? this._findTileCoveringTileID(e, this.sourceCache) : null;\n      }\n      prepareDrawTile() {\n        this.renderedToTile = !0;\n      }\n      _clearRenderCacheForTile(e, t) {\n        let i = this._tilesDirty[e];\n        i || (i = this._tilesDirty[e] = {}), i[t.key] = !0;\n      }\n      getWirefameBuffer() {\n        if (!this.wireframeSegments) {\n          const t = function (t) {\n            let i = 0;\n            const o = new e.StructArrayLayout2ui4(),\n              r = 131;\n            for (let e = 1; e < 129; e++) {\n              for (let t = 1; t < 129; t++) i = e * r + t, o.emplaceBack(i, i + 1), o.emplaceBack(i, i + r), o.emplaceBack(i + 1, i + r), 128 === e && o.emplaceBack(i + r, i + r + 1);\n              o.emplaceBack(i + 1, i + 1 + r);\n            }\n            return o;\n          }();\n          this.wireframeIndexBuffer = this.painter.context.createIndexBuffer(t), this.wireframeSegments = e.SegmentVector.simpleSegment(0, 0, this.gridBuffer.length, t.length);\n        }\n        return [this.wireframeIndexBuffer, this.wireframeSegments];\n      }\n    }\n    class Li {\n      static cacheKey(e, t, i, o) {\n        let r = `${t}${o ? o.cacheKey : \"\"}`;\n        for (const t of i) e.usedDefines.includes(t) && (r += `/${t}`);\n        return r;\n      }\n      constructor(t, i, o, r, n, s) {\n        const a = t.gl;\n        this.program = a.createProgram();\n        const l = function (e) {\n            const t = [];\n            for (let i = 0; i < e.length; i++) {\n              if (null === e[i]) continue;\n              const o = e[i].split(\" \");\n              t.push(o.pop());\n            }\n            return t;\n          }(o.staticAttributes),\n          c = r ? r.getBinderAttributes() : [],\n          h = l.concat(c);\n        let u = r ? r.defines() : [];\n        u = u.concat(s.map(e => `#define ${e}`));\n        const _ = t.isWebGL2 ? \"#version 300 es\\n\" : \"\",\n          d = _ + u.concat(t.extStandardDerivatives && 0 === _.length ? \"#extension GL_OES_standard_derivatives : enable\\n\".concat(li) : li, li, ai, si.fragmentSource, ri.fragmentSource, o.fragmentSource).join(\"\\n\"),\n          p = _ + u.concat(\"\\n#ifdef GL_ES\\nprecision highp float;\\n#else\\n\\n#if !defined(lowp)\\n#define lowp\\n#endif\\n\\n#if !defined(mediump)\\n#define mediump\\n#endif\\n\\n#if !defined(highp)\\n#define highp\\n#endif\\n\\n#endif\", ai, si.vertexSource, ri.vertexSource, oi.vertexSource, o.vertexSource).join(\"\\n\"),\n          m = a.createShader(a.FRAGMENT_SHADER);\n        if (a.isContextLost()) return void (this.failedToCreate = !0);\n        a.shaderSource(m, d), a.compileShader(m), a.attachShader(this.program, m);\n        const f = a.createShader(a.VERTEX_SHADER);\n        if (a.isContextLost()) this.failedToCreate = !0;else {\n          a.shaderSource(f, p), a.compileShader(f), a.attachShader(this.program, f), this.attributes = {}, this.numAttributes = h.length;\n          for (let e = 0; e < this.numAttributes; e++) h[e] && (a.bindAttribLocation(this.program, e, h[e]), this.attributes[h[e]] = e);\n          a.linkProgram(this.program), a.deleteShader(f), a.deleteShader(m), this.fixedUniforms = n(t), this.binderUniforms = r ? r.getUniforms(t) : [], s.includes(\"TERRAIN\") && (this.terrainUniforms = (t => ({\n            u_dem: new e.Uniform1i(t),\n            u_dem_prev: new e.Uniform1i(t),\n            u_dem_unpack: new e.Uniform4f(t),\n            u_dem_tl: new e.Uniform2f(t),\n            u_dem_scale: new e.Uniform1f(t),\n            u_dem_tl_prev: new e.Uniform2f(t),\n            u_dem_scale_prev: new e.Uniform1f(t),\n            u_dem_size: new e.Uniform1f(t),\n            u_dem_lerp: new e.Uniform1f(t),\n            u_exaggeration: new e.Uniform1f(t),\n            u_depth: new e.Uniform1i(t),\n            u_depth_size_inv: new e.Uniform2f(t),\n            u_meter_to_dem: new e.Uniform1f(t),\n            u_label_plane_matrix_inv: new e.UniformMatrix4f(t)\n          }))(t)), s.includes(\"GLOBE\") && (this.globeUniforms = (t => ({\n            u_tile_tl_up: new e.Uniform3f(t),\n            u_tile_tr_up: new e.Uniform3f(t),\n            u_tile_br_up: new e.Uniform3f(t),\n            u_tile_bl_up: new e.Uniform3f(t),\n            u_tile_up_scale: new e.Uniform1f(t)\n          }))(t)), s.includes(\"FOG\") && (this.fogUniforms = (t => ({\n            u_fog_matrix: new e.UniformMatrix4f(t),\n            u_fog_range: new e.Uniform2f(t),\n            u_fog_color: new e.Uniform4f(t),\n            u_fog_horizon_blend: new e.Uniform1f(t),\n            u_fog_temporal_offset: new e.Uniform1f(t),\n            u_frustum_tl: new e.Uniform3f(t),\n            u_frustum_tr: new e.Uniform3f(t),\n            u_frustum_br: new e.Uniform3f(t),\n            u_frustum_bl: new e.Uniform3f(t),\n            u_globe_pos: new e.Uniform3f(t),\n            u_globe_radius: new e.Uniform1f(t),\n            u_globe_transition: new e.Uniform1f(t),\n            u_is_globe: new e.Uniform1i(t),\n            u_viewport: new e.Uniform2f(t)\n          }))(t));\n        }\n      }\n      setTerrainUniformValues(e, t) {\n        if (!this.terrainUniforms) return;\n        const i = this.terrainUniforms;\n        if (!this.failedToCreate) {\n          e.program.set(this.program);\n          for (const e in t) i[e] && i[e].set(this.program, e, t[e]);\n        }\n      }\n      setGlobeUniformValues(e, t) {\n        if (!this.globeUniforms) return;\n        const i = this.globeUniforms;\n        if (!this.failedToCreate) {\n          e.program.set(this.program);\n          for (const e in t) i[e] && i[e].set(this.program, e, t[e]);\n        }\n      }\n      setFogUniformValues(e, t) {\n        if (!this.fogUniforms) return;\n        const i = this.fogUniforms;\n        if (!this.failedToCreate) {\n          e.program.set(this.program);\n          for (const e in t) i[e].set(this.program, e, t[e]);\n        }\n      }\n      draw(e, t, i, o, r, n, s, a, l, c, h, u, _, d, p) {\n        const m = e.gl;\n        if (this.failedToCreate) return;\n        e.program.set(this.program), e.setDepthMode(i), e.setStencilMode(o), e.setColorMode(r), e.setCullFace(n);\n        for (const e of Object.keys(this.fixedUniforms)) this.fixedUniforms[e].set(this.program, e, s[e]);\n        d && d.setUniforms(this.program, e, this.binderUniforms, u, {\n          zoom: _\n        });\n        const f = {\n          [m.LINES]: 2,\n          [m.TRIANGLES]: 3,\n          [m.LINE_STRIP]: 1\n        }[t];\n        for (const i of h.get()) {\n          const o = i.vaos || (i.vaos = {});\n          (o[a] || (o[a] = new _i())).bind(e, this, l, d ? d.getPaintVertexBuffers() : [], c, i.vertexOffset, p || []), m.drawElements(t, i.primitiveLength * f, m.UNSIGNED_SHORT, i.primitiveOffset * f * 2);\n        }\n      }\n    }\n    function Ai(e, t) {\n      const i = Math.pow(2, t.tileID.overscaledZ),\n        o = t.tileSize * Math.pow(2, e.transform.tileZoom) / i,\n        r = o * (t.tileID.canonical.x + t.tileID.wrap * i),\n        n = o * t.tileID.canonical.y;\n      return {\n        u_image: 0,\n        u_texsize: t.imageAtlasTexture.size,\n        u_tile_units_to_pixels: 1 / D(t, 1, e.transform.tileZoom),\n        u_pixel_coord_upper: [r >> 16, n >> 16],\n        u_pixel_coord_lower: [65535 & r, 65535 & n]\n      };\n    }\n    const zi = e.create(),\n      Ri = (t, i, o, r, n, s, a, l, c, h, u) => {\n        const _ = i.style.light,\n          d = _.properties.get(\"position\"),\n          p = [d.x, d.y, d.z],\n          m = e.create$1();\n        \"viewport\" === _.properties.get(\"anchor\") && (e.fromRotation(m, -i.transform.angle), e.transformMat3(p, p, m));\n        const f = _.properties.get(\"color\"),\n          g = i.transform,\n          v = {\n            u_matrix: t,\n            u_lightpos: p,\n            u_lightintensity: _.properties.get(\"intensity\"),\n            u_lightcolor: [f.r, f.g, f.b],\n            u_vertical_gradient: +o,\n            u_opacity: r,\n            u_tile_id: [0, 0, 0],\n            u_zoom_transition: 0,\n            u_inv_rot_matrix: zi,\n            u_merc_center: [0, 0],\n            u_up_dir: [0, 0, 0],\n            u_height_lift: 0,\n            u_ao: n,\n            u_edge_radius: s\n          };\n        return \"globe\" === g.projection.name && (v.u_tile_id = [a.canonical.x, a.canonical.y, 1 << a.canonical.z], v.u_zoom_transition = c, v.u_inv_rot_matrix = u, v.u_merc_center = h, v.u_up_dir = g.projection.upVector(new e.CanonicalTileID(0, 0, 0), h[0] * e.EXTENT, h[1] * e.EXTENT), v.u_height_lift = l), v;\n      },\n      Oi = (t, i, o, r, n, s, a, l, c, h, u, _) => {\n        const d = Ri(t, i, o, r, n, s, a, c, h, u, _),\n          p = {\n            u_height_factor: -Math.pow(2, a.overscaledZ) / l.tileSize / 8\n          };\n        return e.extend(d, Ai(i, l), p);\n      },\n      Bi = e => ({\n        u_matrix: e\n      }),\n      ki = (t, i, o) => e.extend(Bi(t), Ai(i, o)),\n      Fi = (e, t) => ({\n        u_matrix: e,\n        u_world: t\n      }),\n      Ui = (t, i, o, r) => e.extend(ki(t, i, o), {\n        u_world: r\n      }),\n      Ni = e.create(),\n      ji = (t, i, o, r, n, s) => {\n        const a = t.transform,\n          l = \"globe\" === a.projection.name;\n        let c;\n        if (\"map\" === s.paint.get(\"circle-pitch-alignment\")) {\n          if (l) {\n            const t = e.globePixelsToTileUnits(a.zoom, i.canonical) * a._pixelsPerMercatorPixel;\n            c = Float32Array.from([t, 0, 0, t]);\n          } else c = a.calculatePixelsToTileUnitsMatrix(o);\n        } else c = new Float32Array([a.pixelsToGLUnits[0], 0, 0, a.pixelsToGLUnits[1]]);\n        const h = {\n          u_camera_to_center_distance: a.cameraToCenterDistance,\n          u_matrix: t.translatePosMatrix(i.projMatrix, o, s.paint.get(\"circle-translate\"), s.paint.get(\"circle-translate-anchor\")),\n          u_device_pixel_ratio: e.exported.devicePixelRatio,\n          u_extrude_scale: c,\n          u_inv_rot_matrix: Ni,\n          u_merc_center: [0, 0],\n          u_tile_id: [0, 0, 0],\n          u_zoom_transition: 0,\n          u_up_dir: [0, 0, 0]\n        };\n        if (l) {\n          h.u_inv_rot_matrix = r, h.u_merc_center = n, h.u_tile_id = [i.canonical.x, i.canonical.y, 1 << i.canonical.z], h.u_zoom_transition = e.globeToMercatorTransition(a.zoom);\n          const t = n[0] * e.EXTENT,\n            o = n[1] * e.EXTENT;\n          h.u_up_dir = a.projection.upVector(new e.CanonicalTileID(0, 0, 0), t, o);\n        }\n        return h;\n      },\n      Gi = e => {\n        const t = [];\n        return \"map\" === e.paint.get(\"circle-pitch-alignment\") && t.push(\"PITCH_WITH_MAP\"), \"map\" === e.paint.get(\"circle-pitch-scale\") && t.push(\"SCALE_WITH_MAP\"), t;\n      },\n      Zi = (t, i, o, r) => {\n        const n = e.EXTENT / o.tileSize;\n        return {\n          u_matrix: t,\n          u_camera_to_center_distance: i.getCameraToCenterDistance(r),\n          u_extrude_scale: [i.pixelsToGLUnits[0] / n, i.pixelsToGLUnits[1] / n]\n        };\n      },\n      Vi = (e, t, i = 1) => ({\n        u_matrix: e,\n        u_color: t,\n        u_overlay: 0,\n        u_overlay_scale: i\n      }),\n      Wi = e.create(),\n      Xi = (t, i, o, r, n, s, a) => {\n        const l = t.transform,\n          c = \"globe\" === l.projection.name,\n          h = c ? e.globePixelsToTileUnits(l.zoom, i.canonical) * l._pixelsPerMercatorPixel : D(o, 1, s),\n          u = {\n            u_matrix: i.projMatrix,\n            u_extrude_scale: h,\n            u_intensity: a,\n            u_inv_rot_matrix: Wi,\n            u_merc_center: [0, 0],\n            u_tile_id: [0, 0, 0],\n            u_zoom_transition: 0,\n            u_up_dir: [0, 0, 0]\n          };\n        if (c) {\n          u.u_inv_rot_matrix = r, u.u_merc_center = n, u.u_tile_id = [i.canonical.x, i.canonical.y, 1 << i.canonical.z], u.u_zoom_transition = e.globeToMercatorTransition(l.zoom);\n          const t = n[0] * e.EXTENT,\n            o = n[1] * e.EXTENT;\n          u.u_up_dir = l.projection.upVector(new e.CanonicalTileID(0, 0, 0), t, o);\n        }\n        return u;\n      },\n      qi = (e, t, i, o, r, n, s) => {\n        const a = e.transform,\n          l = a.calculatePixelsToTileUnitsMatrix(t);\n        return {\n          u_matrix: Yi(e, t, i, o),\n          u_pixels_to_tile_units: l,\n          u_device_pixel_ratio: n,\n          u_units_to_pixels: [1 / a.pixelsToGLUnits[0], 1 / a.pixelsToGLUnits[1]],\n          u_dash_image: 0,\n          u_gradient_image: 1,\n          u_image_height: r,\n          u_texsize: Ki(i) ? t.lineAtlasTexture.size : [0, 0],\n          u_tile_units_to_pixels: Hi(t, e.transform),\n          u_alpha_discard_threshold: 0,\n          u_trim_offset: s\n        };\n      },\n      $i = (e, t, i, o, r) => {\n        const n = e.transform;\n        return {\n          u_matrix: Yi(e, t, i, o),\n          u_texsize: t.imageAtlasTexture.size,\n          u_pixels_to_tile_units: n.calculatePixelsToTileUnitsMatrix(t),\n          u_device_pixel_ratio: r,\n          u_image: 0,\n          u_tile_units_to_pixels: Hi(t, n),\n          u_units_to_pixels: [1 / n.pixelsToGLUnits[0], 1 / n.pixelsToGLUnits[1]],\n          u_alpha_discard_threshold: 0\n        };\n      };\n    function Hi(e, t) {\n      return 1 / D(e, 1, t.tileZoom);\n    }\n    function Yi(e, t, i, o) {\n      return e.translatePosMatrix(o || t.tileID.projMatrix, t, i.paint.get(\"line-translate\"), i.paint.get(\"line-translate-anchor\"));\n    }\n    function Ki(e) {\n      const t = e.paint.get(\"line-dasharray\").value;\n      return t.value || \"constant\" !== t.kind;\n    }\n    const Ji = (e, t, i, o, r, n) => {\n      return {\n        u_matrix: e,\n        u_tl_parent: t,\n        u_scale_parent: i,\n        u_fade_t: o.mix,\n        u_opacity: o.opacity * r.paint.get(\"raster-opacity\"),\n        u_image0: 0,\n        u_image1: 1,\n        u_brightness_low: r.paint.get(\"raster-brightness-min\"),\n        u_brightness_high: r.paint.get(\"raster-brightness-max\"),\n        u_saturation_factor: (a = r.paint.get(\"raster-saturation\"), a > 0 ? 1 - 1 / (1.001 - a) : -a),\n        u_contrast_factor: (s = r.paint.get(\"raster-contrast\"), s > 0 ? 1 / (1 - s) : 1 + s),\n        u_spin_weights: Qi(r.paint.get(\"raster-hue-rotate\")),\n        u_perspective_transform: n\n      };\n      var s, a;\n    };\n    function Qi(e) {\n      e *= Math.PI / 180;\n      const t = Math.sin(e),\n        i = Math.cos(e);\n      return [(2 * i + 1) / 3, (-Math.sqrt(3) * t - i + 1) / 3, (Math.sqrt(3) * t - i + 1) / 3];\n    }\n    const eo = e.create(),\n      to = (t, i, o, r, n, s, a, l, c, h, u, _, d, p, m, f) => {\n        const g = n.transform,\n          v = {\n            u_is_size_zoom_constant: +(\"constant\" === t || \"source\" === t),\n            u_is_size_feature_constant: +(\"constant\" === t || \"camera\" === t),\n            u_size_t: i ? i.uSizeT : 0,\n            u_size: i ? i.uSize : 0,\n            u_camera_to_center_distance: g.cameraToCenterDistance,\n            u_rotate_symbol: +o,\n            u_aspect_ratio: g.width / g.height,\n            u_fade_change: n.options.fadeDuration ? n.symbolFadeChange : 1,\n            u_matrix: s,\n            u_label_plane_matrix: a,\n            u_coord_matrix: l,\n            u_is_text: +c,\n            u_pitch_with_map: +r,\n            u_texsize: h,\n            u_texture: 0,\n            u_tile_id: [0, 0, 0],\n            u_zoom_transition: 0,\n            u_inv_rot_matrix: eo,\n            u_merc_center: [0, 0],\n            u_camera_forward: [0, 0, 0],\n            u_ecef_origin: [0, 0, 0],\n            u_tile_matrix: eo,\n            u_up_vector: [0, -1, 0]\n          };\n        return \"globe\" === f.name && (v.u_tile_id = [u.canonical.x, u.canonical.y, 1 << u.canonical.z], v.u_zoom_transition = _, v.u_inv_rot_matrix = p, v.u_merc_center = d, v.u_camera_forward = g._camera.forward(), v.u_ecef_origin = e.globeECEFOrigin(g.globeMatrix, u.toUnwrapped()), v.u_tile_matrix = Float32Array.from(g.globeMatrix), v.u_up_vector = m), v;\n      },\n      io = (t, i, o, r, n, s, a, l, c, h, u, _, d, p, m, f, g) => e.extend(to(t, i, o, r, n, s, a, l, c, h, _, d, p, m, f, g), {\n        u_gamma_scale: r ? n.transform.cameraToCenterDistance * Math.cos(n.terrain ? 0 : n.transform._pitch) : 1,\n        u_device_pixel_ratio: e.exported.devicePixelRatio,\n        u_is_halo: +u\n      }),\n      oo = (t, i, o, r, n, s, a, l, c, h, u, _, d, p, m, f) => e.extend(io(t, i, o, r, n, s, a, l, !0, c, !0, u, _, d, p, m, f), {\n        u_texsize_icon: h,\n        u_texture_icon: 1\n      }),\n      ro = (e, t, i) => ({\n        u_matrix: e,\n        u_opacity: t,\n        u_color: i\n      }),\n      no = (t, i, o, r, n) => e.extend(function (e, t, i) {\n        const o = t.imageManager.getPattern(e.toString()),\n          {\n            width: r,\n            height: n\n          } = t.imageManager.getPixelSize(),\n          s = Math.pow(2, i.tileID.overscaledZ),\n          a = i.tileSize * Math.pow(2, t.transform.tileZoom) / s,\n          l = a * (i.tileID.canonical.x + i.tileID.wrap * s),\n          c = a * i.tileID.canonical.y;\n        return {\n          u_image: 0,\n          u_pattern_tl: o.tl,\n          u_pattern_br: o.br,\n          u_texsize: [r, n],\n          u_pattern_size: o.displaySize,\n          u_tile_units_to_pixels: 1 / D(i, 1, t.transform.tileZoom),\n          u_pixel_coord_upper: [l >> 16, c >> 16],\n          u_pixel_coord_lower: [65535 & l, 65535 & c]\n        };\n      }(r, o, n), {\n        u_matrix: t,\n        u_opacity: i\n      }),\n      so = {\n        fillExtrusion: t => ({\n          u_matrix: new e.UniformMatrix4f(t),\n          u_lightpos: new e.Uniform3f(t),\n          u_lightintensity: new e.Uniform1f(t),\n          u_lightcolor: new e.Uniform3f(t),\n          u_vertical_gradient: new e.Uniform1f(t),\n          u_opacity: new e.Uniform1f(t),\n          u_edge_radius: new e.Uniform1f(t),\n          u_ao: new e.Uniform2f(t),\n          u_tile_id: new e.Uniform3f(t),\n          u_zoom_transition: new e.Uniform1f(t),\n          u_inv_rot_matrix: new e.UniformMatrix4f(t),\n          u_merc_center: new e.Uniform2f(t),\n          u_up_dir: new e.Uniform3f(t),\n          u_height_lift: new e.Uniform1f(t)\n        }),\n        fillExtrusionPattern: t => ({\n          u_matrix: new e.UniformMatrix4f(t),\n          u_lightpos: new e.Uniform3f(t),\n          u_lightintensity: new e.Uniform1f(t),\n          u_lightcolor: new e.Uniform3f(t),\n          u_vertical_gradient: new e.Uniform1f(t),\n          u_height_factor: new e.Uniform1f(t),\n          u_edge_radius: new e.Uniform1f(t),\n          u_ao: new e.Uniform2f(t),\n          u_tile_id: new e.Uniform3f(t),\n          u_zoom_transition: new e.Uniform1f(t),\n          u_inv_rot_matrix: new e.UniformMatrix4f(t),\n          u_merc_center: new e.Uniform2f(t),\n          u_up_dir: new e.Uniform3f(t),\n          u_height_lift: new e.Uniform1f(t),\n          u_image: new e.Uniform1i(t),\n          u_texsize: new e.Uniform2f(t),\n          u_pixel_coord_upper: new e.Uniform2f(t),\n          u_pixel_coord_lower: new e.Uniform2f(t),\n          u_tile_units_to_pixels: new e.Uniform1f(t),\n          u_opacity: new e.Uniform1f(t)\n        }),\n        fill: t => ({\n          u_matrix: new e.UniformMatrix4f(t)\n        }),\n        fillPattern: t => ({\n          u_matrix: new e.UniformMatrix4f(t),\n          u_image: new e.Uniform1i(t),\n          u_texsize: new e.Uniform2f(t),\n          u_pixel_coord_upper: new e.Uniform2f(t),\n          u_pixel_coord_lower: new e.Uniform2f(t),\n          u_tile_units_to_pixels: new e.Uniform1f(t)\n        }),\n        fillOutline: t => ({\n          u_matrix: new e.UniformMatrix4f(t),\n          u_world: new e.Uniform2f(t)\n        }),\n        fillOutlinePattern: t => ({\n          u_matrix: new e.UniformMatrix4f(t),\n          u_world: new e.Uniform2f(t),\n          u_image: new e.Uniform1i(t),\n          u_texsize: new e.Uniform2f(t),\n          u_pixel_coord_upper: new e.Uniform2f(t),\n          u_pixel_coord_lower: new e.Uniform2f(t),\n          u_tile_units_to_pixels: new e.Uniform1f(t)\n        }),\n        circle: t => ({\n          u_camera_to_center_distance: new e.Uniform1f(t),\n          u_extrude_scale: new e.UniformMatrix2f(t),\n          u_device_pixel_ratio: new e.Uniform1f(t),\n          u_matrix: new e.UniformMatrix4f(t),\n          u_inv_rot_matrix: new e.UniformMatrix4f(t),\n          u_merc_center: new e.Uniform2f(t),\n          u_tile_id: new e.Uniform3f(t),\n          u_zoom_transition: new e.Uniform1f(t),\n          u_up_dir: new e.Uniform3f(t)\n        }),\n        collisionBox: t => ({\n          u_matrix: new e.UniformMatrix4f(t),\n          u_camera_to_center_distance: new e.Uniform1f(t),\n          u_extrude_scale: new e.Uniform2f(t)\n        }),\n        collisionCircle: t => ({\n          u_matrix: new e.UniformMatrix4f(t),\n          u_inv_matrix: new e.UniformMatrix4f(t),\n          u_camera_to_center_distance: new e.Uniform1f(t),\n          u_viewport_size: new e.Uniform2f(t)\n        }),\n        debug: t => ({\n          u_color: new e.UniformColor(t),\n          u_matrix: new e.UniformMatrix4f(t),\n          u_overlay: new e.Uniform1i(t),\n          u_overlay_scale: new e.Uniform1f(t)\n        }),\n        clippingMask: t => ({\n          u_matrix: new e.UniformMatrix4f(t)\n        }),\n        heatmap: t => ({\n          u_extrude_scale: new e.Uniform1f(t),\n          u_intensity: new e.Uniform1f(t),\n          u_matrix: new e.UniformMatrix4f(t),\n          u_inv_rot_matrix: new e.UniformMatrix4f(t),\n          u_merc_center: new e.Uniform2f(t),\n          u_tile_id: new e.Uniform3f(t),\n          u_zoom_transition: new e.Uniform1f(t),\n          u_up_dir: new e.Uniform3f(t)\n        }),\n        heatmapTexture: t => ({\n          u_image: new e.Uniform1i(t),\n          u_color_ramp: new e.Uniform1i(t),\n          u_opacity: new e.Uniform1f(t)\n        }),\n        hillshade: t => ({\n          u_matrix: new e.UniformMatrix4f(t),\n          u_image: new e.Uniform1i(t),\n          u_latrange: new e.Uniform2f(t),\n          u_light: new e.Uniform2f(t),\n          u_shadow: new e.UniformColor(t),\n          u_highlight: new e.UniformColor(t),\n          u_accent: new e.UniformColor(t)\n        }),\n        hillshadePrepare: t => ({\n          u_matrix: new e.UniformMatrix4f(t),\n          u_image: new e.Uniform1i(t),\n          u_dimension: new e.Uniform2f(t),\n          u_zoom: new e.Uniform1f(t),\n          u_unpack: new e.Uniform4f(t)\n        }),\n        line: t => ({\n          u_matrix: new e.UniformMatrix4f(t),\n          u_pixels_to_tile_units: new e.UniformMatrix2f(t),\n          u_device_pixel_ratio: new e.Uniform1f(t),\n          u_units_to_pixels: new e.Uniform2f(t),\n          u_dash_image: new e.Uniform1i(t),\n          u_gradient_image: new e.Uniform1i(t),\n          u_image_height: new e.Uniform1f(t),\n          u_texsize: new e.Uniform2f(t),\n          u_tile_units_to_pixels: new e.Uniform1f(t),\n          u_alpha_discard_threshold: new e.Uniform1f(t),\n          u_trim_offset: new e.Uniform2f(t)\n        }),\n        linePattern: t => ({\n          u_matrix: new e.UniformMatrix4f(t),\n          u_texsize: new e.Uniform2f(t),\n          u_pixels_to_tile_units: new e.UniformMatrix2f(t),\n          u_device_pixel_ratio: new e.Uniform1f(t),\n          u_image: new e.Uniform1i(t),\n          u_units_to_pixels: new e.Uniform2f(t),\n          u_tile_units_to_pixels: new e.Uniform1f(t),\n          u_alpha_discard_threshold: new e.Uniform1f(t)\n        }),\n        raster: t => ({\n          u_matrix: new e.UniformMatrix4f(t),\n          u_tl_parent: new e.Uniform2f(t),\n          u_scale_parent: new e.Uniform1f(t),\n          u_fade_t: new e.Uniform1f(t),\n          u_opacity: new e.Uniform1f(t),\n          u_image0: new e.Uniform1i(t),\n          u_image1: new e.Uniform1i(t),\n          u_brightness_low: new e.Uniform1f(t),\n          u_brightness_high: new e.Uniform1f(t),\n          u_saturation_factor: new e.Uniform1f(t),\n          u_contrast_factor: new e.Uniform1f(t),\n          u_spin_weights: new e.Uniform3f(t),\n          u_perspective_transform: new e.Uniform2f(t)\n        }),\n        symbolIcon: t => ({\n          u_is_size_zoom_constant: new e.Uniform1i(t),\n          u_is_size_feature_constant: new e.Uniform1i(t),\n          u_size_t: new e.Uniform1f(t),\n          u_size: new e.Uniform1f(t),\n          u_camera_to_center_distance: new e.Uniform1f(t),\n          u_rotate_symbol: new e.Uniform1i(t),\n          u_aspect_ratio: new e.Uniform1f(t),\n          u_fade_change: new e.Uniform1f(t),\n          u_matrix: new e.UniformMatrix4f(t),\n          u_label_plane_matrix: new e.UniformMatrix4f(t),\n          u_coord_matrix: new e.UniformMatrix4f(t),\n          u_is_text: new e.Uniform1i(t),\n          u_pitch_with_map: new e.Uniform1i(t),\n          u_texsize: new e.Uniform2f(t),\n          u_tile_id: new e.Uniform3f(t),\n          u_zoom_transition: new e.Uniform1f(t),\n          u_inv_rot_matrix: new e.UniformMatrix4f(t),\n          u_merc_center: new e.Uniform2f(t),\n          u_camera_forward: new e.Uniform3f(t),\n          u_tile_matrix: new e.UniformMatrix4f(t),\n          u_up_vector: new e.Uniform3f(t),\n          u_ecef_origin: new e.Uniform3f(t),\n          u_texture: new e.Uniform1i(t)\n        }),\n        symbolSDF: t => ({\n          u_is_size_zoom_constant: new e.Uniform1i(t),\n          u_is_size_feature_constant: new e.Uniform1i(t),\n          u_size_t: new e.Uniform1f(t),\n          u_size: new e.Uniform1f(t),\n          u_camera_to_center_distance: new e.Uniform1f(t),\n          u_rotate_symbol: new e.Uniform1i(t),\n          u_aspect_ratio: new e.Uniform1f(t),\n          u_fade_change: new e.Uniform1f(t),\n          u_matrix: new e.UniformMatrix4f(t),\n          u_label_plane_matrix: new e.UniformMatrix4f(t),\n          u_coord_matrix: new e.UniformMatrix4f(t),\n          u_is_text: new e.Uniform1i(t),\n          u_pitch_with_map: new e.Uniform1i(t),\n          u_texsize: new e.Uniform2f(t),\n          u_texture: new e.Uniform1i(t),\n          u_gamma_scale: new e.Uniform1f(t),\n          u_device_pixel_ratio: new e.Uniform1f(t),\n          u_tile_id: new e.Uniform3f(t),\n          u_zoom_transition: new e.Uniform1f(t),\n          u_inv_rot_matrix: new e.UniformMatrix4f(t),\n          u_merc_center: new e.Uniform2f(t),\n          u_camera_forward: new e.Uniform3f(t),\n          u_tile_matrix: new e.UniformMatrix4f(t),\n          u_up_vector: new e.Uniform3f(t),\n          u_ecef_origin: new e.Uniform3f(t),\n          u_is_halo: new e.Uniform1i(t)\n        }),\n        symbolTextAndIcon: t => ({\n          u_is_size_zoom_constant: new e.Uniform1i(t),\n          u_is_size_feature_constant: new e.Uniform1i(t),\n          u_size_t: new e.Uniform1f(t),\n          u_size: new e.Uniform1f(t),\n          u_camera_to_center_distance: new e.Uniform1f(t),\n          u_rotate_symbol: new e.Uniform1i(t),\n          u_aspect_ratio: new e.Uniform1f(t),\n          u_fade_change: new e.Uniform1f(t),\n          u_matrix: new e.UniformMatrix4f(t),\n          u_label_plane_matrix: new e.UniformMatrix4f(t),\n          u_coord_matrix: new e.UniformMatrix4f(t),\n          u_is_text: new e.Uniform1i(t),\n          u_pitch_with_map: new e.Uniform1i(t),\n          u_texsize: new e.Uniform2f(t),\n          u_texsize_icon: new e.Uniform2f(t),\n          u_texture: new e.Uniform1i(t),\n          u_texture_icon: new e.Uniform1i(t),\n          u_gamma_scale: new e.Uniform1f(t),\n          u_device_pixel_ratio: new e.Uniform1f(t),\n          u_is_halo: new e.Uniform1i(t)\n        }),\n        background: t => ({\n          u_matrix: new e.UniformMatrix4f(t),\n          u_opacity: new e.Uniform1f(t),\n          u_color: new e.UniformColor(t)\n        }),\n        backgroundPattern: t => ({\n          u_matrix: new e.UniformMatrix4f(t),\n          u_opacity: new e.Uniform1f(t),\n          u_image: new e.Uniform1i(t),\n          u_pattern_tl: new e.Uniform2f(t),\n          u_pattern_br: new e.Uniform2f(t),\n          u_texsize: new e.Uniform2f(t),\n          u_pattern_size: new e.Uniform2f(t),\n          u_pixel_coord_upper: new e.Uniform2f(t),\n          u_pixel_coord_lower: new e.Uniform2f(t),\n          u_tile_units_to_pixels: new e.Uniform1f(t)\n        }),\n        terrainRaster: gi,\n        terrainDepth: gi,\n        skybox: t => ({\n          u_matrix: new e.UniformMatrix4f(t),\n          u_sun_direction: new e.Uniform3f(t),\n          u_cubemap: new e.Uniform1i(t),\n          u_opacity: new e.Uniform1f(t),\n          u_temporal_offset: new e.Uniform1f(t)\n        }),\n        skyboxGradient: t => ({\n          u_matrix: new e.UniformMatrix4f(t),\n          u_color_ramp: new e.Uniform1i(t),\n          u_center_direction: new e.Uniform3f(t),\n          u_radius: new e.Uniform1f(t),\n          u_opacity: new e.Uniform1f(t),\n          u_temporal_offset: new e.Uniform1f(t)\n        }),\n        skyboxCapture: t => ({\n          u_matrix_3f: new e.UniformMatrix3f(t),\n          u_sun_direction: new e.Uniform3f(t),\n          u_sun_intensity: new e.Uniform1f(t),\n          u_color_tint_r: new e.Uniform4f(t),\n          u_color_tint_m: new e.Uniform4f(t),\n          u_luminance: new e.Uniform1f(t)\n        }),\n        globeRaster: t => ({\n          u_proj_matrix: new e.UniformMatrix4f(t),\n          u_globe_matrix: new e.UniformMatrix4f(t),\n          u_normalize_matrix: new e.UniformMatrix4f(t),\n          u_merc_matrix: new e.UniformMatrix4f(t),\n          u_zoom_transition: new e.Uniform1f(t),\n          u_merc_center: new e.Uniform2f(t),\n          u_image0: new e.Uniform1i(t),\n          u_grid_matrix: new e.UniformMatrix3f(t),\n          u_skirt_height: new e.Uniform1f(t),\n          u_frustum_tl: new e.Uniform3f(t),\n          u_frustum_tr: new e.Uniform3f(t),\n          u_frustum_br: new e.Uniform3f(t),\n          u_frustum_bl: new e.Uniform3f(t),\n          u_globe_pos: new e.Uniform3f(t),\n          u_globe_radius: new e.Uniform1f(t),\n          u_viewport: new e.Uniform2f(t)\n        }),\n        globeAtmosphere: t => ({\n          u_frustum_tl: new e.Uniform3f(t),\n          u_frustum_tr: new e.Uniform3f(t),\n          u_frustum_br: new e.Uniform3f(t),\n          u_frustum_bl: new e.Uniform3f(t),\n          u_horizon: new e.Uniform1f(t),\n          u_transition: new e.Uniform1f(t),\n          u_fadeout_range: new e.Uniform1f(t),\n          u_color: new e.Uniform4f(t),\n          u_high_color: new e.Uniform4f(t),\n          u_space_color: new e.Uniform4f(t),\n          u_star_intensity: new e.Uniform1f(t),\n          u_star_density: new e.Uniform1f(t),\n          u_star_size: new e.Uniform1f(t),\n          u_temporal_offset: new e.Uniform1f(t),\n          u_horizon_angle: new e.Uniform1f(t),\n          u_rotation_matrix: new e.UniformMatrix4f(t)\n        })\n      };\n    let ao;\n    function lo(t, i, o, r, n, s, a) {\n      const l = t.context,\n        c = l.gl,\n        h = t.transform,\n        u = t.useProgram(\"collisionBox\"),\n        _ = [];\n      let d = 0,\n        p = 0;\n      for (let m = 0; m < r.length; m++) {\n        const f = r[m],\n          g = i.getTile(f),\n          v = g.getBucket(o);\n        if (!v) continue;\n        const x = vt(f, v, h);\n        let y = x;\n        0 === n[0] && 0 === n[1] || (y = t.translatePosMatrix(x, g, n, s));\n        const b = a ? v.textCollisionBox : v.iconCollisionBox,\n          w = v.collisionCircleArray;\n        if (w.length > 0) {\n          const t = e.create(),\n            i = y;\n          e.mul(t, v.placementInvProjMatrix, h.glCoordMatrix), e.mul(t, t, v.placementViewportMatrix), _.push({\n            circleArray: w,\n            circleOffset: p,\n            transform: i,\n            invTransform: t,\n            projection: v.getProjection()\n          }), d += w.length / 4, p = d;\n        }\n        b && (t.terrain && t.terrain.setupElevationDraw(g, u), u.draw(l, c.LINES, e.DepthMode.disabled, e.StencilMode.disabled, t.colorModeForRenderPass(), e.CullFaceMode.disabled, Zi(y, h, g, v.getProjection()), o.id, b.layoutVertexBuffer, b.indexBuffer, b.segments, null, h.zoom, null, [b.collisionVertexBuffer, b.collisionVertexBufferExt]));\n      }\n      if (!a || !_.length) return;\n      const m = t.useProgram(\"collisionCircle\"),\n        f = new e.StructArrayLayout2f1f2i16();\n      f.resize(4 * d), f._trim();\n      let g = 0;\n      for (const e of _) for (let t = 0; t < e.circleArray.length / 4; t++) {\n        const i = 4 * t,\n          o = e.circleArray[i + 0],\n          r = e.circleArray[i + 1],\n          n = e.circleArray[i + 2],\n          s = e.circleArray[i + 3];\n        f.emplace(g++, o, r, n, s, 0), f.emplace(g++, o, r, n, s, 1), f.emplace(g++, o, r, n, s, 2), f.emplace(g++, o, r, n, s, 3);\n      }\n      (!ao || ao.length < 2 * d) && (ao = function (t) {\n        const i = 2 * t,\n          o = new e.StructArrayLayout3ui6();\n        o.resize(i), o._trim();\n        for (let e = 0; e < i; e++) {\n          const t = 6 * e;\n          o.uint16[t + 0] = 4 * e + 0, o.uint16[t + 1] = 4 * e + 1, o.uint16[t + 2] = 4 * e + 2, o.uint16[t + 3] = 4 * e + 2, o.uint16[t + 4] = 4 * e + 3, o.uint16[t + 5] = 4 * e + 0;\n        }\n        return o;\n      }(d));\n      const v = l.createIndexBuffer(ao, !0),\n        x = l.createVertexBuffer(f, e.collisionCircleLayout.members, !0);\n      for (const i of _) {\n        const r = {\n          u_matrix: i.transform,\n          u_inv_matrix: i.invTransform,\n          u_camera_to_center_distance: (y = h).getCameraToCenterDistance(i.projection),\n          u_viewport_size: [y.width, y.height]\n        };\n        m.draw(l, c.TRIANGLES, e.DepthMode.disabled, e.StencilMode.disabled, t.colorModeForRenderPass(), e.CullFaceMode.disabled, r, o.id, x, v, e.SegmentVector.simpleSegment(0, 2 * i.circleOffset, i.circleArray.length, i.circleArray.length / 2), null, h.zoom);\n      }\n      var y;\n      x.destroy(), v.destroy();\n    }\n    const co = e.create();\n    function ho({\n      width: t,\n      height: i,\n      anchor: o,\n      textOffset: r,\n      textScale: n\n    }, s) {\n      const {\n          horizontalAlign: a,\n          verticalAlign: l\n        } = e.getAnchorAlignment(o),\n        c = -(a - .5) * t,\n        h = -(l - .5) * i,\n        u = e.evaluateVariableOffset(o, r);\n      return new e.Point((c / n + u[0]) * s, (h / n + u[1]) * s);\n    }\n    function uo(t, i, o, r, n, s, a, l, c, h, u) {\n      const _ = t.text.placedSymbolArray,\n        d = t.text.dynamicLayoutVertexArray,\n        p = t.icon.dynamicLayoutVertexArray,\n        m = {},\n        f = t.getProjection(),\n        g = xt(l, f, s),\n        v = s.elevation,\n        x = f.upVectorScale(l.canonical, s.center.lat, s.worldSize).metersToTile;\n      d.clear();\n      for (let p = 0; p < _.length; p++) {\n        const y = _.get(p),\n          {\n            tileAnchorX: b,\n            tileAnchorY: w,\n            numGlyphs: T\n          } = y,\n          E = y.hidden || !y.crossTileID || t.allowVerticalPlacement && !y.placedOrientation ? null : r[y.crossTileID];\n        if (E) {\n          let r = 0,\n            _ = 0,\n            p = 0;\n          if (v) {\n            const e = v ? v.getAtTileOffset(l, b, w) : 0,\n              [t, i, o] = f.upVector(l.canonical, b, w);\n            r = e * t * x, _ = e * i * x, p = e * o * x;\n          }\n          let [C, M, I, P] = ot(y.projectedAnchorX + r, y.projectedAnchorY + _, y.projectedAnchorZ + p, o ? g : a);\n          const S = rt(s.getCameraToCenterDistance(f), P);\n          let D = n.evaluateSizeForFeature(t.textSizeData, h, y) * S / e.ONE_EM;\n          o && (D *= t.tilePixelRatio / c);\n          const L = ho(E, D);\n          o ? (({\n            x: C,\n            y: M,\n            z: I\n          } = f.projectTilePoint(b + L.x, w + L.y, l.canonical)), [C, M, I] = ot(C + r, M + _, I + p, a)) : (i && L._rotate(-s.angle), C += L.x, M += L.y, I = 0);\n          const A = t.allowVerticalPlacement && y.placedOrientation === e.WritingMode.vertical ? Math.PI / 2 : 0;\n          for (let t = 0; t < T; t++) e.addDynamicAttributes(d, C, M, I, A);\n          u && y.associatedIconIndex >= 0 && (m[y.associatedIconIndex] = {\n            x: C,\n            y: M,\n            z: I,\n            angle: A\n          });\n        } else dt(T, d);\n      }\n      if (u) {\n        p.clear();\n        const i = t.icon.placedSymbolArray;\n        for (let t = 0; t < i.length; t++) {\n          const o = i.get(t),\n            {\n              numGlyphs: r\n            } = o,\n            n = m[t];\n          if (o.hidden || !n) dt(r, p);else {\n            const {\n              x: t,\n              y: i,\n              z: o,\n              angle: s\n            } = n;\n            for (let n = 0; n < r; n++) e.addDynamicAttributes(p, t, i, o, s);\n          }\n        }\n        t.icon.dynamicLayoutVertexBuffer.updateData(p);\n      }\n      t.text.dynamicLayoutVertexBuffer.updateData(d);\n    }\n    function _o(e, t, i) {\n      return i.iconsInText && t ? \"symbolTextAndIcon\" : e ? \"symbolSDF\" : \"symbolIcon\";\n    }\n    function po(t, i, o, r, n, s, a, l, c, h, u, _) {\n      const d = t.context,\n        p = d.gl,\n        m = t.transform,\n        f = \"map\" === l,\n        g = \"map\" === c,\n        v = f && \"point\" !== o.layout.get(\"symbol-placement\"),\n        x = f && !g && !v,\n        y = void 0 !== o.layout.get(\"symbol-sort-key\").constantOr(1);\n      let b = !1;\n      const w = t.depthModeForSublayer(0, e.DepthMode.ReadOnly),\n        T = [e.mercatorXfromLng(m.center.lng), e.mercatorYfromLat(m.center.lat)],\n        E = o.layout.get(\"text-variable-anchor\"),\n        C = \"globe\" === m.projection.name,\n        M = [],\n        I = [0, -1, 0];\n      let P = I;\n      !C && !m.mercatorFromTransition || f || (P = function (t) {\n        const i = t._camera.getWorldToCamera(t.worldSize, 1),\n          o = e.multiply([], i, t.globeMatrix);\n        e.invert(o, o);\n        const r = [0, 0, 0],\n          n = [0, 1, 0, 0];\n        return e.transformMat4$1(n, n, o), r[0] = n[0], r[1] = n[1], r[2] = n[2], e.normalize(r, r), r;\n      }(m));\n      for (const l of r) {\n        const r = i.getTile(l),\n          c = r.getBucket(o);\n        if (!c) continue;\n        if (\"mercator\" === c.projection.name && C) continue;\n        const u = n ? c.text : c.icon;\n        if (!u || c.fullyClipped || !u.segments.get().length) continue;\n        const _ = u.programConfigurations.get(o.id),\n          d = n || c.sdfIcons,\n          w = n ? c.textSizeData : c.iconSizeData,\n          S = g || 0 !== m.pitch,\n          D = e.evaluateSizeForZoom(w, m.zoom);\n        let L,\n          A,\n          z,\n          R,\n          O = [0, 0],\n          B = null;\n        if (n) A = r.glyphAtlasTexture, z = p.LINEAR, L = r.glyphAtlasTexture.size, c.iconsInText && (O = r.imageAtlasTexture.size, B = r.imageAtlasTexture, R = S || t.options.rotating || t.options.zooming || \"composite\" === w.kind || \"camera\" === w.kind ? p.LINEAR : p.NEAREST);else {\n          const e = 1 !== o.layout.get(\"icon-size\").constantOr(0) || c.iconsNeedLinear;\n          A = r.imageAtlasTexture, z = d || t.options.rotating || t.options.zooming || e || S ? p.LINEAR : p.NEAREST, L = r.imageAtlasTexture.size;\n        }\n        const k = \"globe\" === c.projection.name,\n          F = k ? P : I,\n          U = k ? e.globeToMercatorTransition(m.zoom) : 0,\n          N = xt(l, c.getProjection(), m),\n          j = m.calculatePixelsToTileUnitsMatrix(r),\n          G = et(N, r.tileID.canonical, g, f, m, c.getProjection(), j),\n          Z = t.terrain && g && v ? e.invert(e.create(), G) : co,\n          V = it(N, r.tileID.canonical, g, f, m, c.getProjection(), j),\n          W = E && c.hasTextData(),\n          X = \"none\" !== o.layout.get(\"icon-text-fit\") && W && c.hasIconData();\n        if (v) {\n          const e = m.elevation,\n            i = e ? e.getAtTileOffsetFunc(l, m.center.lat, m.worldSize, c.getProjection()) : null,\n            o = tt(N, r.tileID.canonical, g, f, m, c.getProjection(), j);\n          st(c, N, t, n, o, V, g, h, i, l);\n        }\n        const q = v || n && E || X,\n          $ = t.translatePosMatrix(N, r, s, a),\n          H = q ? co : G,\n          Y = t.translatePosMatrix(V, r, s, a, !0),\n          K = c.getProjection().createInversionMatrix(m, l.canonical),\n          J = [];\n        t.terrainRenderModeElevated() && g && J.push(\"PITCH_WITH_MAP_TERRAIN\"), k && J.push(\"PROJECTION_GLOBE_VIEW\"), q && J.push(\"PROJECTED_POS_ON_VIEWPORT\");\n        const Q = d && 0 !== o.paint.get(n ? \"text-halo-width\" : \"icon-halo-width\").constantOr(1);\n        let ee;\n        ee = d ? c.iconsInText ? oo(w.kind, D, x, g, t, $, H, Y, L, O, l, U, T, K, F, c.getProjection()) : io(w.kind, D, x, g, t, $, H, Y, n, L, !0, l, U, T, K, F, c.getProjection()) : to(w.kind, D, x, g, t, $, H, Y, n, L, l, U, T, K, F, c.getProjection());\n        const te = {\n          program: t.useProgram(_o(d, n, c), _, J),\n          buffers: u,\n          uniformValues: ee,\n          atlasTexture: A,\n          atlasTextureIcon: B,\n          atlasInterpolation: z,\n          atlasInterpolationIcon: R,\n          isSDF: d,\n          hasHalo: Q,\n          tile: r,\n          labelPlaneMatrixInv: Z\n        };\n        if (y && c.canOverlap) {\n          b = !0;\n          const t = u.segments.get();\n          for (const i of t) M.push({\n            segments: new e.SegmentVector([i]),\n            sortKey: i.sortKey,\n            state: te\n          });\n        } else M.push({\n          segments: u.segments,\n          sortKey: 0,\n          state: te\n        });\n      }\n      b && M.sort((e, t) => e.sortKey - t.sortKey);\n      for (const e of M) {\n        const i = e.state;\n        if (t.terrain && t.terrain.setupElevationDraw(i.tile, i.program, {\n          useDepthForOcclusion: !C,\n          labelPlaneMatrixInv: i.labelPlaneMatrixInv\n        }), d.activeTexture.set(p.TEXTURE0), i.atlasTexture.bind(i.atlasInterpolation, p.CLAMP_TO_EDGE), i.atlasTextureIcon && (d.activeTexture.set(p.TEXTURE1), i.atlasTextureIcon && i.atlasTextureIcon.bind(i.atlasInterpolationIcon, p.CLAMP_TO_EDGE)), i.isSDF) {\n          const r = i.uniformValues;\n          i.hasHalo && (r.u_is_halo = 1, mo(i.buffers, e.segments, o, t, i.program, w, u, _, r)), r.u_is_halo = 0;\n        }\n        mo(i.buffers, e.segments, o, t, i.program, w, u, _, i.uniformValues);\n      }\n    }\n    function mo(t, i, o, r, n, s, a, l, c) {\n      const h = r.context,\n        u = [t.dynamicLayoutVertexBuffer, t.opacityVertexBuffer, t.globeExtVertexBuffer];\n      n.draw(h, h.gl.TRIANGLES, s, a, l, e.CullFaceMode.disabled, c, o.id, t.layoutVertexBuffer, t.indexBuffer, i, o.paint, r.transform.zoom, t.programConfigurations.get(o.id), u);\n    }\n    function fo(t, i, o, r, n, s, a) {\n      const l = t.context.gl,\n        c = o.paint.get(\"fill-pattern\"),\n        h = c && c.constantOr(1);\n      let u, _, d, p, m;\n      a ? (_ = h && !o.getPaintProperty(\"fill-outline-color\") ? \"fillOutlinePattern\" : \"fillOutline\", u = l.LINES) : (_ = h ? \"fillPattern\" : \"fill\", u = l.TRIANGLES);\n      for (const f of r) {\n        const r = i.getTile(f);\n        if (h && !r.patternsLoaded()) continue;\n        const g = r.getBucket(o);\n        if (!g) continue;\n        t.prepareDrawTile();\n        const v = g.programConfigurations.get(o.id),\n          x = t.useProgram(_, v);\n        h && (t.context.activeTexture.set(l.TEXTURE0), r.imageAtlasTexture.bind(l.LINEAR, l.CLAMP_TO_EDGE), v.updatePaintBuffers());\n        const y = c.constantOr(null);\n        if (y && r.imageAtlas) {\n          const e = r.imageAtlas.patternPositions[y.toString()];\n          e && v.setConstantPatternPositions(e);\n        }\n        const b = t.translatePosMatrix(f.projMatrix, r, o.paint.get(\"fill-translate\"), o.paint.get(\"fill-translate-anchor\"));\n        if (a) {\n          p = g.indexBuffer2, m = g.segments2;\n          const e = t.terrain && t.terrain.renderingToTexture ? t.terrain.drapeBufferSize : [l.drawingBufferWidth, l.drawingBufferHeight];\n          d = \"fillOutlinePattern\" === _ && h ? Ui(b, t, r, e) : Fi(b, e);\n        } else p = g.indexBuffer, m = g.segments, d = h ? ki(b, t, r) : Bi(b);\n        t.prepareDrawProgram(t.context, x, f.toUnwrapped()), x.draw(t.context, u, n, t.stencilModeForClipping(f), s, e.CullFaceMode.disabled, d, o.id, g.layoutVertexBuffer, p, m, o.paint, t.transform.zoom, v);\n      }\n    }\n    function go(t, i, o, r, n, s, a) {\n      const l = t.context,\n        c = l.gl,\n        h = t.transform,\n        u = o.paint.get(\"fill-extrusion-pattern\"),\n        _ = u.constantOr(1),\n        d = o.paint.get(\"fill-extrusion-opacity\"),\n        p = [o.paint.get(\"fill-extrusion-ambient-occlusion-intensity\"), o.paint.get(\"fill-extrusion-ambient-occlusion-radius\")],\n        m = o.layout.get(\"fill-extrusion-edge-radius\"),\n        f = m > 0 && !o.paint.get(\"fill-extrusion-rounded-roof\"),\n        g = f ? 0 : m,\n        v = \"globe\" === h.projection.name ? e.fillExtrusionHeightLift() : 0,\n        x = \"globe\" === h.projection.name,\n        y = x ? e.globeToMercatorTransition(h.zoom) : 0,\n        b = [e.mercatorXfromLng(h.center.lng), e.mercatorYfromLat(h.center.lat)],\n        w = [];\n      x && w.push(\"PROJECTION_GLOBE_VIEW\"), p[0] > 0 && w.push(\"FAUX_AO\"), f && w.push(\"ZERO_ROOF_RADIUS\");\n      for (const m of r) {\n        const r = i.getTile(m),\n          f = r.getBucket(o);\n        if (!f || f.projection.name !== h.projection.name) continue;\n        const T = f.programConfigurations.get(o.id),\n          E = t.useProgram(_ ? \"fillExtrusionPattern\" : \"fillExtrusion\", T, w);\n        if (t.terrain) {\n          const e = t.terrain;\n          if (t.style.terrainSetForDrapingOnly()) e.setupElevationDraw(r, E, {\n            useMeterToDem: !0\n          });else {\n            if (!f.enableTerrain) continue;\n            if (e.setupElevationDraw(r, E, {\n              useMeterToDem: !0\n            }), vo(l, i, m, f, o, e), !f.centroidVertexBuffer) {\n              const e = E.attributes.a_centroid_pos;\n              void 0 !== e && c.vertexAttrib2f(e, 0, 0);\n            }\n          }\n        }\n        _ && (t.context.activeTexture.set(c.TEXTURE0), r.imageAtlasTexture.bind(c.LINEAR, c.CLAMP_TO_EDGE), T.updatePaintBuffers());\n        const C = u.constantOr(null);\n        if (C && r.imageAtlas) {\n          const e = r.imageAtlas.patternPositions[C.toString()];\n          e && T.setConstantPatternPositions(e);\n        }\n        const M = t.translatePosMatrix(m.projMatrix, r, o.paint.get(\"fill-extrusion-translate\"), o.paint.get(\"fill-extrusion-translate-anchor\")),\n          I = h.projection.createInversionMatrix(h, m.canonical),\n          P = o.paint.get(\"fill-extrusion-vertical-gradient\"),\n          S = _ ? Oi(M, t, P, d, p, g, m, r, v, y, b, I) : Ri(M, t, P, d, p, g, m, v, y, b, I);\n        t.prepareDrawProgram(l, E, m.toUnwrapped());\n        const D = [];\n        t.terrain && D.push(f.centroidVertexBuffer), x && D.push(f.layoutVertexExtBuffer), E.draw(l, l.gl.TRIANGLES, n, s, a, e.CullFaceMode.backCCW, S, o.id, f.layoutVertexBuffer, f.indexBuffer, f.segments, o.paint, t.transform.zoom, T, D);\n      }\n    }\n    function vo(t, i, o, r, n, s) {\n      const a = [t => {\n          let i = t.canonical.x - 1,\n            o = t.wrap;\n          return i < 0 && (i = (1 << t.canonical.z) - 1, o--), new e.OverscaledTileID(t.overscaledZ, o, t.canonical.z, i, t.canonical.y);\n        }, t => {\n          let i = t.canonical.x + 1,\n            o = t.wrap;\n          return i === 1 << t.canonical.z && (i = 0, o++), new e.OverscaledTileID(t.overscaledZ, o, t.canonical.z, i, t.canonical.y);\n        }, t => new e.OverscaledTileID(t.overscaledZ, t.wrap, t.canonical.z, t.canonical.x, (0 === t.canonical.y ? 1 << t.canonical.z : t.canonical.y) - 1), t => new e.OverscaledTileID(t.overscaledZ, t.wrap, t.canonical.z, t.canonical.x, t.canonical.y === (1 << t.canonical.z) - 1 ? 0 : t.canonical.y + 1)],\n        l = e => {\n          const t = i.getSource().minzoom,\n            o = e => {\n              const t = i.getTileByID(e);\n              if (t && t.hasData()) return t.getBucket(n);\n            },\n            r = [0, -1, 1];\n          for (const i of r) {\n            if (e.overscaledZ + i < t) continue;\n            const r = o(e.calculateScaledKey(e.overscaledZ + i));\n            if (r) return r;\n          }\n        },\n        c = [0, 0, 0],\n        h = (t, i) => (c[0] = Math.min(t.min.y, i.min.y), c[1] = Math.max(t.max.y, i.max.y), c[2] = e.EXTENT - i.min.x > t.max.x ? i.min.x - e.EXTENT : t.max.x, c),\n        u = (t, i) => (c[0] = Math.min(t.min.x, i.min.x), c[1] = Math.max(t.max.x, i.max.x), c[2] = e.EXTENT - i.min.y > t.max.y ? i.min.y - e.EXTENT : t.max.y, c),\n        _ = [(e, t) => h(e, t), (e, t) => h(t, e), (e, t) => u(e, t), (e, t) => u(t, e)],\n        d = new e.Point(0, 0);\n      let p, m, f;\n      const g = (t, i, r, n, a) => {\n        const l = [[n ? r : t, n ? t : r, 0], [n ? r : i, n ? i : r, 0]],\n          c = a < 0 ? e.EXTENT + a : a,\n          h = [n ? c : (t + i) / 2, n ? (t + i) / 2 : c, 0];\n        return 0 === r && a < 0 || 0 !== r && a > 0 ? s.getForTilePoints(f, [h], !0, m) : l.push(h), s.getForTilePoints(o, l, !0, p), Math.max(l[0][2], l[1][2], h[2]) / s.exaggeration();\n      };\n      for (let t = 0; t < 4; t++) {\n        const i = (t < 2 ? 1 : 5) - t,\n          n = r.borders[t];\n        if (0 === n.length) continue;\n        const c = f = a[t](o),\n          h = l(c);\n        if (!(h && h instanceof e.FillExtrusionBucket && h.enableTerrain)) continue;\n        if (r.borderDoneWithNeighborZ[t] === h.canonical.z && h.borderDoneWithNeighborZ[i] === r.canonical.z) continue;\n        if (m = s.findDEMTileFor(c), !m || !m.dem) continue;\n        if (!p) {\n          const e = s.findDEMTileFor(o);\n          if (!e || !e.dem) return;\n          p = e;\n        }\n        const u = h.borders[i];\n        let v = 0;\n        const x = h.borderDoneWithNeighborZ[i] !== r.canonical.z;\n        if (r.canonical.z === h.canonical.z) {\n          for (let o = 0; o < n.length; o++) {\n            const s = r.featuresOnBorder[n[o]],\n              a = s.borders[t];\n            let l;\n            for (; v < u.length && (l = h.featuresOnBorder[u[v]], !(l.borders[i][1] > a[0] + 3));) x && h.encodeCentroid(void 0, l, !1), v++;\n            if (l && v < u.length) {\n              const o = v;\n              let n = 0;\n              for (; !(l.borders[i][0] > a[1] - 3) && (n++, ++v !== u.length);) l = h.featuresOnBorder[u[v]];\n              if (l = h.featuresOnBorder[u[o]], s.intersectsCount() > 1 || l.intersectsCount() > 1 || 1 !== n) {\n                1 !== n && (v = o), r.encodeCentroid(void 0, s, !1), x && h.encodeCentroid(void 0, l, !1);\n                continue;\n              }\n              const c = _[t](s, l),\n                p = t % 2 ? e.EXTENT - 1 : 0;\n              d.x = g(c[0], Math.min(e.EXTENT - 1, c[1]), p, t < 2, c[2]), d.y = 0, r.encodeCentroid(d, s, !1), x && h.encodeCentroid(d, l, !1);\n            } else r.encodeCentroid(void 0, s, !1);\n          }\n          r.borderDoneWithNeighborZ[t] = h.canonical.z, r.needsCentroidUpdate = !0, x && (h.borderDoneWithNeighborZ[i] = r.canonical.z, h.needsCentroidUpdate = !0);\n        } else {\n          for (const e of n) r.encodeCentroid(void 0, r.featuresOnBorder[e], !1);\n          if (x) {\n            for (const e of u) h.encodeCentroid(void 0, h.featuresOnBorder[e], !1);\n            h.borderDoneWithNeighborZ[i] = r.canonical.z, h.needsCentroidUpdate = !0;\n          }\n          r.borderDoneWithNeighborZ[t] = h.canonical.z, r.needsCentroidUpdate = !0;\n        }\n      }\n      (r.needsCentroidUpdate || !r.centroidVertexBuffer && 0 !== r.centroidVertexArray.length) && r.uploadCentroid(t);\n    }\n    const xo = new e.Color(1, 0, 0, 1),\n      yo = new e.Color(0, 1, 0, 1),\n      bo = new e.Color(0, 0, 1, 1),\n      wo = new e.Color(1, 0, 1, 1),\n      To = new e.Color(0, 1, 1, 1);\n    function Eo(t, i, o) {\n      const r = t.context,\n        n = t.transform,\n        s = r.gl,\n        a = \"globe\" === n.projection.name,\n        l = a ? [\"PROJECTION_GLOBE_VIEW\"] : null;\n      let c = o.projMatrix;\n      if (a && e.globeToMercatorTransition(n.zoom) > 0) {\n        const t = e.transitionTileAABBinECEF(o.canonical, n),\n          i = e.globeDenormalizeECEF(t);\n        c = e.multiply(new Float32Array(16), n.globeMatrix, i), e.multiply(c, n.projMatrix, c);\n      }\n      const h = t.useProgram(\"debug\", null, l),\n        u = i.getTileByID(o.key);\n      t.terrain && t.terrain.setupElevationDraw(u, h);\n      const _ = e.DepthMode.disabled,\n        d = e.StencilMode.disabled,\n        p = t.colorModeForRenderPass(),\n        m = \"$debug\";\n      r.activeTexture.set(s.TEXTURE0), t.emptyTexture.bind(s.LINEAR, s.CLAMP_TO_EDGE), a ? u._makeGlobeTileDebugBuffers(t.context, n) : u._makeDebugTileBoundsBuffers(t.context, n.projection);\n      const f = u._tileDebugBuffer || t.debugBuffer,\n        g = u._tileDebugIndexBuffer || t.debugIndexBuffer,\n        v = u._tileDebugSegments || t.debugSegments;\n      h.draw(r, s.LINE_STRIP, _, d, p, e.CullFaceMode.disabled, Vi(c, e.Color.red), m, f, g, v, null, null, null, [u._globeTileDebugBorderBuffer]);\n      const x = u.latestRawTileData,\n        y = Math.floor((x && x.byteLength || 0) / 1024),\n        b = i.getTile(o).tileSize,\n        w = 512 / Math.min(b, 512) * (o.overscaledZ / n.zoom) * .5;\n      let T = o.canonical.toString();\n      o.overscaledZ !== o.canonical.z && (T += ` => ${o.overscaledZ}`), T += ` ${y}kb`, function (e, t) {\n        e.initDebugOverlayCanvas();\n        const i = e.debugOverlayCanvas,\n          o = e.context.gl,\n          r = e.debugOverlayCanvas.getContext(\"2d\");\n        r.clearRect(0, 0, i.width, i.height), r.shadowColor = \"white\", r.shadowBlur = 2, r.lineWidth = 1.5, r.strokeStyle = \"white\", r.textBaseline = \"top\", r.font = \"bold 36px Open Sans, sans-serif\", r.fillText(t, 5, 5), r.strokeText(t, 5, 5), e.debugOverlayTexture.update(i), e.debugOverlayTexture.bind(o.LINEAR, o.CLAMP_TO_EDGE);\n      }(t, T);\n      const E = u._tileDebugTextBuffer || t.debugBuffer,\n        C = u._tileDebugTextIndexBuffer || t.quadTriangleIndexBuffer,\n        M = u._tileDebugTextSegments || t.debugSegments;\n      h.draw(r, s.TRIANGLES, _, d, e.ColorMode.alphaBlended, e.CullFaceMode.disabled, Vi(c, e.Color.transparent, w), m, E, C, M, null, null, null, [u._globeTileDebugTextBuffer]);\n    }\n    function Co(e, t, i, o) {\n      Io(e, 0, t + i / 2, e.transform.width, i, o);\n    }\n    function Mo(e, t, i, o) {\n      Io(e, t - i / 2, 0, i, e.transform.height, o);\n    }\n    function Io(t, i, o, r, n, s) {\n      const a = t.context,\n        l = a.gl;\n      l.enable(l.SCISSOR_TEST), l.scissor(i * e.exported.devicePixelRatio, o * e.exported.devicePixelRatio, r * e.exported.devicePixelRatio, n * e.exported.devicePixelRatio), a.clear({\n        color: s\n      }), l.disable(l.SCISSOR_TEST);\n    }\n    const Po = e.createLayout([{\n        name: \"a_pos_3f\",\n        components: 3,\n        type: \"Float32\"\n      }]),\n      {\n        members: So\n      } = Po;\n    function Do(e, t, i, o) {\n      e.emplaceBack(t, i, o);\n    }\n    class Lo {\n      constructor(t) {\n        this.vertexArray = new e.StructArrayLayout3f12(), this.indices = new e.StructArrayLayout3ui6(), Do(this.vertexArray, -1, -1, 1), Do(this.vertexArray, 1, -1, 1), Do(this.vertexArray, -1, 1, 1), Do(this.vertexArray, 1, 1, 1), Do(this.vertexArray, -1, -1, -1), Do(this.vertexArray, 1, -1, -1), Do(this.vertexArray, -1, 1, -1), Do(this.vertexArray, 1, 1, -1), this.indices.emplaceBack(5, 1, 3), this.indices.emplaceBack(3, 7, 5), this.indices.emplaceBack(6, 2, 0), this.indices.emplaceBack(0, 4, 6), this.indices.emplaceBack(2, 6, 7), this.indices.emplaceBack(7, 3, 2), this.indices.emplaceBack(5, 4, 0), this.indices.emplaceBack(0, 1, 5), this.indices.emplaceBack(0, 2, 3), this.indices.emplaceBack(3, 1, 0), this.indices.emplaceBack(7, 6, 4), this.indices.emplaceBack(4, 5, 7), this.vertexBuffer = t.createVertexBuffer(this.vertexArray, So), this.indexBuffer = t.createIndexBuffer(this.indices), this.segment = e.SegmentVector.simpleSegment(0, 0, 36, 12);\n      }\n    }\n    function Ao(t, i, o, r, n, s) {\n      const a = t.gl,\n        l = i.paint.get(\"sky-atmosphere-color\"),\n        c = i.paint.get(\"sky-atmosphere-halo-color\"),\n        h = i.paint.get(\"sky-atmosphere-sun-intensity\"),\n        u = ((e, t, i, o, r) => ({\n          u_matrix_3f: e,\n          u_sun_direction: t,\n          u_sun_intensity: i,\n          u_color_tint_r: [o.r, o.g, o.b, o.a],\n          u_color_tint_m: [r.r, r.g, r.b, r.a],\n          u_luminance: 5e-5\n        }))(e.fromMat4(e.create$1(), r), n, h, l, c);\n      a.framebufferTexture2D(a.FRAMEBUFFER, a.COLOR_ATTACHMENT0, a.TEXTURE_CUBE_MAP_POSITIVE_X + s, i.skyboxTexture, 0), o.draw(t, a.TRIANGLES, e.DepthMode.disabled, e.StencilMode.disabled, e.ColorMode.unblended, e.CullFaceMode.frontCW, u, \"skyboxCapture\", i.skyboxGeometry.vertexBuffer, i.skyboxGeometry.indexBuffer, i.skyboxGeometry.segment);\n    }\n    const zo = e.createLayout([{\n      type: \"Float32\",\n      name: \"a_pos\",\n      components: 3\n    }, {\n      type: \"Float32\",\n      name: \"a_uv\",\n      components: 2\n    }]);\n    class Ro {\n      constructor(t) {\n        const i = new e.StructArrayLayout5f20();\n        i.emplaceBack(-1, 1, 1, 0, 0), i.emplaceBack(1, 1, 1, 1, 0), i.emplaceBack(1, -1, 1, 1, 1), i.emplaceBack(-1, -1, 1, 0, 1);\n        const o = new e.StructArrayLayout3ui6();\n        o.emplaceBack(0, 1, 2), o.emplaceBack(2, 3, 0), this.vertexBuffer = t.createVertexBuffer(i, zo.members), this.indexBuffer = t.createIndexBuffer(o), this.segments = e.SegmentVector.simpleSegment(0, 0, 4, 2);\n      }\n      destroy() {\n        this.vertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy();\n      }\n    }\n    const Oo = {\n      symbol: function (t, i, o, r, n) {\n        if (\"translucent\" !== t.renderPass) return;\n        const s = e.StencilMode.disabled,\n          a = t.colorModeForRenderPass();\n        o.layout.get(\"text-variable-anchor\") && function (t, i, o, r, n, s, a) {\n          const l = i.transform,\n            c = \"map\" === n,\n            h = \"map\" === s;\n          for (const i of t) {\n            const t = r.getTile(i),\n              n = t.getBucket(o);\n            if (!n || !n.text || !n.text.segments.get().length) continue;\n            const s = e.evaluateSizeForZoom(n.textSizeData, l.zoom),\n              u = xt(i, n.getProjection(), l),\n              _ = l.calculatePixelsToTileUnitsMatrix(t),\n              d = et(u, t.tileID.canonical, h, c, l, n.getProjection(), _),\n              p = \"none\" !== o.layout.get(\"icon-text-fit\") && n.hasIconData();\n            if (s) {\n              const o = Math.pow(2, l.zoom - t.tileID.overscaledZ);\n              uo(n, c, h, a, e.symbolSize, l, d, i, o, s, p);\n            }\n          }\n        }(r, t, o, i, o.layout.get(\"text-rotation-alignment\"), o.layout.get(\"text-pitch-alignment\"), n), 0 !== o.paint.get(\"icon-opacity\").constantOr(1) && po(t, i, o, r, !1, o.paint.get(\"icon-translate\"), o.paint.get(\"icon-translate-anchor\"), o.layout.get(\"icon-rotation-alignment\"), o.layout.get(\"icon-pitch-alignment\"), o.layout.get(\"icon-keep-upright\"), s, a), 0 !== o.paint.get(\"text-opacity\").constantOr(1) && po(t, i, o, r, !0, o.paint.get(\"text-translate\"), o.paint.get(\"text-translate-anchor\"), o.layout.get(\"text-rotation-alignment\"), o.layout.get(\"text-pitch-alignment\"), o.layout.get(\"text-keep-upright\"), s, a), i.map.showCollisionBoxes && (lo(t, i, o, r, o.paint.get(\"text-translate\"), o.paint.get(\"text-translate-anchor\"), !0), lo(t, i, o, r, o.paint.get(\"icon-translate\"), o.paint.get(\"icon-translate-anchor\"), !1));\n      },\n      circle: function (t, i, o, r) {\n        if (\"translucent\" !== t.renderPass) return;\n        const n = o.paint.get(\"circle-opacity\"),\n          s = o.paint.get(\"circle-stroke-width\"),\n          a = o.paint.get(\"circle-stroke-opacity\"),\n          l = void 0 !== o.layout.get(\"circle-sort-key\").constantOr(1);\n        if (0 === n.constantOr(1) && (0 === s.constantOr(1) || 0 === a.constantOr(1))) return;\n        const c = t.context,\n          h = c.gl,\n          u = t.transform,\n          _ = t.depthModeForSublayer(0, e.DepthMode.ReadOnly),\n          d = e.StencilMode.disabled,\n          p = t.colorModeForRenderPass(),\n          m = \"globe\" === u.projection.name,\n          f = [e.mercatorXfromLng(u.center.lng), e.mercatorYfromLat(u.center.lat)],\n          g = [];\n        for (let n = 0; n < r.length; n++) {\n          const s = r[n],\n            a = i.getTile(s),\n            c = a.getBucket(o);\n          if (!c || c.projection.name !== u.projection.name) continue;\n          const h = c.programConfigurations.get(o.id),\n            _ = Gi(o);\n          m && _.push(\"PROJECTION_GLOBE_VIEW\");\n          const d = t.useProgram(\"circle\", h, _),\n            p = c.layoutVertexBuffer,\n            v = c.globeExtVertexBuffer,\n            x = c.indexBuffer,\n            y = u.projection.createInversionMatrix(u, s.canonical),\n            b = {\n              programConfiguration: h,\n              program: d,\n              layoutVertexBuffer: p,\n              globeExtVertexBuffer: v,\n              indexBuffer: x,\n              uniformValues: ji(t, s, a, y, f, o),\n              tile: a\n            };\n          if (l) {\n            const t = c.segments.get();\n            for (const i of t) g.push({\n              segments: new e.SegmentVector([i]),\n              sortKey: i.sortKey,\n              state: b\n            });\n          } else g.push({\n            segments: c.segments,\n            sortKey: 0,\n            state: b\n          });\n        }\n        l && g.sort((e, t) => e.sortKey - t.sortKey);\n        const v = {\n          useDepthForOcclusion: !m\n        };\n        for (const i of g) {\n          const {\n              programConfiguration: r,\n              program: n,\n              layoutVertexBuffer: s,\n              globeExtVertexBuffer: a,\n              indexBuffer: l,\n              uniformValues: m,\n              tile: f\n            } = i.state,\n            g = i.segments;\n          t.terrain && t.terrain.setupElevationDraw(f, n, v), t.prepareDrawProgram(c, n, f.tileID.toUnwrapped()), n.draw(c, h.TRIANGLES, _, d, p, e.CullFaceMode.disabled, m, o.id, s, l, g, o.paint, u.zoom, r, [a]);\n        }\n      },\n      heatmap: function (t, i, o, r) {\n        if (0 !== o.paint.get(\"heatmap-opacity\")) if (\"offscreen\" === t.renderPass) {\n          const n = t.context,\n            s = n.gl,\n            a = e.StencilMode.disabled,\n            l = new e.ColorMode([s.ONE, s.ONE], e.Color.transparent, [!0, !0, !0, !0]);\n          !function (e, t, i, o) {\n            const r = e.gl,\n              n = t.width * o,\n              s = t.height * o;\n            e.activeTexture.set(r.TEXTURE1), e.viewport.set([0, 0, n, s]);\n            let a = i.heatmapFbo;\n            if (!a || a && (a.width !== n || a.height !== s)) {\n              a && a.destroy();\n              const t = r.createTexture();\n              r.bindTexture(r.TEXTURE_2D, t), r.texParameteri(r.TEXTURE_2D, r.TEXTURE_WRAP_S, r.CLAMP_TO_EDGE), r.texParameteri(r.TEXTURE_2D, r.TEXTURE_WRAP_T, r.CLAMP_TO_EDGE), r.texParameteri(r.TEXTURE_2D, r.TEXTURE_MIN_FILTER, r.LINEAR), r.texParameteri(r.TEXTURE_2D, r.TEXTURE_MAG_FILTER, r.LINEAR), a = i.heatmapFbo = e.createFramebuffer(n, s, !1), function (e, t, i, o, r, n) {\n                const s = e.gl;\n                s.texImage2D(s.TEXTURE_2D, 0, e.isWebGL2 && e.extRenderToTextureHalfFloat ? s.RGBA16F : s.RGBA, r, n, 0, s.RGBA, e.extRenderToTextureHalfFloat ? e.isWebGL2 ? s.HALF_FLOAT : e.extTextureHalfFloat.HALF_FLOAT_OES : s.UNSIGNED_BYTE, null), o.colorAttachment.set(i);\n              }(e, 0, t, a, n, s);\n            } else r.bindTexture(r.TEXTURE_2D, a.colorAttachment.get()), e.bindFramebuffer.set(a.framebuffer);\n          }(n, t, o, \"globe\" === t.transform.projection.name ? .5 : .25), n.clear({\n            color: e.Color.transparent\n          });\n          const c = t.transform,\n            h = \"globe\" === c.projection.name,\n            u = h ? [\"PROJECTION_GLOBE_VIEW\"] : null,\n            _ = h ? e.CullFaceMode.frontCCW : e.CullFaceMode.disabled,\n            d = [e.mercatorXfromLng(c.center.lng), e.mercatorYfromLat(c.center.lat)];\n          for (let p = 0; p < r.length; p++) {\n            const m = r[p];\n            if (i.hasRenderableParent(m)) continue;\n            const f = i.getTile(m),\n              g = f.getBucket(o);\n            if (!g || g.projection.name !== c.projection.name) continue;\n            const v = g.programConfigurations.get(o.id),\n              x = t.useProgram(\"heatmap\", v, u),\n              {\n                zoom: y\n              } = t.transform;\n            t.terrain && t.terrain.setupElevationDraw(f, x), t.prepareDrawProgram(n, x, m.toUnwrapped());\n            const b = c.projection.createInversionMatrix(c, m.canonical);\n            x.draw(n, s.TRIANGLES, e.DepthMode.disabled, a, l, _, Xi(t, m, f, b, d, y, o.paint.get(\"heatmap-intensity\")), o.id, g.layoutVertexBuffer, g.indexBuffer, g.segments, o.paint, t.transform.zoom, v, h ? [g.globeExtVertexBuffer] : null);\n          }\n          n.viewport.set([0, 0, t.width, t.height]);\n        } else \"translucent\" === t.renderPass && (t.context.setColorMode(t.colorModeForRenderPass()), function (t, i) {\n          const o = t.context,\n            r = o.gl,\n            n = i.heatmapFbo;\n          if (!n) return;\n          o.activeTexture.set(r.TEXTURE0), r.bindTexture(r.TEXTURE_2D, n.colorAttachment.get()), o.activeTexture.set(r.TEXTURE1);\n          let s = i.colorRampTexture;\n          s || (s = i.colorRampTexture = new e.Texture(o, i.colorRamp, r.RGBA)), s.bind(r.LINEAR, r.CLAMP_TO_EDGE), t.useProgram(\"heatmapTexture\").draw(o, r.TRIANGLES, e.DepthMode.disabled, e.StencilMode.disabled, t.colorModeForRenderPass(), e.CullFaceMode.disabled, ((e, t, i, o) => ({\n            u_image: 0,\n            u_color_ramp: 1,\n            u_opacity: t.paint.get(\"heatmap-opacity\")\n          }))(0, i), i.id, t.viewportBuffer, t.quadTriangleIndexBuffer, t.viewportSegments, i.paint, t.transform.zoom);\n        }(t, o));\n      },\n      line: function (t, i, o, r) {\n        if (\"translucent\" !== t.renderPass) return;\n        const n = o.paint.get(\"line-opacity\"),\n          s = o.paint.get(\"line-width\");\n        if (0 === n.constantOr(1) || 0 === s.constantOr(1)) return;\n        const a = t.depthModeForSublayer(0, e.DepthMode.ReadOnly),\n          l = t.colorModeForRenderPass(),\n          c = t.terrain && t.terrain.renderingToTexture ? 1 : e.exported.devicePixelRatio,\n          h = o.paint.get(\"line-dasharray\"),\n          u = h.constantOr(1),\n          _ = o.layout.get(\"line-cap\"),\n          d = o.paint.get(\"line-pattern\"),\n          p = d.constantOr(1),\n          m = o.paint.get(\"line-gradient\"),\n          f = p ? \"linePattern\" : \"line\",\n          g = t.context,\n          v = g.gl,\n          x = (e => {\n            const t = [];\n            Ki(e) && t.push(\"RENDER_LINE_DASH\"), e.paint.get(\"line-gradient\") && t.push(\"RENDER_LINE_GRADIENT\");\n            const i = e.paint.get(\"line-trim-offset\");\n            0 === i[0] && 0 === i[1] || t.push(\"RENDER_LINE_TRIM_OFFSET\");\n            const o = e.paint.get(\"line-pattern\").constantOr(1),\n              r = 1 !== e.paint.get(\"line-opacity\").constantOr(1);\n            return !o && r && t.push(\"RENDER_LINE_ALPHA_DISCARD\"), t;\n          })(o);\n        let y = x.includes(\"RENDER_LINE_ALPHA_DISCARD\");\n        t.terrain && t.terrain.clipOrMaskOverlapStencilType() && (y = !1);\n        for (const n of r) {\n          const r = i.getTile(n);\n          if (p && !r.patternsLoaded()) continue;\n          const s = r.getBucket(o);\n          if (!s) continue;\n          t.prepareDrawTile();\n          const b = s.programConfigurations.get(o.id),\n            w = t.useProgram(f, b, x),\n            T = d.constantOr(null);\n          if (T && r.imageAtlas) {\n            const e = r.imageAtlas.patternPositions[T.toString()];\n            e && b.setConstantPatternPositions(e);\n          }\n          const E = h.constantOr(null),\n            C = _.constantOr(null);\n          if (!p && E && C && r.lineAtlas) {\n            const e = r.lineAtlas.getDash(E, C);\n            e && b.setConstantPatternPositions(e);\n          }\n          let [M, I] = o.paint.get(\"line-trim-offset\");\n          if (\"round\" === C || \"square\" === C) {\n            const e = 1;\n            M !== I && (0 === M && (M -= e), 1 === I && (I += e));\n          }\n          const P = t.terrain ? n.projMatrix : null,\n            S = p ? $i(t, r, o, P, c) : qi(t, r, o, P, s.lineClipsArray.length, c, [M, I]);\n          if (m) {\n            const r = s.gradients[o.id];\n            let a = r.texture;\n            if (o.gradientVersion !== r.version) {\n              let l = 256;\n              if (o.stepInterpolant) {\n                const o = i.getSource().maxzoom,\n                  r = n.canonical.z === o ? Math.ceil(1 << t.transform.maxZoom - n.canonical.z) : 1;\n                l = e.clamp(e.nextPowerOfTwo(s.maxLineLength / e.EXTENT * 1024 * r), 256, g.maxTextureSize);\n              }\n              r.gradient = e.renderColorRamp({\n                expression: o.gradientExpression(),\n                evaluationKey: \"lineProgress\",\n                resolution: l,\n                image: r.gradient || void 0,\n                clips: s.lineClipsArray\n              }), r.texture ? r.texture.update(r.gradient) : r.texture = new e.Texture(g, r.gradient, v.RGBA), r.version = o.gradientVersion, a = r.texture;\n            }\n            g.activeTexture.set(v.TEXTURE1), a.bind(o.stepInterpolant ? v.NEAREST : v.LINEAR, v.CLAMP_TO_EDGE);\n          }\n          u && (g.activeTexture.set(v.TEXTURE0), r.lineAtlasTexture.bind(v.LINEAR, v.REPEAT), b.updatePaintBuffers()), p && (g.activeTexture.set(v.TEXTURE0), r.imageAtlasTexture.bind(v.LINEAR, v.CLAMP_TO_EDGE), b.updatePaintBuffers()), t.prepareDrawProgram(g, w, n.toUnwrapped());\n          const D = i => {\n            w.draw(g, v.TRIANGLES, a, i, l, e.CullFaceMode.disabled, S, o.id, s.layoutVertexBuffer, s.indexBuffer, s.segments, o.paint, t.transform.zoom, b, [s.layoutVertexBuffer2]);\n          };\n          if (y) {\n            const i = t.stencilModeForClipping(n).ref;\n            0 === i && t.terrain && g.clear({\n              stencil: 0\n            });\n            const o = {\n              func: v.EQUAL,\n              mask: 255\n            };\n            S.u_alpha_discard_threshold = .8, D(new e.StencilMode(o, i, 255, v.KEEP, v.KEEP, v.INVERT)), S.u_alpha_discard_threshold = 0, D(new e.StencilMode(o, i, 255, v.KEEP, v.KEEP, v.KEEP));\n          } else D(t.stencilModeForClipping(n));\n        }\n        y && (t.resetStencilClippingMasks(), t.terrain && g.clear({\n          stencil: 0\n        }));\n      },\n      fill: function (t, i, o, r) {\n        const n = o.paint.get(\"fill-color\"),\n          s = o.paint.get(\"fill-opacity\");\n        if (0 === s.constantOr(1)) return;\n        const a = t.colorModeForRenderPass(),\n          l = o.paint.get(\"fill-pattern\"),\n          c = t.opaquePassEnabledForLayer() && !l.constantOr(1) && 1 === n.constantOr(e.Color.transparent).a && 1 === s.constantOr(0) ? \"opaque\" : \"translucent\";\n        if (t.renderPass === c) {\n          const n = t.depthModeForSublayer(1, \"opaque\" === t.renderPass ? e.DepthMode.ReadWrite : e.DepthMode.ReadOnly);\n          fo(t, i, o, r, n, a, !1);\n        }\n        if (\"translucent\" === t.renderPass && o.paint.get(\"fill-antialias\")) {\n          const n = t.depthModeForSublayer(o.getPaintProperty(\"fill-outline-color\") ? 2 : 0, e.DepthMode.ReadOnly);\n          fo(t, i, o, r, n, a, !0);\n        }\n      },\n      \"fill-extrusion\": function (t, i, o, r) {\n        const n = o.paint.get(\"fill-extrusion-opacity\");\n        if (0 !== n && \"translucent\" === t.renderPass) {\n          const s = new e.DepthMode(t.context.gl.LEQUAL, e.DepthMode.ReadWrite, t.depthRangeFor3D);\n          if (1 !== n || o.paint.get(\"fill-extrusion-pattern\").constantOr(1)) go(t, i, o, r, s, e.StencilMode.disabled, e.ColorMode.disabled), go(t, i, o, r, s, t.stencilModeFor3D(), t.colorModeForRenderPass()), t.resetStencilClippingMasks();else {\n            const n = t.colorModeForRenderPass();\n            go(t, i, o, r, s, e.StencilMode.disabled, n);\n          }\n        }\n      },\n      hillshade: function (t, i, o, r) {\n        if (\"offscreen\" !== t.renderPass && \"translucent\" !== t.renderPass) return;\n        const n = t.context,\n          s = t.depthModeForSublayer(0, e.DepthMode.ReadOnly),\n          a = t.colorModeForRenderPass(),\n          l = t.terrain && t.terrain.renderingToTexture,\n          [c, h] = \"translucent\" !== t.renderPass || l ? [{}, r] : t.stencilConfigForOverlap(r);\n        for (const r of h) {\n          const n = i.getTile(r);\n          if (n.needsHillshadePrepare && \"offscreen\" === t.renderPass) fi(t, n, o, s, e.StencilMode.disabled, a);else if (\"translucent\" === t.renderPass) {\n            const e = l && t.terrain ? t.terrain.stencilModeForRTTOverlap(r) : c[r.overscaledZ];\n            pi(t, r, n, o, s, e, a);\n          }\n        }\n        n.viewport.set([0, 0, t.width, t.height]), t.resetStencilClippingMasks();\n      },\n      raster: function (t, i, o, r, n, s) {\n        if (\"translucent\" !== t.renderPass) return;\n        if (0 === o.paint.get(\"raster-opacity\")) return;\n        if (!r.length) return;\n        const a = t.context,\n          l = a.gl,\n          c = i.getSource(),\n          h = t.useProgram(\"raster\"),\n          u = t.colorModeForRenderPass(),\n          _ = t.terrain && t.terrain.renderingToTexture,\n          [d, p] = c instanceof Pe || _ ? [{}, r] : t.stencilConfigForOverlap(r),\n          m = p[p.length - 1].overscaledZ,\n          f = !t.options.moving;\n        for (const r of p) {\n          const n = _ ? e.DepthMode.disabled : t.depthModeForSublayer(r.overscaledZ - m, 1 === o.paint.get(\"raster-opacity\") ? e.DepthMode.ReadWrite : e.DepthMode.ReadOnly, l.LESS),\n            p = r.toUnwrapped(),\n            g = i.getTile(r);\n          if (_ && (!g || !g.hasData())) continue;\n          const v = _ ? r.projMatrix : t.transform.calculateProjMatrix(p, f),\n            x = t.terrain && _ ? t.terrain.stencilModeForRTTOverlap(r) : d[r.overscaledZ],\n            y = s ? 0 : o.paint.get(\"raster-fade-duration\");\n          g.registerFadeDuration(y);\n          const b = i.findLoadedParent(r, 0),\n            w = Mi(g, b, i, t.transform, y);\n          let T, E;\n          t.terrain && t.terrain.prepareDrawTile();\n          const C = \"nearest\" === o.paint.get(\"raster-resampling\") ? l.NEAREST : l.LINEAR;\n          a.activeTexture.set(l.TEXTURE0), g.texture.bind(C, l.CLAMP_TO_EDGE), a.activeTexture.set(l.TEXTURE1), b ? (b.texture.bind(C, l.CLAMP_TO_EDGE), T = Math.pow(2, b.tileID.overscaledZ - g.tileID.overscaledZ), E = [g.tileID.canonical.x * T % 1, g.tileID.canonical.y * T % 1]) : g.texture.bind(C, l.CLAMP_TO_EDGE), g.texture.useMipmap && a.extTextureFilterAnisotropic && t.transform.pitch > 20 && l.texParameterf(l.TEXTURE_2D, a.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, a.extTextureFilterAnisotropicMax);\n          const M = Ji(v, E || [0, 0], T || 1, w, o, c instanceof Pe ? c.perspectiveTransform : [0, 0]);\n          if (t.prepareDrawProgram(a, h, p), c instanceof Pe) c.boundsBuffer && c.boundsSegments && h.draw(a, l.TRIANGLES, n, e.StencilMode.disabled, u, e.CullFaceMode.disabled, M, o.id, c.boundsBuffer, t.quadTriangleIndexBuffer, c.boundsSegments);else {\n            const {\n              tileBoundsBuffer: i,\n              tileBoundsIndexBuffer: r,\n              tileBoundsSegments: s\n            } = t.getTileBoundsBuffers(g);\n            h.draw(a, l.TRIANGLES, n, x, u, e.CullFaceMode.disabled, M, o.id, i, r, s);\n          }\n        }\n        t.resetStencilClippingMasks();\n      },\n      background: function (t, i, o, r) {\n        const n = o.paint.get(\"background-color\"),\n          s = o.paint.get(\"background-opacity\");\n        if (0 === s) return;\n        const a = t.context,\n          l = a.gl,\n          c = t.transform,\n          h = c.tileSize,\n          u = o.paint.get(\"background-pattern\");\n        if (t.isPatternMissing(u)) return;\n        const _ = !u && 1 === n.a && 1 === s && t.opaquePassEnabledForLayer() ? \"opaque\" : \"translucent\";\n        if (t.renderPass !== _) return;\n        const d = e.StencilMode.disabled,\n          p = t.depthModeForSublayer(0, \"opaque\" === _ ? e.DepthMode.ReadWrite : e.DepthMode.ReadOnly),\n          m = t.colorModeForRenderPass(),\n          f = t.useProgram(u ? \"backgroundPattern\" : \"background\");\n        let g,\n          v = r;\n        v || (g = t.getBackgroundTiles(), v = Object.values(g).map(e => e.tileID)), u && (a.activeTexture.set(l.TEXTURE0), t.imageManager.bind(t.context));\n        for (const _ of v) {\n          const v = _.toUnwrapped(),\n            x = r ? _.projMatrix : t.transform.calculateProjMatrix(v);\n          t.prepareDrawTile();\n          const y = i ? i.getTile(_) : g ? g[_.key] : new e.Tile(_, h, c.zoom, t),\n            b = u ? no(x, s, t, u, {\n              tileID: _,\n              tileSize: h\n            }) : ro(x, s, n);\n          t.prepareDrawProgram(a, f, v);\n          const {\n            tileBoundsBuffer: w,\n            tileBoundsIndexBuffer: T,\n            tileBoundsSegments: E\n          } = t.getTileBoundsBuffers(y);\n          f.draw(a, l.TRIANGLES, p, d, m, e.CullFaceMode.disabled, b, o.id, w, T, E);\n        }\n      },\n      sky: function (t, i, o) {\n        const r = t.transform,\n          n = \"mercator\" === r.projection.name || \"globe\" === r.projection.name ? 1 : e.smoothstep(7, 8, r.zoom),\n          s = o.paint.get(\"sky-opacity\") * n;\n        if (0 === s) return;\n        const a = t.context,\n          l = o.paint.get(\"sky-type\"),\n          c = new e.DepthMode(a.gl.LEQUAL, e.DepthMode.ReadOnly, [0, 1]),\n          h = t.frameCounter / 1e3 % 1;\n        \"atmosphere\" === l ? \"offscreen\" === t.renderPass ? o.needsSkyboxCapture(t) && (function (t, i, o, r) {\n          const n = t.context,\n            s = n.gl;\n          let a = i.skyboxFbo;\n          if (!a) {\n            a = i.skyboxFbo = n.createFramebuffer(32, 32, !1), i.skyboxGeometry = new Lo(n), i.skyboxTexture = n.gl.createTexture(), s.bindTexture(s.TEXTURE_CUBE_MAP, i.skyboxTexture), s.texParameteri(s.TEXTURE_CUBE_MAP, s.TEXTURE_WRAP_S, s.CLAMP_TO_EDGE), s.texParameteri(s.TEXTURE_CUBE_MAP, s.TEXTURE_WRAP_T, s.CLAMP_TO_EDGE), s.texParameteri(s.TEXTURE_CUBE_MAP, s.TEXTURE_MIN_FILTER, s.LINEAR), s.texParameteri(s.TEXTURE_CUBE_MAP, s.TEXTURE_MAG_FILTER, s.LINEAR);\n            for (let e = 0; e < 6; ++e) s.texImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + e, 0, s.RGBA, 32, 32, 0, s.RGBA, s.UNSIGNED_BYTE, null);\n          }\n          n.bindFramebuffer.set(a.framebuffer), n.viewport.set([0, 0, 32, 32]);\n          const l = i.getCenter(t, !0),\n            c = t.useProgram(\"skyboxCapture\"),\n            h = new Float64Array(16);\n          e.identity(h), e.rotateY(h, h, .5 * -Math.PI), Ao(n, i, c, h, l, 0), e.identity(h), e.rotateY(h, h, .5 * Math.PI), Ao(n, i, c, h, l, 1), e.identity(h), e.rotateX(h, h, .5 * -Math.PI), Ao(n, i, c, h, l, 2), e.identity(h), e.rotateX(h, h, .5 * Math.PI), Ao(n, i, c, h, l, 3), e.identity(h), Ao(n, i, c, h, l, 4), e.identity(h), e.rotateY(h, h, Math.PI), Ao(n, i, c, h, l, 5), n.viewport.set([0, 0, t.width, t.height]);\n        }(t, o), o.markSkyboxValid(t)) : \"sky\" === t.renderPass && function (t, i, o, r, n) {\n          const s = t.context,\n            a = s.gl,\n            l = t.transform,\n            c = t.useProgram(\"skybox\");\n          s.activeTexture.set(a.TEXTURE0), a.bindTexture(a.TEXTURE_CUBE_MAP, i.skyboxTexture);\n          const h = ((e, t, i, o, r) => ({\n            u_matrix: e,\n            u_sun_direction: t,\n            u_cubemap: 0,\n            u_opacity: o,\n            u_temporal_offset: r\n          }))(l.skyboxMatrix, i.getCenter(t, !1), 0, r, n);\n          t.prepareDrawProgram(s, c), c.draw(s, a.TRIANGLES, o, e.StencilMode.disabled, t.colorModeForRenderPass(), e.CullFaceMode.backCW, h, \"skybox\", i.skyboxGeometry.vertexBuffer, i.skyboxGeometry.indexBuffer, i.skyboxGeometry.segment);\n        }(t, o, c, s, h) : \"gradient\" === l && \"sky\" === t.renderPass && function (t, i, o, r, n) {\n          const s = t.context,\n            a = s.gl,\n            l = t.transform,\n            c = t.useProgram(\"skyboxGradient\");\n          i.skyboxGeometry || (i.skyboxGeometry = new Lo(s)), s.activeTexture.set(a.TEXTURE0);\n          let h = i.colorRampTexture;\n          h || (h = i.colorRampTexture = new e.Texture(s, i.colorRamp, a.RGBA)), h.bind(a.LINEAR, a.CLAMP_TO_EDGE);\n          const u = ((t, i, o, r, n) => ({\n            u_matrix: t,\n            u_color_ramp: 0,\n            u_center_direction: i,\n            u_radius: e.degToRad(o),\n            u_opacity: r,\n            u_temporal_offset: n\n          }))(l.skyboxMatrix, i.getCenter(t, !1), i.paint.get(\"sky-gradient-radius\"), r, n);\n          t.prepareDrawProgram(s, c), c.draw(s, a.TRIANGLES, o, e.StencilMode.disabled, t.colorModeForRenderPass(), e.CullFaceMode.backCW, u, \"skyboxGradient\", i.skyboxGeometry.vertexBuffer, i.skyboxGeometry.indexBuffer, i.skyboxGeometry.segment);\n        }(t, o, c, s, h);\n      },\n      debug: function (e, t, i) {\n        for (let o = 0; o < i.length; o++) Eo(e, t, i[o]);\n      },\n      custom: function (t, i, o, r) {\n        const n = t.context,\n          s = o.implementation;\n        if (!t.transform.projection.unsupportedLayers || !t.transform.projection.unsupportedLayers.includes(\"custom\") || t.terrain && (t.terrain.renderingToTexture || \"offscreen\" === t.renderPass) && o.isLayerDraped()) {\n          if (\"offscreen\" === t.renderPass) {\n            const i = s.prerender;\n            if (i) {\n              if (t.setCustomLayerDefaults(), n.setColorMode(t.colorModeForRenderPass()), \"globe\" === t.transform.projection.name) {\n                const o = t.transform.pointMerc;\n                i.call(s, n.gl, t.transform.customLayerMatrix(), t.transform.getProjection(), t.transform.globeToMercatorMatrix(), e.globeToMercatorTransition(t.transform.zoom), [o.x, o.y], t.transform.pixelsPerMeterRatio);\n              } else i.call(s, n.gl, t.transform.customLayerMatrix());\n              n.setDirty(), t.setBaseState();\n            }\n          } else if (\"translucent\" === t.renderPass) {\n            if (t.terrain && t.terrain.renderingToTexture) {\n              const i = s.renderToTile;\n              if (i) {\n                const o = r[0].canonical,\n                  a = new e.MercatorCoordinate(o.x + r[0].wrap * (1 << o.z), o.y, o.z);\n                n.setDepthMode(e.DepthMode.disabled), n.setStencilMode(e.StencilMode.disabled), n.setColorMode(t.colorModeForRenderPass()), t.setCustomLayerDefaults(), i.call(s, n.gl, a), n.setDirty(), t.setBaseState();\n              }\n              return;\n            }\n            t.setCustomLayerDefaults(), n.setColorMode(t.colorModeForRenderPass()), n.setStencilMode(e.StencilMode.disabled);\n            const i = \"3d\" === s.renderingMode ? new e.DepthMode(t.context.gl.LEQUAL, e.DepthMode.ReadWrite, t.depthRangeFor3D) : t.depthModeForSublayer(0, e.DepthMode.ReadOnly);\n            if (n.setDepthMode(i), \"globe\" === t.transform.projection.name) {\n              const i = t.transform.pointMerc;\n              s.render(n.gl, t.transform.customLayerMatrix(), t.transform.getProjection(), t.transform.globeToMercatorMatrix(), e.globeToMercatorTransition(t.transform.zoom), [i.x, i.y], t.transform.pixelsPerMeterRatio);\n            } else s.render(n.gl, t.transform.customLayerMatrix());\n            n.setDirty(), t.setBaseState(), n.bindFramebuffer.set(null);\n          }\n        } else e.warnOnce(\"Custom layers are not yet supported with this projection. Use mercator or globe to enable usage of custom layers.\");\n      }\n    };\n    class Bo {\n      constructor(t, i, o = !1) {\n        this.context = new Ee(t, o), this.transform = i, this._tileTextures = {}, this.frameCopies = [], this.loadTimeStamps = [], this.setup(), this.numSublayers = e.SourceCache.maxUnderzooming + e.SourceCache.maxOverzooming + 1, this.depthEpsilon = 1 / Math.pow(2, 16), this.deferredRenderGpuTimeQueries = [], this.gpuTimers = {}, this.frameCounter = 0, this._backgroundTiles = {};\n      }\n      updateTerrain(e, t) {\n        const i = !!e && !!e.terrain && this.transform.projection.supportsTerrain;\n        if (!(i || this._terrain && this._terrain.enabled)) return;\n        this._terrain || (this._terrain = new Di(this, e));\n        const o = this._terrain;\n        this.transform.elevation = i ? o : null, o.update(e, this.transform, t);\n      }\n      _updateFog(e) {\n        const t = e.fog;\n        if (!t || \"globe\" === this.transform.projection.name || t.getOpacity(this.transform.pitch) < 1 || t.properties.get(\"horizon-blend\") < .03) return void (this.transform.fogCullDistSq = null);\n        const [i, o] = t.getFovAdjustedRange(this.transform._fov);\n        if (i > o) return void (this.transform.fogCullDistSq = null);\n        const r = i + .78 * (o - i);\n        this.transform.fogCullDistSq = r * r;\n      }\n      get terrain() {\n        return this.transform._terrainEnabled() && this._terrain && this._terrain.enabled ? this._terrain : null;\n      }\n      resize(t, i) {\n        if (this.width = t * e.exported.devicePixelRatio, this.height = i * e.exported.devicePixelRatio, this.context.viewport.set([0, 0, this.width, this.height]), this.style) for (const e of this.style.order) this.style._layers[e].resize();\n      }\n      setup() {\n        const t = this.context,\n          i = new e.StructArrayLayout2i4();\n        i.emplaceBack(0, 0), i.emplaceBack(e.EXTENT, 0), i.emplaceBack(0, e.EXTENT), i.emplaceBack(e.EXTENT, e.EXTENT), this.tileExtentBuffer = t.createVertexBuffer(i, e.posAttributes.members), this.tileExtentSegments = e.SegmentVector.simpleSegment(0, 0, 4, 2);\n        const o = new e.StructArrayLayout2i4();\n        o.emplaceBack(0, 0), o.emplaceBack(e.EXTENT, 0), o.emplaceBack(0, e.EXTENT), o.emplaceBack(e.EXTENT, e.EXTENT), this.debugBuffer = t.createVertexBuffer(o, e.posAttributes.members), this.debugSegments = e.SegmentVector.simpleSegment(0, 0, 4, 5);\n        const r = new e.StructArrayLayout2i4();\n        r.emplaceBack(-1, -1), r.emplaceBack(1, -1), r.emplaceBack(-1, 1), r.emplaceBack(1, 1), this.viewportBuffer = t.createVertexBuffer(r, e.posAttributes.members), this.viewportSegments = e.SegmentVector.simpleSegment(0, 0, 4, 2);\n        const n = new e.StructArrayLayout4i8();\n        n.emplaceBack(0, 0, 0, 0), n.emplaceBack(e.EXTENT, 0, e.EXTENT, 0), n.emplaceBack(0, e.EXTENT, 0, e.EXTENT), n.emplaceBack(e.EXTENT, e.EXTENT, e.EXTENT, e.EXTENT), this.mercatorBoundsBuffer = t.createVertexBuffer(n, e.boundsAttributes.members), this.mercatorBoundsSegments = e.SegmentVector.simpleSegment(0, 0, 4, 2);\n        const s = new e.StructArrayLayout3ui6();\n        s.emplaceBack(0, 1, 2), s.emplaceBack(2, 1, 3), this.quadTriangleIndexBuffer = t.createIndexBuffer(s);\n        const a = new e.StructArrayLayout1ui2();\n        for (const e of [0, 1, 3, 2, 0]) a.emplaceBack(e);\n        this.debugIndexBuffer = t.createIndexBuffer(a), this.emptyTexture = new e.Texture(t, new e.RGBAImage({\n          width: 1,\n          height: 1\n        }, Uint8Array.of(0, 0, 0, 0)), t.gl.RGBA), this.identityMat = e.create();\n        const l = this.context.gl;\n        this.stencilClearMode = new e.StencilMode({\n          func: l.ALWAYS,\n          mask: 0\n        }, 0, 255, l.ZERO, l.ZERO, l.ZERO), this.loadTimeStamps.push(e.window.performance.now()), this.atmosphereBuffer = new Ro(this.context);\n      }\n      getMercatorTileBoundsBuffers() {\n        return {\n          tileBoundsBuffer: this.mercatorBoundsBuffer,\n          tileBoundsIndexBuffer: this.quadTriangleIndexBuffer,\n          tileBoundsSegments: this.mercatorBoundsSegments\n        };\n      }\n      getTileBoundsBuffers(e) {\n        return e._makeTileBoundsBuffers(this.context, this.transform.projection), e._tileBoundsBuffer ? {\n          tileBoundsBuffer: e._tileBoundsBuffer,\n          tileBoundsIndexBuffer: e._tileBoundsIndexBuffer,\n          tileBoundsSegments: e._tileBoundsSegments\n        } : this.getMercatorTileBoundsBuffers();\n      }\n      clearStencil() {\n        const t = this.context,\n          i = t.gl;\n        this.nextStencilID = 1, this.currentStencilSource = void 0, this._tileClippingMaskIDs = {}, this.useProgram(\"clippingMask\").draw(t, i.TRIANGLES, e.DepthMode.disabled, this.stencilClearMode, e.ColorMode.disabled, e.CullFaceMode.disabled, Ci(this.identityMat), \"$clipping\", this.viewportBuffer, this.quadTriangleIndexBuffer, this.viewportSegments);\n      }\n      resetStencilClippingMasks() {\n        this.terrain || (this.currentStencilSource = void 0, this._tileClippingMaskIDs = {});\n      }\n      _renderTileClippingMasks(t, i, o) {\n        if (!i || this.currentStencilSource === i.id || !t.isTileClipped() || !o || 0 === o.length) return;\n        if (this._tileClippingMaskIDs && !this.terrain) {\n          let e = !1;\n          for (const t of o) if (void 0 === this._tileClippingMaskIDs[t.key]) {\n            e = !0;\n            break;\n          }\n          if (!e) return;\n        }\n        this.currentStencilSource = i.id;\n        const r = this.context,\n          n = r.gl;\n        this.nextStencilID + o.length > 256 && this.clearStencil(), r.setColorMode(e.ColorMode.disabled), r.setDepthMode(e.DepthMode.disabled);\n        const s = this.useProgram(\"clippingMask\");\n        this._tileClippingMaskIDs = {};\n        for (const t of o) {\n          const o = i.getTile(t),\n            a = this._tileClippingMaskIDs[t.key] = this.nextStencilID++,\n            {\n              tileBoundsBuffer: l,\n              tileBoundsIndexBuffer: c,\n              tileBoundsSegments: h\n            } = this.getTileBoundsBuffers(o);\n          s.draw(r, n.TRIANGLES, e.DepthMode.disabled, new e.StencilMode({\n            func: n.ALWAYS,\n            mask: 0\n          }, a, 255, n.KEEP, n.KEEP, n.REPLACE), e.ColorMode.disabled, e.CullFaceMode.disabled, Ci(t.projMatrix), \"$clipping\", l, c, h);\n        }\n      }\n      stencilModeFor3D() {\n        this.currentStencilSource = void 0, this.nextStencilID + 1 > 256 && this.clearStencil();\n        const t = this.nextStencilID++,\n          i = this.context.gl;\n        return new e.StencilMode({\n          func: i.NOTEQUAL,\n          mask: 255\n        }, t, 255, i.KEEP, i.KEEP, i.REPLACE);\n      }\n      stencilModeForClipping(t) {\n        if (this.terrain) return this.terrain.stencilModeForRTTOverlap(t);\n        const i = this.context.gl;\n        return new e.StencilMode({\n          func: i.EQUAL,\n          mask: 255\n        }, this._tileClippingMaskIDs[t.key], 0, i.KEEP, i.KEEP, i.REPLACE);\n      }\n      stencilConfigForOverlap(t) {\n        const i = this.context.gl,\n          o = t.sort((e, t) => t.overscaledZ - e.overscaledZ),\n          r = o[o.length - 1].overscaledZ,\n          n = o[0].overscaledZ - r + 1;\n        if (n > 1) {\n          this.currentStencilSource = void 0, this.nextStencilID + n > 256 && this.clearStencil();\n          const t = {};\n          for (let o = 0; o < n; o++) t[o + r] = new e.StencilMode({\n            func: i.GEQUAL,\n            mask: 255\n          }, o + this.nextStencilID, 255, i.KEEP, i.KEEP, i.REPLACE);\n          return this.nextStencilID += n, [t, o];\n        }\n        return [{\n          [r]: e.StencilMode.disabled\n        }, o];\n      }\n      colorModeForRenderPass() {\n        const t = this.context.gl;\n        if (this._showOverdrawInspector) {\n          const i = 1 / 8;\n          return new e.ColorMode([t.CONSTANT_COLOR, t.ONE], new e.Color(i, i, i, 0), [!0, !0, !0, !0]);\n        }\n        return \"opaque\" === this.renderPass ? e.ColorMode.unblended : e.ColorMode.alphaBlended;\n      }\n      depthModeForSublayer(t, i, o) {\n        if (!this.opaquePassEnabledForLayer()) return e.DepthMode.disabled;\n        const r = 1 - ((1 + this.currentLayer) * this.numSublayers + t) * this.depthEpsilon;\n        return new e.DepthMode(o || this.context.gl.LEQUAL, i, [r, r]);\n      }\n      opaquePassEnabledForLayer() {\n        return this.currentLayer < this.opaquePassCutoff;\n      }\n      render(t, i) {\n        this.style = t, this.options = i, this.imageManager = t.imageManager, this.glyphManager = t.glyphManager, this.symbolFadeChange = t.placement.symbolFadeChange(e.exported.now()), this.imageManager.beginFrame();\n        const o = this.style.order,\n          r = this.style._sourceCaches;\n        for (const e in r) {\n          const t = r[e];\n          t.used && t.prepare(this.context);\n        }\n        const n = {},\n          s = {},\n          a = {};\n        for (const e in r) {\n          const t = r[e];\n          n[e] = t.getVisibleCoordinates(), s[e] = n[e].slice().reverse(), a[e] = t.getVisibleCoordinates(!0).reverse();\n        }\n        this.opaquePassCutoff = 1 / 0;\n        for (let e = 0; e < o.length; e++) if (this.style._layers[o[e]].is3D()) {\n          this.opaquePassCutoff = e;\n          break;\n        }\n        if (this.terrain && (this.terrain.updateTileBinding(a), this.opaquePassCutoff = 0), \"globe\" !== this.transform.projection.name || this.globeSharedBuffers || (this.globeSharedBuffers = new e.GlobeSharedBuffers(this.context)), !e.isMapAuthenticated(this.context.gl)) return;\n        this.renderPass = \"offscreen\";\n        for (const e of o) {\n          const i = this.style._layers[e],\n            o = t._getLayerSourceCache(i);\n          if (!i.hasOffscreenPass() || i.isHidden(this.transform.zoom)) continue;\n          const r = o ? s[o.id] : void 0;\n          (\"custom\" === i.type || i.isSky() || r && r.length) && this.renderLayer(this, o, i, r);\n        }\n        this.depthRangeFor3D = [0, 1 - (t.order.length + 2) * this.numSublayers * this.depthEpsilon];\n        const l = this.terrain;\n        if (l && (this.style.hasSymbolLayers() || this.style.hasCircleLayers()) && l.drawDepth(), this.context.bindFramebuffer.set(null), this.context.viewport.set([0, 0, this.width, this.height]), this.context.clear({\n          color: i.showOverdrawInspector ? e.Color.black : e.Color.transparent,\n          depth: 1\n        }), this.clearStencil(), this._showOverdrawInspector = i.showOverdrawInspector, this.renderPass = \"opaque\", !this.terrain) for (this.currentLayer = o.length - 1; this.currentLayer >= 0; this.currentLayer--) {\n          const e = this.style._layers[o[this.currentLayer]],\n            i = t._getLayerSourceCache(e);\n          if (e.isSky()) continue;\n          const r = i ? s[i.id] : void 0;\n          this._renderTileClippingMasks(e, i, r), this.renderLayer(this, i, e, r);\n        }\n        if (this.style.fog && this.transform.projection.supportsFog && function (t, i) {\n          const o = t.context,\n            r = o.gl,\n            n = t.transform,\n            s = new e.DepthMode(r.LEQUAL, e.DepthMode.ReadOnly, [0, 1]),\n            a = t.useProgram(\"globeAtmosphere\", null, \"globe\" === n.projection.name ? [\"PROJECTION_GLOBE_VIEW\", \"FOG\"] : [\"FOG\"]),\n            l = e.globeToMercatorTransition(n.zoom),\n            c = i.properties.get(\"color\").toArray01(),\n            h = i.properties.get(\"high-color\").toArray01(),\n            u = i.properties.get(\"space-color\").toArray01PremultipliedAlpha(),\n            _ = e.identity$1([]);\n          e.rotateY$1(_, _, -e.degToRad(n._center.lng)), e.rotateX$1(_, _, e.degToRad(n._center.lat)), e.rotateZ$1(_, _, n.angle), e.rotateX$1(_, _, -n._pitch);\n          const d = e.fromQuat(new Float32Array(16), _),\n            p = e.mapValue(i.properties.get(\"star-intensity\"), 0, 1, 0, .25),\n            m = 5e-4,\n            f = e.mapValue(i.properties.get(\"horizon-blend\"), 0, 1, m, .25),\n            g = e.globeUseCustomAntiAliasing(t, o, n) && f === m ? n.worldSize / (2 * Math.PI * 1.025) - 1 : n.globeRadius,\n            v = t.frameCounter / 1e3 % 1,\n            x = e.length(n.globeCenterInViewSpace),\n            y = Math.sqrt(Math.pow(x, 2) - Math.pow(g, 2)),\n            b = Math.acos(y / x),\n            w = ((t, i, o, r, n, s, a, l, c, h, u, _, d, p) => ({\n              u_frustum_tl: t,\n              u_frustum_tr: i,\n              u_frustum_br: o,\n              u_frustum_bl: r,\n              u_horizon: n,\n              u_transition: s,\n              u_fadeout_range: a,\n              u_color: l,\n              u_high_color: c,\n              u_space_color: h,\n              u_star_intensity: u,\n              u_star_size: 5 * e.exported.devicePixelRatio,\n              u_star_density: 0,\n              u_temporal_offset: _,\n              u_horizon_angle: d,\n              u_rotation_matrix: p\n            }))(n.frustumCorners.TL, n.frustumCorners.TR, n.frustumCorners.BR, n.frustumCorners.BL, n.frustumCorners.horizon, l, f, c, h, u, p, v, b, d);\n          t.prepareDrawProgram(o, a);\n          const T = t.atmosphereBuffer;\n          T && a.draw(o, r.TRIANGLES, s, e.StencilMode.disabled, e.ColorMode.alphaBlended, e.CullFaceMode.backCW, w, \"skybox\", T.vertexBuffer, T.indexBuffer, T.segments);\n        }(this, this.style.fog), this.renderPass = \"sky\", (e.globeToMercatorTransition(this.transform.zoom) > 0 || \"globe\" !== this.transform.projection.name) && this.transform.isHorizonVisible()) for (this.currentLayer = 0; this.currentLayer < o.length; this.currentLayer++) {\n          const e = this.style._layers[o[this.currentLayer]],\n            i = t._getLayerSourceCache(e);\n          e.isSky() && this.renderLayer(this, i, e, i ? s[i.id] : void 0);\n        }\n        for (this.renderPass = \"translucent\", this.currentLayer = 0; this.currentLayer < o.length;) {\n          const e = this.style._layers[o[this.currentLayer]],\n            i = t._getLayerSourceCache(e);\n          if (e.isSky()) {\n            ++this.currentLayer;\n            continue;\n          }\n          if (this.terrain && this.style.isLayerDraped(e)) {\n            if (e.isHidden(this.transform.zoom)) {\n              ++this.currentLayer;\n              continue;\n            }\n            this.currentLayer = this.terrain.renderBatch(this.currentLayer);\n            continue;\n          }\n          const r = i ? (\"symbol\" === e.type ? a : s)[i.id] : void 0;\n          this._renderTileClippingMasks(e, i, i ? n[i.id] : void 0), this.renderLayer(this, i, e, r), ++this.currentLayer;\n        }\n        if (this.terrain && this.terrain.postRender(), this.options.showTileBoundaries || this.options.showQueryGeometry || this.options.showTileAABBs) {\n          let i = null;\n          e.values(this.style._layers).forEach(e => {\n            const o = t._getLayerSourceCache(e);\n            o && !e.isHidden(this.transform.zoom) && (!i || i.getSource().maxzoom < o.getSource().maxzoom) && (i = o);\n          }), i && this.options.showTileBoundaries && Oo.debug(this, i, i.getVisibleCoordinates());\n        }\n        this.options.showPadding && function (e) {\n          const t = e.transform.padding;\n          Co(e, e.transform.height - (t.top || 0), 3, xo), Co(e, t.bottom || 0, 3, yo), Mo(e, t.left || 0, 3, bo), Mo(e, e.transform.width - (t.right || 0), 3, wo);\n          const i = e.transform.centerPoint;\n          !function (e, t, i, o) {\n            Io(e, t - 1, i - 10, 2, 20, o), Io(e, t - 10, i - 1, 20, 2, o);\n          }(e, i.x, e.transform.height - i.y, To);\n        }(this), this.context.setDefault(), this.frameCounter = (this.frameCounter + 1) % Number.MAX_SAFE_INTEGER, this.tileLoaded && this.options.speedIndexTiming && (this.loadTimeStamps.push(e.window.performance.now()), this.saveCanvasCopy());\n      }\n      renderLayer(e, t, i, o) {\n        i.isHidden(this.transform.zoom) || (\"background\" === i.type || \"sky\" === i.type || \"custom\" === i.type || o && o.length) && (this.id = i.id, this.gpuTimingStart(i), (!e.transform.projection.unsupportedLayers || !e.transform.projection.unsupportedLayers.includes(i.type) || e.terrain && \"custom\" === i.type) && Oo[i.type](e, t, i, o, this.style.placement.variableOffsets, this.options.isInitialLoad), this.gpuTimingEnd());\n      }\n      gpuTimingStart(e) {\n        if (!this.options.gpuTiming) return;\n        const t = this.context.extTimerQuery;\n        let i = this.gpuTimers[e.id];\n        i || (i = this.gpuTimers[e.id] = {\n          calls: 0,\n          cpuTime: 0,\n          query: t.createQueryEXT()\n        }), i.calls++, t.beginQueryEXT(t.TIME_ELAPSED_EXT, i.query);\n      }\n      gpuTimingDeferredRenderStart() {\n        if (this.options.gpuTimingDeferredRender) {\n          const e = this.context.extTimerQuery,\n            t = e.createQueryEXT();\n          this.deferredRenderGpuTimeQueries.push(t), e.beginQueryEXT(e.TIME_ELAPSED_EXT, t);\n        }\n      }\n      gpuTimingDeferredRenderEnd() {\n        if (!this.options.gpuTimingDeferredRender) return;\n        const e = this.context.extTimerQuery;\n        e.endQueryEXT(e.TIME_ELAPSED_EXT);\n      }\n      gpuTimingEnd() {\n        if (!this.options.gpuTiming) return;\n        const e = this.context.extTimerQuery;\n        e.endQueryEXT(e.TIME_ELAPSED_EXT);\n      }\n      collectGpuTimers() {\n        const e = this.gpuTimers;\n        return this.gpuTimers = {}, e;\n      }\n      collectDeferredRenderGpuQueries() {\n        const e = this.deferredRenderGpuTimeQueries;\n        return this.deferredRenderGpuTimeQueries = [], e;\n      }\n      queryGpuTimers(e) {\n        const t = {};\n        for (const i in e) {\n          const o = e[i],\n            r = this.context.extTimerQuery,\n            n = r.getQueryObjectEXT(o.query, r.QUERY_RESULT_EXT) / 1e6;\n          r.deleteQueryEXT(o.query), t[i] = n;\n        }\n        return t;\n      }\n      queryGpuTimeDeferredRender(e) {\n        if (!this.options.gpuTimingDeferredRender) return 0;\n        const t = this.context.extTimerQuery;\n        let i = 0;\n        for (const o of e) i += t.getQueryObjectEXT(o, t.QUERY_RESULT_EXT) / 1e6, t.deleteQueryEXT(o);\n        return i;\n      }\n      translatePosMatrix(t, i, o, r, n) {\n        if (!o[0] && !o[1]) return t;\n        const s = n ? \"map\" === r ? this.transform.angle : 0 : \"viewport\" === r ? -this.transform.angle : 0;\n        if (s) {\n          const e = Math.sin(s),\n            t = Math.cos(s);\n          o = [o[0] * t - o[1] * e, o[0] * e + o[1] * t];\n        }\n        const a = [n ? o[0] : D(i, o[0], this.transform.zoom), n ? o[1] : D(i, o[1], this.transform.zoom), 0],\n          l = new Float32Array(16);\n        return e.translate(l, t, a), l;\n      }\n      saveTileTexture(e) {\n        const t = this._tileTextures[e.size[0]];\n        t ? t.push(e) : this._tileTextures[e.size[0]] = [e];\n      }\n      getTileTexture(e) {\n        const t = this._tileTextures[e];\n        return t && t.length > 0 ? t.pop() : null;\n      }\n      isPatternMissing(e) {\n        return null === e || void 0 !== e && !this.imageManager.getPattern(e.toString());\n      }\n      terrainRenderModeElevated() {\n        return this.style && !!this.style.getTerrain() && !!this.terrain && !this.terrain.renderingToTexture;\n      }\n      currentGlobalDefines() {\n        const e = this.terrain && this.terrain.renderingToTexture,\n          t = this.terrain && 0 === this.terrain.exaggeration(),\n          i = this.style && this.style.fog,\n          o = [];\n        return this.terrainRenderModeElevated() && o.push(\"TERRAIN\"), \"globe\" === this.transform.projection.name && o.push(\"GLOBE\"), t && o.push(\"ZERO_EXAGGERATION\"), i && !e && 0 !== i.getOpacity(this.transform.pitch) && o.push(\"FOG\"), e && o.push(\"RENDER_TO_TEXTURE\"), this._showOverdrawInspector && o.push(\"OVERDRAW_INSPECTOR\"), o;\n      }\n      useProgram(e, t, i) {\n        this.cache = this.cache || {};\n        const o = i || [],\n          r = this.currentGlobalDefines().concat(o),\n          n = Li.cacheKey(ci[e], e, r, t);\n        return this.cache[n] || (this.cache[n] = new Li(this.context, e, ci[e], t, so[e], r)), this.cache[n];\n      }\n      setCustomLayerDefaults() {\n        this.context.unbindVAO(), this.context.cullFace.setDefault(), this.context.frontFace.setDefault(), this.context.cullFaceSide.setDefault(), this.context.activeTexture.setDefault(), this.context.pixelStoreUnpack.setDefault(), this.context.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.context.pixelStoreUnpackFlipY.setDefault();\n      }\n      setBaseState() {\n        const e = this.context.gl;\n        this.context.cullFace.set(!1), this.context.viewport.set([0, 0, this.width, this.height]), this.context.blendEquation.set(e.FUNC_ADD);\n      }\n      initDebugOverlayCanvas() {\n        null == this.debugOverlayCanvas && (this.debugOverlayCanvas = e.window.document.createElement(\"canvas\"), this.debugOverlayCanvas.width = 512, this.debugOverlayCanvas.height = 512, this.debugOverlayTexture = new e.Texture(this.context, this.debugOverlayCanvas, this.context.gl.RGBA));\n      }\n      destroy() {\n        this._terrain && this._terrain.destroy(), this.globeSharedBuffers && this.globeSharedBuffers.destroy(), this.emptyTexture.destroy(), this.debugOverlayTexture && this.debugOverlayTexture.destroy(), this.atmosphereBuffer && this.atmosphereBuffer.destroy();\n      }\n      prepareDrawTile() {\n        this.terrain && this.terrain.prepareDrawTile();\n      }\n      prepareDrawProgram(t, i, o) {\n        if (this.terrain && this.terrain.renderingToTexture) return;\n        const r = this.style.fog;\n        if (r) {\n          const n = r.getOpacity(this.transform.pitch),\n            s = ((t, i, o, r, n, s, a, l, c, h, u) => {\n              const _ = t.transform,\n                d = i.properties.get(\"color\").toArray01();\n              d[3] = r;\n              const p = t.frameCounter / 1e3 % 1;\n              return {\n                u_fog_matrix: o ? _.calculateFogTileMatrix(o) : t.identityMat,\n                u_fog_range: i.getFovAdjustedRange(_._fov),\n                u_fog_color: d,\n                u_fog_horizon_blend: i.properties.get(\"horizon-blend\"),\n                u_fog_temporal_offset: p,\n                u_frustum_tl: n,\n                u_frustum_tr: s,\n                u_frustum_br: a,\n                u_frustum_bl: l,\n                u_globe_pos: c,\n                u_globe_radius: h,\n                u_viewport: u,\n                u_globe_transition: e.globeToMercatorTransition(_.zoom),\n                u_is_globe: +(\"globe\" === _.projection.name)\n              };\n            })(this, r, o, n, this.transform.frustumCorners.TL, this.transform.frustumCorners.TR, this.transform.frustumCorners.BR, this.transform.frustumCorners.BL, this.transform.globeCenterInViewSpace, this.transform.globeRadius, [this.transform.width * e.exported.devicePixelRatio, this.transform.height * e.exported.devicePixelRatio]);\n          i.setFogUniformValues(t, s);\n        }\n      }\n      setTileLoadedFlag(e) {\n        this.tileLoaded = e;\n      }\n      saveCanvasCopy() {\n        const e = this.canvasCopy();\n        e && (this.frameCopies.push(e), this.tileLoaded = !1);\n      }\n      canvasCopy() {\n        const e = this.context.gl,\n          t = e.createTexture();\n        return e.bindTexture(e.TEXTURE_2D, t), e.copyTexImage2D(e.TEXTURE_2D, 0, e.RGBA, 0, 0, e.drawingBufferWidth, e.drawingBufferHeight, 0), t;\n      }\n      getCanvasCopiesAndTimestamps() {\n        return {\n          canvasCopies: this.frameCopies,\n          timeStamps: this.loadTimeStamps\n        };\n      }\n      averageElevationNeedsEasing() {\n        if (!this.transform._elevation) return !1;\n        const e = this.style && this.style.fog;\n        return !!e && 0 !== e.getOpacity(this.transform.pitch);\n      }\n      getBackgroundTiles() {\n        const t = this._backgroundTiles,\n          i = this._backgroundTiles = {},\n          o = this.transform.coveringTiles({\n            tileSize: 512\n          });\n        for (const r of o) i[r.key] = t[r.key] || new e.Tile(r, 512, this.transform.tileZoom, this);\n        return i;\n      }\n      clearBackgroundTiles() {\n        this._backgroundTiles = {};\n      }\n    }\n    class ko {\n      constructor(e = 0, t = 0, i = 0, o = 0) {\n        if (isNaN(e) || e < 0 || isNaN(t) || t < 0 || isNaN(i) || i < 0 || isNaN(o) || o < 0) throw new Error(\"Invalid value for edge-insets, top, bottom, left and right must all be numbers\");\n        this.top = e, this.bottom = t, this.left = i, this.right = o;\n      }\n      interpolate(t, i, o) {\n        return null != i.top && null != t.top && (this.top = e.number(t.top, i.top, o)), null != i.bottom && null != t.bottom && (this.bottom = e.number(t.bottom, i.bottom, o)), null != i.left && null != t.left && (this.left = e.number(t.left, i.left, o)), null != i.right && null != t.right && (this.right = e.number(t.right, i.right, o)), this;\n      }\n      getCenter(t, i) {\n        const o = e.clamp((this.left + t - this.right) / 2, 0, t),\n          r = e.clamp((this.top + i - this.bottom) / 2, 0, i);\n        return new e.Point(o, r);\n      }\n      equals(e) {\n        return this.top === e.top && this.bottom === e.bottom && this.left === e.left && this.right === e.right;\n      }\n      clone() {\n        return new ko(this.top, this.bottom, this.left, this.right);\n      }\n      toJSON() {\n        return {\n          top: this.top,\n          bottom: this.bottom,\n          left: this.left,\n          right: this.right\n        };\n      }\n    }\n    function Fo(t, i) {\n      const o = e.getColumn(t, 3);\n      e.fromQuat(t, i), e.setColumn(t, 3, o);\n    }\n    function Uo(t, i) {\n      const o = e.identity$1([]);\n      return e.rotateZ$1(o, o, -i), e.rotateX$1(o, o, -t), o;\n    }\n    function No(t, i) {\n      const o = [t[0], t[1], 0],\n        r = [i[0], i[1], 0];\n      if (e.length(o) >= 1e-15) {\n        const t = e.normalize([], o);\n        e.scale$2(r, t, e.dot(r, t)), i[0] = r[0], i[1] = r[1];\n      }\n      const n = e.cross([], i, t);\n      if (e.len(n) < 1e-15) return null;\n      const s = Math.atan2(-n[1], n[0]);\n      return Uo(Math.atan2(Math.sqrt(t[0] * t[0] + t[1] * t[1]), -t[2]), s);\n    }\n    class jo {\n      constructor(e, t) {\n        this.position = e, this.orientation = t;\n      }\n      get position() {\n        return this._position;\n      }\n      set position(t) {\n        if (t) {\n          const i = t instanceof e.MercatorCoordinate ? t : new e.MercatorCoordinate(t[0], t[1], t[2]);\n          this._renderWorldCopies && (i.x = e.wrap(i.x, 0, 1)), this._position = i;\n        } else this._position = null;\n      }\n      lookAtPoint(t, i) {\n        if (this.orientation = null, !this.position) return;\n        const o = this.position,\n          r = this._elevation ? this._elevation.getAtPointOrZero(e.MercatorCoordinate.fromLngLat(t)) : 0,\n          n = e.MercatorCoordinate.fromLngLat(t, r),\n          s = [n.x - o.x, n.y - o.y, n.z - o.z];\n        i || (i = [0, 0, 1]), i[2] = Math.abs(i[2]), this.orientation = No(s, i);\n      }\n      setPitchBearing(t, i) {\n        this.orientation = Uo(e.degToRad(t), e.degToRad(-i));\n      }\n    }\n    class Go {\n      constructor(t, i) {\n        this._transform = e.identity([]), this.orientation = i, this.position = t;\n      }\n      get mercatorPosition() {\n        const t = this.position;\n        return new e.MercatorCoordinate(t[0], t[1], t[2]);\n      }\n      get position() {\n        const t = e.getColumn(this._transform, 3);\n        return [t[0], t[1], t[2]];\n      }\n      set position(t) {\n        var i;\n        t && e.setColumn(this._transform, 3, [(i = t)[0], i[1], i[2], 1]);\n      }\n      get orientation() {\n        return this._orientation;\n      }\n      set orientation(t) {\n        this._orientation = t || e.identity$1([]), t && Fo(this._transform, this._orientation);\n      }\n      getPitchBearing() {\n        const e = this.forward(),\n          t = this.right();\n        return {\n          bearing: Math.atan2(-t[1], t[0]),\n          pitch: Math.atan2(Math.sqrt(e[0] * e[0] + e[1] * e[1]), -e[2])\n        };\n      }\n      setPitchBearing(e, t) {\n        this._orientation = Uo(e, t), Fo(this._transform, this._orientation);\n      }\n      forward() {\n        const t = e.getColumn(this._transform, 2);\n        return [-t[0], -t[1], -t[2]];\n      }\n      up() {\n        const t = e.getColumn(this._transform, 1);\n        return [-t[0], -t[1], -t[2]];\n      }\n      right() {\n        const t = e.getColumn(this._transform, 0);\n        return [t[0], t[1], t[2]];\n      }\n      getCameraToWorld(t, i) {\n        const o = new Float64Array(16);\n        return e.invert(o, this.getWorldToCamera(t, i)), o;\n      }\n      getWorldToCameraPosition(t, i, o) {\n        const r = this.position;\n        e.scale$2(r, r, -t);\n        const n = new Float64Array(16);\n        return e.fromScaling(n, [o, o, o]), e.translate(n, n, r), n[10] *= i, n;\n      }\n      getWorldToCamera(t, i) {\n        const o = new Float64Array(16),\n          r = new Float64Array(4),\n          n = this.position;\n        return e.conjugate(r, this._orientation), e.scale$2(n, n, -t), e.fromQuat(o, r), e.translate(o, o, n), o[1] *= -1, o[5] *= -1, o[9] *= -1, o[13] *= -1, o[8] *= i, o[9] *= i, o[10] *= i, o[11] *= i, o;\n      }\n      getCameraToClipPerspective(t, i, o, r) {\n        const n = new Float64Array(16);\n        return e.perspective(n, t, i, o, r), n;\n      }\n      getDistanceToElevation(t, i = !1) {\n        const o = 0 === t ? 0 : e.mercatorZfromAltitude(t, i ? e.latFromMercatorY(this.position[1]) : this.position[1]),\n          r = this.forward();\n        return (o - this.position[2]) / r[2];\n      }\n      clone() {\n        return new Go([...this.position], [...this.orientation]);\n      }\n    }\n    function Zo(t, i) {\n      const o = Wo(t.projection, t.zoom, t.width, t.height),\n        r = function (t, i, o, r, n) {\n          const s = new e.LngLat(o.lng - 180 * Xo, o.lat),\n            a = new e.LngLat(o.lng + 180 * Xo, o.lat),\n            l = t.project(s.lng, s.lat),\n            c = t.project(a.lng, a.lat),\n            h = -Math.atan2(c.y - l.y, c.x - l.x),\n            u = e.MercatorCoordinate.fromLngLat(o);\n          u.y = e.clamp(u.y, -1 + Xo, 1 - Xo);\n          const _ = u.toLngLat(),\n            d = t.project(_.lng, _.lat),\n            p = e.MercatorCoordinate.fromLngLat(_);\n          p.x += Xo;\n          const m = p.toLngLat(),\n            f = t.project(m.lng, m.lat),\n            g = $o(f.x - d.x, f.y - d.y, h),\n            v = e.MercatorCoordinate.fromLngLat(_);\n          v.y += Xo;\n          const x = v.toLngLat(),\n            y = t.project(x.lng, x.lat),\n            b = $o(y.x - d.x, y.y - d.y, h),\n            w = Math.abs(g.x) / Math.abs(b.y),\n            T = e.identity([]);\n          e.rotateZ(T, T, -h * (1 - (n ? 0 : r)));\n          const E = e.identity([]);\n          return e.scale(E, E, [1, 1 - (1 - w) * r, 1]), E[4] = -b.x / b.y * r, e.rotateZ(E, E, h), e.multiply(E, T, E), E;\n        }(t.projection, 0, t.center, o, i),\n        n = Vo(t);\n      return e.scale(r, r, [n, n, 1]), r;\n    }\n    function Vo(t) {\n      const i = t.projection,\n        o = Wo(t.projection, t.zoom, t.width, t.height),\n        r = qo(i, t.center),\n        n = qo(i, e.LngLat.convert(i.center));\n      return Math.pow(2, r * o + (1 - o) * n);\n    }\n    function Wo(t, i, o, r, n = 1 / 0) {\n      const s = t.range;\n      if (!s) return 0;\n      const a = Math.min(n, Math.max(o, r)),\n        l = Math.log(a / 1024) / Math.LN2;\n      return e.smoothstep(s[0] + l, s[1] + l, i);\n    }\n    const Xo = 1 / 4e4;\n    function qo(t, i) {\n      const o = e.clamp(i.lat, -e.MAX_MERCATOR_LATITUDE, e.MAX_MERCATOR_LATITUDE),\n        r = new e.LngLat(i.lng - 180 * Xo, o),\n        n = new e.LngLat(i.lng + 180 * Xo, o),\n        s = t.project(r.lng, o),\n        a = t.project(n.lng, o),\n        l = e.MercatorCoordinate.fromLngLat(r),\n        c = e.MercatorCoordinate.fromLngLat(n),\n        h = a.x - s.x,\n        u = a.y - s.y,\n        _ = c.x - l.x,\n        d = c.y - l.y,\n        p = Math.sqrt((_ * _ + d * d) / (h * h + u * u));\n      return Math.log(p) / Math.LN2;\n    }\n    function $o(e, t, i) {\n      const o = Math.cos(i),\n        r = Math.sin(i);\n      return {\n        x: e * o - t * r,\n        y: e * r + t * o\n      };\n    }\n    class Ho {\n      constructor(t, i, o, r, n, s, a) {\n        this.tileSize = 512, this._renderWorldCopies = void 0 === n || n, this._minZoom = t || 0, this._maxZoom = i || 22, this._minPitch = null == o ? 0 : o, this._maxPitch = null == r ? 60 : r, this.setProjection(s), this.setMaxBounds(a), this.width = 0, this.height = 0, this._center = new e.LngLat(0, 0), this.zoom = 0, this.angle = 0, this._fov = .6435011087932844, this._pitch = 0, this._nearZ = 0, this._farZ = 0, this._unmodified = !0, this._edgeInsets = new ko(), this._projMatrixCache = {}, this._alignedProjMatrixCache = {}, this._fogTileMatrixCache = {}, this._distanceTileDataCache = {}, this._camera = new Go(), this._centerAltitude = 0, this._averageElevation = 0, this.cameraElevationReference = \"ground\", this._pixelsPerMercatorPixel = 1, this.globeRadius = 0, this.globeCenterInViewSpace = [0, 0, 0], this._horizonShift = .1;\n      }\n      clone() {\n        const e = new Ho(this._minZoom, this._maxZoom, this._minPitch, this.maxPitch, this._renderWorldCopies, this.getProjection());\n        return e._elevation = this._elevation, e._centerAltitude = this._centerAltitude, e._centerAltitudeValidForExaggeration = this._centerAltitudeValidForExaggeration, e.tileSize = this.tileSize, e.mercatorFromTransition = this.mercatorFromTransition, e.width = this.width, e.height = this.height, e.cameraElevationReference = this.cameraElevationReference, e._center = this._center, e._setZoom(this.zoom), e._seaLevelZoom = this._seaLevelZoom, e.angle = this.angle, e._fov = this._fov, e._pitch = this._pitch, e._nearZ = this._nearZ, e._farZ = this._farZ, e._averageElevation = this._averageElevation, e._unmodified = this._unmodified, e._edgeInsets = this._edgeInsets.clone(), e._camera = this._camera.clone(), e._calcMatrices(), e.freezeTileCoverage = this.freezeTileCoverage, e.frustumCorners = this.frustumCorners, e;\n      }\n      get elevation() {\n        return this._elevation;\n      }\n      set elevation(e) {\n        this._elevation !== e && (this._elevation = e, this._updateCameraOnTerrain(), this._calcMatrices());\n      }\n      updateElevation(e, t = !1) {\n        const i = this._elevation && this._elevation.exaggeration() !== this._centerAltitudeValidForExaggeration;\n        (null == this._seaLevelZoom || i) && this._updateCameraOnTerrain(), (e || i) && this._constrainCamera(t), this._calcMatrices();\n      }\n      getProjection() {\n        return e.pick(this.projection, [\"name\", \"center\", \"parallels\"]);\n      }\n      setProjection(i) {\n        this.projectionOptions = i || {\n          name: \"mercator\"\n        };\n        const o = this.projection ? this.getProjection() : void 0;\n        this.projection = e.getProjection(this.projectionOptions);\n        const r = !t(o, this.getProjection());\n        return r && this._calcMatrices(), this.mercatorFromTransition = !1, r;\n      }\n      setMercatorFromTransition() {\n        const t = this.projection.name;\n        this.mercatorFromTransition = !0, this.projectionOptions = {\n          name: \"mercator\"\n        }, this.projection = e.getProjection({\n          name: \"mercator\"\n        });\n        const i = t !== this.projection.name;\n        return i && this._calcMatrices(), i;\n      }\n      get minZoom() {\n        return this._minZoom;\n      }\n      set minZoom(e) {\n        this._minZoom !== e && (this._minZoom = e, this.zoom = Math.max(this.zoom, e));\n      }\n      get maxZoom() {\n        return this._maxZoom;\n      }\n      set maxZoom(e) {\n        this._maxZoom !== e && (this._maxZoom = e, this.zoom = Math.min(this.zoom, e));\n      }\n      get minPitch() {\n        return this._minPitch;\n      }\n      set minPitch(e) {\n        this._minPitch !== e && (this._minPitch = e, this.pitch = Math.max(this.pitch, e));\n      }\n      get maxPitch() {\n        return this._maxPitch;\n      }\n      set maxPitch(e) {\n        this._maxPitch !== e && (this._maxPitch = e, this.pitch = Math.min(this.pitch, e));\n      }\n      get renderWorldCopies() {\n        return this._renderWorldCopies && !0 === this.projection.supportsWorldCopies;\n      }\n      set renderWorldCopies(e) {\n        void 0 === e ? e = !0 : null === e && (e = !1), this._renderWorldCopies = e;\n      }\n      get worldSize() {\n        return this.tileSize * this.scale;\n      }\n      get cameraWorldSizeForFog() {\n        const e = Math.max(this._camera.getDistanceToElevation(this._averageElevation), Number.EPSILON);\n        return this._worldSizeFromZoom(this._zoomFromMercatorZ(e));\n      }\n      get cameraWorldSize() {\n        const e = Math.max(this._camera.getDistanceToElevation(this._averageElevation, !0), Number.EPSILON);\n        return this._worldSizeFromZoom(this._zoomFromMercatorZ(e));\n      }\n      get pixelsPerMeter() {\n        return this.projection.pixelsPerMeter(this.center.lat, this.worldSize);\n      }\n      get cameraPixelsPerMeter() {\n        return e.mercatorZfromAltitude(this.center.lat, this.cameraWorldSizeForFog);\n      }\n      get centerOffset() {\n        return this.centerPoint._sub(this.size._div(2));\n      }\n      get size() {\n        return new e.Point(this.width, this.height);\n      }\n      get bearing() {\n        return e.wrap(this.rotation, -180, 180);\n      }\n      set bearing(e) {\n        this.rotation = e;\n      }\n      get rotation() {\n        return -this.angle / Math.PI * 180;\n      }\n      set rotation(t) {\n        const i = -t * Math.PI / 180;\n        var o;\n        this.angle !== i && (this._unmodified = !1, this.angle = i, this._calcMatrices(), this.rotationMatrix = (o = new e.ARRAY_TYPE(4), e.ARRAY_TYPE != Float32Array && (o[1] = 0, o[2] = 0), o[0] = 1, o[3] = 1, o), function (e, t, i) {\n          var o = t[0],\n            r = t[1],\n            n = t[2],\n            s = t[3],\n            a = Math.sin(i),\n            l = Math.cos(i);\n          e[0] = o * l + n * a, e[1] = r * l + s * a, e[2] = o * -a + n * l, e[3] = r * -a + s * l;\n        }(this.rotationMatrix, this.rotationMatrix, this.angle));\n      }\n      get pitch() {\n        return this._pitch / Math.PI * 180;\n      }\n      set pitch(t) {\n        const i = e.clamp(t, this.minPitch, this.maxPitch) / 180 * Math.PI;\n        this._pitch !== i && (this._unmodified = !1, this._pitch = i, this._calcMatrices());\n      }\n      get aspect() {\n        return this.width / this.height;\n      }\n      get fov() {\n        return this._fov / Math.PI * 180;\n      }\n      get fovX() {\n        return this._fov;\n      }\n      get fovY() {\n        const e = 1 / Math.tan(.5 * this.fovX);\n        return 2 * Math.atan(1 / this.aspect / e);\n      }\n      set fov(t) {\n        t = Math.max(.01, Math.min(60, t)), this._fov !== t && (this._unmodified = !1, this._fov = e.degToRad(t), this._calcMatrices());\n      }\n      get averageElevation() {\n        return this._averageElevation;\n      }\n      set averageElevation(e) {\n        this._averageElevation = e, this._calcFogMatrices(), this._distanceTileDataCache = {};\n      }\n      get zoom() {\n        return this._zoom;\n      }\n      set zoom(e) {\n        const t = Math.min(Math.max(e, this.minZoom), this.maxZoom);\n        this._zoom !== t && (this._unmodified = !1, this._setZoom(t), this._updateSeaLevelZoom(), this._constrain(), this._calcMatrices());\n      }\n      _setZoom(e) {\n        this._zoom = e, this.scale = this.zoomScale(e), this.tileZoom = Math.floor(e), this.zoomFraction = e - this.tileZoom;\n      }\n      _updateCameraOnTerrain() {\n        if (!this._elevation || !this._elevation.isDataAvailableAtPoint(this.locationCoordinate(this.center))) return this._centerAltitude = 0, this._seaLevelZoom = null, void (this._centerAltitudeValidForExaggeration = void 0);\n        const e = this._elevation;\n        this._centerAltitude = e.getAtPointOrZero(this.locationCoordinate(this.center)), this._centerAltitudeValidForExaggeration = e.exaggeration(), this._updateSeaLevelZoom();\n      }\n      _updateSeaLevelZoom() {\n        void 0 !== this._centerAltitudeValidForExaggeration && (this._seaLevelZoom = this._zoomFromMercatorZ((this.pixelsPerMeter * this._centerAltitude + this.cameraToCenterDistance) / this.worldSize));\n      }\n      sampleAverageElevation() {\n        if (!this._elevation) return 0;\n        const t = this._elevation,\n          i = [[.5, .2], [.3, .5], [.5, .5], [.7, .5], [.5, .8]],\n          o = this.horizonLineFromTop();\n        let r = 0,\n          n = 0;\n        for (let s = 0; s < i.length; s++) {\n          const a = new e.Point(i[s][0] * this.width, o + i[s][1] * (this.height - o)),\n            l = t.pointCoordinate(a);\n          if (!l) continue;\n          const c = 1 / Math.hypot(l[0] - this._camera.position[0], l[1] - this._camera.position[1]);\n          r += l[3] * c, n += c;\n        }\n        return 0 === n ? NaN : r / n;\n      }\n      get center() {\n        return this._center;\n      }\n      set center(e) {\n        e.lat === this._center.lat && e.lng === this._center.lng || (this._unmodified = !1, this._center = e, this._terrainEnabled() && (\"ground\" === this.cameraElevationReference ? this._updateCameraOnTerrain() : this._updateZoomFromElevation()), this._constrain(), this._calcMatrices());\n      }\n      _updateZoomFromElevation() {\n        if (null == this._seaLevelZoom || !this._elevation) return;\n        const e = this._seaLevelZoom,\n          t = this._elevation.getAtPointOrZero(this.locationCoordinate(this.center)),\n          i = this.pixelsPerMeter / this.worldSize * t,\n          o = this._mercatorZfromZoom(e),\n          r = this._mercatorZfromZoom(this._maxZoom),\n          n = Math.max(o - i, r);\n        this._setZoom(this._zoomFromMercatorZ(n));\n      }\n      get padding() {\n        return this._edgeInsets.toJSON();\n      }\n      set padding(e) {\n        this._edgeInsets.equals(e) || (this._unmodified = !1, this._edgeInsets.interpolate(this._edgeInsets, e, 1), this._calcMatrices());\n      }\n      computeZoomRelativeTo(t) {\n        const i = this.rayIntersectionCoordinate(this.pointRayIntersection(this.centerPoint, t.toAltitude()));\n        let o;\n        o = t.z < this._camera.position[2] ? [i.x, i.y, i.z] : [t.x, t.y, t.z];\n        const r = e.length(e.sub([], this._camera.position, o));\n        return e.clamp(this._zoomFromMercatorZ(r), this._minZoom, this._maxZoom);\n      }\n      setFreeCameraOptions(t) {\n        if (!this.height) return;\n        if (!t.position && !t.orientation) return;\n        this._updateCameraState();\n        let i = !1;\n        if (t.orientation && !e.exactEquals(t.orientation, this._camera.orientation) && (i = this._setCameraOrientation(t.orientation)), t.position) {\n          const o = [t.position.x, t.position.y, t.position.z];\n          e.exactEquals$1(o, this._camera.position) || (this._setCameraPosition(o), i = !0);\n        }\n        i && (this._updateStateFromCamera(), this.recenterOnTerrain());\n      }\n      getFreeCameraOptions() {\n        this._updateCameraState();\n        const t = this._camera.position,\n          i = new jo();\n        return i.position = new e.MercatorCoordinate(t[0], t[1], t[2]), i.orientation = this._camera.orientation, i._elevation = this.elevation, i._renderWorldCopies = this.renderWorldCopies, i;\n      }\n      _setCameraOrientation(t) {\n        if (!e.length$1(t)) return !1;\n        e.normalize$1(t, t);\n        const i = e.transformQuat([], [0, 0, -1], t),\n          o = e.transformQuat([], [0, -1, 0], t);\n        if (o[2] < 0) return !1;\n        const r = No(i, o);\n        return !!r && (this._camera.orientation = r, !0);\n      }\n      _setCameraPosition(t) {\n        const i = this.zoomScale(this.minZoom) * this.tileSize,\n          o = this.zoomScale(this.maxZoom) * this.tileSize,\n          r = this.cameraToCenterDistance;\n        t[2] = e.clamp(t[2], r / o, r / i), this._camera.position = t;\n      }\n      get centerPoint() {\n        return this._edgeInsets.getCenter(this.width, this.height);\n      }\n      get fovAboveCenter() {\n        return this._fov * (.5 + this.centerOffset.y / this.height);\n      }\n      isPaddingEqual(e) {\n        return this._edgeInsets.equals(e);\n      }\n      interpolatePadding(e, t, i) {\n        this._unmodified = !1, this._edgeInsets.interpolate(e, t, i), this._constrain(), this._calcMatrices();\n      }\n      coveringZoomLevel(e) {\n        const t = (e.roundZoom ? Math.round : Math.floor)(this.zoom + this.scaleZoom(this.tileSize / e.tileSize));\n        return Math.max(0, t);\n      }\n      getVisibleUnwrappedCoordinates(t) {\n        const i = [new e.UnwrappedTileID(0, t)];\n        if (this.renderWorldCopies) {\n          const o = this.pointCoordinate(new e.Point(0, 0)),\n            r = this.pointCoordinate(new e.Point(this.width, 0)),\n            n = this.pointCoordinate(new e.Point(this.width, this.height)),\n            s = this.pointCoordinate(new e.Point(0, this.height)),\n            a = Math.floor(Math.min(o.x, r.x, n.x, s.x)),\n            l = Math.floor(Math.max(o.x, r.x, n.x, s.x)),\n            c = 1;\n          for (let o = a - c; o <= l + c; o++) 0 !== o && i.push(new e.UnwrappedTileID(o, t));\n        }\n        return i;\n      }\n      coveringTiles(t) {\n        let i = this.coveringZoomLevel(t);\n        const o = i,\n          r = this.elevation && !t.isTerrainDEM,\n          n = \"mercator\" === this.projection.name;\n        if (void 0 !== t.minzoom && i < t.minzoom) return [];\n        void 0 !== t.maxzoom && i > t.maxzoom && (i = t.maxzoom);\n        const s = this.locationCoordinate(this.center),\n          a = this.center.lat,\n          l = 1 << i,\n          c = [l * s.x, l * s.y, 0],\n          h = \"globe\" === this.projection.name,\n          u = !h,\n          _ = e.Frustum.fromInvProjectionMatrix(this.invProjMatrix, this.worldSize, i, u),\n          d = h ? this._camera.mercatorPosition : this.pointCoordinate(this.getCameraPoint()),\n          p = l * e.mercatorZfromAltitude(1, this.center.lat),\n          m = this._camera.position[2] / e.mercatorZfromAltitude(1, this.center.lat),\n          f = [l * d.x, l * d.y, m * (u ? 1 : p)],\n          g = this.cameraToCenterDistance / t.tileSize * (t.roundZoom ? 1 : .502),\n          v = this.pitch <= 60 && this._edgeInsets.top <= this._edgeInsets.bottom && !this._elevation && !this.projection.isReprojectedInTileSpace ? i : 0,\n          x = t.isTerrainDEM && this._elevation ? 1e4 * this._elevation.exaggeration() : this._centerAltitude,\n          y = t.isTerrainDEM ? -x : this._elevation ? this._elevation.getMinElevationBelowMSL() : 0,\n          b = this.projection.isReprojectedInTileSpace ? Vo(this) : 1,\n          w = t => {\n            const i = 1 / 4e4,\n              o = new e.MercatorCoordinate(t.x + i, t.y, t.z),\n              r = new e.MercatorCoordinate(t.x, t.y + i, t.z),\n              n = t.toLngLat(),\n              s = o.toLngLat(),\n              a = r.toLngLat(),\n              l = this.locationCoordinate(n),\n              c = this.locationCoordinate(s),\n              h = this.locationCoordinate(a),\n              u = Math.hypot(c.x - l.x, c.y - l.y),\n              _ = Math.hypot(h.x - l.x, h.y - l.y);\n            return Math.sqrt(u * _) * b / i;\n          },\n          T = t => {\n            const i = x,\n              o = y;\n            return {\n              aabb: e.tileAABB(this, l, 0, 0, 0, t, o, i, this.projection),\n              zoom: 0,\n              x: 0,\n              y: 0,\n              minZ: o,\n              maxZ: i,\n              wrap: t,\n              fullyVisible: !1\n            };\n          },\n          E = [];\n        let C = [];\n        const M = i,\n          I = t.reparseOverscaled ? o : i,\n          P = e => e * e,\n          S = P((m - this._centerAltitude) * p),\n          D = e => {\n            if (!this._elevation || !e.tileID || !n) return;\n            const t = this._elevation.getMinMaxForTile(e.tileID),\n              i = e.aabb;\n            t ? (i.min[2] = t.min, i.max[2] = t.max, i.center[2] = (i.min[2] + i.max[2]) / 2) : (e.shouldSplit = L(e), e.shouldSplit || (i.min[2] = i.max[2] = i.center[2] = this._centerAltitude));\n          },\n          L = t => {\n            if (t.zoom < v) return !0;\n            if (t.zoom === M) return !1;\n            if (null != t.shouldSplit) return t.shouldSplit;\n            const i = t.aabb.distanceX(f),\n              n = t.aabb.distanceY(f);\n            let s = S,\n              l = 1;\n            if (h) {\n              s = P(t.aabb.distanceZ(f));\n              const i = Math.pow(2, t.zoom),\n                o = e.latFromMercatorY((t.y + 1) / i),\n                r = e.latFromMercatorY(t.y / i),\n                n = Math.min(Math.max(a, o), r),\n                c = e.circumferenceAtLatitude(n) / e.circumferenceAtLatitude(a);\n              if (l = n === a ? 1 / Math.max(1, this._mercatorScaleRatio - .3) : Math.min(1, c / this._mercatorScaleRatio), this.zoom <= e.GLOBE_ZOOM_THRESHOLD_MIN && t.zoom === M - 1 && c >= .9) return !0;\n            } else if (r && (s = P(t.aabb.distanceZ(f) * p)), this.projection.isReprojectedInTileSpace && o <= 5) {\n              const i = Math.pow(2, t.zoom),\n                o = w(new e.MercatorCoordinate((t.x + .5) / i, (t.y + .5) / i));\n              l = o > .85 ? 1 : o;\n            }\n            const c = i * i + n * n + s,\n              u = P((1 << M - t.zoom) * g * l * ((e, t) => {\n                if (t * P(.707) < e) return 1;\n                const i = Math.sqrt(t / e);\n                return i / (1.4144271570014144 + (Math.pow(1.1, i - 1.4144271570014144 + 1) - 1) / (1.1 - 1) - 1);\n              })(Math.max(s, S), c));\n            return c < u;\n          };\n        if (this.renderWorldCopies) for (let e = 1; e <= 3; e++) E.push(T(-e)), E.push(T(e));\n        for (E.push(T(0)); E.length > 0;) {\n          const o = E.pop(),\n            s = o.x,\n            a = o.y;\n          let u = o.fullyVisible;\n          if (!u) {\n            const e = o.aabb.intersects(_);\n            if (0 === e) continue;\n            u = 2 === e;\n          }\n          if (o.zoom !== M && L(o)) for (let t = 0; t < 4; t++) {\n            const i = (s << 1) + t % 2,\n              c = (a << 1) + (t >> 1),\n              _ = {\n                aabb: n ? o.aabb.quadrant(t) : e.tileAABB(this, l, o.zoom + 1, i, c, o.wrap, o.minZ, o.maxZ, this.projection),\n                zoom: o.zoom + 1,\n                x: i,\n                y: c,\n                wrap: o.wrap,\n                fullyVisible: u,\n                tileID: void 0,\n                shouldSplit: void 0,\n                minZ: o.minZ,\n                maxZ: o.maxZ\n              };\n            r && !h && (_.tileID = new e.OverscaledTileID(o.zoom + 1 === M ? I : o.zoom + 1, o.wrap, o.zoom + 1, i, c), D(_)), E.push(_);\n          } else {\n            const r = o.zoom === M ? I : o.zoom;\n            if (t.minzoom && t.minzoom > r) continue;\n            const n = c[0] - (.5 + s + (o.wrap << o.zoom)) * (1 << i - o.zoom),\n              l = c[1] - .5 - a,\n              h = o.tileID ? o.tileID : new e.OverscaledTileID(r, o.wrap, o.zoom, s, a);\n            C.push({\n              tileID: h,\n              distanceSq: n * n + l * l\n            });\n          }\n        }\n        if (this.fogCullDistSq) {\n          const i = this.fogCullDistSq,\n            o = this.horizonLineFromTop();\n          C = C.filter(r => {\n            const n = [0, 0, 0, 1],\n              s = [e.EXTENT, e.EXTENT, 0, 1],\n              a = this.calculateFogTileMatrix(r.tileID.toUnwrapped());\n            e.transformMat4$1(n, n, a), e.transformMat4$1(s, s, a);\n            const l = e.getAABBPointSquareDist(n, s);\n            if (0 === l) return !0;\n            let c = !1;\n            const h = this._elevation;\n            if (h && l > i && 0 !== o) {\n              const i = this.calculateProjMatrix(r.tileID.toUnwrapped());\n              let n;\n              t.isTerrainDEM || (n = h.getMinMaxForTile(r.tileID)), n || (n = {\n                min: y,\n                max: x\n              });\n              const s = e.furthestTileCorner(this.rotation),\n                a = [s[0] * e.EXTENT, s[1] * e.EXTENT, n.max];\n              e.transformMat4(a, a, i), c = (1 - a[1]) * this.height * .5 < o;\n            }\n            return l < i || c;\n          });\n        }\n        return C.sort((e, t) => e.distanceSq - t.distanceSq).map(e => e.tileID);\n      }\n      resize(e, t) {\n        this.width = e, this.height = t, this.pixelsToGLUnits = [2 / e, -2 / t], this._constrain(), this._calcMatrices();\n      }\n      get unmodified() {\n        return this._unmodified;\n      }\n      zoomScale(e) {\n        return Math.pow(2, e);\n      }\n      scaleZoom(e) {\n        return Math.log(e) / Math.LN2;\n      }\n      project(t) {\n        const i = e.clamp(t.lat, -e.MAX_MERCATOR_LATITUDE, e.MAX_MERCATOR_LATITUDE),\n          o = this.projection.project(t.lng, i);\n        return new e.Point(o.x * this.worldSize, o.y * this.worldSize);\n      }\n      unproject(e) {\n        return this.projection.unproject(e.x / this.worldSize, e.y / this.worldSize);\n      }\n      get point() {\n        return this.project(this.center);\n      }\n      get pointMerc() {\n        return this.point._div(this.worldSize);\n      }\n      get pixelsPerMeterRatio() {\n        return this.pixelsPerMeter / e.mercatorZfromAltitude(1, this.center.lat) / this.worldSize;\n      }\n      setLocationAtPoint(t, i) {\n        let o, r;\n        const n = this.centerPoint;\n        if (\"globe\" === this.projection.name) {\n          const e = this.worldSize;\n          o = (i.x - n.x) / e, r = (i.y - n.y) / e;\n        } else {\n          const e = this.pointCoordinate(i),\n            t = this.pointCoordinate(n);\n          o = e.x - t.x, r = e.y - t.y;\n        }\n        const s = this.locationCoordinate(t);\n        this.setLocation(new e.MercatorCoordinate(s.x - o, s.y - r));\n      }\n      setLocation(e) {\n        this.center = this.coordinateLocation(e), this.projection.wrap && (this.center = this.center.wrap());\n      }\n      locationPoint(e) {\n        return this.projection.locationPoint(this, e);\n      }\n      locationPoint3D(e) {\n        return this.projection.locationPoint(this, e, !0);\n      }\n      pointLocation(e) {\n        return this.coordinateLocation(this.pointCoordinate(e));\n      }\n      pointLocation3D(e) {\n        return this.coordinateLocation(this.pointCoordinate3D(e));\n      }\n      locationCoordinate(t, i) {\n        const o = i ? e.mercatorZfromAltitude(i, t.lat) : void 0,\n          r = this.projection.project(t.lng, t.lat);\n        return new e.MercatorCoordinate(r.x, r.y, o);\n      }\n      coordinateLocation(e) {\n        return this.projection.unproject(e.x, e.y);\n      }\n      pointRayIntersection(t, i) {\n        const o = null != i ? i : this._centerAltitude,\n          r = [t.x, t.y, 0, 1],\n          n = [t.x, t.y, 1, 1];\n        e.transformMat4$1(r, r, this.pixelMatrixInverse), e.transformMat4$1(n, n, this.pixelMatrixInverse);\n        const s = n[3];\n        e.scale$1(r, r, 1 / r[3]), e.scale$1(n, n, 1 / s);\n        const a = r[2],\n          l = n[2];\n        return {\n          p0: r,\n          p1: n,\n          t: a === l ? 0 : (o - a) / (l - a)\n        };\n      }\n      screenPointToMercatorRay(t) {\n        const i = [t.x, t.y, 0, 1],\n          o = [t.x, t.y, 1, 1];\n        return e.transformMat4$1(i, i, this.pixelMatrixInverse), e.transformMat4$1(o, o, this.pixelMatrixInverse), e.scale$1(i, i, 1 / i[3]), e.scale$1(o, o, 1 / o[3]), i[2] = e.mercatorZfromAltitude(i[2], this._center.lat) * this.worldSize, o[2] = e.mercatorZfromAltitude(o[2], this._center.lat) * this.worldSize, e.scale$1(i, i, 1 / this.worldSize), e.scale$1(o, o, 1 / this.worldSize), new e.Ray([i[0], i[1], i[2]], e.normalize([], e.sub([], o, i)));\n      }\n      rayIntersectionCoordinate(t) {\n        const {\n            p0: i,\n            p1: o,\n            t: r\n          } = t,\n          n = e.mercatorZfromAltitude(i[2], this._center.lat),\n          s = e.mercatorZfromAltitude(o[2], this._center.lat);\n        return new e.MercatorCoordinate(e.number(i[0], o[0], r) / this.worldSize, e.number(i[1], o[1], r) / this.worldSize, e.number(n, s, r));\n      }\n      pointCoordinate(e, t = this._centerAltitude) {\n        return this.projection.pointCoordinate(this, e.x, e.y, t);\n      }\n      pointCoordinate3D(t) {\n        if (!this.elevation) return this.pointCoordinate(t);\n        let i = this.projection.pointCoordinate3D(this, t.x, t.y);\n        if (i) return new e.MercatorCoordinate(i[0], i[1], i[2]);\n        let o = 0,\n          r = this.horizonLineFromTop();\n        if (t.y > r) return this.pointCoordinate(t);\n        const n = .02 * r,\n          s = t.clone();\n        for (let t = 0; t < 10 && r - o > n; t++) {\n          s.y = e.number(o, r, .66);\n          const t = this.projection.pointCoordinate3D(this, s.x, s.y);\n          t ? (r = s.y, i = t) : o = s.y;\n        }\n        return i ? new e.MercatorCoordinate(i[0], i[1], i[2]) : this.pointCoordinate(t);\n      }\n      isPointAboveHorizon(e) {\n        return this.projection.isPointAboveHorizon(this, e);\n      }\n      isPointOnSurface(t) {\n        if (t.y < 0 || t.y > this.height || t.x < 0 || t.x > this.width) return !1;\n        if (this.elevation || this.zoom >= e.GLOBE_ZOOM_THRESHOLD_MAX) return !this.isPointAboveHorizon(t);\n        const i = this.pointCoordinate(t);\n        return i.y >= 0 && i.y <= 1;\n      }\n      _coordinatePoint(t, i) {\n        const o = i && this.elevation ? this.elevation.getAtPointOrZero(t, this._centerAltitude) : this._centerAltitude,\n          r = [t.x * this.worldSize, t.y * this.worldSize, o + t.toAltitude(), 1];\n        return e.transformMat4$1(r, r, this.pixelMatrix), r[3] > 0 ? new e.Point(r[0] / r[3], r[1] / r[3]) : new e.Point(Number.MAX_VALUE, Number.MAX_VALUE);\n      }\n      _getBoundsNonRectangular() {\n        const {\n            top: t,\n            left: i\n          } = this._edgeInsets,\n          o = this.height - this._edgeInsets.bottom,\n          r = this.width - this._edgeInsets.right,\n          n = this.pointLocation3D(new e.Point(i, t)),\n          s = this.pointLocation3D(new e.Point(r, t)),\n          a = this.pointLocation3D(new e.Point(r, o)),\n          l = this.pointLocation3D(new e.Point(i, o));\n        let c = Math.min(n.lng, s.lng, a.lng, l.lng),\n          h = Math.max(n.lng, s.lng, a.lng, l.lng),\n          u = Math.min(n.lat, s.lat, a.lat, l.lat),\n          _ = Math.max(n.lat, s.lat, a.lat, l.lat);\n        const d = Math.pow(2, -this.zoom) / 16 * 270,\n          p = \"globe\" === this.projection.name ? 1 : 4,\n          m = (t, i, o, r, n) => {\n            const s = (t + o) / 2,\n              a = (i + r) / 2,\n              l = new e.Point(s, a),\n              {\n                lng: f,\n                lat: g\n              } = this.pointLocation3D(l),\n              v = Math.max(0, c - f, u - g, f - h, g - _);\n            c = Math.min(c, f), h = Math.max(h, f), u = Math.min(u, g), _ = Math.max(_, g), (n < p || v > d) && (m(t, i, s, a, n + 1), m(s, a, o, r, n + 1));\n          };\n        if (m(i, t, r, t, 1), m(r, t, r, o, 1), m(r, o, i, o, 1), m(i, o, i, t, 1), \"globe\" === this.projection.name) {\n          const [t, i] = e.polesInViewport(this);\n          t ? (_ = 90, h = 180, c = -180) : i && (u = -90, h = 180, c = -180);\n        }\n        return new e.LngLatBounds(new e.LngLat(c, u), new e.LngLat(h, _));\n      }\n      _getBoundsRectangular(t, i) {\n        const {\n            top: o,\n            left: r\n          } = this._edgeInsets,\n          n = this.height - this._edgeInsets.bottom,\n          s = this.width - this._edgeInsets.right,\n          a = new e.Point(r, o),\n          l = new e.Point(s, o),\n          c = new e.Point(s, n),\n          h = new e.Point(r, n);\n        let u = this.pointCoordinate(a, t),\n          _ = this.pointCoordinate(l, t);\n        const d = this.pointCoordinate(c, i),\n          p = this.pointCoordinate(h, i),\n          m = (e, t) => (t.y - e.y) / (t.x - e.x);\n        return u.y > 1 && _.y >= 0 ? u = new e.MercatorCoordinate((1 - p.y) / m(p, u) + p.x, 1) : u.y < 0 && _.y <= 1 && (u = new e.MercatorCoordinate(-p.y / m(p, u) + p.x, 0)), _.y > 1 && u.y >= 0 ? _ = new e.MercatorCoordinate((1 - d.y) / m(d, _) + d.x, 1) : _.y < 0 && u.y <= 1 && (_ = new e.MercatorCoordinate(-d.y / m(d, _) + d.x, 0)), new e.LngLatBounds().extend(this.coordinateLocation(u)).extend(this.coordinateLocation(_)).extend(this.coordinateLocation(p)).extend(this.coordinateLocation(d));\n      }\n      _getBoundsRectangularTerrain() {\n        const e = this.elevation;\n        if (!e.visibleDemTiles.length || e.isUsingMockSource()) return this._getBoundsRectangular(0, 0);\n        const t = e.visibleDemTiles.reduce((e, t) => {\n          if (t.dem) {\n            const i = t.dem.tree;\n            e.min = Math.min(e.min, i.minimums[0]), e.max = Math.max(e.max, i.maximums[0]);\n          }\n          return e;\n        }, {\n          min: Number.MAX_VALUE,\n          max: 0\n        });\n        return this._getBoundsRectangular(t.min * e.exaggeration(), t.max * e.exaggeration());\n      }\n      getBounds() {\n        return \"mercator\" === this.projection.name || \"equirectangular\" === this.projection.name ? this._terrainEnabled() ? this._getBoundsRectangularTerrain() : this._getBoundsRectangular(0, 0) : this._getBoundsNonRectangular();\n      }\n      horizonLineFromTop(e = !0) {\n        const t = this.height / 2 / Math.tan(this._fov / 2) / Math.tan(Math.max(this._pitch, .1)) + this.centerOffset.y,\n          i = this.height / 2 - t * (1 - this._horizonShift);\n        return e ? Math.max(0, i) : i;\n      }\n      getMaxBounds() {\n        return this.maxBounds;\n      }\n      setMaxBounds(t) {\n        this.maxBounds = t, this.minLat = -e.MAX_MERCATOR_LATITUDE, this.maxLat = e.MAX_MERCATOR_LATITUDE, this.minLng = -180, this.maxLng = 180, t && (this.minLat = t.getSouth(), this.maxLat = t.getNorth(), this.minLng = t.getWest(), this.maxLng = t.getEast(), this.maxLng < this.minLng && (this.maxLng += 360)), this.worldMinX = e.mercatorXfromLng(this.minLng) * this.tileSize, this.worldMaxX = e.mercatorXfromLng(this.maxLng) * this.tileSize, this.worldMinY = e.mercatorYfromLat(this.maxLat) * this.tileSize, this.worldMaxY = e.mercatorYfromLat(this.minLat) * this.tileSize, this._constrain();\n      }\n      calculatePosMatrix(e, t) {\n        return this.projection.createTileMatrix(this, t, e);\n      }\n      calculateDistanceTileData(t) {\n        const i = t.key,\n          o = this._distanceTileDataCache;\n        if (o[i]) return o[i];\n        const r = t.canonical,\n          n = 1 / this.height,\n          s = this.cameraWorldSize,\n          a = s / this.zoomScale(r.z),\n          l = (r.x + Math.pow(2, r.z) * t.wrap) * a,\n          c = r.y * a,\n          h = this.point;\n        h.x *= s / this.worldSize, h.y *= s / this.worldSize;\n        const u = this.angle,\n          _ = Math.sin(-u),\n          d = -Math.cos(-u);\n        return o[i] = {\n          bearing: [_, d],\n          center: [(h.x - l) * n, (h.y - c) * n],\n          scale: a / e.EXTENT * n\n        }, o[i];\n      }\n      calculateFogTileMatrix(t) {\n        const i = t.key,\n          o = this._fogTileMatrixCache;\n        if (o[i]) return o[i];\n        const r = this.projection.createTileMatrix(this, this.cameraWorldSizeForFog, t);\n        return e.multiply(r, this.worldToFogMatrix, r), o[i] = new Float32Array(r), o[i];\n      }\n      calculateProjMatrix(t, i = !1) {\n        const o = t.key,\n          r = i ? this._alignedProjMatrixCache : this._projMatrixCache;\n        if (r[o]) return r[o];\n        const n = this.calculatePosMatrix(t, this.worldSize);\n        return e.multiply(n, this.projection.isReprojectedInTileSpace ? this.mercatorMatrix : i ? this.alignedProjMatrix : this.projMatrix, n), r[o] = new Float32Array(n), r[o];\n      }\n      calculatePixelsToTileUnitsMatrix(t) {\n        const i = t.tileID.key,\n          o = this._pixelsToTileUnitsCache;\n        if (o[i]) return o[i];\n        const r = function (t, i) {\n          const {\n              scale: o\n            } = t.tileTransform,\n            r = o * e.EXTENT / (t.tileSize * Math.pow(2, i.zoom - t.tileID.overscaledZ + t.tileID.canonical.z));\n          return n = new Float32Array(4), l = (s = i.inverseAdjustmentMatrix)[1], c = s[2], h = s[3], _ = (a = [r, r])[1], n[0] = s[0] * (u = a[0]), n[1] = l * u, n[2] = c * _, n[3] = h * _, n;\n          var n, s, a, l, c, h, u, _;\n        }(t, this);\n        return o[i] = r, o[i];\n      }\n      customLayerMatrix() {\n        return this.mercatorMatrix.slice();\n      }\n      globeToMercatorMatrix() {\n        if (\"globe\" === this.projection.name) {\n          const t = 1 / this.worldSize,\n            i = e.fromScaling([], [t, t, t]);\n          return e.multiply(i, i, this.globeMatrix), i;\n        }\n      }\n      recenterOnTerrain() {\n        if (!this._elevation || \"globe\" === this.projection.name) return;\n        const t = this._elevation;\n        this._updateCameraState();\n        const i = e.mercatorZfromAltitude(1, this._center.lat) * this.worldSize,\n          o = this._computeCameraPosition(i),\n          r = this._camera.forward(),\n          n = e.mercatorZfromAltitude(1, this._center.lat);\n        o[2] /= n, r[2] /= n, e.normalize(r, r);\n        const s = t.raycast(o, r, t.exaggeration());\n        if (s) {\n          const t = e.scaleAndAdd([], o, r, s),\n            i = new e.MercatorCoordinate(t[0], t[1], e.mercatorZfromAltitude(t[2], e.latFromMercatorY(t[1]))),\n            a = (i.z + e.length([i.x - o[0], i.y - o[1], i.z - o[2] * n])) * this._pixelsPerMercatorPixel;\n          this._seaLevelZoom = this._zoomFromMercatorZ(a), this._centerAltitude = i.toAltitude(), this._center = this.coordinateLocation(i), this._updateZoomFromElevation(), this._constrain(), this._calcMatrices();\n        }\n      }\n      _constrainCamera(t = !1) {\n        if (!this._elevation) return;\n        const i = this._elevation,\n          o = e.mercatorZfromAltitude(1, this._center.lat) * this.worldSize,\n          r = this._computeCameraPosition(o),\n          n = i.getAtPointOrZero(new e.MercatorCoordinate(...r)),\n          s = this.pixelsPerMeter / this.worldSize * n,\n          a = this._minimumHeightOverTerrain(),\n          l = r[2] - s;\n        if (l <= a) if (l < 0 || t) {\n          const t = this.locationCoordinate(this._center, this._centerAltitude),\n            i = [r[0], r[1], t.z - r[2]],\n            o = e.length(i);\n          i[2] -= (a - l) / this._pixelsPerMercatorPixel;\n          const n = e.length(i);\n          if (0 === n) return;\n          e.scale$2(i, i, o / n * this._pixelsPerMercatorPixel), this._camera.position = [r[0], r[1], t.z * this._pixelsPerMercatorPixel - i[2]], this._updateStateFromCamera();\n        } else this._isCameraConstrained = !0;\n      }\n      _constrain() {\n        if (!this.center || !this.width || !this.height || this._constraining) return;\n        this._constraining = !0;\n        const t = \"globe\" === this.projection.name || this.mercatorFromTransition;\n        if (this.projection.isReprojectedInTileSpace || t) {\n          const i = this.center;\n          return i.lat = e.clamp(i.lat, this.minLat, this.maxLat), (this.maxBounds || !this.renderWorldCopies && !t) && (i.lng = e.clamp(i.lng, this.minLng, this.maxLng)), this.center = i, void (this._constraining = !1);\n        }\n        const i = this._unmodified,\n          {\n            x: o,\n            y: r\n          } = this.point;\n        let n = 0,\n          s = o,\n          a = r;\n        const l = this.width / 2,\n          c = this.height / 2,\n          h = this.worldMinY * this.scale,\n          u = this.worldMaxY * this.scale;\n        if (r - c < h && (a = h + c), r + c > u && (a = u - c), u - h < this.height && (n = Math.max(n, this.height / (u - h)), a = (u + h) / 2), this.maxBounds || !this._renderWorldCopies || !this.projection.wrap) {\n          const e = this.worldMinX * this.scale,\n            t = this.worldMaxX * this.scale,\n            i = this.worldSize / 2 - (e + t) / 2;\n          s = (o + i + this.worldSize) % this.worldSize - i, s - l < e && (s = e + l), s + l > t && (s = t - l), t - e < this.width && (n = Math.max(n, this.width / (t - e)), s = (t + e) / 2);\n        }\n        s === o && a === r || (this.center = this.unproject(new e.Point(s, a))), n && (this.zoom += this.scaleZoom(n)), this._constrainCamera(), this._unmodified = i, this._constraining = !1;\n      }\n      _minZoomForBounds() {\n        let e = Math.max(0, this.scaleZoom(this.height / (this.worldMaxY - this.worldMinY)));\n        return this.maxBounds && (e = Math.max(e, this.scaleZoom(this.width / (this.worldMaxX - this.worldMinX)))), e;\n      }\n      _maxCameraBoundsDistance() {\n        return this._mercatorZfromZoom(this._minZoomForBounds());\n      }\n      _calcMatrices() {\n        if (!this.height) return;\n        const t = this.centerOffset,\n          i = this.pixelsPerMeter;\n        \"globe\" === this.projection.name && (this._mercatorScaleRatio = e.mercatorZfromAltitude(1, this.center.lat) / e.mercatorZfromAltitude(1, e.GLOBE_SCALE_MATCH_LATITUDE));\n        const o = Wo(this.projection, this.zoom, this.width, this.height, 1024);\n        this._pixelsPerMercatorPixel = this.projection.pixelSpaceConversion(this.center.lat, this.worldSize, o), this.cameraToCenterDistance = .5 / Math.tan(.5 * this._fov) * this.height * this._pixelsPerMercatorPixel, this._updateCameraState(), this._farZ = this.projection.farthestPixelDistance(this), this._nearZ = this.height / 50;\n        const r = \"meters\" === this.projection.zAxisUnit ? i : 1,\n          n = this._camera.getWorldToCamera(this.worldSize, r),\n          s = this._camera.getCameraToClipPerspective(this._fov, this.width / this.height, this._nearZ, this._farZ);\n        s[8] = 2 * -t.x / this.width, s[9] = 2 * t.y / this.height;\n        let a = e.mul([], s, n);\n        if (this.projection.isReprojectedInTileSpace) {\n          const t = this.locationCoordinate(this.center),\n            i = e.identity([]);\n          e.translate(i, i, [t.x * this.worldSize, t.y * this.worldSize, 0]), e.multiply(i, i, Zo(this)), e.translate(i, i, [-t.x * this.worldSize, -t.y * this.worldSize, 0]), e.multiply(a, a, i), this.inverseAdjustmentMatrix = function (e) {\n            const t = Zo(e, !0);\n            return v([], [t[0], t[1], t[4], t[5]]);\n          }(this);\n        } else this.inverseAdjustmentMatrix = [1, 0, 0, 1];\n        this.mercatorMatrix = e.scale([], a, [this.worldSize, this.worldSize, this.worldSize / r, 1]), this.projMatrix = a, this.invProjMatrix = e.invert(new Float64Array(16), this.projMatrix);\n        const l = e.invert([], s);\n        this.frustumCorners = e.FrustumCorners.fromInvProjectionMatrix(l, this.horizonLineFromTop(), this.height);\n        const c = new Float32Array(16);\n        e.identity(c), e.scale(c, c, [1, -1, 1]), e.rotateX(c, c, this._pitch), e.rotateZ(c, c, this.angle);\n        const h = e.perspective(new Float32Array(16), this._fov, this.width / this.height, this._nearZ, this._farZ),\n          u = (Math.PI / 2 - this._pitch) * (this.height / this._fov) * this._horizonShift;\n        h[8] = 2 * -t.x / this.width, h[9] = 2 * (t.y + u) / this.height, this.skyboxMatrix = e.multiply(c, h, c);\n        const _ = this.point,\n          d = _.x,\n          p = _.y,\n          m = this.width % 2 / 2,\n          f = this.height % 2 / 2,\n          g = Math.cos(this.angle),\n          x = Math.sin(this.angle),\n          y = d - Math.round(d) + g * m + x * f,\n          b = p - Math.round(p) + g * f + x * m,\n          w = new Float64Array(a);\n        if (e.translate(w, w, [y > .5 ? y - 1 : y, b > .5 ? b - 1 : b, 0]), this.alignedProjMatrix = w, a = e.create(), e.scale(a, a, [this.width / 2, -this.height / 2, 1]), e.translate(a, a, [1, -1, 0]), this.labelPlaneMatrix = a, a = e.create(), e.scale(a, a, [1, -1, 1]), e.translate(a, a, [-1, -1, 0]), e.scale(a, a, [2 / this.width, 2 / this.height, 1]), this.glCoordMatrix = a, this.pixelMatrix = e.multiply(new Float64Array(16), this.labelPlaneMatrix, this.projMatrix), this._calcFogMatrices(), this._distanceTileDataCache = {}, a = e.invert(new Float64Array(16), this.pixelMatrix), !a) throw new Error(\"failed to invert matrix\");\n        if (this.pixelMatrixInverse = a, \"globe\" === this.projection.name || this.mercatorFromTransition) {\n          this.globeMatrix = e.calculateGlobeMatrix(this);\n          const t = [this.globeMatrix[12], this.globeMatrix[13], this.globeMatrix[14]];\n          this.globeCenterInViewSpace = e.transformMat4(t, t, n), this.globeRadius = this.worldSize / 2 / Math.PI - 1;\n        } else this.globeMatrix = a;\n        this._projMatrixCache = {}, this._alignedProjMatrixCache = {}, this._pixelsToTileUnitsCache = {};\n      }\n      _calcFogMatrices() {\n        this._fogTileMatrixCache = {};\n        const t = this.cameraWorldSizeForFog,\n          i = this.cameraPixelsPerMeter,\n          o = this._camera.position,\n          r = 1 / this.height / this._pixelsPerMercatorPixel,\n          n = [t, t, i];\n        e.scale$2(n, n, r), e.scale$2(o, o, -1), e.multiply$2(o, o, n);\n        const s = e.create();\n        e.translate(s, s, o), e.scale(s, s, n), this.mercatorFogMatrix = s, this.worldToFogMatrix = this._camera.getWorldToCameraPosition(t, i, r);\n      }\n      _computeCameraPosition(e) {\n        const t = (e = e || this.pixelsPerMeter) / this.pixelsPerMeter,\n          i = this._camera.forward(),\n          o = this.point,\n          r = this._mercatorZfromZoom(this._seaLevelZoom ? this._seaLevelZoom : this._zoom) * t - e / this.worldSize * this._centerAltitude;\n        return [o.x / this.worldSize - i[0] * r, o.y / this.worldSize - i[1] * r, e / this.worldSize * this._centerAltitude - i[2] * r];\n      }\n      _updateCameraState() {\n        this.height && (this._camera.setPitchBearing(this._pitch, this.angle), this._camera.position = this._computeCameraPosition());\n      }\n      _translateCameraConstrained(t) {\n        const i = this._maxCameraBoundsDistance() * Math.cos(this._pitch),\n          o = this._camera.position[2],\n          r = t[2];\n        let n = 1;\n        this.projection.wrap && (this.center = this.center.wrap()), r > 0 && (n = Math.min((i - o) / r, 1)), this._camera.position = e.scaleAndAdd([], this._camera.position, t, n), this._updateStateFromCamera();\n      }\n      _updateStateFromCamera() {\n        const t = this._camera.position,\n          i = this._camera.forward(),\n          {\n            pitch: o,\n            bearing: r\n          } = this._camera.getPitchBearing(),\n          n = e.mercatorZfromAltitude(this._centerAltitude, this.center.lat) * this._pixelsPerMercatorPixel,\n          s = this._mercatorZfromZoom(this._maxZoom) * Math.cos(e.degToRad(this._maxPitch)),\n          a = Math.max((t[2] - n) / Math.cos(o), s),\n          l = this._zoomFromMercatorZ(a);\n        e.scaleAndAdd(t, t, i, a), this._pitch = e.clamp(o, e.degToRad(this.minPitch), e.degToRad(this.maxPitch)), this.angle = e.wrap(r, -Math.PI, Math.PI), this._setZoom(e.clamp(l, this._minZoom, this._maxZoom)), this._updateSeaLevelZoom(), this._center = this.coordinateLocation(new e.MercatorCoordinate(t[0], t[1], t[2])), this._unmodified = !1, this._constrain(), this._calcMatrices();\n      }\n      _worldSizeFromZoom(e) {\n        return Math.pow(2, e) * this.tileSize;\n      }\n      _mercatorZfromZoom(e) {\n        return this.cameraToCenterDistance / this._worldSizeFromZoom(e);\n      }\n      _minimumHeightOverTerrain() {\n        const e = Math.min((null != this._seaLevelZoom ? this._seaLevelZoom : this._zoom) + 4, this._maxZoom);\n        return this._mercatorZfromZoom(e);\n      }\n      _zoomFromMercatorZ(e) {\n        return this.scaleZoom(this.cameraToCenterDistance / (e * this.tileSize));\n      }\n      zoomFromMercatorZAdjusted(t) {\n        let i = 0,\n          o = e.GLOBE_ZOOM_THRESHOLD_MAX,\n          r = 0,\n          n = 1 / 0;\n        for (; o - i > 1e-6 && o > i;) {\n          const e = i + .5 * (o - i),\n            s = this.tileSize * Math.pow(2, e),\n            a = this.getCameraToCenterDistance(this.projection, e, s),\n            l = this.scaleZoom(a / (t * this.tileSize)),\n            c = Math.abs(e - l);\n          c < n && (n = c, r = e), e < l ? i = e : o = e;\n        }\n        return r;\n      }\n      _terrainEnabled() {\n        return !(!this._elevation || !this.projection.supportsTerrain && (e.warnOnce(\"Terrain is not yet supported with alternate projections. Use mercator or globe to enable terrain.\"), 1));\n      }\n      anyCornerOffEdge(t, i) {\n        const o = Math.min(t.x, i.x),\n          r = Math.max(t.x, i.x),\n          n = Math.min(t.y, i.y),\n          s = Math.max(t.y, i.y);\n        if (n < this.horizonLineFromTop(!1)) return !0;\n        if (\"mercator\" !== this.projection.name) return !1;\n        const a = [new e.Point(o, n), new e.Point(r, s), new e.Point(o, s), new e.Point(r, n)],\n          l = this.renderWorldCopies ? -3 : 0,\n          c = this.renderWorldCopies ? 4 : 1;\n        for (const e of a) {\n          const t = this.pointRayIntersection(e);\n          if (t.t < 0) return !0;\n          const i = this.rayIntersectionCoordinate(t);\n          if (i.x < l || i.y < 0 || i.x > c || i.y > 1) return !0;\n        }\n        return !1;\n      }\n      isHorizonVisible() {\n        return this.pitch + e.radToDeg(this.fovAboveCenter) > 88 || this.anyCornerOffEdge(new e.Point(0, 0), new e.Point(this.width, this.height));\n      }\n      zoomDeltaToMovement(t, i) {\n        const o = e.length(e.sub([], this._camera.position, t)),\n          r = this._zoomFromMercatorZ(o) + i;\n        return o - this._mercatorZfromZoom(r);\n      }\n      getCameraPoint() {\n        if (\"globe\" === this.projection.name) {\n          const t = function ([t, i, o], r) {\n            const n = [t, i, o, 1];\n            e.transformMat4$1(n, n, r);\n            const s = n[3] = Math.max(n[3], 1e-6);\n            return n[0] /= s, n[1] /= s, n[2] /= s, n;\n          }([this.globeMatrix[12], this.globeMatrix[13], this.globeMatrix[14]], this.pixelMatrix);\n          return new e.Point(t[0], t[1]);\n        }\n        {\n          const t = Math.tan(this._pitch) * (this.cameraToCenterDistance || 1);\n          return this.centerPoint.add(new e.Point(0, t));\n        }\n      }\n      getCameraToCenterDistance(e, t = this.zoom, i = this.worldSize) {\n        const o = Wo(e, t, this.width, this.height, 1024),\n          r = e.pixelSpaceConversion(this.center.lat, i, o);\n        return .5 / Math.tan(.5 * this._fov) * this.height * r;\n      }\n      getWorldToCameraMatrix() {\n        const t = this._camera.getWorldToCamera(this.worldSize, \"meters\" === this.projection.zAxisUnit ? this.pixelsPerMeter : 1);\n        return \"globe\" === this.projection.name && e.multiply(t, t, this.globeMatrix), t;\n      }\n    }\n    function Yo(e, t) {\n      let i = !1,\n        o = null;\n      const r = () => {\n        o = null, i && (e(), o = setTimeout(r, t), i = !1);\n      };\n      return () => (i = !0, o || r(), o);\n    }\n    class Ko {\n      constructor(t) {\n        this._hashName = t && encodeURIComponent(t), e.bindAll([\"_getCurrentHash\", \"_onHashChange\", \"_updateHash\"], this), this._updateHash = Yo(this._updateHashUnthrottled.bind(this), 300);\n      }\n      addTo(t) {\n        return this._map = t, e.window.addEventListener(\"hashchange\", this._onHashChange, !1), t.on(\"moveend\", this._updateHash), this;\n      }\n      remove() {\n        return this._map ? (this._map.off(\"moveend\", this._updateHash), e.window.removeEventListener(\"hashchange\", this._onHashChange, !1), clearTimeout(this._updateHash()), this._map = void 0, this) : this;\n      }\n      getHashString() {\n        const t = this._map;\n        if (!t) return \"\";\n        const i = Jo(t);\n        if (this._hashName) {\n          const t = this._hashName;\n          let o = !1;\n          const r = e.window.location.hash.slice(1).split(\"&\").map(e => {\n            const r = e.split(\"=\")[0];\n            return r === t ? (o = !0, `${r}=${i}`) : e;\n          }).filter(e => e);\n          return o || r.push(`${t}=${i}`), `#${r.join(\"&\")}`;\n        }\n        return `#${i}`;\n      }\n      _getCurrentHash() {\n        const t = e.window.location.hash.replace(\"#\", \"\");\n        if (this._hashName) {\n          let e;\n          return t.split(\"&\").map(e => e.split(\"=\")).forEach(t => {\n            t[0] === this._hashName && (e = t);\n          }), (e && e[1] || \"\").split(\"/\");\n        }\n        return t.split(\"/\");\n      }\n      _onHashChange() {\n        const e = this._map;\n        if (!e) return !1;\n        const t = this._getCurrentHash();\n        if (t.length >= 3 && !t.some(e => isNaN(e))) {\n          const i = e.dragRotate.isEnabled() && e.touchZoomRotate.isEnabled() ? +(t[3] || 0) : e.getBearing();\n          return e.jumpTo({\n            center: [+t[2], +t[1]],\n            zoom: +t[0],\n            bearing: i,\n            pitch: +(t[4] || 0)\n          }), !0;\n        }\n        return !1;\n      }\n      _updateHashUnthrottled() {\n        const t = e.window.location.href.replace(/(#.+)?$/, this.getHashString());\n        e.window.history.replaceState(e.window.history.state, null, t);\n      }\n    }\n    function Jo(e, t) {\n      const i = e.getCenter(),\n        o = Math.round(100 * e.getZoom()) / 100,\n        r = Math.ceil((o * Math.LN2 + Math.log(512 / 360 / .5)) / Math.LN10),\n        n = Math.pow(10, r),\n        s = Math.round(i.lng * n) / n,\n        a = Math.round(i.lat * n) / n,\n        l = e.getBearing(),\n        c = e.getPitch();\n      let h = t ? `/${s}/${a}/${o}` : `${o}/${a}/${s}`;\n      return (l || c) && (h += \"/\" + Math.round(10 * l) / 10), c && (h += `/${Math.round(c)}`), h;\n    }\n    const Qo = {\n        linearity: .3,\n        easing: e.bezier(0, 0, .3, 1)\n      },\n      er = e.extend({\n        deceleration: 2500,\n        maxSpeed: 1400\n      }, Qo),\n      tr = e.extend({\n        deceleration: 20,\n        maxSpeed: 1400\n      }, Qo),\n      ir = e.extend({\n        deceleration: 1e3,\n        maxSpeed: 360\n      }, Qo),\n      or = e.extend({\n        deceleration: 1e3,\n        maxSpeed: 90\n      }, Qo);\n    class rr {\n      constructor(e) {\n        this._map = e, this.clear();\n      }\n      clear() {\n        this._inertiaBuffer = [];\n      }\n      record(t) {\n        this._drainInertiaBuffer(), this._inertiaBuffer.push({\n          time: e.exported.now(),\n          settings: t\n        });\n      }\n      _drainInertiaBuffer() {\n        const t = this._inertiaBuffer,\n          i = e.exported.now();\n        for (; t.length > 0 && i - t[0].time > 160;) t.shift();\n      }\n      _onMoveEnd(t) {\n        if (this._map._prefersReducedMotion()) return;\n        if (this._drainInertiaBuffer(), this._inertiaBuffer.length < 2) return;\n        const i = {\n          zoom: 0,\n          bearing: 0,\n          pitch: 0,\n          pan: new e.Point(0, 0),\n          pinchAround: void 0,\n          around: void 0\n        };\n        for (const {\n          settings: e\n        } of this._inertiaBuffer) i.zoom += e.zoomDelta || 0, i.bearing += e.bearingDelta || 0, i.pitch += e.pitchDelta || 0, e.panDelta && i.pan._add(e.panDelta), e.around && (i.around = e.around), e.pinchAround && (i.pinchAround = e.pinchAround);\n        const o = this._inertiaBuffer[this._inertiaBuffer.length - 1].time - this._inertiaBuffer[0].time,\n          r = {};\n        if (i.pan.mag()) {\n          const n = sr(i.pan.mag(), o, e.extend({}, er, t || {}));\n          r.offset = i.pan.mult(n.amount / i.pan.mag()), r.center = this._map.transform.center, nr(r, n);\n        }\n        if (i.zoom) {\n          const e = sr(i.zoom, o, tr);\n          r.zoom = this._map.transform.zoom + e.amount, nr(r, e);\n        }\n        if (i.bearing) {\n          const t = sr(i.bearing, o, ir);\n          r.bearing = this._map.transform.bearing + e.clamp(t.amount, -179, 179), nr(r, t);\n        }\n        if (i.pitch) {\n          const e = sr(i.pitch, o, or);\n          r.pitch = this._map.transform.pitch + e.amount, nr(r, e);\n        }\n        if (r.zoom || r.bearing) {\n          const e = void 0 === i.pinchAround ? i.around : i.pinchAround;\n          r.around = e ? this._map.unproject(e) : this._map.getCenter();\n        }\n        return this.clear(), r.noMoveStart = !0, r;\n      }\n    }\n    function nr(e, t) {\n      (!e.duration || e.duration < t.duration) && (e.duration = t.duration, e.easing = t.easing);\n    }\n    function sr(t, i, o) {\n      const {\n          maxSpeed: r,\n          linearity: n,\n          deceleration: s\n        } = o,\n        a = e.clamp(t * n / (i / 1e3), -r, r),\n        l = Math.abs(a) / (s * n);\n      return {\n        easing: o.easing,\n        duration: 1e3 * l,\n        amount: a * (l / 2)\n      };\n    }\n    class ar extends e.Event {\n      preventDefault() {\n        this._defaultPrevented = !0;\n      }\n      get defaultPrevented() {\n        return this._defaultPrevented;\n      }\n      constructor(t, i, o, r = {}) {\n        const n = p(i.getCanvasContainer(), o),\n          s = i.unproject(n);\n        super(t, e.extend({\n          point: n,\n          lngLat: s,\n          originalEvent: o\n        }, r)), this._defaultPrevented = !1, this.target = i;\n      }\n    }\n    class lr extends e.Event {\n      preventDefault() {\n        this._defaultPrevented = !0;\n      }\n      get defaultPrevented() {\n        return this._defaultPrevented;\n      }\n      constructor(t, i, o) {\n        const r = \"touchend\" === t ? o.changedTouches : o.touches,\n          n = m(i.getCanvasContainer(), r),\n          s = n.map(e => i.unproject(e)),\n          a = n.reduce((e, t, i, o) => e.add(t.div(o.length)), new e.Point(0, 0));\n        super(t, {\n          points: n,\n          point: a,\n          lngLats: s,\n          lngLat: i.unproject(a),\n          originalEvent: o\n        }), this._defaultPrevented = !1;\n      }\n    }\n    class cr extends e.Event {\n      preventDefault() {\n        this._defaultPrevented = !0;\n      }\n      get defaultPrevented() {\n        return this._defaultPrevented;\n      }\n      constructor(e, t, i) {\n        super(e, {\n          originalEvent: i\n        }), this._defaultPrevented = !1;\n      }\n    }\n    class hr {\n      constructor(e, t) {\n        this._map = e, this._clickTolerance = t.clickTolerance;\n      }\n      reset() {\n        this._mousedownPos = void 0;\n      }\n      wheel(e) {\n        return this._firePreventable(new cr(e.type, this._map, e));\n      }\n      mousedown(e, t) {\n        return this._mousedownPos = t, this._firePreventable(new ar(e.type, this._map, e));\n      }\n      mouseup(e) {\n        this._map.fire(new ar(e.type, this._map, e));\n      }\n      preclick(t) {\n        const i = e.extend({}, t);\n        i.type = \"preclick\", this._map.fire(new ar(i.type, this._map, i));\n      }\n      click(e, t) {\n        this._mousedownPos && this._mousedownPos.dist(t) >= this._clickTolerance || (this.preclick(e), this._map.fire(new ar(e.type, this._map, e)));\n      }\n      dblclick(e) {\n        return this._firePreventable(new ar(e.type, this._map, e));\n      }\n      mouseover(e) {\n        this._map.fire(new ar(e.type, this._map, e));\n      }\n      mouseout(e) {\n        this._map.fire(new ar(e.type, this._map, e));\n      }\n      touchstart(e) {\n        return this._firePreventable(new lr(e.type, this._map, e));\n      }\n      touchmove(e) {\n        this._map.fire(new lr(e.type, this._map, e));\n      }\n      touchend(e) {\n        this._map.fire(new lr(e.type, this._map, e));\n      }\n      touchcancel(e) {\n        this._map.fire(new lr(e.type, this._map, e));\n      }\n      _firePreventable(e) {\n        if (this._map.fire(e), e.defaultPrevented) return {};\n      }\n      isEnabled() {\n        return !0;\n      }\n      isActive() {\n        return !1;\n      }\n      enable() {}\n      disable() {}\n    }\n    class ur {\n      constructor(e) {\n        this._map = e;\n      }\n      reset() {\n        this._delayContextMenu = !1, this._contextMenuEvent = void 0;\n      }\n      mousemove(e) {\n        this._map.fire(new ar(e.type, this._map, e));\n      }\n      mousedown() {\n        this._delayContextMenu = !0;\n      }\n      mouseup() {\n        this._delayContextMenu = !1, this._contextMenuEvent && (this._map.fire(new ar(\"contextmenu\", this._map, this._contextMenuEvent)), delete this._contextMenuEvent);\n      }\n      contextmenu(e) {\n        this._delayContextMenu ? this._contextMenuEvent = e : this._map.fire(new ar(e.type, this._map, e)), this._map.listens(\"contextmenu\") && e.preventDefault();\n      }\n      isEnabled() {\n        return !0;\n      }\n      isActive() {\n        return !1;\n      }\n      enable() {}\n      disable() {}\n    }\n    class _r {\n      constructor(e, t) {\n        this._map = e, this._el = e.getCanvasContainer(), this._container = e.getContainer(), this._clickTolerance = t.clickTolerance || 1;\n      }\n      isEnabled() {\n        return !!this._enabled;\n      }\n      isActive() {\n        return !!this._active;\n      }\n      enable() {\n        this.isEnabled() || (this._enabled = !0);\n      }\n      disable() {\n        this.isEnabled() && (this._enabled = !1);\n      }\n      mousedown(e, t) {\n        this.isEnabled() && e.shiftKey && 0 === e.button && (h(), this._startPos = this._lastPos = t, this._active = !0);\n      }\n      mousemoveWindow(e, t) {\n        if (!this._active) return;\n        const i = t,\n          o = this._startPos,\n          r = this._lastPos;\n        if (!o || !r || r.equals(i) || !this._box && i.dist(o) < this._clickTolerance) return;\n        this._lastPos = i, this._box || (this._box = n(\"div\", \"mapboxgl-boxzoom\", this._container), this._container.classList.add(\"mapboxgl-crosshair\"), this._fireEvent(\"boxzoomstart\", e));\n        const s = Math.min(o.x, i.x),\n          a = Math.max(o.x, i.x),\n          l = Math.min(o.y, i.y),\n          c = Math.max(o.y, i.y);\n        this._map._requestDomTask(() => {\n          this._box && (this._box.style.transform = `translate(${s}px,${l}px)`, this._box.style.width = a - s + \"px\", this._box.style.height = c - l + \"px\");\n        });\n      }\n      mouseupWindow(t, i) {\n        if (!this._active) return;\n        const o = this._startPos,\n          r = i;\n        if (o && 0 === t.button) {\n          if (this.reset(), d(), o.x !== r.x || o.y !== r.y) return this._map.fire(new e.Event(\"boxzoomend\", {\n            originalEvent: t\n          })), {\n            cameraAnimation: e => e.fitScreenCoordinates(o, r, this._map.getBearing(), {\n              linear: !1\n            })\n          };\n          this._fireEvent(\"boxzoomcancel\", t);\n        }\n      }\n      keydown(e) {\n        this._active && 27 === e.keyCode && (this.reset(), this._fireEvent(\"boxzoomcancel\", e));\n      }\n      blur() {\n        this.reset();\n      }\n      reset() {\n        this._active = !1, this._container.classList.remove(\"mapboxgl-crosshair\"), this._box && (this._box.remove(), this._box = null), u(), delete this._startPos, delete this._lastPos;\n      }\n      _fireEvent(t, i) {\n        return this._map.fire(new e.Event(t, {\n          originalEvent: i\n        }));\n      }\n    }\n    function dr(e, t) {\n      const i = {};\n      for (let o = 0; o < e.length; o++) i[e[o].identifier] = t[o];\n      return i;\n    }\n    class pr {\n      constructor(e) {\n        this.reset(), this.numTouches = e.numTouches;\n      }\n      reset() {\n        this.centroid = void 0, this.startTime = 0, this.touches = {}, this.aborted = !1;\n      }\n      touchstart(t, i, o) {\n        (this.centroid || o.length > this.numTouches) && (this.aborted = !0), this.aborted || (0 === this.startTime && (this.startTime = t.timeStamp), o.length === this.numTouches && (this.centroid = function (t) {\n          const i = new e.Point(0, 0);\n          for (const e of t) i._add(e);\n          return i.div(t.length);\n        }(i), this.touches = dr(o, i)));\n      }\n      touchmove(e, t, i) {\n        if (this.aborted || !this.centroid) return;\n        const o = dr(i, t);\n        for (const e in this.touches) {\n          const t = o[e];\n          (!t || t.dist(this.touches[e]) > 30) && (this.aborted = !0);\n        }\n      }\n      touchend(e, t, i) {\n        if ((!this.centroid || e.timeStamp - this.startTime > 500) && (this.aborted = !0), 0 === i.length) {\n          const e = !this.aborted && this.centroid;\n          if (this.reset(), e) return e;\n        }\n      }\n    }\n    class mr {\n      constructor(e) {\n        this.singleTap = new pr(e), this.numTaps = e.numTaps, this.reset();\n      }\n      reset() {\n        this.lastTime = 1 / 0, this.lastTap = void 0, this.count = 0, this.singleTap.reset();\n      }\n      touchstart(e, t, i) {\n        this.singleTap.touchstart(e, t, i);\n      }\n      touchmove(e, t, i) {\n        this.singleTap.touchmove(e, t, i);\n      }\n      touchend(e, t, i) {\n        const o = this.singleTap.touchend(e, t, i);\n        if (o) {\n          const t = e.timeStamp - this.lastTime < 500,\n            i = !this.lastTap || this.lastTap.dist(o) < 30;\n          if (t && i || this.reset(), this.count++, this.lastTime = e.timeStamp, this.lastTap = o, this.count === this.numTaps) return this.reset(), o;\n        }\n      }\n    }\n    class fr {\n      constructor() {\n        this._zoomIn = new mr({\n          numTouches: 1,\n          numTaps: 2\n        }), this._zoomOut = new mr({\n          numTouches: 2,\n          numTaps: 1\n        }), this.reset();\n      }\n      reset() {\n        this._active = !1, this._zoomIn.reset(), this._zoomOut.reset();\n      }\n      touchstart(e, t, i) {\n        this._zoomIn.touchstart(e, t, i), this._zoomOut.touchstart(e, t, i);\n      }\n      touchmove(e, t, i) {\n        this._zoomIn.touchmove(e, t, i), this._zoomOut.touchmove(e, t, i);\n      }\n      touchend(e, t, i) {\n        const o = this._zoomIn.touchend(e, t, i),\n          r = this._zoomOut.touchend(e, t, i);\n        return o ? (this._active = !0, e.preventDefault(), setTimeout(() => this.reset(), 0), {\n          cameraAnimation: t => t.easeTo({\n            duration: 300,\n            zoom: t.getZoom() + 1,\n            around: t.unproject(o)\n          }, {\n            originalEvent: e\n          })\n        }) : r ? (this._active = !0, e.preventDefault(), setTimeout(() => this.reset(), 0), {\n          cameraAnimation: t => t.easeTo({\n            duration: 300,\n            zoom: t.getZoom() - 1,\n            around: t.unproject(r)\n          }, {\n            originalEvent: e\n          })\n        }) : void 0;\n      }\n      touchcancel() {\n        this.reset();\n      }\n      enable() {\n        this._enabled = !0;\n      }\n      disable() {\n        this._enabled = !1, this.reset();\n      }\n      isEnabled() {\n        return this._enabled;\n      }\n      isActive() {\n        return this._active;\n      }\n    }\n    const gr = {\n      0: 1,\n      2: 2\n    };\n    class vr {\n      constructor(e) {\n        this.reset(), this._clickTolerance = e.clickTolerance || 1;\n      }\n      blur() {\n        this.reset();\n      }\n      reset() {\n        this._active = !1, this._moved = !1, this._lastPoint = void 0, this._eventButton = void 0;\n      }\n      _correctButton(e, t) {\n        return !1;\n      }\n      _move(e, t) {\n        return {};\n      }\n      mousedown(e, t) {\n        if (this._lastPoint) return;\n        const i = f(e);\n        this._correctButton(e, i) && (this._lastPoint = t, this._eventButton = i);\n      }\n      mousemoveWindow(e, t) {\n        const i = this._lastPoint;\n        if (i) if (e.preventDefault(), null != this._eventButton && function (e, t) {\n          const i = gr[t];\n          return void 0 === e.buttons || (e.buttons & i) !== i;\n        }(e, this._eventButton)) this.reset();else if (this._moved || !(t.dist(i) < this._clickTolerance)) return this._moved = !0, this._lastPoint = t, this._move(i, t);\n      }\n      mouseupWindow(e) {\n        this._lastPoint && f(e) === this._eventButton && (this._moved && d(), this.reset());\n      }\n      enable() {\n        this._enabled = !0;\n      }\n      disable() {\n        this._enabled = !1, this.reset();\n      }\n      isEnabled() {\n        return this._enabled;\n      }\n      isActive() {\n        return this._active;\n      }\n    }\n    class xr extends vr {\n      mousedown(e, t) {\n        super.mousedown(e, t), this._lastPoint && (this._active = !0);\n      }\n      _correctButton(e, t) {\n        return 0 === t && !e.ctrlKey;\n      }\n      _move(e, t) {\n        return {\n          around: t,\n          panDelta: t.sub(e)\n        };\n      }\n    }\n    class yr extends vr {\n      _correctButton(e, t) {\n        return 0 === t && e.ctrlKey || 2 === t;\n      }\n      _move(e, t) {\n        const i = .8 * (t.x - e.x);\n        if (i) return this._active = !0, {\n          bearingDelta: i\n        };\n      }\n      contextmenu(e) {\n        e.preventDefault();\n      }\n    }\n    class br extends vr {\n      _correctButton(e, t) {\n        return 0 === t && e.ctrlKey || 2 === t;\n      }\n      _move(e, t) {\n        const i = -.5 * (t.y - e.y);\n        if (i) return this._active = !0, {\n          pitchDelta: i\n        };\n      }\n      contextmenu(e) {\n        e.preventDefault();\n      }\n    }\n    class wr {\n      constructor(t, i) {\n        this._map = t, this._el = t.getCanvasContainer(), this._minTouches = 1, this._clickTolerance = i.clickTolerance || 1, this.reset(), e.bindAll([\"_addTouchPanBlocker\", \"_showTouchPanBlockerAlert\"], this);\n      }\n      reset() {\n        this._active = !1, this._touches = {}, this._sum = new e.Point(0, 0);\n      }\n      touchstart(e, t, i) {\n        return this._calculateTransform(e, t, i);\n      }\n      touchmove(t, i, o) {\n        if (this._active && !(o.length < this._minTouches)) {\n          if (this._map._cooperativeGestures && !this._map.isMoving()) {\n            if (1 === o.length && !e.isFullscreen()) return void this._showTouchPanBlockerAlert();\n            \"hidden\" !== this._alertContainer.style.visibility && (this._alertContainer.style.visibility = \"hidden\", clearTimeout(this._alertTimer));\n          }\n          return t.cancelable && t.preventDefault(), this._calculateTransform(t, i, o);\n        }\n      }\n      touchend(e, t, i) {\n        this._calculateTransform(e, t, i), this._active && i.length < this._minTouches && this.reset();\n      }\n      touchcancel() {\n        this.reset();\n      }\n      _calculateTransform(t, i, o) {\n        o.length > 0 && (this._active = !0);\n        const r = dr(o, i),\n          n = new e.Point(0, 0),\n          s = new e.Point(0, 0);\n        let a = 0;\n        for (const e in r) {\n          const t = r[e],\n            i = this._touches[e];\n          i && (n._add(t), s._add(t.sub(i)), a++, r[e] = t);\n        }\n        if (this._touches = r, a < this._minTouches || !s.mag()) return;\n        const l = s.div(a);\n        return this._sum._add(l), this._sum.mag() < this._clickTolerance ? void 0 : {\n          around: n.div(a),\n          panDelta: l\n        };\n      }\n      enable() {\n        this._enabled = !0, this._map._cooperativeGestures && (this._addTouchPanBlocker(), this._el.classList.add(\"mapboxgl-touch-pan-blocker-override\", \"mapboxgl-scrollable-page\"));\n      }\n      disable() {\n        this._enabled = !1, this._map._cooperativeGestures && (clearTimeout(this._alertTimer), this._alertContainer.remove(), this._el.classList.remove(\"mapboxgl-touch-pan-blocker-override\", \"mapboxgl-scrollable-page\")), this.reset();\n      }\n      isEnabled() {\n        return !!this._enabled;\n      }\n      isActive() {\n        return !!this._active;\n      }\n      _addTouchPanBlocker() {\n        this._map && !this._alertContainer && (this._alertContainer = n(\"div\", \"mapboxgl-touch-pan-blocker\", this._map._container), this._alertContainer.textContent = this._map._getUIString(\"TouchPanBlocker.Message\"), this._alertContainer.style.fontSize = `${Math.max(10, Math.min(24, Math.floor(.05 * this._el.clientWidth)))}px`);\n      }\n      _showTouchPanBlockerAlert() {\n        this._alertContainer.style.visibility = \"visible\", this._alertContainer.classList.add(\"mapboxgl-touch-pan-blocker-show\"), this._alertContainer.setAttribute(\"role\", \"alert\"), clearTimeout(this._alertTimer), this._alertTimer = setTimeout(() => {\n          this._alertContainer.classList.remove(\"mapboxgl-touch-pan-blocker-show\"), this._alertContainer.setAttribute(\"role\", \"null\");\n        }, 500);\n      }\n    }\n    class Tr {\n      constructor() {\n        this.reset();\n      }\n      reset() {\n        this._active = !1, this._firstTwoTouches = void 0;\n      }\n      _start(e) {}\n      _move(e, t, i) {\n        return {};\n      }\n      touchstart(e, t, i) {\n        this._firstTwoTouches || i.length < 2 || (this._firstTwoTouches = [i[0].identifier, i[1].identifier], this._start([t[0], t[1]]));\n      }\n      touchmove(e, t, i) {\n        const o = this._firstTwoTouches;\n        if (!o) return;\n        e.preventDefault();\n        const [r, n] = o,\n          s = Er(i, t, r),\n          a = Er(i, t, n);\n        if (!s || !a) return;\n        const l = this._aroundCenter ? null : s.add(a).div(2);\n        return this._move([s, a], l, e);\n      }\n      touchend(e, t, i) {\n        if (!this._firstTwoTouches) return;\n        const [o, r] = this._firstTwoTouches,\n          n = Er(i, t, o),\n          s = Er(i, t, r);\n        n && s || (this._active && d(), this.reset());\n      }\n      touchcancel() {\n        this.reset();\n      }\n      enable(e) {\n        this._enabled = !0, this._aroundCenter = !!e && \"center\" === e.around;\n      }\n      disable() {\n        this._enabled = !1, this.reset();\n      }\n      isEnabled() {\n        return this._enabled;\n      }\n      isActive() {\n        return this._active;\n      }\n    }\n    function Er(e, t, i) {\n      for (let o = 0; o < e.length; o++) if (e[o].identifier === i) return t[o];\n    }\n    function Cr(e, t) {\n      return Math.log(e / t) / Math.LN2;\n    }\n    class Mr extends Tr {\n      reset() {\n        super.reset(), this._distance = 0, this._startDistance = 0;\n      }\n      _start(e) {\n        this._startDistance = this._distance = e[0].dist(e[1]);\n      }\n      _move(e, t) {\n        const i = this._distance;\n        if (this._distance = e[0].dist(e[1]), this._active || !(Math.abs(Cr(this._distance, this._startDistance)) < .1)) return this._active = !0, {\n          zoomDelta: Cr(this._distance, i),\n          pinchAround: t\n        };\n      }\n    }\n    function Ir(e, t) {\n      return 180 * e.angleWith(t) / Math.PI;\n    }\n    class Pr extends Tr {\n      reset() {\n        super.reset(), this._minDiameter = 0, this._startVector = void 0, this._vector = void 0;\n      }\n      _start(e) {\n        this._startVector = this._vector = e[0].sub(e[1]), this._minDiameter = e[0].dist(e[1]);\n      }\n      _move(e, t) {\n        const i = this._vector;\n        if (this._vector = e[0].sub(e[1]), i && (this._active || !this._isBelowThreshold(this._vector))) return this._active = !0, {\n          bearingDelta: Ir(this._vector, i),\n          pinchAround: t\n        };\n      }\n      _isBelowThreshold(e) {\n        this._minDiameter = Math.min(this._minDiameter, e.mag());\n        const t = 25 / (Math.PI * this._minDiameter) * 360,\n          i = this._startVector;\n        if (!i) return !1;\n        const o = Ir(e, i);\n        return Math.abs(o) < t;\n      }\n    }\n    function Sr(e) {\n      return Math.abs(e.y) > Math.abs(e.x);\n    }\n    class Dr extends Tr {\n      constructor(e) {\n        super(), this._map = e;\n      }\n      reset() {\n        super.reset(), this._valid = void 0, this._firstMove = void 0, this._lastPoints = void 0;\n      }\n      _start(e) {\n        this._lastPoints = e, Sr(e[0].sub(e[1])) && (this._valid = !1);\n      }\n      _move(t, i, o) {\n        const r = this._lastPoints;\n        if (!r) return;\n        const n = t[0].sub(r[0]),\n          s = t[1].sub(r[1]);\n        return this._map._cooperativeGestures && !e.isFullscreen() && o.touches.length < 3 || (this._valid = this.gestureBeginsVertically(n, s, o.timeStamp), !this._valid) ? void 0 : (this._lastPoints = t, this._active = !0, {\n          pitchDelta: (n.y + s.y) / 2 * -.5\n        });\n      }\n      gestureBeginsVertically(e, t, i) {\n        if (void 0 !== this._valid) return this._valid;\n        const o = e.mag() >= 2,\n          r = t.mag() >= 2;\n        if (!o && !r) return;\n        if (!o || !r) return null == this._firstMove && (this._firstMove = i), i - this._firstMove < 100 && void 0;\n        const n = e.y > 0 == t.y > 0;\n        return Sr(e) && Sr(t) && n;\n      }\n    }\n    const Lr = {\n      panStep: 100,\n      bearingStep: 15,\n      pitchStep: 10\n    };\n    class Ar {\n      constructor() {\n        const e = Lr;\n        this._panStep = e.panStep, this._bearingStep = e.bearingStep, this._pitchStep = e.pitchStep, this._rotationDisabled = !1;\n      }\n      blur() {\n        this.reset();\n      }\n      reset() {\n        this._active = !1;\n      }\n      keydown(e) {\n        if (e.altKey || e.ctrlKey || e.metaKey) return;\n        let t = 0,\n          i = 0,\n          o = 0,\n          r = 0,\n          n = 0;\n        switch (e.keyCode) {\n          case 61:\n          case 107:\n          case 171:\n          case 187:\n            t = 1;\n            break;\n          case 189:\n          case 109:\n          case 173:\n            t = -1;\n            break;\n          case 37:\n            e.shiftKey ? i = -1 : (e.preventDefault(), r = -1);\n            break;\n          case 39:\n            e.shiftKey ? i = 1 : (e.preventDefault(), r = 1);\n            break;\n          case 38:\n            e.shiftKey ? o = 1 : (e.preventDefault(), n = -1);\n            break;\n          case 40:\n            e.shiftKey ? o = -1 : (e.preventDefault(), n = 1);\n            break;\n          default:\n            return;\n        }\n        return this._rotationDisabled && (i = 0, o = 0), {\n          cameraAnimation: s => {\n            const a = s.getZoom();\n            s.easeTo({\n              duration: 300,\n              easeId: \"keyboardHandler\",\n              easing: zr,\n              zoom: t ? Math.round(a) + t * (e.shiftKey ? 2 : 1) : a,\n              bearing: s.getBearing() + i * this._bearingStep,\n              pitch: s.getPitch() + o * this._pitchStep,\n              offset: [-r * this._panStep, -n * this._panStep],\n              center: s.getCenter()\n            }, {\n              originalEvent: e\n            });\n          }\n        };\n      }\n      enable() {\n        this._enabled = !0;\n      }\n      disable() {\n        this._enabled = !1, this.reset();\n      }\n      isEnabled() {\n        return this._enabled;\n      }\n      isActive() {\n        return this._active;\n      }\n      disableRotation() {\n        this._rotationDisabled = !0;\n      }\n      enableRotation() {\n        this._rotationDisabled = !1;\n      }\n    }\n    function zr(e) {\n      return e * (2 - e);\n    }\n    const Rr = 4.000244140625;\n    class Or {\n      constructor(t, i) {\n        this._map = t, this._el = t.getCanvasContainer(), this._handler = i, this._delta = 0, this._defaultZoomRate = .01, this._wheelZoomRate = .0022222222222222222, e.bindAll([\"_onTimeout\", \"_addScrollZoomBlocker\", \"_showBlockerAlert\"], this);\n      }\n      setZoomRate(e) {\n        this._defaultZoomRate = e;\n      }\n      setWheelZoomRate(e) {\n        this._wheelZoomRate = e;\n      }\n      isEnabled() {\n        return !!this._enabled;\n      }\n      isActive() {\n        return this._active || void 0 !== this._finishTimeout;\n      }\n      isZooming() {\n        return !!this._zooming;\n      }\n      enable(e) {\n        this.isEnabled() || (this._enabled = !0, this._aroundCenter = !!e && \"center\" === e.around, this._map._cooperativeGestures && this._addScrollZoomBlocker());\n      }\n      disable() {\n        this.isEnabled() && (this._enabled = !1, this._map._cooperativeGestures && (clearTimeout(this._alertTimer), this._alertContainer.remove()));\n      }\n      wheel(t) {\n        if (!this.isEnabled()) return;\n        if (this._map._cooperativeGestures) {\n          if (!(t.ctrlKey || t.metaKey || this.isZooming() || e.isFullscreen())) return void this._showBlockerAlert();\n          \"hidden\" !== this._alertContainer.style.visibility && (this._alertContainer.style.visibility = \"hidden\", clearTimeout(this._alertTimer));\n        }\n        let i = t.deltaMode === e.window.WheelEvent.DOM_DELTA_LINE ? 40 * t.deltaY : t.deltaY;\n        const o = e.exported.now(),\n          r = o - (this._lastWheelEventTime || 0);\n        this._lastWheelEventTime = o, 0 !== i && i % Rr == 0 ? this._type = \"wheel\" : 0 !== i && Math.abs(i) < 4 ? this._type = \"trackpad\" : r > 400 ? (this._type = null, this._lastValue = i, this._timeout = setTimeout(this._onTimeout, 40, t)) : this._type || (this._type = Math.abs(r * i) < 200 ? \"trackpad\" : \"wheel\", this._timeout && (clearTimeout(this._timeout), this._timeout = null, i += this._lastValue)), t.shiftKey && i && (i /= 4), this._type && (this._lastWheelEvent = t, this._delta -= i, this._active || this._start(t)), t.preventDefault();\n      }\n      _onTimeout(e) {\n        this._type = \"wheel\", this._delta -= this._lastValue, this._active || this._start(e);\n      }\n      _start(e) {\n        if (!this._delta) return;\n        this._frameId && (this._frameId = null), this._active = !0, this.isZooming() || (this._zooming = !0), this._finishTimeout && (clearTimeout(this._finishTimeout), delete this._finishTimeout);\n        const t = p(this._el, e);\n        this._aroundPoint = this._aroundCenter ? this._map.transform.centerPoint : t, this._aroundCoord = this._map.transform.pointCoordinate3D(this._aroundPoint), this._targetZoom = void 0, this._frameId || (this._frameId = !0, this._handler._triggerRenderFrame());\n      }\n      renderFrame() {\n        if (!this._frameId) return;\n        if (this._frameId = null, !this.isActive()) return;\n        const t = this._map.transform;\n        \"wheel\" === this._type && t.projection.wrap && (t._center.lng >= 180 || t._center.lng <= -180) && (this._prevEase = null, this._easing = null, this._lastWheelEvent = null, this._lastWheelEventTime = 0);\n        const i = () => t._terrainEnabled() && this._aroundCoord ? t.computeZoomRelativeTo(this._aroundCoord) : t.zoom;\n        if (0 !== this._delta) {\n          const e = \"wheel\" === this._type && Math.abs(this._delta) > Rr ? this._wheelZoomRate : this._defaultZoomRate;\n          let o = 2 / (1 + Math.exp(-Math.abs(this._delta * e)));\n          this._delta < 0 && 0 !== o && (o = 1 / o);\n          const r = i(),\n            n = Math.pow(2, r),\n            s = \"number\" == typeof this._targetZoom ? t.zoomScale(this._targetZoom) : n;\n          this._targetZoom = Math.min(t.maxZoom, Math.max(t.minZoom, t.scaleZoom(s * o))), \"wheel\" === this._type && (this._startZoom = r, this._easing = this._smoothOutEasing(200)), this._delta = 0;\n        }\n        const o = \"number\" == typeof this._targetZoom ? this._targetZoom : i(),\n          r = this._startZoom,\n          n = this._easing;\n        let s,\n          a = !1;\n        if (\"wheel\" === this._type && r && n) {\n          const t = Math.min((e.exported.now() - this._lastWheelEventTime) / 200, 1),\n            i = n(t);\n          s = e.number(r, o, i), t < 1 ? this._frameId || (this._frameId = !0) : a = !0;\n        } else s = o, a = !0;\n        return this._active = !0, a && (this._active = !1, this._finishTimeout = setTimeout(() => {\n          this._zooming = !1, this._handler._triggerRenderFrame(), delete this._targetZoom, delete this._finishTimeout;\n        }, 200)), {\n          noInertia: !0,\n          needsRenderFrame: !a,\n          zoomDelta: s - i(),\n          around: this._aroundPoint,\n          aroundCoord: this._aroundCoord,\n          originalEvent: this._lastWheelEvent\n        };\n      }\n      _smoothOutEasing(t) {\n        let i = e.ease;\n        if (this._prevEase) {\n          const t = this._prevEase,\n            o = (e.exported.now() - t.start) / t.duration,\n            r = t.easing(o + .01) - t.easing(o),\n            n = .27 / Math.sqrt(r * r + 1e-4) * .01,\n            s = Math.sqrt(.0729 - n * n);\n          i = e.bezier(n, s, .25, 1);\n        }\n        return this._prevEase = {\n          start: e.exported.now(),\n          duration: t,\n          easing: i\n        }, i;\n      }\n      blur() {\n        this.reset();\n      }\n      reset() {\n        this._active = !1;\n      }\n      _addScrollZoomBlocker() {\n        this._map && !this._alertContainer && (this._alertContainer = n(\"div\", \"mapboxgl-scroll-zoom-blocker\", this._map._container), this._alertContainer.textContent = /(Mac|iPad)/i.test(e.window.navigator.userAgent) ? this._map._getUIString(\"ScrollZoomBlocker.CmdMessage\") : this._map._getUIString(\"ScrollZoomBlocker.CtrlMessage\"), this._alertContainer.style.fontSize = `${Math.max(10, Math.min(24, Math.floor(.05 * this._el.clientWidth)))}px`);\n      }\n      _showBlockerAlert() {\n        this._alertContainer.style.visibility = \"visible\", this._alertContainer.classList.add(\"mapboxgl-scroll-zoom-blocker-show\"), this._alertContainer.setAttribute(\"role\", \"alert\"), clearTimeout(this._alertTimer), this._alertTimer = setTimeout(() => {\n          this._alertContainer.classList.remove(\"mapboxgl-scroll-zoom-blocker-show\"), this._alertContainer.setAttribute(\"role\", \"null\");\n        }, 200);\n      }\n    }\n    class Br {\n      constructor(e, t) {\n        this._clickZoom = e, this._tapZoom = t;\n      }\n      enable() {\n        this._clickZoom.enable(), this._tapZoom.enable();\n      }\n      disable() {\n        this._clickZoom.disable(), this._tapZoom.disable();\n      }\n      isEnabled() {\n        return this._clickZoom.isEnabled() && this._tapZoom.isEnabled();\n      }\n      isActive() {\n        return this._clickZoom.isActive() || this._tapZoom.isActive();\n      }\n    }\n    class kr {\n      constructor() {\n        this.reset();\n      }\n      reset() {\n        this._active = !1;\n      }\n      blur() {\n        this.reset();\n      }\n      dblclick(e, t) {\n        return e.preventDefault(), {\n          cameraAnimation: i => {\n            i.easeTo({\n              duration: 300,\n              zoom: i.getZoom() + (e.shiftKey ? -1 : 1),\n              around: i.unproject(t)\n            }, {\n              originalEvent: e\n            });\n          }\n        };\n      }\n      enable() {\n        this._enabled = !0;\n      }\n      disable() {\n        this._enabled = !1, this.reset();\n      }\n      isEnabled() {\n        return this._enabled;\n      }\n      isActive() {\n        return this._active;\n      }\n    }\n    class Fr {\n      constructor() {\n        this._tap = new mr({\n          numTouches: 1,\n          numTaps: 1\n        }), this.reset();\n      }\n      reset() {\n        this._active = !1, this._swipePoint = void 0, this._swipeTouch = 0, this._tapTime = 0, this._tap.reset();\n      }\n      touchstart(e, t, i) {\n        this._swipePoint || (this._tapTime && e.timeStamp - this._tapTime > 500 && this.reset(), this._tapTime ? i.length > 0 && (this._swipePoint = t[0], this._swipeTouch = i[0].identifier) : this._tap.touchstart(e, t, i));\n      }\n      touchmove(e, t, i) {\n        if (this._tapTime) {\n          if (this._swipePoint) {\n            if (i[0].identifier !== this._swipeTouch) return;\n            const o = t[0],\n              r = o.y - this._swipePoint.y;\n            return this._swipePoint = o, e.preventDefault(), this._active = !0, {\n              zoomDelta: r / 128\n            };\n          }\n        } else this._tap.touchmove(e, t, i);\n      }\n      touchend(e, t, i) {\n        this._tapTime ? this._swipePoint && 0 === i.length && this.reset() : this._tap.touchend(e, t, i) && (this._tapTime = e.timeStamp);\n      }\n      touchcancel() {\n        this.reset();\n      }\n      enable() {\n        this._enabled = !0;\n      }\n      disable() {\n        this._enabled = !1, this.reset();\n      }\n      isEnabled() {\n        return this._enabled;\n      }\n      isActive() {\n        return this._active;\n      }\n    }\n    class Ur {\n      constructor(e, t, i) {\n        this._el = e, this._mousePan = t, this._touchPan = i;\n      }\n      enable(e) {\n        this._inertiaOptions = e || {}, this._mousePan.enable(), this._touchPan.enable(), this._el.classList.add(\"mapboxgl-touch-drag-pan\");\n      }\n      disable() {\n        this._mousePan.disable(), this._touchPan.disable(), this._el.classList.remove(\"mapboxgl-touch-drag-pan\");\n      }\n      isEnabled() {\n        return this._mousePan.isEnabled() && this._touchPan.isEnabled();\n      }\n      isActive() {\n        return this._mousePan.isActive() || this._touchPan.isActive();\n      }\n    }\n    class Nr {\n      constructor(e, t, i) {\n        this._pitchWithRotate = e.pitchWithRotate, this._mouseRotate = t, this._mousePitch = i;\n      }\n      enable() {\n        this._mouseRotate.enable(), this._pitchWithRotate && this._mousePitch.enable();\n      }\n      disable() {\n        this._mouseRotate.disable(), this._mousePitch.disable();\n      }\n      isEnabled() {\n        return this._mouseRotate.isEnabled() && (!this._pitchWithRotate || this._mousePitch.isEnabled());\n      }\n      isActive() {\n        return this._mouseRotate.isActive() || this._mousePitch.isActive();\n      }\n    }\n    class jr {\n      constructor(e, t, i, o) {\n        this._el = e, this._touchZoom = t, this._touchRotate = i, this._tapDragZoom = o, this._rotationDisabled = !1, this._enabled = !0;\n      }\n      enable(e) {\n        this._touchZoom.enable(e), this._rotationDisabled || this._touchRotate.enable(e), this._tapDragZoom.enable(), this._el.classList.add(\"mapboxgl-touch-zoom-rotate\");\n      }\n      disable() {\n        this._touchZoom.disable(), this._touchRotate.disable(), this._tapDragZoom.disable(), this._el.classList.remove(\"mapboxgl-touch-zoom-rotate\");\n      }\n      isEnabled() {\n        return this._touchZoom.isEnabled() && (this._rotationDisabled || this._touchRotate.isEnabled()) && this._tapDragZoom.isEnabled();\n      }\n      isActive() {\n        return this._touchZoom.isActive() || this._touchRotate.isActive() || this._tapDragZoom.isActive();\n      }\n      disableRotation() {\n        this._rotationDisabled = !0, this._touchRotate.disable();\n      }\n      enableRotation() {\n        this._rotationDisabled = !1, this._touchZoom.isEnabled() && this._touchRotate.enable();\n      }\n    }\n    const Gr = e => e.zoom || e.drag || e.pitch || e.rotate;\n    class Zr extends e.Event {}\n    class Vr {\n      constructor() {\n        this.constants = [1, 1, .01], this.radius = 0;\n      }\n      setup(t, i) {\n        const o = e.sub([], i, t);\n        this.radius = e.length(o[2] < 0 ? e.div([], o, this.constants) : [o[0], o[1], 0]);\n      }\n      projectRay(t) {\n        e.div(t, t, this.constants), e.normalize(t, t), e.mul$1(t, t, this.constants);\n        const i = e.scale$2([], t, this.radius);\n        if (i[2] > 0) {\n          const t = e.scale$2([], [0, 0, 1], e.dot(i, [0, 0, 1])),\n            o = e.scale$2([], e.normalize([], [i[0], i[1], 0]), this.radius),\n            r = e.add([], i, e.scale$2([], e.sub([], e.add([], o, t), i), 2));\n          i[0] = r[0], i[1] = r[1];\n        }\n        return i;\n      }\n    }\n    function Wr(e) {\n      return e.panDelta && e.panDelta.mag() || e.zoomDelta || e.bearingDelta || e.pitchDelta;\n    }\n    class Xr {\n      constructor(t, i) {\n        this._map = t, this._el = this._map.getCanvasContainer(), this._handlers = [], this._handlersById = {}, this._changes = [], this._inertia = new rr(t), this._bearingSnap = i.bearingSnap, this._previousActiveHandlers = {}, this._trackingEllipsoid = new Vr(), this._dragOrigin = null, this._eventsInProgress = {}, this._addDefaultHandlers(i), e.bindAll([\"handleEvent\", \"handleWindowEvent\"], this);\n        const o = this._el;\n        this._listeners = [[o, \"touchstart\", {\n          passive: !0\n        }], [o, \"touchmove\", {\n          passive: !1\n        }], [o, \"touchend\", void 0], [o, \"touchcancel\", void 0], [o, \"mousedown\", void 0], [o, \"mousemove\", void 0], [o, \"mouseup\", void 0], [e.window.document, \"mousemove\", {\n          capture: !0\n        }], [e.window.document, \"mouseup\", void 0], [o, \"mouseover\", void 0], [o, \"mouseout\", void 0], [o, \"dblclick\", void 0], [o, \"click\", void 0], [o, \"keydown\", {\n          capture: !1\n        }], [o, \"keyup\", void 0], [o, \"wheel\", {\n          passive: !1\n        }], [o, \"contextmenu\", void 0], [e.window, \"blur\", void 0]];\n        for (const [t, i, o] of this._listeners) t.addEventListener(i, t === e.window.document ? this.handleWindowEvent : this.handleEvent, o);\n      }\n      destroy() {\n        for (const [t, i, o] of this._listeners) t.removeEventListener(i, t === e.window.document ? this.handleWindowEvent : this.handleEvent, o);\n      }\n      _addDefaultHandlers(e) {\n        const t = this._map,\n          i = t.getCanvasContainer();\n        this._add(\"mapEvent\", new hr(t, e));\n        const o = t.boxZoom = new _r(t, e);\n        this._add(\"boxZoom\", o);\n        const r = new fr(),\n          n = new kr();\n        t.doubleClickZoom = new Br(n, r), this._add(\"tapZoom\", r), this._add(\"clickZoom\", n);\n        const s = new Fr();\n        this._add(\"tapDragZoom\", s);\n        const a = t.touchPitch = new Dr(t);\n        this._add(\"touchPitch\", a);\n        const l = new yr(e),\n          c = new br(e);\n        t.dragRotate = new Nr(e, l, c), this._add(\"mouseRotate\", l, [\"mousePitch\"]), this._add(\"mousePitch\", c, [\"mouseRotate\"]);\n        const h = new xr(e),\n          u = new wr(t, e);\n        t.dragPan = new Ur(i, h, u), this._add(\"mousePan\", h), this._add(\"touchPan\", u, [\"touchZoom\", \"touchRotate\"]);\n        const _ = new Pr(),\n          d = new Mr();\n        t.touchZoomRotate = new jr(i, d, _, s), this._add(\"touchRotate\", _, [\"touchPan\", \"touchZoom\"]), this._add(\"touchZoom\", d, [\"touchPan\", \"touchRotate\"]), this._add(\"blockableMapEvent\", new ur(t));\n        const p = t.scrollZoom = new Or(t, this);\n        this._add(\"scrollZoom\", p, [\"mousePan\"]);\n        const m = t.keyboard = new Ar();\n        this._add(\"keyboard\", m);\n        for (const i of [\"boxZoom\", \"doubleClickZoom\", \"tapDragZoom\", \"touchPitch\", \"dragRotate\", \"dragPan\", \"touchZoomRotate\", \"scrollZoom\", \"keyboard\"]) e.interactive && e[i] && t[i].enable(e[i]);\n      }\n      _add(e, t, i) {\n        this._handlers.push({\n          handlerName: e,\n          handler: t,\n          allowed: i\n        }), this._handlersById[e] = t;\n      }\n      stop(e) {\n        if (!this._updatingCamera) {\n          for (const {\n            handler: e\n          } of this._handlers) e.reset();\n          this._inertia.clear(), this._fireEvents({}, {}, e), this._changes = [];\n        }\n      }\n      isActive() {\n        for (const {\n          handler: e\n        } of this._handlers) if (e.isActive()) return !0;\n        return !1;\n      }\n      isZooming() {\n        return !!this._eventsInProgress.zoom || this._map.scrollZoom.isZooming();\n      }\n      isRotating() {\n        return !!this._eventsInProgress.rotate;\n      }\n      isMoving() {\n        return !!Gr(this._eventsInProgress) || this.isZooming();\n      }\n      _isDragging() {\n        return !!this._eventsInProgress.drag;\n      }\n      _blockedByActive(e, t, i) {\n        for (const o in e) if (o !== i && (!t || t.indexOf(o) < 0)) return !0;\n        return !1;\n      }\n      handleWindowEvent(e) {\n        this.handleEvent(e, `${e.type}Window`);\n      }\n      _getMapTouches(e) {\n        const t = [];\n        for (const i of e) this._el.contains(i.target) && t.push(i);\n        return t;\n      }\n      handleEvent(e, t) {\n        this._updatingCamera = !0;\n        const i = \"renderFrame\" === e.type,\n          o = i ? void 0 : e,\n          r = {\n            needsRenderFrame: !1\n          },\n          n = {},\n          s = {},\n          a = e.touches ? this._getMapTouches(e.touches) : void 0,\n          l = a ? m(this._el, a) : i ? void 0 : p(this._el, e);\n        for (const {\n          handlerName: i,\n          handler: c,\n          allowed: h\n        } of this._handlers) {\n          if (!c.isEnabled()) continue;\n          let u;\n          this._blockedByActive(s, h, i) ? c.reset() : c[t || e.type] && (u = c[t || e.type](e, l, a), this.mergeHandlerResult(r, n, u, i, o), u && u.needsRenderFrame && this._triggerRenderFrame()), (u || c.isActive()) && (s[i] = c);\n        }\n        const c = {};\n        for (const e in this._previousActiveHandlers) s[e] || (c[e] = o);\n        this._previousActiveHandlers = s, (Object.keys(c).length || Wr(r)) && (this._changes.push([r, n, c]), this._triggerRenderFrame()), (Object.keys(s).length || Wr(r)) && this._map._stop(!0), this._updatingCamera = !1;\n        const {\n          cameraAnimation: h\n        } = r;\n        h && (this._inertia.clear(), this._fireEvents({}, {}, !0), this._changes = [], h(this._map));\n      }\n      mergeHandlerResult(t, i, o, r, n) {\n        if (!o) return;\n        e.extend(t, o);\n        const s = {\n          handlerName: r,\n          originalEvent: o.originalEvent || n\n        };\n        void 0 !== o.zoomDelta && (i.zoom = s), void 0 !== o.panDelta && (i.drag = s), void 0 !== o.pitchDelta && (i.pitch = s), void 0 !== o.bearingDelta && (i.rotate = s);\n      }\n      _applyChanges() {\n        const t = {},\n          i = {},\n          o = {};\n        for (const [r, n, s] of this._changes) r.panDelta && (t.panDelta = (t.panDelta || new e.Point(0, 0))._add(r.panDelta)), r.zoomDelta && (t.zoomDelta = (t.zoomDelta || 0) + r.zoomDelta), r.bearingDelta && (t.bearingDelta = (t.bearingDelta || 0) + r.bearingDelta), r.pitchDelta && (t.pitchDelta = (t.pitchDelta || 0) + r.pitchDelta), void 0 !== r.around && (t.around = r.around), void 0 !== r.aroundCoord && (t.aroundCoord = r.aroundCoord), void 0 !== r.pinchAround && (t.pinchAround = r.pinchAround), r.noInertia && (t.noInertia = r.noInertia), e.extend(i, n), e.extend(o, s);\n        this._updateMapTransform(t, i, o), this._changes = [];\n      }\n      _updateMapTransform(t, i, o) {\n        const r = this._map,\n          n = r.transform,\n          s = e => [e.x, e.y, e.z];\n        if ((e => {\n          const t = this._eventsInProgress.drag;\n          return t && !this._handlersById[t.handlerName].isActive();\n        })() && !Wr(t)) {\n          const e = n.zoom;\n          n.cameraElevationReference = \"sea\", n.recenterOnTerrain(), n.cameraElevationReference = \"ground\", e !== n.zoom && this._map._update(!0);\n        }\n        if (n._isCameraConstrained && r._stop(!0), !Wr(t)) return void this._fireEvents(i, o, !0);\n        let {\n          panDelta: a,\n          zoomDelta: l,\n          bearingDelta: c,\n          pitchDelta: h,\n          around: u,\n          aroundCoord: _,\n          pinchAround: d\n        } = t;\n        n._isCameraConstrained && (l > 0 && (l = 0), n._isCameraConstrained = !1), void 0 !== d && (u = d), (l || (e => i[e] && !this._eventsInProgress[e])(\"drag\")) && u && (this._dragOrigin = s(n.pointCoordinate3D(u)), this._trackingEllipsoid.setup(n._camera.position, this._dragOrigin)), n.cameraElevationReference = \"sea\", r._stop(!0), u = u || r.transform.centerPoint, c && (n.bearing += c), h && (n.pitch += h), n._updateCameraState();\n        const p = [0, 0, 0];\n        if (a) if (\"mercator\" === n.projection.name) {\n          const e = this._trackingEllipsoid.projectRay(n.screenPointToMercatorRay(u).dir),\n            t = this._trackingEllipsoid.projectRay(n.screenPointToMercatorRay(u.sub(a)).dir);\n          p[0] = t[0] - e[0], p[1] = t[1] - e[1];\n        } else {\n          const t = n.pointCoordinate(u);\n          if (\"globe\" === n.projection.name) {\n            a = a.rotate(-n.angle);\n            const i = n._pixelsPerMercatorPixel / n.worldSize;\n            p[0] = -a.x * e.mercatorScale(e.latFromMercatorY(t.y)) * i, p[1] = -a.y * e.mercatorScale(n.center.lat) * i;\n          } else {\n            const e = n.pointCoordinate(u.sub(a));\n            t && e && (p[0] = e.x - t.x, p[1] = e.y - t.y);\n          }\n        }\n        const m = n.zoom,\n          f = [0, 0, 0];\n        if (l) {\n          const t = s(_ || n.pointCoordinate3D(u)),\n            i = {\n              dir: e.normalize([], e.sub([], t, n._camera.position))\n            };\n          if (i.dir[2] < 0) {\n            const o = n.zoomDeltaToMovement(t, l);\n            e.scale$2(f, i.dir, o);\n          }\n        }\n        const g = e.add(p, p, f);\n        n._translateCameraConstrained(g), l && Math.abs(n.zoom - m) > 1e-4 && n.recenterOnTerrain(), n.cameraElevationReference = \"ground\", this._map._update(), t.noInertia || this._inertia.record(t), this._fireEvents(i, o, !0);\n      }\n      _fireEvents(t, i, o) {\n        const r = Gr(this._eventsInProgress),\n          n = Gr(t),\n          s = {};\n        for (const e in t) {\n          const {\n            originalEvent: i\n          } = t[e];\n          this._eventsInProgress[e] || (s[`${e}start`] = i), this._eventsInProgress[e] = t[e];\n        }\n        !r && n && this._fireEvent(\"movestart\", n.originalEvent);\n        for (const e in s) this._fireEvent(e, s[e]);\n        n && this._fireEvent(\"move\", n.originalEvent);\n        for (const e in t) {\n          const {\n            originalEvent: i\n          } = t[e];\n          this._fireEvent(e, i);\n        }\n        const a = {};\n        let l;\n        for (const e in this._eventsInProgress) {\n          const {\n            handlerName: t,\n            originalEvent: o\n          } = this._eventsInProgress[e];\n          this._handlersById[t].isActive() || (delete this._eventsInProgress[e], l = i[t] || o, a[`${e}end`] = l);\n        }\n        for (const e in a) this._fireEvent(e, a[e]);\n        const c = Gr(this._eventsInProgress);\n        if (o && (r || n) && !c) {\n          this._updatingCamera = !0;\n          const t = this._inertia._onMoveEnd(this._map.dragPan._inertiaOptions),\n            i = e => 0 !== e && -this._bearingSnap < e && e < this._bearingSnap;\n          t ? (i(t.bearing || this._map.getBearing()) && (t.bearing = 0), this._map.easeTo(t, {\n            originalEvent: l\n          })) : (this._map.fire(new e.Event(\"moveend\", {\n            originalEvent: l\n          })), i(this._map.getBearing()) && this._map.resetNorth()), this._updatingCamera = !1;\n        }\n      }\n      _fireEvent(t, i) {\n        this._map.fire(new e.Event(t, i ? {\n          originalEvent: i\n        } : {}));\n      }\n      _requestFrame() {\n        return this._map.triggerRepaint(), this._map._renderTaskQueue.add(e => {\n          this._frameId = void 0, this.handleEvent(new Zr(\"renderFrame\", {\n            timeStamp: e\n          })), this._applyChanges();\n        });\n      }\n      _triggerRenderFrame() {\n        void 0 === this._frameId && (this._frameId = this._requestFrame());\n      }\n    }\n    const qr = \"map.setFreeCameraOptions(...) and map.getFreeCameraOptions() are not yet supported for non-mercator projections.\";\n    class $r extends e.Evented {\n      constructor(t, i) {\n        super(), this._moving = !1, this._zooming = !1, this.transform = t, this._bearingSnap = i.bearingSnap, this._respectPrefersReducedMotion = !1 !== i.respectPrefersReducedMotion, e.bindAll([\"_renderFrameCallback\"], this);\n      }\n      getCenter() {\n        return new e.LngLat(this.transform.center.lng, this.transform.center.lat);\n      }\n      setCenter(e, t) {\n        return this.jumpTo({\n          center: e\n        }, t);\n      }\n      panBy(t, i, o) {\n        return t = e.Point.convert(t).mult(-1), this.panTo(this.transform.center, e.extend({\n          offset: t\n        }, i), o);\n      }\n      panTo(t, i, o) {\n        return this.easeTo(e.extend({\n          center: t\n        }, i), o);\n      }\n      getZoom() {\n        return this.transform.zoom;\n      }\n      setZoom(e, t) {\n        return this.jumpTo({\n          zoom: e\n        }, t), this;\n      }\n      zoomTo(t, i, o) {\n        return this.easeTo(e.extend({\n          zoom: t\n        }, i), o);\n      }\n      zoomIn(e, t) {\n        return this.zoomTo(this.getZoom() + 1, e, t), this;\n      }\n      zoomOut(e, t) {\n        return this.zoomTo(this.getZoom() - 1, e, t), this;\n      }\n      getBearing() {\n        return this.transform.bearing;\n      }\n      setBearing(e, t) {\n        return this.jumpTo({\n          bearing: e\n        }, t), this;\n      }\n      getPadding() {\n        return this.transform.padding;\n      }\n      setPadding(e, t) {\n        return this.jumpTo({\n          padding: e\n        }, t), this;\n      }\n      rotateTo(t, i, o) {\n        return this.easeTo(e.extend({\n          bearing: t\n        }, i), o);\n      }\n      resetNorth(t, i) {\n        return this.rotateTo(0, e.extend({\n          duration: 1e3\n        }, t), i), this;\n      }\n      resetNorthPitch(t, i) {\n        return this.easeTo(e.extend({\n          bearing: 0,\n          pitch: 0,\n          duration: 1e3\n        }, t), i), this;\n      }\n      snapToNorth(e, t) {\n        return Math.abs(this.getBearing()) < this._bearingSnap ? this.resetNorth(e, t) : this;\n      }\n      getPitch() {\n        return this.transform.pitch;\n      }\n      setPitch(e, t) {\n        return this.jumpTo({\n          pitch: e\n        }, t), this;\n      }\n      cameraForBounds(t, i) {\n        t = e.LngLatBounds.convert(t);\n        const o = i && i.bearing || 0,\n          r = i && i.pitch || 0,\n          n = t.getNorthWest(),\n          s = t.getSouthEast();\n        return this._cameraForBounds(this.transform, n, s, o, r, i);\n      }\n      _extendCameraOptions(t) {\n        const i = {\n          top: 0,\n          bottom: 0,\n          right: 0,\n          left: 0\n        };\n        if (\"number\" == typeof (t = e.extend({\n          padding: i,\n          offset: [0, 0],\n          maxZoom: this.transform.maxZoom\n        }, t)).padding) {\n          const e = t.padding;\n          t.padding = {\n            top: e,\n            bottom: e,\n            right: e,\n            left: e\n          };\n        }\n        return t.padding = e.extend(i, t.padding), t;\n      }\n      _minimumAABBFrustumDistance(e, t) {\n        const i = t.max[0] - t.min[0],\n          o = t.max[1] - t.min[1];\n        return i / o > e.aspect ? i / (2 * Math.tan(.5 * e.fovX) * e.aspect) : o / (2 * Math.tan(.5 * e.fovY) * e.aspect);\n      }\n      _cameraForBoundsOnGlobe(t, i, o, r, n, s) {\n        const a = t.clone(),\n          l = this._extendCameraOptions(s);\n        a.bearing = r, a.pitch = n;\n        const c = e.LngLat.convert(i),\n          h = e.LngLat.convert(o),\n          u = .5 * (c.lat + h.lat),\n          _ = .5 * (c.lng + h.lng),\n          d = e.latLngToECEF(u, _),\n          p = e.normalize([], d),\n          m = e.normalize([], e.cross([], p, [0, 1, 0])),\n          f = e.cross([], m, p),\n          g = [m[0], m[1], m[2], 0, f[0], f[1], f[2], 0, p[0], p[1], p[2], 0, 0, 0, 0, 1],\n          v = [d, e.latLngToECEF(c.lat, c.lng), e.latLngToECEF(h.lat, c.lng), e.latLngToECEF(h.lat, h.lng), e.latLngToECEF(c.lat, h.lng), e.latLngToECEF(u, c.lng), e.latLngToECEF(u, h.lng), e.latLngToECEF(c.lat, _), e.latLngToECEF(h.lat, _)];\n        let x = e.Aabb.fromPoints(v.map(t => [e.dot(m, t), e.dot(f, t), e.dot(p, t)]));\n        const y = e.transformMat4([], x.center, g);\n        0 === e.squaredLength(y) && e.set(y, 0, 0, 1), e.normalize(y, y), e.scale$2(y, y, e.GLOBE_RADIUS), a.center = e.ecefToLatLng(y);\n        const b = a.getWorldToCameraMatrix(),\n          w = e.invert(new Float64Array(16), b);\n        x = e.Aabb.applyTransform(x, e.multiply([], b, g)), e.transformMat4(y, y, b);\n        const T = .5 * (x.max[2] - x.min[2]),\n          E = this._minimumAABBFrustumDistance(a, x),\n          C = e.scale$2([], [0, 0, 1], T),\n          M = e.add(C, y, C),\n          I = E + (0 === a.pitch ? 0 : e.distance(y, M)),\n          P = a.globeCenterInViewSpace,\n          S = e.sub([], y, [P[0], P[1], P[2]]);\n        e.normalize(S, S), e.scale$2(S, S, I);\n        const D = e.add([], y, S);\n        e.transformMat4(D, D, w);\n        const L = e.earthRadius / e.GLOBE_RADIUS,\n          A = e.length(D),\n          z = e.mercatorZfromAltitude(Math.max(A * L - e.earthRadius, Number.EPSILON), 0),\n          R = Math.min(a.zoomFromMercatorZAdjusted(z), l.maxZoom);\n        return R > .5 * (e.GLOBE_ZOOM_THRESHOLD_MIN + e.GLOBE_ZOOM_THRESHOLD_MAX) ? (a.setProjection({\n          name: \"mercator\"\n        }), a.zoom = R, this._cameraForBounds(a, i, o, r, n, s)) : {\n          center: a.center,\n          zoom: R,\n          bearing: r,\n          pitch: n\n        };\n      }\n      queryTerrainElevation(t, i) {\n        const o = this.transform.elevation;\n        return o ? (i = e.extend({}, {\n          exaggerated: !0\n        }, i), o.getAtPoint(e.MercatorCoordinate.fromLngLat(t), null, i.exaggerated)) : null;\n      }\n      _cameraForBounds(t, i, o, r, n, s) {\n        if (\"globe\" === t.projection.name) return this._cameraForBoundsOnGlobe(t, i, o, r, n, s);\n        const a = t.clone(),\n          l = this._extendCameraOptions(s),\n          c = a.padding;\n        a.bearing = r, a.pitch = n;\n        const h = e.LngLat.convert(i),\n          u = e.LngLat.convert(o),\n          _ = new e.LngLat(h.lng, u.lat),\n          d = new e.LngLat(u.lng, h.lat),\n          p = a.project(h),\n          m = a.project(u),\n          f = this.queryTerrainElevation(h),\n          g = this.queryTerrainElevation(u),\n          v = this.queryTerrainElevation(_),\n          x = this.queryTerrainElevation(d),\n          y = [[p.x, p.y, Math.min(f || 0, g || 0, v || 0, x || 0)], [m.x, m.y, Math.max(f || 0, g || 0, v || 0, x || 0)]];\n        let b = e.Aabb.fromPoints(y);\n        const w = a.getWorldToCameraMatrix(),\n          T = e.invert(new Float64Array(16), w);\n        b = e.Aabb.applyTransform(b, w);\n        const E = e.sub([], b.max, b.min),\n          C = c.left || 0,\n          M = c.right || 0,\n          I = c.bottom || 0,\n          P = c.top || 0,\n          {\n            left: S,\n            right: D,\n            top: L,\n            bottom: A\n          } = l.padding,\n          z = .5 * (C + M),\n          R = .5 * (P + I),\n          O = Math.min(a.scaleZoom(a.scale * Math.min((a.width - (C + M + S + D)) / E[0], (a.height - (I + P + A + L)) / E[1])), l.maxZoom),\n          B = a.scale / a.zoomScale(O);\n        b = new e.Aabb([b.min[0] - (S + z) * B, b.min[1] - (A + R) * B, b.min[2]], [b.max[0] + (D + z) * B, b.max[1] + (L + R) * B, b.max[2]]);\n        const k = .5 * E[2],\n          F = this._minimumAABBFrustumDistance(a, b),\n          U = [0, 0, 1, 0];\n        e.transformMat4$1(U, U, w), e.normalize$2(U, U);\n        const N = e.scale$2([], U, F + k),\n          j = e.add([], b.center, N),\n          G = (\"number\" == typeof l.offset.x && \"number\" == typeof l.offset.y ? new e.Point(l.offset.x, l.offset.y) : e.Point.convert(l.offset)).rotate(-e.degToRad(r));\n        b.center[0] -= G.x * B, b.center[1] += G.y * B, e.transformMat4(b.center, b.center, T), e.transformMat4(j, j, T);\n        const Z = [b.center[0], b.center[1], j[2] * a.pixelsPerMeter];\n        e.scale$2(Z, Z, 1 / a.worldSize);\n        const V = e.lngFromMercatorX(Z[0]),\n          W = e.latFromMercatorY(Z[1]),\n          X = Math.min(a._zoomFromMercatorZ(Z[2]), l.maxZoom),\n          q = new e.LngLat(V, W);\n        return a.mercatorFromTransition && X < .5 * (e.GLOBE_ZOOM_THRESHOLD_MIN + e.GLOBE_ZOOM_THRESHOLD_MAX) ? (a.setProjection({\n          name: \"globe\"\n        }), a.zoom = X, this._cameraForBounds(a, i, o, r, n, s)) : {\n          center: q,\n          zoom: X,\n          bearing: r,\n          pitch: n\n        };\n      }\n      fitBounds(e, t, i) {\n        const o = this.cameraForBounds(e, t);\n        return this._fitInternal(o, t, i);\n      }\n      fitScreenCoordinates(t, i, o, r, n) {\n        const s = e.Point.convert(t),\n          a = e.Point.convert(i),\n          l = new e.Point(Math.min(s.x, a.x), Math.min(s.y, a.y)),\n          c = new e.Point(Math.max(s.x, a.x), Math.max(s.y, a.y));\n        if (\"mercator\" === this.transform.projection.name && this.transform.anyCornerOffEdge(s, a)) return this;\n        const h = this.transform.pointLocation3D(l),\n          u = this.transform.pointLocation3D(c),\n          _ = this.transform.pointLocation3D(new e.Point(l.x, c.y)),\n          d = this.transform.pointLocation3D(new e.Point(c.x, l.y)),\n          p = [Math.min(h.lng, u.lng, _.lng, d.lng), Math.min(h.lat, u.lat, _.lat, d.lat)],\n          m = [Math.max(h.lng, u.lng, _.lng, d.lng), Math.max(h.lat, u.lat, _.lat, d.lat)],\n          f = r && r.pitch ? r.pitch : this.getPitch(),\n          g = this._cameraForBounds(this.transform, p, m, o, f, r);\n        return this._fitInternal(g, r, n);\n      }\n      _fitInternal(t, i, o) {\n        return t ? (delete (i = e.extend(t, i)).padding, i.linear ? this.easeTo(i, o) : this.flyTo(i, o)) : this;\n      }\n      jumpTo(t, i) {\n        this.stop();\n        const o = t.preloadOnly ? this.transform.clone() : this.transform;\n        let r = !1,\n          n = !1,\n          s = !1;\n        return \"zoom\" in t && o.zoom !== +t.zoom && (r = !0, o.zoom = +t.zoom), void 0 !== t.center && (o.center = e.LngLat.convert(t.center)), \"bearing\" in t && o.bearing !== +t.bearing && (n = !0, o.bearing = +t.bearing), \"pitch\" in t && o.pitch !== +t.pitch && (s = !0, o.pitch = +t.pitch), null == t.padding || o.isPaddingEqual(t.padding) || (o.padding = t.padding), t.preloadOnly ? (this._preloadTiles(o), this) : (this.fire(new e.Event(\"movestart\", i)).fire(new e.Event(\"move\", i)), r && this.fire(new e.Event(\"zoomstart\", i)).fire(new e.Event(\"zoom\", i)).fire(new e.Event(\"zoomend\", i)), n && this.fire(new e.Event(\"rotatestart\", i)).fire(new e.Event(\"rotate\", i)).fire(new e.Event(\"rotateend\", i)), s && this.fire(new e.Event(\"pitchstart\", i)).fire(new e.Event(\"pitch\", i)).fire(new e.Event(\"pitchend\", i)), this.fire(new e.Event(\"moveend\", i)));\n      }\n      getFreeCameraOptions() {\n        return this.transform.projection.supportsFreeCamera || e.warnOnce(qr), this.transform.getFreeCameraOptions();\n      }\n      setFreeCameraOptions(t, i) {\n        const o = this.transform;\n        if (!o.projection.supportsFreeCamera) return e.warnOnce(qr), this;\n        this.stop();\n        const r = o.zoom,\n          n = o.pitch,\n          s = o.bearing;\n        o.setFreeCameraOptions(t);\n        const a = r !== o.zoom,\n          l = n !== o.pitch,\n          c = s !== o.bearing;\n        return this.fire(new e.Event(\"movestart\", i)).fire(new e.Event(\"move\", i)), a && this.fire(new e.Event(\"zoomstart\", i)).fire(new e.Event(\"zoom\", i)).fire(new e.Event(\"zoomend\", i)), c && this.fire(new e.Event(\"rotatestart\", i)).fire(new e.Event(\"rotate\", i)).fire(new e.Event(\"rotateend\", i)), l && this.fire(new e.Event(\"pitchstart\", i)).fire(new e.Event(\"pitch\", i)).fire(new e.Event(\"pitchend\", i)), this.fire(new e.Event(\"moveend\", i)), this;\n      }\n      easeTo(t, i) {\n        this._stop(!1, t.easeId), (!1 === (t = e.extend({\n          offset: [0, 0],\n          duration: 500,\n          easing: e.ease\n        }, t)).animate || this._prefersReducedMotion(t)) && (t.duration = 0);\n        const o = this.transform,\n          r = this.getZoom(),\n          n = this.getBearing(),\n          s = this.getPitch(),\n          a = this.getPadding(),\n          l = \"zoom\" in t ? +t.zoom : r,\n          c = \"bearing\" in t ? this._normalizeBearing(t.bearing, n) : n,\n          h = \"pitch\" in t ? +t.pitch : s,\n          u = \"padding\" in t ? t.padding : o.padding,\n          _ = e.Point.convert(t.offset);\n        let d, p, m;\n        if (\"globe\" === o.projection.name) {\n          const i = e.MercatorCoordinate.fromLngLat(o.center),\n            r = _.rotate(-o.angle);\n          i.x += r.x / o.worldSize, i.y += r.y / o.worldSize;\n          const n = i.toLngLat(),\n            s = e.LngLat.convert(t.center || n);\n          this._normalizeCenter(s), d = o.centerPoint.add(r), p = new e.Point(i.x, i.y).mult(o.worldSize), m = new e.Point(e.mercatorXfromLng(s.lng), e.mercatorYfromLat(s.lat)).mult(o.worldSize).sub(p);\n        } else {\n          d = o.centerPoint.add(_);\n          const i = o.pointLocation(d),\n            r = e.LngLat.convert(t.center || i);\n          this._normalizeCenter(r), p = o.project(i), m = o.project(r).sub(p);\n        }\n        const f = o.zoomScale(l - r);\n        let g, v;\n        t.around && (g = e.LngLat.convert(t.around), v = o.locationPoint(g));\n        const x = this._zooming || l !== r,\n          y = this._rotating || n !== c,\n          b = this._pitching || h !== s,\n          w = !o.isPaddingEqual(u),\n          T = o => T => {\n            if (x && (o.zoom = e.number(r, l, T)), y && (o.bearing = e.number(n, c, T)), b && (o.pitch = e.number(s, h, T)), w && (o.interpolatePadding(a, u, T), d = o.centerPoint.add(_)), g) o.setLocationAtPoint(g, v);else {\n              const e = o.zoomScale(o.zoom - r),\n                t = l > r ? Math.min(2, f) : Math.max(.5, f),\n                i = Math.pow(t, 1 - T),\n                n = o.unproject(p.add(m.mult(T * i)).mult(e));\n              o.setLocationAtPoint(o.renderWorldCopies ? n.wrap() : n, d);\n            }\n            return t.preloadOnly || this._fireMoveEvents(i), o;\n          };\n        if (t.preloadOnly) {\n          const e = this._emulate(T, t.duration, o);\n          return this._preloadTiles(e), this;\n        }\n        const E = {\n          moving: this._moving,\n          zooming: this._zooming,\n          rotating: this._rotating,\n          pitching: this._pitching\n        };\n        return this._zooming = x, this._rotating = y, this._pitching = b, this._padding = w, this._easeId = t.easeId, this._prepareEase(i, t.noMoveStart, E), this._ease(T(o), e => {\n          o.recenterOnTerrain(), this._afterEase(i, e);\n        }, t), this;\n      }\n      _prepareEase(t, i, o = {}) {\n        this._moving = !0, this.transform.cameraElevationReference = \"sea\", i || o.moving || this.fire(new e.Event(\"movestart\", t)), this._zooming && !o.zooming && this.fire(new e.Event(\"zoomstart\", t)), this._rotating && !o.rotating && this.fire(new e.Event(\"rotatestart\", t)), this._pitching && !o.pitching && this.fire(new e.Event(\"pitchstart\", t));\n      }\n      _fireMoveEvents(t) {\n        this.fire(new e.Event(\"move\", t)), this._zooming && this.fire(new e.Event(\"zoom\", t)), this._rotating && this.fire(new e.Event(\"rotate\", t)), this._pitching && this.fire(new e.Event(\"pitch\", t));\n      }\n      _afterEase(t, i) {\n        if (this._easeId && i && this._easeId === i) return;\n        this._easeId = void 0, this.transform.cameraElevationReference = \"ground\";\n        const o = this._zooming,\n          r = this._rotating,\n          n = this._pitching;\n        this._moving = !1, this._zooming = !1, this._rotating = !1, this._pitching = !1, this._padding = !1, o && this.fire(new e.Event(\"zoomend\", t)), r && this.fire(new e.Event(\"rotateend\", t)), n && this.fire(new e.Event(\"pitchend\", t)), this.fire(new e.Event(\"moveend\", t));\n      }\n      flyTo(t, i) {\n        if (this._prefersReducedMotion(t)) {\n          const o = e.pick(t, [\"center\", \"zoom\", \"bearing\", \"pitch\", \"around\"]);\n          return this.jumpTo(o, i);\n        }\n        this.stop(), t = e.extend({\n          offset: [0, 0],\n          speed: 1.2,\n          curve: 1.42,\n          easing: e.ease\n        }, t);\n        const o = this.transform,\n          r = this.getZoom(),\n          n = this.getBearing(),\n          s = this.getPitch(),\n          a = this.getPadding(),\n          l = \"zoom\" in t ? e.clamp(+t.zoom, o.minZoom, o.maxZoom) : r,\n          c = \"bearing\" in t ? this._normalizeBearing(t.bearing, n) : n,\n          h = \"pitch\" in t ? +t.pitch : s,\n          u = \"padding\" in t ? t.padding : o.padding,\n          _ = o.zoomScale(l - r),\n          d = e.Point.convert(t.offset);\n        let p = o.centerPoint.add(d);\n        const m = o.pointLocation(p),\n          f = e.LngLat.convert(t.center || m);\n        this._normalizeCenter(f);\n        const g = o.project(m),\n          v = o.project(f).sub(g);\n        let x = t.curve;\n        const y = Math.max(o.width, o.height),\n          b = y / _,\n          w = v.mag();\n        if (\"minZoom\" in t) {\n          const i = e.clamp(Math.min(t.minZoom, r, l), o.minZoom, o.maxZoom),\n            n = y / o.zoomScale(i - r);\n          x = Math.sqrt(n / w * 2);\n        }\n        const T = x * x;\n        function E(e) {\n          const t = (b * b - y * y + (e ? -1 : 1) * T * T * w * w) / (2 * (e ? b : y) * T * w);\n          return Math.log(Math.sqrt(t * t + 1) - t);\n        }\n        function C(e) {\n          return (Math.exp(e) - Math.exp(-e)) / 2;\n        }\n        function M(e) {\n          return (Math.exp(e) + Math.exp(-e)) / 2;\n        }\n        const I = E(0);\n        let P = function (e) {\n            return M(I) / M(I + x * e);\n          },\n          S = function (e) {\n            return y * ((M(I) * (C(t = I + x * e) / M(t)) - C(I)) / T) / w;\n            var t;\n          },\n          D = (E(1) - I) / x;\n        if (Math.abs(w) < 1e-6 || !isFinite(D)) {\n          if (Math.abs(y - b) < 1e-6) return this.easeTo(t, i);\n          const e = b < y ? -1 : 1;\n          D = Math.abs(Math.log(b / y)) / x, S = function () {\n            return 0;\n          }, P = function (t) {\n            return Math.exp(e * x * t);\n          };\n        }\n        t.duration = \"duration\" in t ? +t.duration : 1e3 * D / (\"screenSpeed\" in t ? +t.screenSpeed / x : +t.speed), t.maxDuration && t.duration > t.maxDuration && (t.duration = 0);\n        const L = n !== c,\n          A = h !== s,\n          z = !o.isPaddingEqual(u),\n          R = o => _ => {\n            const m = _ * D,\n              x = 1 / P(m);\n            o.zoom = 1 === _ ? l : r + o.scaleZoom(x), L && (o.bearing = e.number(n, c, _)), A && (o.pitch = e.number(s, h, _)), z && (o.interpolatePadding(a, u, _), p = o.centerPoint.add(d));\n            const y = 1 === _ ? f : o.unproject(g.add(v.mult(S(m))).mult(x));\n            return o.setLocationAtPoint(o.renderWorldCopies ? y.wrap() : y, p), o._updateCameraOnTerrain(), t.preloadOnly || this._fireMoveEvents(i), o;\n          };\n        if (t.preloadOnly) {\n          const e = this._emulate(R, t.duration, o);\n          return this._preloadTiles(e), this;\n        }\n        return this._zooming = !0, this._rotating = L, this._pitching = A, this._padding = z, this._prepareEase(i, !1), this._ease(R(o), () => this._afterEase(i), t), this;\n      }\n      isEasing() {\n        return !!this._easeFrameId;\n      }\n      stop() {\n        return this._stop();\n      }\n      _stop(e, t) {\n        if (this._easeFrameId && (this._cancelRenderFrame(this._easeFrameId), this._easeFrameId = void 0, this._onEaseFrame = void 0), this._onEaseEnd) {\n          const e = this._onEaseEnd;\n          this._onEaseEnd = void 0, e.call(this, t);\n        }\n        if (!e) {\n          const e = this.handlers;\n          e && e.stop(!1);\n        }\n        return this;\n      }\n      _ease(t, i, o) {\n        !1 === o.animate || 0 === o.duration ? (t(1), i()) : (this._easeStart = e.exported.now(), this._easeOptions = o, this._onEaseFrame = t, this._onEaseEnd = i, this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback));\n      }\n      _renderFrameCallback() {\n        const t = Math.min((e.exported.now() - this._easeStart) / this._easeOptions.duration, 1),\n          i = this._onEaseFrame;\n        i && i(this._easeOptions.easing(t)), t < 1 ? this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback) : this.stop();\n      }\n      _normalizeBearing(t, i) {\n        t = e.wrap(t, -180, 180);\n        const o = Math.abs(t - i);\n        return Math.abs(t - 360 - i) < o && (t -= 360), Math.abs(t + 360 - i) < o && (t += 360), t;\n      }\n      _normalizeCenter(e) {\n        const t = this.transform;\n        if (!t.renderWorldCopies || t.maxBounds) return;\n        const i = e.lng - t.center.lng;\n        e.lng += i > 180 ? -360 : i < -180 ? 360 : 0;\n      }\n      _prefersReducedMotion(t) {\n        return this._respectPrefersReducedMotion && e.exported.prefersReducedMotion && !(t && t.essential);\n      }\n      _emulate(e, t, i) {\n        const o = Math.ceil(15 * t / 1e3),\n          r = [],\n          n = e(i.clone());\n        for (let e = 0; e <= o; e++) {\n          const t = n(e / o);\n          r.push(t.clone());\n        }\n        return r;\n      }\n    }\n    class Hr {\n      constructor(t = {}) {\n        this.options = t, e.bindAll([\"_toggleAttribution\", \"_updateEditLink\", \"_updateData\", \"_updateCompact\"], this);\n      }\n      getDefaultPosition() {\n        return \"bottom-right\";\n      }\n      onAdd(e) {\n        const t = this.options && this.options.compact;\n        return this._map = e, this._container = n(\"div\", \"mapboxgl-ctrl mapboxgl-ctrl-attrib\"), this._compactButton = n(\"button\", \"mapboxgl-ctrl-attrib-button\", this._container), n(\"span\", \"mapboxgl-ctrl-icon\", this._compactButton).setAttribute(\"aria-hidden\", \"true\"), this._compactButton.type = \"button\", this._compactButton.addEventListener(\"click\", this._toggleAttribution), this._setElementTitle(this._compactButton, \"ToggleAttribution\"), this._innerContainer = n(\"div\", \"mapboxgl-ctrl-attrib-inner\", this._container), this._innerContainer.setAttribute(\"role\", \"list\"), t && this._container.classList.add(\"mapboxgl-compact\"), this._updateAttributions(), this._updateEditLink(), this._map.on(\"styledata\", this._updateData), this._map.on(\"sourcedata\", this._updateData), this._map.on(\"moveend\", this._updateEditLink), void 0 === t && (this._map.on(\"resize\", this._updateCompact), this._updateCompact()), this._container;\n      }\n      onRemove() {\n        this._container.remove(), this._map.off(\"styledata\", this._updateData), this._map.off(\"sourcedata\", this._updateData), this._map.off(\"moveend\", this._updateEditLink), this._map.off(\"resize\", this._updateCompact), this._map = void 0, this._attribHTML = void 0;\n      }\n      _setElementTitle(e, t) {\n        const i = this._map._getUIString(`AttributionControl.${t}`);\n        e.setAttribute(\"aria-label\", i), e.removeAttribute(\"title\"), e.firstElementChild && e.firstElementChild.setAttribute(\"title\", i);\n      }\n      _toggleAttribution() {\n        this._container.classList.contains(\"mapboxgl-compact-show\") ? (this._container.classList.remove(\"mapboxgl-compact-show\"), this._compactButton.setAttribute(\"aria-expanded\", \"false\")) : (this._container.classList.add(\"mapboxgl-compact-show\"), this._compactButton.setAttribute(\"aria-expanded\", \"true\"));\n      }\n      _updateEditLink() {\n        let t = this._editLink;\n        t || (t = this._editLink = this._container.querySelector(\".mapbox-improve-map\"));\n        const i = [{\n          key: \"owner\",\n          value: this.styleOwner\n        }, {\n          key: \"id\",\n          value: this.styleId\n        }, {\n          key: \"access_token\",\n          value: this._map._requestManager._customAccessToken || e.config.ACCESS_TOKEN\n        }];\n        if (t) {\n          const o = i.reduce((e, t, o) => (t.value && (e += `${t.key}=${t.value}${o < i.length - 1 ? \"&\" : \"\"}`), e), \"?\");\n          t.href = `${e.config.FEEDBACK_URL}/${o}#${Jo(this._map, !0)}`, t.rel = \"noopener nofollow\", this._setElementTitle(t, \"MapFeedback\");\n        }\n      }\n      _updateData(e) {\n        !e || \"metadata\" !== e.sourceDataType && \"visibility\" !== e.sourceDataType && \"style\" !== e.dataType || (this._updateAttributions(), this._updateEditLink());\n      }\n      _updateAttributions() {\n        if (!this._map.style) return;\n        let e = [];\n        if (this._map.style.stylesheet) {\n          const e = this._map.style.stylesheet;\n          this.styleOwner = e.owner, this.styleId = e.id;\n        }\n        const t = this._map.style._sourceCaches;\n        for (const i in t) {\n          const o = t[i];\n          if (o.used) {\n            const t = o.getSource();\n            t.attribution && e.indexOf(t.attribution) < 0 && e.push(t.attribution);\n          }\n        }\n        e.sort((e, t) => e.length - t.length), e = e.filter((t, i) => {\n          for (let o = i + 1; o < e.length; o++) if (e[o].indexOf(t) >= 0) return !1;\n          return !0;\n        }), this.options.customAttribution && (Array.isArray(this.options.customAttribution) ? e = [...this.options.customAttribution, ...e] : e.unshift(this.options.customAttribution));\n        const i = e.join(\" | \");\n        i !== this._attribHTML && (this._attribHTML = i, e.length ? (this._innerContainer.innerHTML = i, this._container.classList.remove(\"mapboxgl-attrib-empty\")) : this._container.classList.add(\"mapboxgl-attrib-empty\"), this._editLink = null);\n      }\n      _updateCompact() {\n        this._map.getCanvasContainer().offsetWidth <= 640 ? this._container.classList.add(\"mapboxgl-compact\") : this._container.classList.remove(\"mapboxgl-compact\", \"mapboxgl-compact-show\");\n      }\n    }\n    class Yr {\n      constructor() {\n        e.bindAll([\"_updateLogo\", \"_updateCompact\"], this);\n      }\n      onAdd(e) {\n        this._map = e, this._container = n(\"div\", \"mapboxgl-ctrl\");\n        const t = n(\"a\", \"mapboxgl-ctrl-logo\");\n        return t.target = \"_blank\", t.rel = \"noopener nofollow\", t.href = \"https://www.mapbox.com/\", t.setAttribute(\"aria-label\", this._map._getUIString(\"LogoControl.Title\")), t.setAttribute(\"rel\", \"noopener nofollow\"), this._container.appendChild(t), this._container.style.display = \"none\", this._map.on(\"sourcedata\", this._updateLogo), this._updateLogo(), this._map.on(\"resize\", this._updateCompact), this._updateCompact(), this._container;\n      }\n      onRemove() {\n        this._container.remove(), this._map.off(\"sourcedata\", this._updateLogo), this._map.off(\"resize\", this._updateCompact);\n      }\n      getDefaultPosition() {\n        return \"bottom-left\";\n      }\n      _updateLogo(e) {\n        e && \"metadata\" !== e.sourceDataType || (this._container.style.display = this._logoRequired() ? \"block\" : \"none\");\n      }\n      _logoRequired() {\n        if (!this._map.style) return !0;\n        const e = this._map.style._sourceCaches;\n        if (0 === Object.entries(e).length) return !0;\n        for (const t in e) {\n          const i = e[t].getSource();\n          if (i.hasOwnProperty(\"mapbox_logo\") && !i.mapbox_logo) return !1;\n        }\n        return !0;\n      }\n      _updateCompact() {\n        const e = this._container.children;\n        if (e.length) {\n          const t = e[0];\n          this._map.getCanvasContainer().offsetWidth < 250 ? t.classList.add(\"mapboxgl-compact\") : t.classList.remove(\"mapboxgl-compact\");\n        }\n      }\n    }\n    class Kr {\n      constructor() {\n        this._queue = [], this._id = 0, this._cleared = !1, this._currentlyRunning = !1;\n      }\n      add(e) {\n        const t = ++this._id;\n        return this._queue.push({\n          callback: e,\n          id: t,\n          cancelled: !1\n        }), t;\n      }\n      remove(e) {\n        const t = this._currentlyRunning,\n          i = t ? this._queue.concat(t) : this._queue;\n        for (const t of i) if (t.id === e) return void (t.cancelled = !0);\n      }\n      run(e = 0) {\n        const t = this._currentlyRunning = this._queue;\n        this._queue = [];\n        for (const i of t) if (!i.cancelled && (i.callback(e), this._cleared)) break;\n        this._cleared = !1, this._currentlyRunning = !1;\n      }\n      clear() {\n        this._currentlyRunning && (this._cleared = !0), this._queue = [];\n      }\n    }\n    function Jr(t, i, o) {\n      if (t = new e.LngLat(t.lng, t.lat), i) {\n        const r = new e.LngLat(t.lng - 360, t.lat),\n          n = new e.LngLat(t.lng + 360, t.lat),\n          s = 360 * Math.ceil(Math.abs(t.lng - o.center.lng) / 360),\n          a = o.locationPoint(t).distSqr(i),\n          l = i.x < 0 || i.y < 0 || i.x > o.width || i.y > o.height;\n        o.locationPoint(r).distSqr(i) < a && (l || Math.abs(r.lng - o.center.lng) < s) ? t = r : o.locationPoint(n).distSqr(i) < a && (l || Math.abs(n.lng - o.center.lng) < s) && (t = n);\n      }\n      for (; Math.abs(t.lng - o.center.lng) > 180;) {\n        const e = o.locationPoint(t);\n        if (e.x >= 0 && e.y >= 0 && e.x <= o.width && e.y <= o.height) break;\n        t.lng > o.center.lng ? t.lng -= 360 : t.lng += 360;\n      }\n      return t;\n    }\n    const Qr = {\n      center: \"translate(-50%,-50%)\",\n      top: \"translate(-50%,0)\",\n      \"top-left\": \"translate(0,0)\",\n      \"top-right\": \"translate(-100%,0)\",\n      bottom: \"translate(-50%,-100%)\",\n      \"bottom-left\": \"translate(0,-100%)\",\n      \"bottom-right\": \"translate(-100%,-100%)\",\n      left: \"translate(0,-50%)\",\n      right: \"translate(-100%,-50%)\"\n    };\n    class en extends e.Evented {\n      constructor(t, i) {\n        if (super(), (t instanceof e.window.HTMLElement || i) && (t = e.extend({\n          element: t\n        }, i)), e.bindAll([\"_update\", \"_onMove\", \"_onUp\", \"_addDragHandler\", \"_onMapClick\", \"_onKeyPress\", \"_clearFadeTimer\"], this), this._anchor = t && t.anchor || \"center\", this._color = t && t.color || \"#3FB1CE\", this._scale = t && t.scale || 1, this._draggable = t && t.draggable || !1, this._clickTolerance = t && t.clickTolerance || 0, this._isDragging = !1, this._state = \"inactive\", this._rotation = t && t.rotation || 0, this._rotationAlignment = t && t.rotationAlignment || \"auto\", this._pitchAlignment = t && t.pitchAlignment && t.pitchAlignment || \"auto\", this._updateMoving = () => this._update(!0), this._occludedOpacity = t && t.occludedOpacity || .2, t && t.element) this._element = t.element, this._offset = e.Point.convert(t && t.offset || [0, 0]);else {\n          this._defaultMarker = !0, this._element = n(\"div\");\n          const i = 41,\n            o = 27,\n            r = s(\"svg\", {\n              display: \"block\",\n              height: i * this._scale + \"px\",\n              width: o * this._scale + \"px\",\n              viewBox: `0 0 ${o} ${i}`\n            }, this._element),\n            a = s(\"radialGradient\", {\n              id: \"shadowGradient\"\n            }, s(\"defs\", {}, r));\n          s(\"stop\", {\n            offset: \"10%\",\n            \"stop-opacity\": .4\n          }, a), s(\"stop\", {\n            offset: \"100%\",\n            \"stop-opacity\": .05\n          }, a), s(\"ellipse\", {\n            cx: 13.5,\n            cy: 34.8,\n            rx: 10.5,\n            ry: 5.25,\n            fill: \"url(#shadowGradient)\"\n          }, r), s(\"path\", {\n            fill: this._color,\n            d: \"M27,13.5C27,19.07 20.25,27 14.75,34.5C14.02,35.5 12.98,35.5 12.25,34.5C6.75,27 0,19.22 0,13.5C0,6.04 6.04,0 13.5,0C20.96,0 27,6.04 27,13.5Z\"\n          }, r), s(\"path\", {\n            opacity: .25,\n            d: \"M13.5,0C6.04,0 0,6.04 0,13.5C0,19.22 6.75,27 12.25,34.5C13,35.52 14.02,35.5 14.75,34.5C20.25,27 27,19.07 27,13.5C27,6.04 20.96,0 13.5,0ZM13.5,1C20.42,1 26,6.58 26,13.5C26,15.9 24.5,19.18 22.22,22.74C19.95,26.3 16.71,30.14 13.94,33.91C13.74,34.18 13.61,34.32 13.5,34.44C13.39,34.32 13.26,34.18 13.06,33.91C10.28,30.13 7.41,26.31 5.02,22.77C2.62,19.23 1,15.95 1,13.5C1,6.58 6.58,1 13.5,1Z\"\n          }, r), s(\"circle\", {\n            fill: \"white\",\n            cx: 13.5,\n            cy: 13.5,\n            r: 5.5\n          }, r), this._offset = e.Point.convert(t && t.offset || [0, -14]);\n        }\n        this._element.hasAttribute(\"aria-label\") || this._element.setAttribute(\"aria-label\", \"Map marker\"), this._element.classList.add(\"mapboxgl-marker\"), this._element.addEventListener(\"dragstart\", e => {\n          e.preventDefault();\n        }), this._element.addEventListener(\"mousedown\", e => {\n          e.preventDefault();\n        });\n        const o = this._element.classList;\n        for (const e in Qr) o.remove(`mapboxgl-marker-anchor-${e}`);\n        o.add(`mapboxgl-marker-anchor-${this._anchor}`), this._popup = null;\n      }\n      addTo(e) {\n        return e === this._map || (this.remove(), this._map = e, e.getCanvasContainer().appendChild(this._element), e.on(\"move\", this._updateMoving), e.on(\"moveend\", this._update), e.on(\"remove\", this._clearFadeTimer), e._addMarker(this), this.setDraggable(this._draggable), this._update(), e.on(\"click\", this._onMapClick)), this;\n      }\n      remove() {\n        const e = this._map;\n        return e && (e.off(\"click\", this._onMapClick), e.off(\"move\", this._updateMoving), e.off(\"moveend\", this._update), e.off(\"mousedown\", this._addDragHandler), e.off(\"touchstart\", this._addDragHandler), e.off(\"mouseup\", this._onUp), e.off(\"touchend\", this._onUp), e.off(\"mousemove\", this._onMove), e.off(\"touchmove\", this._onMove), e.off(\"remove\", this._clearFadeTimer), e._removeMarker(this), this._map = void 0), this._clearFadeTimer(), this._element.remove(), this._popup && this._popup.remove(), this;\n      }\n      getLngLat() {\n        return this._lngLat;\n      }\n      setLngLat(t) {\n        return this._lngLat = e.LngLat.convert(t), this._pos = null, this._popup && this._popup.setLngLat(this._lngLat), this._update(!0), this;\n      }\n      getElement() {\n        return this._element;\n      }\n      setPopup(e) {\n        if (this._popup && (this._popup.remove(), this._popup = null, this._element.removeAttribute(\"role\"), this._element.removeEventListener(\"keypress\", this._onKeyPress), this._originalTabIndex || this._element.removeAttribute(\"tabindex\")), e) {\n          if (!(\"offset\" in e.options)) {\n            const t = 38.1,\n              i = 13.5,\n              o = Math.sqrt(Math.pow(i, 2) / 2);\n            e.options.offset = this._defaultMarker ? {\n              top: [0, 0],\n              \"top-left\": [0, 0],\n              \"top-right\": [0, 0],\n              bottom: [0, -t],\n              \"bottom-left\": [o, -1 * (t - i + o)],\n              \"bottom-right\": [-o, -1 * (t - i + o)],\n              left: [i, -1 * (t - i)],\n              right: [-i, -1 * (t - i)]\n            } : this._offset;\n          }\n          this._popup = e, e._marker = this, this._lngLat && this._popup.setLngLat(this._lngLat), this._element.setAttribute(\"role\", \"button\"), this._originalTabIndex = this._element.getAttribute(\"tabindex\"), this._originalTabIndex || this._element.setAttribute(\"tabindex\", \"0\"), this._element.addEventListener(\"keypress\", this._onKeyPress), this._element.setAttribute(\"aria-expanded\", \"false\");\n        }\n        return this;\n      }\n      _onKeyPress(e) {\n        const t = e.code,\n          i = e.charCode || e.keyCode;\n        \"Space\" !== t && \"Enter\" !== t && 32 !== i && 13 !== i || this.togglePopup();\n      }\n      _onMapClick(e) {\n        const t = e.originalEvent.target,\n          i = this._element;\n        this._popup && (t === i || i.contains(t)) && this.togglePopup();\n      }\n      getPopup() {\n        return this._popup;\n      }\n      togglePopup() {\n        const e = this._popup;\n        return e ? (e.isOpen() ? (e.remove(), this._element.setAttribute(\"aria-expanded\", \"false\")) : this._map && (e.addTo(this._map), this._element.setAttribute(\"aria-expanded\", \"true\")), this) : this;\n      }\n      _behindTerrain() {\n        const e = this._map,\n          t = this._pos;\n        if (!e || !t) return !1;\n        const i = e.unproject(t),\n          o = e.getFreeCameraOptions();\n        if (!o.position) return !1;\n        const r = o.position.toLngLat();\n        return r.distanceTo(i) < .9 * r.distanceTo(this._lngLat);\n      }\n      _evaluateOpacity() {\n        const t = this._map;\n        if (!t) return;\n        const i = this._pos;\n        if (!i || i.x < 0 || i.x > t.transform.width || i.y < 0 || i.y > t.transform.height) return void this._clearFadeTimer();\n        const o = t.unproject(i);\n        let r;\n        t._showingGlobe() && e.isLngLatBehindGlobe(t.transform, this._lngLat) ? r = 0 : (r = 1 - t._queryFogOpacity(o), t.transform._terrainEnabled() && t.getTerrain() && this._behindTerrain() && (r *= this._occludedOpacity)), this._element.style.opacity = `${r}`, this._element.style.pointerEvents = r > 0 ? \"auto\" : \"none\", this._popup && this._popup._setOpacity(r), this._fadeTimer = null;\n      }\n      _clearFadeTimer() {\n        this._fadeTimer && (clearTimeout(this._fadeTimer), this._fadeTimer = null);\n      }\n      _updateDOM() {\n        const e = this._pos;\n        if (!e || !this._map) return;\n        const t = this._offset.mult(this._scale);\n        this._element.style.transform = `\\n            translate(${e.x}px,${e.y}px)\\n            ${Qr[this._anchor]}\\n            ${this._calculateXYTransform()} ${this._calculateZTransform()}\\n            translate(${t.x}px,${t.y}px)\\n        `;\n      }\n      _calculateXYTransform() {\n        const t = this._pos,\n          i = this._map,\n          o = this.getPitchAlignment();\n        if (!i || !t || \"map\" !== o) return \"\";\n        if (!i._showingGlobe()) {\n          const e = i.getPitch();\n          return e ? `rotateX(${e}deg)` : \"\";\n        }\n        const r = e.radToDeg(e.globeTiltAtLngLat(i.transform, this._lngLat)),\n          n = t.sub(e.globeCenterToScreenPoint(i.transform)),\n          s = Math.abs(n.x) + Math.abs(n.y);\n        if (0 === s) return \"\";\n        const a = r / s;\n        return `rotateX(${-n.y * a}deg) rotateY(${n.x * a}deg)`;\n      }\n      _calculateZTransform() {\n        const t = this._pos,\n          i = this._map;\n        if (!i || !t) return \"\";\n        let o = 0;\n        const r = this.getRotationAlignment();\n        if (\"map\" === r) {\n          if (i._showingGlobe()) {\n            const t = i.project(new e.LngLat(this._lngLat.lng, this._lngLat.lat + .001)),\n              r = i.project(new e.LngLat(this._lngLat.lng, this._lngLat.lat - .001)).sub(t);\n            o = e.radToDeg(Math.atan2(r.y, r.x)) - 90;\n          } else o = -i.getBearing();\n        } else if (\"horizon\" === r) {\n          const r = e.smoothstep(4, 6, i.getZoom()),\n            n = e.globeCenterToScreenPoint(i.transform);\n          n.y += r * i.transform.height;\n          const s = t.sub(n),\n            a = e.radToDeg(Math.atan2(s.y, s.x));\n          o = (a > 90 ? a - 270 : a + 90) * (1 - r);\n        }\n        return o += this._rotation, o ? `rotateZ(${o}deg)` : \"\";\n      }\n      _update(t) {\n        e.window.cancelAnimationFrame(this._updateFrameId);\n        const i = this._map;\n        i && (i.transform.renderWorldCopies && (this._lngLat = Jr(this._lngLat, this._pos, i.transform)), this._pos = i.project(this._lngLat), !0 === t ? this._updateFrameId = e.window.requestAnimationFrame(() => {\n          this._element && this._pos && this._anchor && (this._pos = this._pos.round(), this._updateDOM());\n        }) : this._pos = this._pos.round(), i._requestDomTask(() => {\n          this._map && (this._element && this._pos && this._anchor && this._updateDOM(), (i._showingGlobe() || i.getTerrain() || i.getFog()) && !this._fadeTimer && (this._fadeTimer = setTimeout(this._evaluateOpacity.bind(this), 60)));\n        }));\n      }\n      getOffset() {\n        return this._offset;\n      }\n      setOffset(t) {\n        return this._offset = e.Point.convert(t), this._update(), this;\n      }\n      _onMove(t) {\n        const i = this._map;\n        if (!i) return;\n        const o = this._pointerdownPos,\n          r = this._positionDelta;\n        if (o && r) {\n          if (!this._isDragging) {\n            const e = this._clickTolerance || i._clickTolerance;\n            if (t.point.dist(o) < e) return;\n            this._isDragging = !0;\n          }\n          this._pos = t.point.sub(r), this._lngLat = i.unproject(this._pos), this.setLngLat(this._lngLat), this._element.style.pointerEvents = \"none\", \"pending\" === this._state && (this._state = \"active\", this.fire(new e.Event(\"dragstart\"))), this.fire(new e.Event(\"drag\"));\n        }\n      }\n      _onUp() {\n        this._element.style.pointerEvents = \"auto\", this._positionDelta = null, this._pointerdownPos = null, this._isDragging = !1;\n        const t = this._map;\n        t && (t.off(\"mousemove\", this._onMove), t.off(\"touchmove\", this._onMove)), \"active\" === this._state && this.fire(new e.Event(\"dragend\")), this._state = \"inactive\";\n      }\n      _addDragHandler(e) {\n        const t = this._map,\n          i = this._pos;\n        t && i && this._element.contains(e.originalEvent.target) && (e.preventDefault(), this._positionDelta = e.point.sub(i), this._pointerdownPos = e.point, this._state = \"pending\", t.on(\"mousemove\", this._onMove), t.on(\"touchmove\", this._onMove), t.once(\"mouseup\", this._onUp), t.once(\"touchend\", this._onUp));\n      }\n      setDraggable(e) {\n        this._draggable = !!e;\n        const t = this._map;\n        return t && (e ? (t.on(\"mousedown\", this._addDragHandler), t.on(\"touchstart\", this._addDragHandler)) : (t.off(\"mousedown\", this._addDragHandler), t.off(\"touchstart\", this._addDragHandler))), this;\n      }\n      isDraggable() {\n        return this._draggable;\n      }\n      setRotation(e) {\n        return this._rotation = e || 0, this._update(), this;\n      }\n      getRotation() {\n        return this._rotation;\n      }\n      setRotationAlignment(e) {\n        return this._rotationAlignment = e || \"auto\", this._update(), this;\n      }\n      getRotationAlignment() {\n        return \"auto\" === this._rotationAlignment || \"horizon\" === this._rotationAlignment && this._map && !this._map._showingGlobe() ? \"viewport\" : this._rotationAlignment;\n      }\n      setPitchAlignment(e) {\n        return this._pitchAlignment = e || \"auto\", this._update(), this;\n      }\n      getPitchAlignment() {\n        return \"auto\" === this._pitchAlignment ? this.getRotationAlignment() : this._pitchAlignment;\n      }\n      setOccludedOpacity(e) {\n        return this._occludedOpacity = e || .2, this._update(), this;\n      }\n      getOccludedOpacity() {\n        return this._occludedOpacity;\n      }\n    }\n    const tn = {\n        closeButton: !0,\n        closeOnClick: !0,\n        focusAfterOpen: !0,\n        className: \"\",\n        maxWidth: \"240px\"\n      },\n      on = [\"a[href]\", \"[tabindex]:not([tabindex='-1'])\", \"[contenteditable]:not([contenteditable='false'])\", \"button:not([disabled])\", \"input:not([disabled])\", \"select:not([disabled])\", \"textarea:not([disabled])\"].join(\", \");\n    function rn(t = new e.Point(0, 0), i = \"bottom\") {\n      if (\"number\" == typeof t) {\n        const o = Math.round(Math.sqrt(.5 * Math.pow(t, 2)));\n        switch (i) {\n          case \"top\":\n            return new e.Point(0, t);\n          case \"top-left\":\n            return new e.Point(o, o);\n          case \"top-right\":\n            return new e.Point(-o, o);\n          case \"bottom\":\n            return new e.Point(0, -t);\n          case \"bottom-left\":\n            return new e.Point(o, -o);\n          case \"bottom-right\":\n            return new e.Point(-o, -o);\n          case \"left\":\n            return new e.Point(t, 0);\n          case \"right\":\n            return new e.Point(-t, 0);\n        }\n        return new e.Point(0, 0);\n      }\n      return t instanceof e.Point || Array.isArray(t) ? e.Point.convert(t) : e.Point.convert(t[i] || [0, 0]);\n    }\n    class nn {\n      constructor(e) {\n        this.jumpTo(e);\n      }\n      getValue(t) {\n        if (t <= this._startTime) return this._start;\n        if (t >= this._endTime) return this._end;\n        const i = e.easeCubicInOut((t - this._startTime) / (this._endTime - this._startTime));\n        return this._start * (1 - i) + this._end * i;\n      }\n      isEasing(e) {\n        return e >= this._startTime && e <= this._endTime;\n      }\n      jumpTo(e) {\n        this._startTime = -1 / 0, this._endTime = -1 / 0, this._start = e, this._end = e;\n      }\n      easeTo(e, t, i) {\n        this._start = this.getValue(t), this._end = e, this._startTime = t, this._endTime = t + i;\n      }\n    }\n    const sn = {\n        \"AttributionControl.ToggleAttribution\": \"Toggle attribution\",\n        \"AttributionControl.MapFeedback\": \"Map feedback\",\n        \"FullscreenControl.Enter\": \"Enter fullscreen\",\n        \"FullscreenControl.Exit\": \"Exit fullscreen\",\n        \"GeolocateControl.FindMyLocation\": \"Find my location\",\n        \"GeolocateControl.LocationNotAvailable\": \"Location not available\",\n        \"LogoControl.Title\": \"Mapbox logo\",\n        \"Map.Title\": \"Map\",\n        \"NavigationControl.ResetBearing\": \"Reset bearing to north\",\n        \"NavigationControl.ZoomIn\": \"Zoom in\",\n        \"NavigationControl.ZoomOut\": \"Zoom out\",\n        \"ScrollZoomBlocker.CtrlMessage\": \"Use ctrl + scroll to zoom the map\",\n        \"ScrollZoomBlocker.CmdMessage\": \"Use â + scroll to zoom the map\",\n        \"TouchPanBlocker.Message\": \"Use two fingers to move the map\"\n      },\n      an = {\n        center: [0, 0],\n        zoom: 0,\n        bearing: 0,\n        pitch: 0,\n        minZoom: -2,\n        maxZoom: 22,\n        minPitch: 0,\n        maxPitch: 85,\n        interactive: !0,\n        scrollZoom: !0,\n        boxZoom: !0,\n        dragRotate: !0,\n        dragPan: !0,\n        keyboard: !0,\n        doubleClickZoom: !0,\n        touchZoomRotate: !0,\n        touchPitch: !0,\n        cooperativeGestures: !1,\n        performanceMetricsCollection: !0,\n        bearingSnap: 7,\n        clickTolerance: 3,\n        pitchWithRotate: !0,\n        hash: !1,\n        attributionControl: !0,\n        failIfMajorPerformanceCaveat: !1,\n        preserveDrawingBuffer: !1,\n        trackResize: !0,\n        optimizeForTerrain: !0,\n        renderWorldCopies: !0,\n        refreshExpiredTiles: !0,\n        minTileCacheSize: null,\n        maxTileCacheSize: null,\n        localIdeographFontFamily: \"sans-serif\",\n        localFontFamily: null,\n        transformRequest: null,\n        accessToken: null,\n        fadeDuration: 300,\n        respectPrefersReducedMotion: !0,\n        crossSourceCollisions: !0\n      },\n      ln = {\n        showCompass: !0,\n        showZoom: !0,\n        visualizePitch: !1\n      };\n    class cn {\n      constructor(t, i, o = !1) {\n        this._clickTolerance = 10, this.element = i, this.mouseRotate = new yr({\n          clickTolerance: t.dragRotate._mouseRotate._clickTolerance\n        }), this.map = t, o && (this.mousePitch = new br({\n          clickTolerance: t.dragRotate._mousePitch._clickTolerance\n        })), e.bindAll([\"mousedown\", \"mousemove\", \"mouseup\", \"touchstart\", \"touchmove\", \"touchend\", \"reset\"], this), i.addEventListener(\"mousedown\", this.mousedown), i.addEventListener(\"touchstart\", this.touchstart, {\n          passive: !1\n        }), i.addEventListener(\"touchmove\", this.touchmove), i.addEventListener(\"touchend\", this.touchend), i.addEventListener(\"touchcancel\", this.reset);\n      }\n      down(e, t) {\n        this.mouseRotate.mousedown(e, t), this.mousePitch && this.mousePitch.mousedown(e, t), h();\n      }\n      move(e, t) {\n        const i = this.map,\n          o = this.mouseRotate.mousemoveWindow(e, t),\n          r = o && o.bearingDelta;\n        if (r && i.setBearing(i.getBearing() + r), this.mousePitch) {\n          const o = this.mousePitch.mousemoveWindow(e, t),\n            r = o && o.pitchDelta;\n          r && i.setPitch(i.getPitch() + r);\n        }\n      }\n      off() {\n        const e = this.element;\n        e.removeEventListener(\"mousedown\", this.mousedown), e.removeEventListener(\"touchstart\", this.touchstart, {\n          passive: !1\n        }), e.removeEventListener(\"touchmove\", this.touchmove), e.removeEventListener(\"touchend\", this.touchend), e.removeEventListener(\"touchcancel\", this.reset), this.offTemp();\n      }\n      offTemp() {\n        u(), e.window.removeEventListener(\"mousemove\", this.mousemove), e.window.removeEventListener(\"mouseup\", this.mouseup);\n      }\n      mousedown(t) {\n        this.down(e.extend({}, t, {\n          ctrlKey: !0,\n          preventDefault: () => t.preventDefault()\n        }), p(this.element, t)), e.window.addEventListener(\"mousemove\", this.mousemove), e.window.addEventListener(\"mouseup\", this.mouseup);\n      }\n      mousemove(e) {\n        this.move(e, p(this.element, e));\n      }\n      mouseup(e) {\n        this.mouseRotate.mouseupWindow(e), this.mousePitch && this.mousePitch.mouseupWindow(e), this.offTemp();\n      }\n      touchstart(e) {\n        1 !== e.targetTouches.length ? this.reset() : (this._startPos = this._lastPos = m(this.element, e.targetTouches)[0], this.down({\n          type: \"mousedown\",\n          button: 0,\n          ctrlKey: !0,\n          preventDefault: () => e.preventDefault()\n        }, this._startPos));\n      }\n      touchmove(e) {\n        1 !== e.targetTouches.length ? this.reset() : (this._lastPos = m(this.element, e.targetTouches)[0], this.move({\n          preventDefault: () => e.preventDefault()\n        }, this._lastPos));\n      }\n      touchend(e) {\n        0 === e.targetTouches.length && this._startPos && this._lastPos && this._startPos.dist(this._lastPos) < this._clickTolerance && this.element.click(), this.reset();\n      }\n      reset() {\n        this.mouseRotate.reset(), this.mousePitch && this.mousePitch.reset(), delete this._startPos, delete this._lastPos, this.offTemp();\n      }\n    }\n    const hn = {\n        positionOptions: {\n          enableHighAccuracy: !1,\n          maximumAge: 0,\n          timeout: 6e3\n        },\n        fitBoundsOptions: {\n          maxZoom: 15\n        },\n        trackUserLocation: !1,\n        showAccuracyCircle: !0,\n        showUserLocation: !0,\n        showUserHeading: !1\n      },\n      un = {\n        maxWidth: 100,\n        unit: \"metric\"\n      },\n      _n = {\n        kilometer: \"km\",\n        meter: \"m\",\n        mile: \"mi\",\n        foot: \"ft\",\n        \"nautical-mile\": \"nm\"\n      },\n      dn = {\n        version: e.version,\n        supported: i,\n        setRTLTextPlugin: e.setRTLTextPlugin,\n        getRTLTextPluginStatus: e.getRTLTextPluginStatus,\n        Map: class extends $r {\n          constructor(t) {\n            if (e.LivePerformanceUtils.mark(e.PerformanceMarkers.create), null != (t = e.extend({}, an, t)).minZoom && null != t.maxZoom && t.minZoom > t.maxZoom) throw new Error(\"maxZoom must be greater than or equal to minZoom\");\n            if (null != t.minPitch && null != t.maxPitch && t.minPitch > t.maxPitch) throw new Error(\"maxPitch must be greater than or equal to minPitch\");\n            if (null != t.minPitch && t.minPitch < 0) throw new Error(\"minPitch must be greater than or equal to 0\");\n            if (null != t.maxPitch && t.maxPitch > 85) throw new Error(\"maxPitch must be less than or equal to 85\");\n            if (t.antialias && e.isSafariWithAntialiasingBug(e.window) && (t.antialias = !1, e.warnOnce(\"Antialiasing is disabled for this WebGL context to avoid browser bug: https://github.com/mapbox/mapbox-gl-js/issues/11609\")), super(new Ho(t.minZoom, t.maxZoom, t.minPitch, t.maxPitch, t.renderWorldCopies), t), this._interactive = t.interactive, this._minTileCacheSize = t.minTileCacheSize, this._maxTileCacheSize = t.maxTileCacheSize, this._failIfMajorPerformanceCaveat = t.failIfMajorPerformanceCaveat, this._preserveDrawingBuffer = t.preserveDrawingBuffer, this._antialias = t.antialias, this._useWebGL2 = t.useWebGL2, this._trackResize = t.trackResize, this._bearingSnap = t.bearingSnap, this._refreshExpiredTiles = t.refreshExpiredTiles, this._fadeDuration = t.fadeDuration, this._isInitialLoad = !0, this._crossSourceCollisions = t.crossSourceCollisions, this._collectResourceTiming = t.collectResourceTiming, this._optimizeForTerrain = t.optimizeForTerrain, this._language = this._parseLanguage(t.language), this._worldview = t.worldview, this._renderTaskQueue = new Kr(), this._domRenderTaskQueue = new Kr(), this._controls = [], this._markers = [], this._popups = [], this._mapId = e.uniqueId(), this._locale = e.extend({}, sn, t.locale), this._clickTolerance = t.clickTolerance, this._cooperativeGestures = t.cooperativeGestures, this._performanceMetricsCollection = t.performanceMetricsCollection, this._containerWidth = 0, this._containerHeight = 0, this._averageElevationLastSampledAt = -1 / 0, this._averageElevationExaggeration = 0, this._averageElevation = new nn(0), this._interactionRange = [1 / 0, -1 / 0], this._visibilityHidden = 0, this._useExplicitProjection = !1, this._requestManager = new e.RequestManager(t.transformRequest, t.accessToken, t.testMode), this._silenceAuthErrors = !!t.testMode, \"string\" == typeof t.container) {\n              if (this._container = e.window.document.getElementById(t.container), !this._container) throw new Error(`Container '${t.container}' not found.`);\n            } else {\n              if (!(t.container instanceof e.window.HTMLElement)) throw new Error(\"Invalid type: 'container' must be a String or HTMLElement.\");\n              this._container = t.container;\n            }\n            if (this._container.childNodes.length > 0 && e.warnOnce(\"The map container element should be empty, otherwise the map's interactivity will be negatively impacted. If you want to display a message when WebGL is not supported, use the Mapbox GL Supported plugin instead.\"), t.maxBounds && this.setMaxBounds(t.maxBounds), e.bindAll([\"_onWindowOnline\", \"_onWindowResize\", \"_onVisibilityChange\", \"_onMapScroll\", \"_contextLost\", \"_contextRestored\"], this), this._setupContainer(), this._setupPainter(), void 0 === this.painter) throw new Error(\"Failed to initialize WebGL.\");\n            this.on(\"move\", () => this._update(!1)), this.on(\"moveend\", () => this._update(!1)), this.on(\"zoom\", () => this._update(!0)), void 0 !== e.window && (e.window.addEventListener(\"online\", this._onWindowOnline, !1), e.window.addEventListener(\"resize\", this._onWindowResize, !1), e.window.addEventListener(\"orientationchange\", this._onWindowResize, !1), e.window.addEventListener(\"webkitfullscreenchange\", this._onWindowResize, !1), e.window.addEventListener(\"visibilitychange\", this._onVisibilityChange, !1)), this.handlers = new Xr(this, t), this._localFontFamily = t.localFontFamily, this._localIdeographFontFamily = t.localIdeographFontFamily, t.style && this.setStyle(t.style, {\n              localFontFamily: this._localFontFamily,\n              localIdeographFontFamily: this._localIdeographFontFamily\n            }), t.projection && this.setProjection(t.projection), this._hash = t.hash && new Ko(\"string\" == typeof t.hash && t.hash || void 0).addTo(this), this._hash && this._hash._onHashChange() || (this.jumpTo({\n              center: t.center,\n              zoom: t.zoom,\n              bearing: t.bearing,\n              pitch: t.pitch\n            }), t.bounds && (this.resize(), this.fitBounds(t.bounds, e.extend({}, t.fitBoundsOptions, {\n              duration: 0\n            })))), this.resize(), t.attributionControl && this.addControl(new Hr({\n              customAttribution: t.customAttribution\n            })), this._logoControl = new Yr(), this.addControl(this._logoControl, t.logoPosition), this.on(\"style.load\", () => {\n              this.transform.unmodified && this.jumpTo(this.style.stylesheet);\n            }), this.on(\"data\", t => {\n              this._update(\"style\" === t.dataType), this.fire(new e.Event(`${t.dataType}data`, t));\n            }), this.on(\"dataloading\", t => {\n              this.fire(new e.Event(`${t.dataType}dataloading`, t));\n            });\n          }\n          _getMapId() {\n            return this._mapId;\n          }\n          addControl(t, i) {\n            if (void 0 === i && (i = t.getDefaultPosition ? t.getDefaultPosition() : \"top-right\"), !t || !t.onAdd) return this.fire(new e.ErrorEvent(new Error(\"Invalid argument to map.addControl(). Argument must be a control with onAdd and onRemove methods.\")));\n            const o = t.onAdd(this);\n            this._controls.push(t);\n            const r = this._controlPositions[i];\n            return -1 !== i.indexOf(\"bottom\") ? r.insertBefore(o, r.firstChild) : r.appendChild(o), this;\n          }\n          removeControl(t) {\n            if (!t || !t.onRemove) return this.fire(new e.ErrorEvent(new Error(\"Invalid argument to map.removeControl(). Argument must be a control with onAdd and onRemove methods.\")));\n            const i = this._controls.indexOf(t);\n            return i > -1 && this._controls.splice(i, 1), t.onRemove(this), this;\n          }\n          hasControl(e) {\n            return this._controls.indexOf(e) > -1;\n          }\n          getContainer() {\n            return this._container;\n          }\n          getCanvasContainer() {\n            return this._canvasContainer;\n          }\n          getCanvas() {\n            return this._canvas;\n          }\n          resize(t) {\n            if (this._updateContainerDimensions(), this._containerWidth === this.transform.width && this._containerHeight === this.transform.height) return this;\n            this._resizeCanvas(this._containerWidth, this._containerHeight), this.transform.resize(this._containerWidth, this._containerHeight), this.painter.resize(Math.ceil(this._containerWidth), Math.ceil(this._containerHeight));\n            const i = !this._moving;\n            return i && this.fire(new e.Event(\"movestart\", t)).fire(new e.Event(\"move\", t)), this.fire(new e.Event(\"resize\", t)), i && this.fire(new e.Event(\"moveend\", t)), this;\n          }\n          getBounds() {\n            return this.transform.getBounds();\n          }\n          getMaxBounds() {\n            return this.transform.getMaxBounds() || null;\n          }\n          setMaxBounds(t) {\n            return this.transform.setMaxBounds(e.LngLatBounds.convert(t)), this._update();\n          }\n          setMinZoom(t) {\n            if ((t = null == t ? -2 : t) >= -2 && t <= this.transform.maxZoom) return this.transform.minZoom = t, this._update(), this.getZoom() < t ? this.setZoom(t) : this.fire(new e.Event(\"zoomstart\")).fire(new e.Event(\"zoom\")).fire(new e.Event(\"zoomend\")), this;\n            throw new Error(\"minZoom must be between -2 and the current maxZoom, inclusive\");\n          }\n          getMinZoom() {\n            return this.transform.minZoom;\n          }\n          setMaxZoom(t) {\n            if ((t = null == t ? 22 : t) >= this.transform.minZoom) return this.transform.maxZoom = t, this._update(), this.getZoom() > t ? this.setZoom(t) : this.fire(new e.Event(\"zoomstart\")).fire(new e.Event(\"zoom\")).fire(new e.Event(\"zoomend\")), this;\n            throw new Error(\"maxZoom must be greater than the current minZoom\");\n          }\n          getMaxZoom() {\n            return this.transform.maxZoom;\n          }\n          setMinPitch(t) {\n            if ((t = null == t ? 0 : t) < 0) throw new Error(\"minPitch must be greater than or equal to 0\");\n            if (t >= 0 && t <= this.transform.maxPitch) return this.transform.minPitch = t, this._update(), this.getPitch() < t ? this.setPitch(t) : this.fire(new e.Event(\"pitchstart\")).fire(new e.Event(\"pitch\")).fire(new e.Event(\"pitchend\")), this;\n            throw new Error(\"minPitch must be between 0 and the current maxPitch, inclusive\");\n          }\n          getMinPitch() {\n            return this.transform.minPitch;\n          }\n          setMaxPitch(t) {\n            if ((t = null == t ? 85 : t) > 85) throw new Error(\"maxPitch must be less than or equal to 85\");\n            if (t >= this.transform.minPitch) return this.transform.maxPitch = t, this._update(), this.getPitch() > t ? this.setPitch(t) : this.fire(new e.Event(\"pitchstart\")).fire(new e.Event(\"pitch\")).fire(new e.Event(\"pitchend\")), this;\n            throw new Error(\"maxPitch must be greater than or equal to minPitch\");\n          }\n          getMaxPitch() {\n            return this.transform.maxPitch;\n          }\n          getRenderWorldCopies() {\n            return this.transform.renderWorldCopies;\n          }\n          setRenderWorldCopies(e) {\n            return this.transform.renderWorldCopies = e, this.transform.renderWorldCopies || this._forceMarkerAndPopupUpdate(!0), this._update();\n          }\n          getLanguage() {\n            return this._language;\n          }\n          _parseLanguage(t) {\n            return \"auto\" === t ? e.window.navigator.language : Array.isArray(t) ? 0 === t.length ? void 0 : t.map(t => \"auto\" === t ? e.window.navigator.language : t) : t;\n          }\n          setLanguage(e) {\n            const t = this._parseLanguage(e);\n            if (!this.style || t === this._language) return this;\n            this._language = t, this.style._reloadSources();\n            for (const e of this._controls) e._setLanguage && e._setLanguage(this._language);\n            return this;\n          }\n          getWorldview() {\n            return this._worldview;\n          }\n          setWorldview(e) {\n            return this.style && e !== this._worldview ? (this._worldview = e, this.style._reloadSources(), this) : this;\n          }\n          getProjection() {\n            return this.transform.mercatorFromTransition ? {\n              name: \"globe\",\n              center: [0, 0]\n            } : this.transform.getProjection();\n          }\n          _showingGlobe() {\n            return \"globe\" === this.transform.projection.name;\n          }\n          setProjection(e) {\n            return this._lazyInitEmptyStyle(), e ? \"string\" == typeof e && (e = {\n              name: e\n            }) : e = null, this._useExplicitProjection = !!e, this._prioritizeAndUpdateProjection(e, this.style.stylesheet ? this.style.stylesheet.projection : null);\n          }\n          _updateProjectionTransition() {\n            if (\"globe\" !== this.getProjection().name) return;\n            const t = this.transform,\n              i = t.projection.name;\n            let o;\n            \"globe\" === i && t.zoom >= e.GLOBE_ZOOM_THRESHOLD_MAX ? (t.setMercatorFromTransition(), o = !0) : \"mercator\" === i && t.zoom < e.GLOBE_ZOOM_THRESHOLD_MAX && (t.setProjection({\n              name: \"globe\"\n            }), o = !0), o && (this.style.applyProjectionUpdate(), this.style._forceSymbolLayerUpdate());\n          }\n          _prioritizeAndUpdateProjection(e, t) {\n            return this._updateProjection(e || t || {\n              name: \"mercator\"\n            });\n          }\n          _updateProjection(t) {\n            let i;\n            if (i = \"globe\" === t.name && this.transform.zoom >= e.GLOBE_ZOOM_THRESHOLD_MAX ? this.transform.setMercatorFromTransition() : this.transform.setProjection(t), this.style.applyProjectionUpdate(), i) {\n              this.painter.clearBackgroundTiles();\n              for (const e in this.style._sourceCaches) this.style._sourceCaches[e].clearTiles();\n              this._update(!0), this._forceMarkerAndPopupUpdate(!0);\n            }\n            return this;\n          }\n          project(t) {\n            return this.transform.locationPoint3D(e.LngLat.convert(t));\n          }\n          unproject(t) {\n            return this.transform.pointLocation3D(e.Point.convert(t));\n          }\n          isMoving() {\n            return this._moving || this.handlers && this.handlers.isMoving() || !1;\n          }\n          isZooming() {\n            return this._zooming || this.handlers && this.handlers.isZooming() || !1;\n          }\n          isRotating() {\n            return this._rotating || this.handlers && this.handlers.isRotating() || !1;\n          }\n          _isDragging() {\n            return this.handlers && this.handlers._isDragging() || !1;\n          }\n          _createDelegatedListener(e, t, i) {\n            if (\"mouseenter\" === e || \"mouseover\" === e) {\n              let o = !1;\n              const r = r => {\n                  const n = t.filter(e => this.getLayer(e)),\n                    s = n.length ? this.queryRenderedFeatures(r.point, {\n                      layers: n\n                    }) : [];\n                  s.length ? o || (o = !0, i.call(this, new ar(e, this, r.originalEvent, {\n                    features: s\n                  }))) : o = !1;\n                },\n                n = () => {\n                  o = !1;\n                };\n              return {\n                layers: new Set(t),\n                listener: i,\n                delegates: {\n                  mousemove: r,\n                  mouseout: n\n                }\n              };\n            }\n            if (\"mouseleave\" === e || \"mouseout\" === e) {\n              let o = !1;\n              const r = r => {\n                  const n = t.filter(e => this.getLayer(e));\n                  (n.length ? this.queryRenderedFeatures(r.point, {\n                    layers: n\n                  }) : []).length ? o = !0 : o && (o = !1, i.call(this, new ar(e, this, r.originalEvent)));\n                },\n                n = t => {\n                  o && (o = !1, i.call(this, new ar(e, this, t.originalEvent)));\n                };\n              return {\n                layers: new Set(t),\n                listener: i,\n                delegates: {\n                  mousemove: r,\n                  mouseout: n\n                }\n              };\n            }\n            {\n              const o = e => {\n                const o = t.filter(e => this.getLayer(e)),\n                  r = o.length ? this.queryRenderedFeatures(e.point, {\n                    layers: o\n                  }) : [];\n                r.length && (e.features = r, i.call(this, e), delete e.features);\n              };\n              return {\n                layers: new Set(t),\n                listener: i,\n                delegates: {\n                  [e]: o\n                }\n              };\n            }\n          }\n          on(e, t, i) {\n            if (void 0 === i) return super.on(e, t);\n            Array.isArray(t) || (t = [t]);\n            const o = this._createDelegatedListener(e, t, i);\n            this._delegatedListeners = this._delegatedListeners || {}, this._delegatedListeners[e] = this._delegatedListeners[e] || [], this._delegatedListeners[e].push(o);\n            for (const e in o.delegates) this.on(e, o.delegates[e]);\n            return this;\n          }\n          once(e, t, i) {\n            if (void 0 === i) return super.once(e, t);\n            Array.isArray(t) || (t = [t]);\n            const o = this._createDelegatedListener(e, t, i);\n            for (const e in o.delegates) this.once(e, o.delegates[e]);\n            return this;\n          }\n          off(e, t, i) {\n            if (void 0 === i) return super.off(e, t);\n            t = new Set(Array.isArray(t) ? t : [t]);\n            const o = (e, t) => {\n                if (e.size !== t.size) return !1;\n                for (const i of e) if (!t.has(i)) return !1;\n                return !0;\n              },\n              r = this._delegatedListeners ? this._delegatedListeners[e] : void 0;\n            return r && (e => {\n              for (let r = 0; r < e.length; r++) {\n                const n = e[r];\n                if (n.listener === i && o(n.layers, t)) {\n                  for (const e in n.delegates) this.off(e, n.delegates[e]);\n                  return e.splice(r, 1), this;\n                }\n              }\n            })(r), this;\n          }\n          queryRenderedFeatures(t, i) {\n            return this.style ? (void 0 !== i || void 0 === t || t instanceof e.Point || Array.isArray(t) || (i = t, t = void 0), this.style.queryRenderedFeatures(t = t || [[0, 0], [this.transform.width, this.transform.height]], i = i || {}, this.transform)) : [];\n          }\n          querySourceFeatures(e, t) {\n            return this.style.querySourceFeatures(e, t);\n          }\n          isPointOnSurface(t) {\n            const {\n              name: i\n            } = this.transform.projection;\n            return \"globe\" !== i && \"mercator\" !== i && e.warnOnce(`${i} projection does not support isPointOnSurface, this API may behave unexpectedly.`), this.transform.isPointOnSurface(e.Point.convert(t));\n          }\n          setStyle(t, i) {\n            return !1 !== (i = e.extend({}, {\n              localIdeographFontFamily: this._localIdeographFontFamily,\n              localFontFamily: this._localFontFamily\n            }, i)).diff && i.localIdeographFontFamily === this._localIdeographFontFamily && i.localFontFamily === this._localFontFamily && this.style && t ? (this._diffStyle(t, i), this) : (this._localIdeographFontFamily = i.localIdeographFontFamily, this._localFontFamily = i.localFontFamily, this._updateStyle(t, i));\n          }\n          _getUIString(e) {\n            const t = this._locale[e];\n            if (null == t) throw new Error(`Missing UI string '${e}'`);\n            return t;\n          }\n          _updateStyle(e, t) {\n            return this.style && (this.style.setEventedParent(null), this.style._remove(), this.style = void 0), e && (this.style = new Kt(this, t || {}), this.style.setEventedParent(this, {\n              style: this.style\n            }), \"string\" == typeof e ? this.style.loadURL(e) : this.style.loadJSON(e)), this._updateTerrain(), this;\n          }\n          _lazyInitEmptyStyle() {\n            this.style || (this.style = new Kt(this, {}), this.style.setEventedParent(this, {\n              style: this.style\n            }), this.style.loadEmpty());\n          }\n          _diffStyle(t, i) {\n            if (\"string\" == typeof t) {\n              const o = this._requestManager.normalizeStyleURL(t),\n                r = this._requestManager.transformRequest(o, e.ResourceType.Style);\n              e.getJSON(r, (t, o) => {\n                t ? this.fire(new e.ErrorEvent(t)) : o && this._updateDiff(o, i);\n              });\n            } else \"object\" == typeof t && this._updateDiff(t, i);\n          }\n          _updateDiff(t, i) {\n            try {\n              this.style.setState(t) && this._update(!0);\n            } catch (o) {\n              e.warnOnce(`Unable to perform style diff: ${o.message || o.error || o}.  Rebuilding the style from scratch.`), this._updateStyle(t, i);\n            }\n          }\n          getStyle() {\n            if (this.style) return this.style.serialize();\n          }\n          isStyleLoaded() {\n            return this.style ? this.style.loaded() : (e.warnOnce(\"There is no style added to the map.\"), !1);\n          }\n          addSource(e, t) {\n            return this._lazyInitEmptyStyle(), this.style.addSource(e, t), this._update(!0);\n          }\n          isSourceLoaded(e) {\n            return !!this.style && this.style._isSourceCacheLoaded(e);\n          }\n          areTilesLoaded() {\n            const e = this.style && this.style._sourceCaches;\n            for (const t in e) {\n              const i = e[t]._tiles;\n              for (const e in i) {\n                const t = i[e];\n                if (\"loaded\" !== t.state && \"errored\" !== t.state) return !1;\n              }\n            }\n            return !0;\n          }\n          addSourceType(e, t, i) {\n            this._lazyInitEmptyStyle(), this.style.addSourceType(e, t, i);\n          }\n          removeSource(e) {\n            return this.style.removeSource(e), this._updateTerrain(), this._update(!0);\n          }\n          getSource(e) {\n            return this.style.getSource(e);\n          }\n          addImage(t, i, {\n            pixelRatio: o = 1,\n            sdf: r = !1,\n            stretchX: n,\n            stretchY: s,\n            content: a\n          } = {}) {\n            if (this._lazyInitEmptyStyle(), i instanceof e.window.HTMLImageElement || e.window.ImageBitmap && i instanceof e.window.ImageBitmap) {\n              const {\n                width: l,\n                height: c,\n                data: h\n              } = e.exported.getImageData(i);\n              this.style.addImage(t, {\n                data: new e.RGBAImage({\n                  width: l,\n                  height: c\n                }, h),\n                pixelRatio: o,\n                stretchX: n,\n                stretchY: s,\n                content: a,\n                sdf: r,\n                version: 0\n              });\n            } else if (void 0 === i.width || void 0 === i.height) this.fire(new e.ErrorEvent(new Error(\"Invalid arguments to map.addImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`\")));else {\n              const {\n                  width: l,\n                  height: c\n                } = i,\n                h = i;\n              this.style.addImage(t, {\n                data: new e.RGBAImage({\n                  width: l,\n                  height: c\n                }, new Uint8Array(h.data)),\n                pixelRatio: o,\n                stretchX: n,\n                stretchY: s,\n                content: a,\n                sdf: r,\n                version: 0,\n                userImage: h\n              }), h.onAdd && h.onAdd(this, t);\n            }\n          }\n          updateImage(t, i) {\n            const o = this.style.getImage(t);\n            if (!o) return void this.fire(new e.ErrorEvent(new Error(\"The map has no image with that id. If you are adding a new image use `map.addImage(...)` instead.\")));\n            const r = i instanceof e.window.HTMLImageElement || e.window.ImageBitmap && i instanceof e.window.ImageBitmap ? e.exported.getImageData(i) : i,\n              {\n                width: n,\n                height: s\n              } = r;\n            void 0 !== n && void 0 !== s ? n === o.data.width && s === o.data.height ? (o.data.replace(r.data, !(i instanceof e.window.HTMLImageElement || e.window.ImageBitmap && i instanceof e.window.ImageBitmap)), this.style.updateImage(t, o)) : this.fire(new e.ErrorEvent(new Error(`The width and height of the updated image (${n}, ${s})\\n                must be that same as the previous version of the image\\n                (${o.data.width}, ${o.data.height})`))) : this.fire(new e.ErrorEvent(new Error(\"Invalid arguments to map.updateImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`\")));\n          }\n          hasImage(t) {\n            return t ? !!this.style.getImage(t) : (this.fire(new e.ErrorEvent(new Error(\"Missing required image id\"))), !1);\n          }\n          removeImage(e) {\n            this.style.removeImage(e);\n          }\n          loadImage(t, i) {\n            e.getImage(this._requestManager.transformRequest(t, e.ResourceType.Image), (t, o) => {\n              i(t, o instanceof e.window.HTMLImageElement ? e.exported.getImageData(o) : o);\n            });\n          }\n          listImages() {\n            return this.style.listImages();\n          }\n          addLayer(e, t) {\n            return this._lazyInitEmptyStyle(), this.style.addLayer(e, t), this._update(!0);\n          }\n          moveLayer(e, t) {\n            return this.style.moveLayer(e, t), this._update(!0);\n          }\n          removeLayer(e) {\n            return this.style.removeLayer(e), this._update(!0);\n          }\n          getLayer(e) {\n            return this.style.getLayer(e);\n          }\n          setLayerZoomRange(e, t, i) {\n            return this.style.setLayerZoomRange(e, t, i), this._update(!0);\n          }\n          setFilter(e, t, i = {}) {\n            return this.style.setFilter(e, t, i), this._update(!0);\n          }\n          getFilter(e) {\n            return this.style.getFilter(e);\n          }\n          setPaintProperty(e, t, i, o = {}) {\n            return this.style.setPaintProperty(e, t, i, o), this._update(!0);\n          }\n          getPaintProperty(e, t) {\n            return this.style.getPaintProperty(e, t);\n          }\n          setLayoutProperty(e, t, i, o = {}) {\n            return this.style.setLayoutProperty(e, t, i, o), this._update(!0);\n          }\n          getLayoutProperty(e, t) {\n            return this.style.getLayoutProperty(e, t);\n          }\n          setLight(e, t = {}) {\n            return this._lazyInitEmptyStyle(), this.style.setLight(e, t), this._update(!0);\n          }\n          getLight() {\n            return this.style.getLight();\n          }\n          setTerrain(e) {\n            return this._lazyInitEmptyStyle(), !e && this.transform.projection.requiresDraping ? this.style.setTerrainForDraping() : this.style.setTerrain(e), this._averageElevationLastSampledAt = -1 / 0, this._update(!0);\n          }\n          getTerrain() {\n            return this.style ? this.style.getTerrain() : null;\n          }\n          setFog(e) {\n            return this._lazyInitEmptyStyle(), this.style.setFog(e), this._update(!0);\n          }\n          getFog() {\n            return this.style ? this.style.getFog() : null;\n          }\n          _queryFogOpacity(t) {\n            return this.style && this.style.fog ? this.style.fog.getOpacityAtLatLng(e.LngLat.convert(t), this.transform) : 0;\n          }\n          setFeatureState(e, t) {\n            return this.style.setFeatureState(e, t), this._update();\n          }\n          removeFeatureState(e, t) {\n            return this.style.removeFeatureState(e, t), this._update();\n          }\n          getFeatureState(e) {\n            return this.style.getFeatureState(e);\n          }\n          _updateContainerDimensions() {\n            if (!this._container) return;\n            const t = this._container.getBoundingClientRect().width || 400,\n              i = this._container.getBoundingClientRect().height || 300;\n            let o,\n              r,\n              n,\n              s = this._container;\n            for (; s && (!r || !n);) {\n              const t = e.window.getComputedStyle(s).transform;\n              t && \"none\" !== t && (o = t.match(/matrix.*\\((.+)\\)/)[1].split(\", \"), o[0] && \"0\" !== o[0] && \"1\" !== o[0] && (r = o[0]), o[3] && \"0\" !== o[3] && \"1\" !== o[3] && (n = o[3])), s = s.parentElement;\n            }\n            this._containerWidth = r ? Math.abs(t / r) : t, this._containerHeight = n ? Math.abs(i / n) : i;\n          }\n          _detectMissingCSS() {\n            \"rgb(250, 128, 114)\" !== e.window.getComputedStyle(this._missingCSSCanary).getPropertyValue(\"background-color\") && e.warnOnce(\"This page appears to be missing CSS declarations for Mapbox GL JS, which may cause the map to display incorrectly. Please ensure your page includes mapbox-gl.css, as described in https://www.mapbox.com/mapbox-gl-js/api/.\");\n          }\n          _setupContainer() {\n            const e = this._container;\n            e.classList.add(\"mapboxgl-map\"), (this._missingCSSCanary = n(\"div\", \"mapboxgl-canary\", e)).style.visibility = \"hidden\", this._detectMissingCSS();\n            const t = this._canvasContainer = n(\"div\", \"mapboxgl-canvas-container\", e);\n            this._interactive && t.classList.add(\"mapboxgl-interactive\"), this._canvas = n(\"canvas\", \"mapboxgl-canvas\", t), this._canvas.addEventListener(\"webglcontextlost\", this._contextLost, !1), this._canvas.addEventListener(\"webglcontextrestored\", this._contextRestored, !1), this._canvas.setAttribute(\"tabindex\", \"0\"), this._canvas.setAttribute(\"aria-label\", this._getUIString(\"Map.Title\")), this._canvas.setAttribute(\"role\", \"region\"), this._updateContainerDimensions(), this._resizeCanvas(this._containerWidth, this._containerHeight);\n            const i = this._controlContainer = n(\"div\", \"mapboxgl-control-container\", e),\n              o = this._controlPositions = {};\n            [\"top-left\", \"top-right\", \"bottom-left\", \"bottom-right\"].forEach(e => {\n              o[e] = n(\"div\", `mapboxgl-ctrl-${e}`, i);\n            }), this._container.addEventListener(\"scroll\", this._onMapScroll, !1);\n          }\n          _resizeCanvas(t, i) {\n            const o = e.exported.devicePixelRatio || 1;\n            this._canvas.width = o * Math.ceil(t), this._canvas.height = o * Math.ceil(i), this._canvas.style.width = `${t}px`, this._canvas.style.height = `${i}px`;\n          }\n          _addMarker(e) {\n            this._markers.push(e);\n          }\n          _removeMarker(e) {\n            const t = this._markers.indexOf(e);\n            -1 !== t && this._markers.splice(t, 1);\n          }\n          _addPopup(e) {\n            this._popups.push(e);\n          }\n          _removePopup(e) {\n            const t = this._popups.indexOf(e);\n            -1 !== t && this._popups.splice(t, 1);\n          }\n          _setupPainter() {\n            const t = e.extend({}, i.webGLContextAttributes, {\n                failIfMajorPerformanceCaveat: this._failIfMajorPerformanceCaveat,\n                preserveDrawingBuffer: this._preserveDrawingBuffer,\n                antialias: this._antialias || !1\n              }),\n              o = this._useWebGL2 && this._canvas.getContext(\"webgl2\", t),\n              r = o || this._canvas.getContext(\"webgl\", t) || this._canvas.getContext(\"experimental-webgl\", t);\n            r ? (this._useWebGL2 && !o && e.warnOnce(\"Failed to create WebGL 2 context. Using WebGL 1.\"), e.storeAuthState(r, !0), this.painter = new Bo(r, this.transform, !!o), this.on(\"data\", e => {\n              \"source\" === e.dataType && this.painter.setTileLoadedFlag(!0);\n            }), e.exported$1.testSupport(r)) : this.fire(new e.ErrorEvent(new Error(\"Failed to initialize WebGL\")));\n          }\n          _contextLost(t) {\n            t.preventDefault(), this._frame && (this._frame.cancel(), this._frame = null), this.fire(new e.Event(\"webglcontextlost\", {\n              originalEvent: t\n            }));\n          }\n          _contextRestored(t) {\n            this._setupPainter(), this.resize(), this._update(), this.fire(new e.Event(\"webglcontextrestored\", {\n              originalEvent: t\n            }));\n          }\n          _onMapScroll(e) {\n            if (e.target === this._container) return this._container.scrollTop = 0, this._container.scrollLeft = 0, !1;\n          }\n          loaded() {\n            return !this._styleDirty && !this._sourcesDirty && !!this.style && this.style.loaded();\n          }\n          _update(e) {\n            return this.style ? (this._styleDirty = this._styleDirty || e, this._sourcesDirty = !0, this.triggerRepaint(), this) : this;\n          }\n          _requestRenderFrame(e) {\n            return this._update(), this._renderTaskQueue.add(e);\n          }\n          _cancelRenderFrame(e) {\n            this._renderTaskQueue.remove(e);\n          }\n          _requestDomTask(e) {\n            !this.loaded() || this.loaded() && !this.isMoving() ? e() : this._domRenderTaskQueue.add(e);\n          }\n          _render(t) {\n            let i;\n            const o = this.painter.context.extTimerQuery,\n              r = e.exported.now();\n            if (this.listens(\"gpu-timing-frame\") && (i = o.createQueryEXT(), o.beginQueryEXT(o.TIME_ELAPSED_EXT, i)), this.painter.context.setDirty(), this.painter.setBaseState(), (this.isMoving() || this.isRotating() || this.isZooming()) && (this._interactionRange[0] = Math.min(this._interactionRange[0], e.window.performance.now()), this._interactionRange[1] = Math.max(this._interactionRange[1], e.window.performance.now())), this._renderTaskQueue.run(t), this._domRenderTaskQueue.run(t), this._removed) return;\n            this._updateProjectionTransition();\n            const n = this._isInitialLoad ? 0 : this._fadeDuration;\n            if (this.style && this._styleDirty) {\n              this._styleDirty = !1;\n              const t = this.transform.zoom,\n                i = this.transform.pitch,\n                o = e.exported.now(),\n                r = new e.EvaluationParameters(t, {\n                  now: o,\n                  fadeDuration: n,\n                  pitch: i,\n                  transition: this.style.getTransition()\n                });\n              this.style.update(r);\n            }\n            this.style && this.style.fog && this.style.fog.hasTransition() && (this.style._markersNeedUpdate = !0, this._sourcesDirty = !0);\n            let s = !1;\n            if (this.style && this._sourcesDirty ? (this._sourcesDirty = !1, this.painter._updateFog(this.style), this._updateTerrain(), s = this._updateAverageElevation(r), this.style._updateSources(this.transform), this._forceMarkerAndPopupUpdate()) : s = this._updateAverageElevation(r), this._placementDirty = this.style && this.style._updatePlacement(this.painter.transform, this.showCollisionBoxes, n, this._crossSourceCollisions), this.style && this.painter.render(this.style, {\n              showTileBoundaries: this.showTileBoundaries,\n              showTerrainWireframe: this.showTerrainWireframe,\n              showOverdrawInspector: this._showOverdrawInspector,\n              showQueryGeometry: !!this._showQueryGeometry,\n              showTileAABBs: this.showTileAABBs,\n              rotating: this.isRotating(),\n              zooming: this.isZooming(),\n              moving: this.isMoving(),\n              fadeDuration: n,\n              isInitialLoad: this._isInitialLoad,\n              showPadding: this.showPadding,\n              gpuTiming: !!this.listens(\"gpu-timing-layer\"),\n              gpuTimingDeferredRender: !!this.listens(\"gpu-timing-deferred-render\"),\n              speedIndexTiming: this.speedIndexTiming\n            }), this.fire(new e.Event(\"render\")), this.loaded() && !this._loaded && (this._loaded = !0, this.fire(new e.Event(\"load\"))), this.style && this.style.hasTransitions() && (this._styleDirty = !0), this.style && !this._placementDirty && this.style._releaseSymbolFadeTiles(), i) {\n              const t = e.exported.now() - r;\n              o.endQueryEXT(o.TIME_ELAPSED_EXT, i), setTimeout(() => {\n                const n = o.getQueryObjectEXT(i, o.QUERY_RESULT_EXT) / 1e6;\n                o.deleteQueryEXT(i), this.fire(new e.Event(\"gpu-timing-frame\", {\n                  cpuTime: t,\n                  gpuTime: n\n                })), e.window.performance.mark(\"frame-gpu\", {\n                  startTime: r,\n                  detail: {\n                    gpuTime: n\n                  }\n                });\n              }, 50);\n            }\n            if (this.listens(\"gpu-timing-layer\")) {\n              const t = this.painter.collectGpuTimers();\n              setTimeout(() => {\n                const i = this.painter.queryGpuTimers(t);\n                this.fire(new e.Event(\"gpu-timing-layer\", {\n                  layerTimes: i\n                }));\n              }, 50);\n            }\n            if (this.listens(\"gpu-timing-deferred-render\")) {\n              const t = this.painter.collectDeferredRenderGpuQueries();\n              setTimeout(() => {\n                const i = this.painter.queryGpuTimeDeferredRender(t);\n                this.fire(new e.Event(\"gpu-timing-deferred-render\", {\n                  gpuTime: i\n                }));\n              }, 50);\n            }\n            const a = this._sourcesDirty || this._styleDirty || this._placementDirty || s;\n            if (a || this._repaint) this.triggerRepaint();else {\n              const t = !this.isMoving() && this.loaded();\n              if (t && (s = this._updateAverageElevation(r, !0)), s) this.triggerRepaint();else if (this._triggerFrame(!1), t && (this.fire(new e.Event(\"idle\")), this._isInitialLoad = !1, this.speedIndexTiming)) {\n                const t = this._calculateSpeedIndex();\n                this.fire(new e.Event(\"speedindexcompleted\", {\n                  speedIndex: t\n                })), this.speedIndexTiming = !1;\n              }\n            }\n            !this._loaded || this._fullyLoaded || a || (this._fullyLoaded = !0, e.LivePerformanceUtils.mark(e.PerformanceMarkers.fullLoad), this._performanceMetricsCollection && e.postPerformanceEvent(this._requestManager._customAccessToken, {\n              width: this.painter.width,\n              height: this.painter.height,\n              interactionRange: this._interactionRange,\n              visibilityHidden: this._visibilityHidden,\n              terrainEnabled: !!this.painter.style.getTerrain(),\n              fogEnabled: !!this.painter.style.getFog(),\n              projection: this.getProjection().name,\n              zoom: this.transform.zoom,\n              renderer: this.painter.context.renderer,\n              vendor: this.painter.context.vendor\n            }), this._authenticate());\n          }\n          _forceMarkerAndPopupUpdate(e) {\n            for (const t of this._markers) e && !this.getRenderWorldCopies() && (t._lngLat = t._lngLat.wrap()), t._update();\n            for (const t of this._popups) !e || this.getRenderWorldCopies() || t._trackPointer || (t._lngLat = t._lngLat.wrap()), t._update();\n          }\n          _updateAverageElevation(e, t = !1) {\n            const i = e => (this.transform.averageElevation = e, this._update(!1), !0);\n            if (!this.painter.averageElevationNeedsEasing()) return 0 !== this.transform.averageElevation && i(0);\n            if ((t || e - this._averageElevationLastSampledAt > 500) && !this._averageElevation.isEasing(e)) {\n              const t = this.transform.averageElevation;\n              let o = this.transform.sampleAverageElevation(),\n                r = !1;\n              this.transform.elevation && (r = this.transform.elevation.exaggeration() !== this._averageElevationExaggeration, this._averageElevationExaggeration = this.transform.elevation.exaggeration()), isNaN(o) ? o = 0 : this._averageElevationLastSampledAt = e;\n              const n = Math.abs(t - o);\n              if (n > 1) {\n                if (this._isInitialLoad || r) return this._averageElevation.jumpTo(o), i(o);\n                this._averageElevation.easeTo(o, e, 300);\n              } else if (n > 1e-4) return this._averageElevation.jumpTo(o), i(o);\n            }\n            return !!this._averageElevation.isEasing(e) && i(this._averageElevation.getValue(e));\n          }\n          _authenticate() {\n            e.getMapSessionAPI(this._getMapId(), this._requestManager._skuToken, this._requestManager._customAccessToken, t => {\n              if (t && (t.message === e.AUTH_ERR_MSG || 401 === t.status)) {\n                const t = this.painter.context.gl;\n                e.storeAuthState(t, !1), this._logoControl instanceof Yr && this._logoControl._updateLogo(), t && t.clear(t.DEPTH_BUFFER_BIT | t.COLOR_BUFFER_BIT | t.STENCIL_BUFFER_BIT), this._silenceAuthErrors || this.fire(new e.ErrorEvent(new Error(\"A valid Mapbox access token is required to use Mapbox GL JS. To create an account or a new access token, visit https://account.mapbox.com/\")));\n              }\n            }), e.postMapLoadEvent(this._getMapId(), this._requestManager._skuToken, this._requestManager._customAccessToken, () => {});\n          }\n          _updateTerrain() {\n            const e = this._isDragging();\n            this.painter.updateTerrain(this.style, e);\n          }\n          _calculateSpeedIndex() {\n            const e = this.painter.canvasCopy(),\n              t = this.painter.getCanvasCopiesAndTimestamps();\n            t.timeStamps.push(performance.now());\n            const i = this.painter.context.gl,\n              o = i.createFramebuffer();\n            function r(e) {\n              i.framebufferTexture2D(i.FRAMEBUFFER, i.COLOR_ATTACHMENT0, i.TEXTURE_2D, e, 0);\n              const t = new Uint8Array(i.drawingBufferWidth * i.drawingBufferHeight * 4);\n              return i.readPixels(0, 0, i.drawingBufferWidth, i.drawingBufferHeight, i.RGBA, i.UNSIGNED_BYTE, t), t;\n            }\n            return i.bindFramebuffer(i.FRAMEBUFFER, o), this._canvasPixelComparison(r(e), t.canvasCopies.map(r), t.timeStamps);\n          }\n          _canvasPixelComparison(e, t, i) {\n            let o = i[1] - i[0];\n            const r = e.length / 4;\n            for (let n = 0; n < t.length; n++) {\n              const s = t[n];\n              let a = 0;\n              for (let t = 0; t < s.length; t += 4) s[t] === e[t] && s[t + 1] === e[t + 1] && s[t + 2] === e[t + 2] && s[t + 3] === e[t + 3] && (a += 1);\n              o += (i[n + 2] - i[n + 1]) * (1 - a / r);\n            }\n            return o;\n          }\n          remove() {\n            this._hash && this._hash.remove();\n            for (const e of this._controls) e.onRemove(this);\n            this._controls = [], this._frame && (this._frame.cancel(), this._frame = null), this._renderTaskQueue.clear(), this._domRenderTaskQueue.clear(), this.style && this.style.destroy(), this.painter.destroy(), this.handlers && this.handlers.destroy(), this.handlers = void 0, this.setStyle(null), void 0 !== e.window && (e.window.removeEventListener(\"resize\", this._onWindowResize, !1), e.window.removeEventListener(\"orientationchange\", this._onWindowResize, !1), e.window.removeEventListener(\"webkitfullscreenchange\", this._onWindowResize, !1), e.window.removeEventListener(\"online\", this._onWindowOnline, !1), e.window.removeEventListener(\"visibilitychange\", this._onVisibilityChange, !1));\n            const t = this.painter.context.gl.getExtension(\"WEBGL_lose_context\");\n            t && t.loseContext(), this._canvas.removeEventListener(\"webglcontextlost\", this._contextLost, !1), this._canvas.removeEventListener(\"webglcontextrestored\", this._contextRestored, !1), this._canvasContainer.remove(), this._controlContainer.remove(), this._missingCSSCanary.remove(), this._canvas = void 0, this._canvasContainer = void 0, this._controlContainer = void 0, this._missingCSSCanary = void 0, this._container.classList.remove(\"mapboxgl-map\"), this._container.removeEventListener(\"scroll\", this._onMapScroll, !1), e.removeAuthState(this.painter.context.gl), this._removed = !0, this.fire(new e.Event(\"remove\"));\n          }\n          triggerRepaint() {\n            this._triggerFrame(!0);\n          }\n          _triggerFrame(t) {\n            this._renderNextFrame = this._renderNextFrame || t, this.style && !this._frame && (this._frame = e.exported.frame(e => {\n              const t = !!this._renderNextFrame;\n              this._frame = null, this._renderNextFrame = null, t && this._render(e);\n            }));\n          }\n          _preloadTiles(t) {\n            const i = this.style ? Object.values(this.style._sourceCaches) : [];\n            return e.asyncAll(i, (e, i) => e._preloadTiles(t, i), () => {\n              this.triggerRepaint();\n            }), this;\n          }\n          _onWindowOnline() {\n            this._update();\n          }\n          _onWindowResize(e) {\n            this._trackResize && this.resize({\n              originalEvent: e\n            })._update();\n          }\n          _onVisibilityChange() {\n            \"hidden\" === e.window.document.visibilityState && this._visibilityHidden++;\n          }\n          get showTileBoundaries() {\n            return !!this._showTileBoundaries;\n          }\n          set showTileBoundaries(e) {\n            this._showTileBoundaries !== e && (this._showTileBoundaries = e, this._update());\n          }\n          get showTerrainWireframe() {\n            return !!this._showTerrainWireframe;\n          }\n          set showTerrainWireframe(e) {\n            this._showTerrainWireframe !== e && (this._showTerrainWireframe = e, this._update());\n          }\n          get speedIndexTiming() {\n            return !!this._speedIndexTiming;\n          }\n          set speedIndexTiming(e) {\n            this._speedIndexTiming !== e && (this._speedIndexTiming = e, this._update());\n          }\n          get showPadding() {\n            return !!this._showPadding;\n          }\n          set showPadding(e) {\n            this._showPadding !== e && (this._showPadding = e, this._update());\n          }\n          get showCollisionBoxes() {\n            return !!this._showCollisionBoxes;\n          }\n          set showCollisionBoxes(e) {\n            this._showCollisionBoxes !== e && (this._showCollisionBoxes = e, e ? this.style._generateCollisionBoxes() : this._update());\n          }\n          get showOverdrawInspector() {\n            return !!this._showOverdrawInspector;\n          }\n          set showOverdrawInspector(e) {\n            this._showOverdrawInspector !== e && (this._showOverdrawInspector = e, this._update());\n          }\n          get repaint() {\n            return !!this._repaint;\n          }\n          set repaint(e) {\n            this._repaint !== e && (this._repaint = e, this.triggerRepaint());\n          }\n          get vertices() {\n            return !!this._vertices;\n          }\n          set vertices(e) {\n            this._vertices = e, this._update();\n          }\n          get showTileAABBs() {\n            return !!this._showTileAABBs;\n          }\n          set showTileAABBs(e) {\n            this._showTileAABBs !== e && (this._showTileAABBs = e, e && this._update());\n          }\n          _setCacheLimits(t, i) {\n            e.setCacheLimits(t, i);\n          }\n          get version() {\n            return e.version;\n          }\n        },\n        NavigationControl: class {\n          constructor(t) {\n            this.options = e.extend({}, ln, t), this._container = n(\"div\", \"mapboxgl-ctrl mapboxgl-ctrl-group\"), this._container.addEventListener(\"contextmenu\", e => e.preventDefault()), this.options.showZoom && (e.bindAll([\"_setButtonTitle\", \"_updateZoomButtons\"], this), this._zoomInButton = this._createButton(\"mapboxgl-ctrl-zoom-in\", e => {\n              this._map && this._map.zoomIn({}, {\n                originalEvent: e\n              });\n            }), n(\"span\", \"mapboxgl-ctrl-icon\", this._zoomInButton).setAttribute(\"aria-hidden\", \"true\"), this._zoomOutButton = this._createButton(\"mapboxgl-ctrl-zoom-out\", e => {\n              this._map && this._map.zoomOut({}, {\n                originalEvent: e\n              });\n            }), n(\"span\", \"mapboxgl-ctrl-icon\", this._zoomOutButton).setAttribute(\"aria-hidden\", \"true\")), this.options.showCompass && (e.bindAll([\"_rotateCompassArrow\"], this), this._compass = this._createButton(\"mapboxgl-ctrl-compass\", e => {\n              const t = this._map;\n              t && (this.options.visualizePitch ? t.resetNorthPitch({}, {\n                originalEvent: e\n              }) : t.resetNorth({}, {\n                originalEvent: e\n              }));\n            }), this._compassIcon = n(\"span\", \"mapboxgl-ctrl-icon\", this._compass), this._compassIcon.setAttribute(\"aria-hidden\", \"true\"));\n          }\n          _updateZoomButtons() {\n            const e = this._map;\n            if (!e) return;\n            const t = e.getZoom(),\n              i = t === e.getMaxZoom(),\n              o = t === e.getMinZoom();\n            this._zoomInButton.disabled = i, this._zoomOutButton.disabled = o, this._zoomInButton.setAttribute(\"aria-disabled\", i.toString()), this._zoomOutButton.setAttribute(\"aria-disabled\", o.toString());\n          }\n          _rotateCompassArrow() {\n            const e = this._map;\n            if (!e) return;\n            const t = this.options.visualizePitch ? `scale(${1 / Math.pow(Math.cos(e.transform.pitch * (Math.PI / 180)), .5)}) rotateX(${e.transform.pitch}deg) rotateZ(${e.transform.angle * (180 / Math.PI)}deg)` : `rotate(${e.transform.angle * (180 / Math.PI)}deg)`;\n            e._requestDomTask(() => {\n              this._compassIcon && (this._compassIcon.style.transform = t);\n            });\n          }\n          onAdd(e) {\n            return this._map = e, this.options.showZoom && (this._setButtonTitle(this._zoomInButton, \"ZoomIn\"), this._setButtonTitle(this._zoomOutButton, \"ZoomOut\"), e.on(\"zoom\", this._updateZoomButtons), this._updateZoomButtons()), this.options.showCompass && (this._setButtonTitle(this._compass, \"ResetBearing\"), this.options.visualizePitch && e.on(\"pitch\", this._rotateCompassArrow), e.on(\"rotate\", this._rotateCompassArrow), this._rotateCompassArrow(), this._handler = new cn(e, this._compass, this.options.visualizePitch)), this._container;\n          }\n          onRemove() {\n            const e = this._map;\n            e && (this._container.remove(), this.options.showZoom && e.off(\"zoom\", this._updateZoomButtons), this.options.showCompass && (this.options.visualizePitch && e.off(\"pitch\", this._rotateCompassArrow), e.off(\"rotate\", this._rotateCompassArrow), this._handler && this._handler.off(), this._handler = void 0), this._map = void 0);\n          }\n          _createButton(e, t) {\n            const i = n(\"button\", e, this._container);\n            return i.type = \"button\", i.addEventListener(\"click\", t), i;\n          }\n          _setButtonTitle(e, t) {\n            if (!this._map) return;\n            const i = this._map._getUIString(`NavigationControl.${t}`);\n            e.setAttribute(\"aria-label\", i), e.firstElementChild && e.firstElementChild.setAttribute(\"title\", i);\n          }\n        },\n        GeolocateControl: class extends e.Evented {\n          constructor(t) {\n            super(), this.options = e.extend({\n              geolocation: e.window.navigator.geolocation\n            }, hn, t), e.bindAll([\"_onSuccess\", \"_onError\", \"_onZoom\", \"_finish\", \"_setupUI\", \"_updateCamera\", \"_updateMarker\", \"_updateMarkerRotation\", \"_onDeviceOrientation\"], this), this._updateMarkerRotationThrottled = Yo(this._updateMarkerRotation, 20), this._numberOfWatches = 0;\n          }\n          onAdd(e) {\n            return this._map = e, this._container = n(\"div\", \"mapboxgl-ctrl mapboxgl-ctrl-group\"), this._checkGeolocationSupport(this._setupUI), this._container;\n          }\n          onRemove() {\n            void 0 !== this._geolocationWatchID && (this.options.geolocation.clearWatch(this._geolocationWatchID), this._geolocationWatchID = void 0), this.options.showUserLocation && this._userLocationDotMarker && this._userLocationDotMarker.remove(), this.options.showAccuracyCircle && this._accuracyCircleMarker && this._accuracyCircleMarker.remove(), this._container.remove(), this._map.off(\"zoom\", this._onZoom), this._map = void 0, this._numberOfWatches = 0, this._noTimeout = !1;\n          }\n          _checkGeolocationSupport(t) {\n            const i = (e = !!this.options.geolocation) => {\n              this._supportsGeolocation = e, t(e);\n            };\n            void 0 !== this._supportsGeolocation ? t(this._supportsGeolocation) : void 0 !== e.window.navigator.permissions ? e.window.navigator.permissions.query({\n              name: \"geolocation\"\n            }).then(e => i(\"denied\" !== e.state)).catch(() => i()) : i();\n          }\n          _isOutOfMapMaxBounds(e) {\n            const t = this._map.getMaxBounds(),\n              i = e.coords;\n            return !!t && (i.longitude < t.getWest() || i.longitude > t.getEast() || i.latitude < t.getSouth() || i.latitude > t.getNorth());\n          }\n          _setErrorState() {\n            switch (this._watchState) {\n              case \"WAITING_ACTIVE\":\n                this._watchState = \"ACTIVE_ERROR\", this._geolocateButton.classList.remove(\"mapboxgl-ctrl-geolocate-active\"), this._geolocateButton.classList.add(\"mapboxgl-ctrl-geolocate-active-error\");\n                break;\n              case \"ACTIVE_LOCK\":\n                this._watchState = \"ACTIVE_ERROR\", this._geolocateButton.classList.remove(\"mapboxgl-ctrl-geolocate-active\"), this._geolocateButton.classList.add(\"mapboxgl-ctrl-geolocate-active-error\"), this._geolocateButton.classList.add(\"mapboxgl-ctrl-geolocate-waiting\");\n                break;\n              case \"BACKGROUND\":\n                this._watchState = \"BACKGROUND_ERROR\", this._geolocateButton.classList.remove(\"mapboxgl-ctrl-geolocate-background\"), this._geolocateButton.classList.add(\"mapboxgl-ctrl-geolocate-background-error\"), this._geolocateButton.classList.add(\"mapboxgl-ctrl-geolocate-waiting\");\n            }\n          }\n          _onSuccess(t) {\n            if (this._map) {\n              if (this._isOutOfMapMaxBounds(t)) return this._setErrorState(), this.fire(new e.Event(\"outofmaxbounds\", t)), this._updateMarker(), void this._finish();\n              if (this.options.trackUserLocation) switch (this._lastKnownPosition = t, this._watchState) {\n                case \"WAITING_ACTIVE\":\n                case \"ACTIVE_LOCK\":\n                case \"ACTIVE_ERROR\":\n                  this._watchState = \"ACTIVE_LOCK\", this._geolocateButton.classList.remove(\"mapboxgl-ctrl-geolocate-waiting\"), this._geolocateButton.classList.remove(\"mapboxgl-ctrl-geolocate-active-error\"), this._geolocateButton.classList.add(\"mapboxgl-ctrl-geolocate-active\");\n                  break;\n                case \"BACKGROUND\":\n                case \"BACKGROUND_ERROR\":\n                  this._watchState = \"BACKGROUND\", this._geolocateButton.classList.remove(\"mapboxgl-ctrl-geolocate-waiting\"), this._geolocateButton.classList.remove(\"mapboxgl-ctrl-geolocate-background-error\"), this._geolocateButton.classList.add(\"mapboxgl-ctrl-geolocate-background\");\n              }\n              this.options.showUserLocation && \"OFF\" !== this._watchState && this._updateMarker(t), this.options.trackUserLocation && \"ACTIVE_LOCK\" !== this._watchState || this._updateCamera(t), this.options.showUserLocation && this._dotElement.classList.remove(\"mapboxgl-user-location-dot-stale\"), this.fire(new e.Event(\"geolocate\", t)), this._finish();\n            }\n          }\n          _updateCamera(t) {\n            const i = new e.LngLat(t.coords.longitude, t.coords.latitude),\n              o = t.coords.accuracy,\n              r = this._map.getBearing(),\n              n = e.extend({\n                bearing: r\n              }, this.options.fitBoundsOptions);\n            this._map.fitBounds(i.toBounds(o), n, {\n              geolocateSource: !0\n            });\n          }\n          _updateMarker(t) {\n            if (t) {\n              const i = new e.LngLat(t.coords.longitude, t.coords.latitude);\n              this._accuracyCircleMarker.setLngLat(i).addTo(this._map), this._userLocationDotMarker.setLngLat(i).addTo(this._map), this._accuracy = t.coords.accuracy, this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius();\n            } else this._userLocationDotMarker.remove(), this._accuracyCircleMarker.remove();\n          }\n          _updateCircleRadius() {\n            const t = this._map.transform,\n              i = e.mercatorZfromAltitude(1, t._center.lat) * t.worldSize,\n              o = Math.ceil(2 * this._accuracy * i);\n            this._circleElement.style.width = `${o}px`, this._circleElement.style.height = `${o}px`;\n          }\n          _onZoom() {\n            this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius();\n          }\n          _updateMarkerRotation() {\n            this._userLocationDotMarker && \"number\" == typeof this._heading ? (this._userLocationDotMarker.setRotation(this._heading), this._dotElement.classList.add(\"mapboxgl-user-location-show-heading\")) : (this._dotElement.classList.remove(\"mapboxgl-user-location-show-heading\"), this._userLocationDotMarker.setRotation(0));\n          }\n          _onError(t) {\n            if (this._map) {\n              if (this.options.trackUserLocation) if (1 === t.code) {\n                this._watchState = \"OFF\", this._geolocateButton.classList.remove(\"mapboxgl-ctrl-geolocate-waiting\"), this._geolocateButton.classList.remove(\"mapboxgl-ctrl-geolocate-active\"), this._geolocateButton.classList.remove(\"mapboxgl-ctrl-geolocate-active-error\"), this._geolocateButton.classList.remove(\"mapboxgl-ctrl-geolocate-background\"), this._geolocateButton.classList.remove(\"mapboxgl-ctrl-geolocate-background-error\"), this._geolocateButton.disabled = !0;\n                const e = this._map._getUIString(\"GeolocateControl.LocationNotAvailable\");\n                this._geolocateButton.setAttribute(\"aria-label\", e), this._geolocateButton.firstElementChild && this._geolocateButton.firstElementChild.setAttribute(\"title\", e), void 0 !== this._geolocationWatchID && this._clearWatch();\n              } else {\n                if (3 === t.code && this._noTimeout) return;\n                this._setErrorState();\n              }\n              \"OFF\" !== this._watchState && this.options.showUserLocation && this._dotElement.classList.add(\"mapboxgl-user-location-dot-stale\"), this.fire(new e.Event(\"error\", t)), this._finish();\n            }\n          }\n          _finish() {\n            this._timeoutId && clearTimeout(this._timeoutId), this._timeoutId = void 0;\n          }\n          _setupUI(t) {\n            if (void 0 !== this._map) {\n              if (this._container.addEventListener(\"contextmenu\", e => e.preventDefault()), this._geolocateButton = n(\"button\", \"mapboxgl-ctrl-geolocate\", this._container), n(\"span\", \"mapboxgl-ctrl-icon\", this._geolocateButton).setAttribute(\"aria-hidden\", \"true\"), this._geolocateButton.type = \"button\", !1 === t) {\n                e.warnOnce(\"Geolocation support is not available so the GeolocateControl will be disabled.\");\n                const t = this._map._getUIString(\"GeolocateControl.LocationNotAvailable\");\n                this._geolocateButton.disabled = !0, this._geolocateButton.setAttribute(\"aria-label\", t), this._geolocateButton.firstElementChild && this._geolocateButton.firstElementChild.setAttribute(\"title\", t);\n              } else {\n                const e = this._map._getUIString(\"GeolocateControl.FindMyLocation\");\n                this._geolocateButton.setAttribute(\"aria-label\", e), this._geolocateButton.firstElementChild && this._geolocateButton.firstElementChild.setAttribute(\"title\", e);\n              }\n              this.options.trackUserLocation && (this._geolocateButton.setAttribute(\"aria-pressed\", \"false\"), this._watchState = \"OFF\"), this.options.showUserLocation && (this._dotElement = n(\"div\", \"mapboxgl-user-location\"), this._dotElement.appendChild(n(\"div\", \"mapboxgl-user-location-dot\")), this._dotElement.appendChild(n(\"div\", \"mapboxgl-user-location-heading\")), this._userLocationDotMarker = new en({\n                element: this._dotElement,\n                rotationAlignment: \"map\",\n                pitchAlignment: \"map\"\n              }), this._circleElement = n(\"div\", \"mapboxgl-user-location-accuracy-circle\"), this._accuracyCircleMarker = new en({\n                element: this._circleElement,\n                pitchAlignment: \"map\"\n              }), this.options.trackUserLocation && (this._watchState = \"OFF\"), this._map.on(\"zoom\", this._onZoom)), this._geolocateButton.addEventListener(\"click\", this.trigger.bind(this)), this._setup = !0, this.options.trackUserLocation && this._map.on(\"movestart\", t => {\n                t.geolocateSource || \"ACTIVE_LOCK\" !== this._watchState || t.originalEvent && \"resize\" === t.originalEvent.type || (this._watchState = \"BACKGROUND\", this._geolocateButton.classList.add(\"mapboxgl-ctrl-geolocate-background\"), this._geolocateButton.classList.remove(\"mapboxgl-ctrl-geolocate-active\"), this.fire(new e.Event(\"trackuserlocationend\")));\n              });\n            }\n          }\n          _onDeviceOrientation(e) {\n            this._userLocationDotMarker && (e.webkitCompassHeading ? this._heading = e.webkitCompassHeading : !0 === e.absolute && (this._heading = -1 * e.alpha), this._updateMarkerRotationThrottled());\n          }\n          trigger() {\n            if (!this._setup) return e.warnOnce(\"Geolocate control triggered before added to a map\"), !1;\n            if (this.options.trackUserLocation) {\n              switch (this._watchState) {\n                case \"OFF\":\n                  this._watchState = \"WAITING_ACTIVE\", this.fire(new e.Event(\"trackuserlocationstart\"));\n                  break;\n                case \"WAITING_ACTIVE\":\n                case \"ACTIVE_LOCK\":\n                case \"ACTIVE_ERROR\":\n                case \"BACKGROUND_ERROR\":\n                  this._numberOfWatches--, this._noTimeout = !1, this._watchState = \"OFF\", this._geolocateButton.classList.remove(\"mapboxgl-ctrl-geolocate-waiting\"), this._geolocateButton.classList.remove(\"mapboxgl-ctrl-geolocate-active\"), this._geolocateButton.classList.remove(\"mapboxgl-ctrl-geolocate-active-error\"), this._geolocateButton.classList.remove(\"mapboxgl-ctrl-geolocate-background\"), this._geolocateButton.classList.remove(\"mapboxgl-ctrl-geolocate-background-error\"), this.fire(new e.Event(\"trackuserlocationend\"));\n                  break;\n                case \"BACKGROUND\":\n                  this._watchState = \"ACTIVE_LOCK\", this._geolocateButton.classList.remove(\"mapboxgl-ctrl-geolocate-background\"), this._lastKnownPosition && this._updateCamera(this._lastKnownPosition), this.fire(new e.Event(\"trackuserlocationstart\"));\n              }\n              switch (this._watchState) {\n                case \"WAITING_ACTIVE\":\n                  this._geolocateButton.classList.add(\"mapboxgl-ctrl-geolocate-waiting\"), this._geolocateButton.classList.add(\"mapboxgl-ctrl-geolocate-active\");\n                  break;\n                case \"ACTIVE_LOCK\":\n                  this._geolocateButton.classList.add(\"mapboxgl-ctrl-geolocate-active\");\n                  break;\n                case \"ACTIVE_ERROR\":\n                  this._geolocateButton.classList.add(\"mapboxgl-ctrl-geolocate-waiting\"), this._geolocateButton.classList.add(\"mapboxgl-ctrl-geolocate-active-error\");\n                  break;\n                case \"BACKGROUND\":\n                  this._geolocateButton.classList.add(\"mapboxgl-ctrl-geolocate-background\");\n                  break;\n                case \"BACKGROUND_ERROR\":\n                  this._geolocateButton.classList.add(\"mapboxgl-ctrl-geolocate-waiting\"), this._geolocateButton.classList.add(\"mapboxgl-ctrl-geolocate-background-error\");\n              }\n              if (\"OFF\" === this._watchState && void 0 !== this._geolocationWatchID) this._clearWatch();else if (void 0 === this._geolocationWatchID) {\n                let e;\n                this._geolocateButton.classList.add(\"mapboxgl-ctrl-geolocate-waiting\"), this._geolocateButton.setAttribute(\"aria-pressed\", \"true\"), this._numberOfWatches++, this._numberOfWatches > 1 ? (e = {\n                  maximumAge: 6e5,\n                  timeout: 0\n                }, this._noTimeout = !0) : (e = this.options.positionOptions, this._noTimeout = !1), this._geolocationWatchID = this.options.geolocation.watchPosition(this._onSuccess, this._onError, e), this.options.showUserHeading && this._addDeviceOrientationListener();\n              }\n            } else this.options.geolocation.getCurrentPosition(this._onSuccess, this._onError, this.options.positionOptions), this._timeoutId = setTimeout(this._finish, 1e4);\n            return !0;\n          }\n          _addDeviceOrientationListener() {\n            const t = () => {\n              e.window.addEventListener(\"ondeviceorientationabsolute\" in e.window ? \"deviceorientationabsolute\" : \"deviceorientation\", this._onDeviceOrientation);\n            };\n            void 0 !== e.window.DeviceMotionEvent && \"function\" == typeof e.window.DeviceMotionEvent.requestPermission ? DeviceOrientationEvent.requestPermission().then(e => {\n              \"granted\" === e && t();\n            }).catch(console.error) : t();\n          }\n          _clearWatch() {\n            this.options.geolocation.clearWatch(this._geolocationWatchID), e.window.removeEventListener(\"deviceorientation\", this._onDeviceOrientation), e.window.removeEventListener(\"deviceorientationabsolute\", this._onDeviceOrientation), this._geolocationWatchID = void 0, this._geolocateButton.classList.remove(\"mapboxgl-ctrl-geolocate-waiting\"), this._geolocateButton.setAttribute(\"aria-pressed\", \"false\"), this.options.showUserLocation && this._updateMarker(null);\n          }\n        },\n        AttributionControl: Hr,\n        ScaleControl: class {\n          constructor(t) {\n            this.options = e.extend({}, un, t), this._isNumberFormatSupported = function () {\n              try {\n                return new Intl.NumberFormat(\"en\", {\n                  style: \"unit\",\n                  unitDisplay: \"short\",\n                  unit: \"meter\"\n                }), !0;\n              } catch (e) {\n                return !1;\n              }\n            }(), e.bindAll([\"_update\", \"_setScale\", \"setUnit\"], this);\n          }\n          getDefaultPosition() {\n            return \"bottom-left\";\n          }\n          _update() {\n            const e = this.options.maxWidth || 100,\n              t = this._map,\n              i = t._containerHeight / 2,\n              o = t._containerWidth / 2 - e / 2,\n              r = t.unproject([o, i]),\n              n = t.unproject([o + e, i]),\n              s = r.distanceTo(n);\n            if (\"imperial\" === this.options.unit) {\n              const t = 3.2808 * s;\n              t > 5280 ? this._setScale(e, t / 5280, \"mile\") : this._setScale(e, t, \"foot\");\n            } else \"nautical\" === this.options.unit ? this._setScale(e, s / 1852, \"nautical-mile\") : s >= 1e3 ? this._setScale(e, s / 1e3, \"kilometer\") : this._setScale(e, s, \"meter\");\n          }\n          _setScale(e, t, i) {\n            this._map._requestDomTask(() => {\n              const o = function (e) {\n                  const t = Math.pow(10, `${Math.floor(e)}`.length - 1);\n                  let i = e / t;\n                  return i = i >= 10 ? 10 : i >= 5 ? 5 : i >= 3 ? 3 : i >= 2 ? 2 : i >= 1 ? 1 : function (e) {\n                    const t = Math.pow(10, Math.ceil(-Math.log(e) / Math.LN10));\n                    return Math.round(e * t) / t;\n                  }(i), t * i;\n                }(t),\n                r = o / t;\n              this._container.innerHTML = this._isNumberFormatSupported && \"nautical-mile\" !== i ? new Intl.NumberFormat(this._language, {\n                style: \"unit\",\n                unitDisplay: \"short\",\n                unit: i\n              }).format(o) : `${o}&nbsp;${_n[i]}`, this._container.style.width = e * r + \"px\";\n            });\n          }\n          onAdd(e) {\n            return this._map = e, this._language = e.getLanguage(), this._container = n(\"div\", \"mapboxgl-ctrl mapboxgl-ctrl-scale\", e.getContainer()), this._container.dir = \"auto\", this._map.on(\"move\", this._update), this._update(), this._container;\n          }\n          onRemove() {\n            this._container.remove(), this._map.off(\"move\", this._update), this._map = void 0;\n          }\n          _setLanguage(e) {\n            this._language = e, this._update();\n          }\n          setUnit(e) {\n            this.options.unit = e, this._update();\n          }\n        },\n        FullscreenControl: class {\n          constructor(t) {\n            this._fullscreen = !1, t && t.container && (t.container instanceof e.window.HTMLElement ? this._container = t.container : e.warnOnce(\"Full screen control 'container' must be a DOM element.\")), e.bindAll([\"_onClickFullscreen\", \"_changeIcon\"], this), \"onfullscreenchange\" in e.window.document ? this._fullscreenchange = \"fullscreenchange\" : \"onwebkitfullscreenchange\" in e.window.document && (this._fullscreenchange = \"webkitfullscreenchange\");\n          }\n          onAdd(t) {\n            return this._map = t, this._container || (this._container = this._map.getContainer()), this._controlContainer = n(\"div\", \"mapboxgl-ctrl mapboxgl-ctrl-group\"), this._checkFullscreenSupport() ? this._setupUI() : (this._controlContainer.style.display = \"none\", e.warnOnce(\"This device does not support fullscreen mode.\")), this._controlContainer;\n          }\n          onRemove() {\n            this._controlContainer.remove(), this._map = null, e.window.document.removeEventListener(this._fullscreenchange, this._changeIcon);\n          }\n          _checkFullscreenSupport() {\n            return !(!e.window.document.fullscreenEnabled && !e.window.document.webkitFullscreenEnabled);\n          }\n          _setupUI() {\n            const t = this._fullscreenButton = n(\"button\", \"mapboxgl-ctrl-fullscreen\", this._controlContainer);\n            n(\"span\", \"mapboxgl-ctrl-icon\", t).setAttribute(\"aria-hidden\", \"true\"), t.type = \"button\", this._updateTitle(), this._fullscreenButton.addEventListener(\"click\", this._onClickFullscreen), e.window.document.addEventListener(this._fullscreenchange, this._changeIcon);\n          }\n          _updateTitle() {\n            const e = this._getTitle();\n            this._fullscreenButton.setAttribute(\"aria-label\", e), this._fullscreenButton.firstElementChild && this._fullscreenButton.firstElementChild.setAttribute(\"title\", e);\n          }\n          _getTitle() {\n            return this._map._getUIString(this._isFullscreen() ? \"FullscreenControl.Exit\" : \"FullscreenControl.Enter\");\n          }\n          _isFullscreen() {\n            return this._fullscreen;\n          }\n          _changeIcon() {\n            (e.window.document.fullscreenElement || e.window.document.webkitFullscreenElement) === this._container !== this._fullscreen && (this._fullscreen = !this._fullscreen, this._fullscreenButton.classList.toggle(\"mapboxgl-ctrl-shrink\"), this._fullscreenButton.classList.toggle(\"mapboxgl-ctrl-fullscreen\"), this._updateTitle());\n          }\n          _onClickFullscreen() {\n            this._isFullscreen() ? e.window.document.exitFullscreen ? e.window.document.exitFullscreen() : e.window.document.webkitCancelFullScreen && e.window.document.webkitCancelFullScreen() : this._container.requestFullscreen ? this._container.requestFullscreen() : this._container.webkitRequestFullscreen && this._container.webkitRequestFullscreen();\n          }\n        },\n        Popup: class extends e.Evented {\n          constructor(t) {\n            super(), this.options = e.extend(Object.create(tn), t), e.bindAll([\"_update\", \"_onClose\", \"remove\", \"_onMouseEvent\"], this), this._classList = new Set(t && t.className ? t.className.trim().split(/\\s+/) : []);\n          }\n          addTo(t) {\n            return this._map && this.remove(), this._map = t, this.options.closeOnClick && t.on(\"preclick\", this._onClose), this.options.closeOnMove && t.on(\"move\", this._onClose), t.on(\"remove\", this.remove), this._update(), t._addPopup(this), this._focusFirstElement(), this._trackPointer ? (t.on(\"mousemove\", this._onMouseEvent), t.on(\"mouseup\", this._onMouseEvent), t._canvasContainer.classList.add(\"mapboxgl-track-pointer\")) : t.on(\"move\", this._update), this.fire(new e.Event(\"open\")), this;\n          }\n          isOpen() {\n            return !!this._map;\n          }\n          remove() {\n            this._content && this._content.remove(), this._container && (this._container.remove(), this._container = void 0);\n            const t = this._map;\n            return t && (t.off(\"move\", this._update), t.off(\"move\", this._onClose), t.off(\"preclick\", this._onClose), t.off(\"click\", this._onClose), t.off(\"remove\", this.remove), t.off(\"mousemove\", this._onMouseEvent), t.off(\"mouseup\", this._onMouseEvent), t.off(\"drag\", this._onMouseEvent), t._canvasContainer && t._canvasContainer.classList.remove(\"mapboxgl-track-pointer\"), t._removePopup(this), this._map = void 0), this.fire(new e.Event(\"close\")), this;\n          }\n          getLngLat() {\n            return this._lngLat;\n          }\n          setLngLat(t) {\n            this._lngLat = e.LngLat.convert(t), this._pos = null, this._trackPointer = !1, this._update();\n            const i = this._map;\n            return i && (i.on(\"move\", this._update), i.off(\"mousemove\", this._onMouseEvent), i._canvasContainer.classList.remove(\"mapboxgl-track-pointer\")), this;\n          }\n          trackPointer() {\n            this._trackPointer = !0, this._pos = null, this._update();\n            const e = this._map;\n            return e && (e.off(\"move\", this._update), e.on(\"mousemove\", this._onMouseEvent), e.on(\"drag\", this._onMouseEvent), e._canvasContainer.classList.add(\"mapboxgl-track-pointer\")), this;\n          }\n          getElement() {\n            return this._container;\n          }\n          setText(t) {\n            return this.setDOMContent(e.window.document.createTextNode(t));\n          }\n          setHTML(t) {\n            const i = e.window.document.createDocumentFragment(),\n              o = e.window.document.createElement(\"body\");\n            let r;\n            for (o.innerHTML = t; r = o.firstChild, r;) i.appendChild(r);\n            return this.setDOMContent(i);\n          }\n          getMaxWidth() {\n            return this._container && this._container.style.maxWidth;\n          }\n          setMaxWidth(e) {\n            return this.options.maxWidth = e, this._update(), this;\n          }\n          setDOMContent(e) {\n            let t = this._content;\n            if (t) for (; t.hasChildNodes();) t.firstChild && t.removeChild(t.firstChild);else t = this._content = n(\"div\", \"mapboxgl-popup-content\", this._container || void 0);\n            if (t.appendChild(e), this.options.closeButton) {\n              const e = this._closeButton = n(\"button\", \"mapboxgl-popup-close-button\", t);\n              e.type = \"button\", e.setAttribute(\"aria-label\", \"Close popup\"), e.setAttribute(\"aria-hidden\", \"true\"), e.innerHTML = \"&#215;\", e.addEventListener(\"click\", this._onClose);\n            }\n            return this._update(), this._focusFirstElement(), this;\n          }\n          addClassName(e) {\n            return this._classList.add(e), this._updateClassList(), this;\n          }\n          removeClassName(e) {\n            return this._classList.delete(e), this._updateClassList(), this;\n          }\n          setOffset(e) {\n            return this.options.offset = e, this._update(), this;\n          }\n          toggleClassName(e) {\n            let t;\n            return this._classList.delete(e) ? t = !1 : (this._classList.add(e), t = !0), this._updateClassList(), t;\n          }\n          _onMouseEvent(e) {\n            this._update(e.point);\n          }\n          _getAnchor(e) {\n            if (this.options.anchor) return this.options.anchor;\n            const t = this._map,\n              i = this._container,\n              o = this._pos;\n            if (!t || !i || !o) return \"bottom\";\n            const r = i.offsetWidth,\n              n = i.offsetHeight,\n              s = o.x < r / 2,\n              a = o.x > t.transform.width - r / 2;\n            if (o.y + e < n) return s ? \"top-left\" : a ? \"top-right\" : \"top\";\n            if (o.y > t.transform.height - n) {\n              if (s) return \"bottom-left\";\n              if (a) return \"bottom-right\";\n            }\n            return s ? \"left\" : a ? \"right\" : \"bottom\";\n          }\n          _updateClassList() {\n            const e = this._container;\n            if (!e) return;\n            const t = [...this._classList];\n            t.push(\"mapboxgl-popup\"), this._anchor && t.push(`mapboxgl-popup-anchor-${this._anchor}`), this._trackPointer && t.push(\"mapboxgl-popup-track-pointer\"), e.className = t.join(\" \");\n          }\n          _update(t) {\n            const i = this._map,\n              o = this._content;\n            if (!i || !this._lngLat && !this._trackPointer || !o) return;\n            let r = this._container;\n            if (r || (r = this._container = n(\"div\", \"mapboxgl-popup\", i.getContainer()), this._tip = n(\"div\", \"mapboxgl-popup-tip\", r), r.appendChild(o)), this.options.maxWidth && r.style.maxWidth !== this.options.maxWidth && (r.style.maxWidth = this.options.maxWidth), i.transform.renderWorldCopies && !this._trackPointer && (this._lngLat = Jr(this._lngLat, this._pos, i.transform)), !this._trackPointer || t) {\n              const e = this._pos = this._trackPointer && t ? t : i.project(this._lngLat),\n                o = rn(this.options.offset),\n                r = this._anchor = this._getAnchor(o.y),\n                n = rn(this.options.offset, r),\n                s = e.add(n).round();\n              i._requestDomTask(() => {\n                this._container && r && (this._container.style.transform = `${Qr[r]} translate(${s.x}px,${s.y}px)`);\n              });\n            }\n            if (!this._marker && i._showingGlobe()) {\n              const t = e.isLngLatBehindGlobe(i.transform, this._lngLat) ? 0 : 1;\n              this._setOpacity(t);\n            }\n            this._updateClassList();\n          }\n          _focusFirstElement() {\n            if (!this.options.focusAfterOpen || !this._container) return;\n            const e = this._container.querySelector(on);\n            e && e.focus();\n          }\n          _onClose() {\n            this.remove();\n          }\n          _setOpacity(e) {\n            this._container && (this._container.style.opacity = `${e}`), this._content && (this._content.style.pointerEvents = e ? \"auto\" : \"none\");\n          }\n        },\n        Marker: en,\n        Style: Kt,\n        LngLat: e.LngLat,\n        LngLatBounds: e.LngLatBounds,\n        Point: e.Point,\n        MercatorCoordinate: e.MercatorCoordinate,\n        FreeCameraOptions: jo,\n        Evented: e.Evented,\n        config: e.config,\n        prewarm: function () {\n          Ue().acquire(Be);\n        },\n        clearPrewarmedResources: function () {\n          const e = Fe;\n          e && (e.isPreloaded() && 1 === e.numActive() ? (e.release(Be), Fe = null) : console.warn(\"Could not clear WebWorkers since there are active Map instances that still reference it. The pre-warmed WebWorker pool can only be cleared when all map instances have been removed with map.remove()\"));\n        },\n        get accessToken() {\n          return e.config.ACCESS_TOKEN;\n        },\n        set accessToken(t) {\n          e.config.ACCESS_TOKEN = t;\n        },\n        get baseApiUrl() {\n          return e.config.API_URL;\n        },\n        set baseApiUrl(t) {\n          e.config.API_URL = t;\n        },\n        get workerCount() {\n          return ke.workerCount;\n        },\n        set workerCount(e) {\n          ke.workerCount = e;\n        },\n        get maxParallelImageRequests() {\n          return e.config.MAX_PARALLEL_IMAGE_REQUESTS;\n        },\n        set maxParallelImageRequests(t) {\n          e.config.MAX_PARALLEL_IMAGE_REQUESTS = t;\n        },\n        clearStorage(t) {\n          e.clearTileCache(t);\n        },\n        workerUrl: \"\",\n        workerClass: null,\n        setNow: e.exported.setNow,\n        restoreNow: e.exported.restoreNow\n      };\n    return dn;\n  });\n\n  //\n  // Our custom intro provides a specialized \"define()\" function, called by the\n  // AMD modules below, that sets up the worker blob URL and then executes the\n  // main module, storing its exported value as 'mapboxgl'\n\n  var mapboxgl$1 = mapboxgl;\n  return mapboxgl$1;\n});\n//# sourceMappingURL=mapbox-gl.js.map","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}